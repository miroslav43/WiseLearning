
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model TeacherProfile
 * 
 */
export type TeacherProfile = $Result.DefaultSelection<Prisma.$TeacherProfilePayload>
/**
 * Model UserAvailability
 * 
 */
export type UserAvailability = $Result.DefaultSelection<Prisma.$UserAvailabilityPayload>
/**
 * Model PointsTransaction
 * 
 */
export type PointsTransaction = $Result.DefaultSelection<Prisma.$PointsTransactionPayload>
/**
 * Model PointsPackage
 * 
 */
export type PointsPackage = $Result.DefaultSelection<Prisma.$PointsPackagePayload>
/**
 * Model Course
 * 
 */
export type Course = $Result.DefaultSelection<Prisma.$CoursePayload>
/**
 * Model Topic
 * 
 */
export type Topic = $Result.DefaultSelection<Prisma.$TopicPayload>
/**
 * Model Lesson
 * 
 */
export type Lesson = $Result.DefaultSelection<Prisma.$LessonPayload>
/**
 * Model Quiz
 * 
 */
export type Quiz = $Result.DefaultSelection<Prisma.$QuizPayload>
/**
 * Model Question
 * 
 */
export type Question = $Result.DefaultSelection<Prisma.$QuestionPayload>
/**
 * Model Assignment
 * 
 */
export type Assignment = $Result.DefaultSelection<Prisma.$AssignmentPayload>
/**
 * Model Enrollment
 * 
 */
export type Enrollment = $Result.DefaultSelection<Prisma.$EnrollmentPayload>
/**
 * Model SavedCourse
 * 
 */
export type SavedCourse = $Result.DefaultSelection<Prisma.$SavedCoursePayload>
/**
 * Model LikedCourse
 * 
 */
export type LikedCourse = $Result.DefaultSelection<Prisma.$LikedCoursePayload>
/**
 * Model LessonProgress
 * 
 */
export type LessonProgress = $Result.DefaultSelection<Prisma.$LessonProgressPayload>
/**
 * Model QuizAttempt
 * 
 */
export type QuizAttempt = $Result.DefaultSelection<Prisma.$QuizAttemptPayload>
/**
 * Model AssignmentSubmission
 * 
 */
export type AssignmentSubmission = $Result.DefaultSelection<Prisma.$AssignmentSubmissionPayload>
/**
 * Model CourseReview
 * 
 */
export type CourseReview = $Result.DefaultSelection<Prisma.$CourseReviewPayload>
/**
 * Model TutoringSession
 * 
 */
export type TutoringSession = $Result.DefaultSelection<Prisma.$TutoringSessionPayload>
/**
 * Model TutoringAvailability
 * 
 */
export type TutoringAvailability = $Result.DefaultSelection<Prisma.$TutoringAvailabilityPayload>
/**
 * Model TutoringRequest
 * 
 */
export type TutoringRequest = $Result.DefaultSelection<Prisma.$TutoringRequestPayload>
/**
 * Model TutoringAppointment
 * 
 */
export type TutoringAppointment = $Result.DefaultSelection<Prisma.$TutoringAppointmentPayload>
/**
 * Model TutoringReview
 * 
 */
export type TutoringReview = $Result.DefaultSelection<Prisma.$TutoringReviewPayload>
/**
 * Model TutoringMessage
 * 
 */
export type TutoringMessage = $Result.DefaultSelection<Prisma.$TutoringMessagePayload>
/**
 * Model Achievement
 * 
 */
export type Achievement = $Result.DefaultSelection<Prisma.$AchievementPayload>
/**
 * Model UserAchievement
 * 
 */
export type UserAchievement = $Result.DefaultSelection<Prisma.$UserAchievementPayload>
/**
 * Model Badge
 * 
 */
export type Badge = $Result.DefaultSelection<Prisma.$BadgePayload>
/**
 * Model Certificate
 * 
 */
export type Certificate = $Result.DefaultSelection<Prisma.$CertificatePayload>
/**
 * Model Conversation
 * 
 */
export type Conversation = $Result.DefaultSelection<Prisma.$ConversationPayload>
/**
 * Model ConversationParticipant
 * 
 */
export type ConversationParticipant = $Result.DefaultSelection<Prisma.$ConversationParticipantPayload>
/**
 * Model Message
 * 
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>
/**
 * Model Attachment
 * 
 */
export type Attachment = $Result.DefaultSelection<Prisma.$AttachmentPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model SubscriptionPlan
 * 
 */
export type SubscriptionPlan = $Result.DefaultSelection<Prisma.$SubscriptionPlanPayload>
/**
 * Model CourseBundle
 * 
 */
export type CourseBundle = $Result.DefaultSelection<Prisma.$CourseBundlePayload>
/**
 * Model BundleCourse
 * 
 */
export type BundleCourse = $Result.DefaultSelection<Prisma.$BundleCoursePayload>
/**
 * Model UserSubscription
 * 
 */
export type UserSubscription = $Result.DefaultSelection<Prisma.$UserSubscriptionPayload>
/**
 * Model UserBundle
 * 
 */
export type UserBundle = $Result.DefaultSelection<Prisma.$UserBundlePayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model CalendarEvent
 * 
 */
export type CalendarEvent = $Result.DefaultSelection<Prisma.$CalendarEventPayload>
/**
 * Model BlogPost
 * 
 */
export type BlogPost = $Result.DefaultSelection<Prisma.$BlogPostPayload>
/**
 * Model Category
 * 
 */
export type Category = $Result.DefaultSelection<Prisma.$CategoryPayload>
/**
 * Model PostCategory
 * 
 */
export type PostCategory = $Result.DefaultSelection<Prisma.$PostCategoryPayload>
/**
 * Model Tag
 * 
 */
export type Tag = $Result.DefaultSelection<Prisma.$TagPayload>
/**
 * Model PostTag
 * 
 */
export type PostTag = $Result.DefaultSelection<Prisma.$PostTagPayload>
/**
 * Model BlogComment
 * 
 */
export type BlogComment = $Result.DefaultSelection<Prisma.$BlogCommentPayload>
/**
 * Model ReferralCode
 * 
 */
export type ReferralCode = $Result.DefaultSelection<Prisma.$ReferralCodePayload>
/**
 * Model ReferralUse
 * 
 */
export type ReferralUse = $Result.DefaultSelection<Prisma.$ReferralUsePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  student: 'student',
  teacher: 'teacher',
  admin: 'admin'
};

export type Role = (typeof Role)[keyof typeof Role]


export const PointsTxnType: {
  purchase: 'purchase',
  course_purchase: 'course_purchase',
  referral: 'referral',
  achievement: 'achievement'
};

export type PointsTxnType = (typeof PointsTxnType)[keyof typeof PointsTxnType]


export const CourseStatus: {
  draft: 'draft',
  published: 'published',
  archived: 'archived',
  rejected: 'rejected'
};

export type CourseStatus = (typeof CourseStatus)[keyof typeof CourseStatus]


export const LessonType: {
  lesson: 'lesson',
  quiz: 'quiz',
  assignment: 'assignment'
};

export type LessonType = (typeof LessonType)[keyof typeof LessonType]


export const QuestionType: {
  single: 'single',
  multiple: 'multiple',
  true_false: 'true_false',
  order: 'order'
};

export type QuestionType = (typeof QuestionType)[keyof typeof QuestionType]


export const TutoringLocationType: {
  online: 'online',
  offline: 'offline',
  both: 'both'
};

export type TutoringLocationType = (typeof TutoringLocationType)[keyof typeof TutoringLocationType]


export const TutoringStatus: {
  pending: 'pending',
  approved: 'approved',
  rejected: 'rejected',
  confirmed: 'confirmed',
  completed: 'completed',
  cancelled: 'cancelled'
};

export type TutoringStatus = (typeof TutoringStatus)[keyof typeof TutoringStatus]


export const TutoringRequestStatus: {
  pending: 'pending',
  accepted: 'accepted',
  rejected: 'rejected'
};

export type TutoringRequestStatus = (typeof TutoringRequestStatus)[keyof typeof TutoringRequestStatus]


export const AppointmentStatus: {
  confirmed: 'confirmed',
  completed: 'completed',
  cancelled: 'cancelled'
};

export type AppointmentStatus = (typeof AppointmentStatus)[keyof typeof AppointmentStatus]


export const AchievementCategory: {
  learning: 'learning',
  community: 'community',
  mastery: 'mastery'
};

export type AchievementCategory = (typeof AchievementCategory)[keyof typeof AchievementCategory]


export const BadgeType: {
  course: 'course',
  tutoring: 'tutoring',
  achievement: 'achievement'
};

export type BadgeType = (typeof BadgeType)[keyof typeof BadgeType]


export const NotificationType: {
  info: 'info',
  success: 'success',
  warning: 'warning',
  error: 'error',
  TUTORING_REQUEST: 'TUTORING_REQUEST',
  TUTORING_ACCEPTED: 'TUTORING_ACCEPTED',
  TUTORING_REJECTED: 'TUTORING_REJECTED',
  COURSE_APPROVED: 'COURSE_APPROVED',
  COURSE_REJECTED: 'COURSE_REJECTED'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]


export const SubscriptionPeriod: {
  monthly: 'monthly',
  annual: 'annual'
};

export type SubscriptionPeriod = (typeof SubscriptionPeriod)[keyof typeof SubscriptionPeriod]


export const PaymentStatus: {
  pending: 'pending',
  completed: 'completed',
  failed: 'failed',
  refunded: 'refunded'
};

export type PaymentStatus = (typeof PaymentStatus)[keyof typeof PaymentStatus]


export const PaymentReferenceType: {
  subscription: 'subscription',
  course: 'course',
  bundle: 'bundle',
  points: 'points'
};

export type PaymentReferenceType = (typeof PaymentReferenceType)[keyof typeof PaymentReferenceType]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type PointsTxnType = $Enums.PointsTxnType

export const PointsTxnType: typeof $Enums.PointsTxnType

export type CourseStatus = $Enums.CourseStatus

export const CourseStatus: typeof $Enums.CourseStatus

export type LessonType = $Enums.LessonType

export const LessonType: typeof $Enums.LessonType

export type QuestionType = $Enums.QuestionType

export const QuestionType: typeof $Enums.QuestionType

export type TutoringLocationType = $Enums.TutoringLocationType

export const TutoringLocationType: typeof $Enums.TutoringLocationType

export type TutoringStatus = $Enums.TutoringStatus

export const TutoringStatus: typeof $Enums.TutoringStatus

export type TutoringRequestStatus = $Enums.TutoringRequestStatus

export const TutoringRequestStatus: typeof $Enums.TutoringRequestStatus

export type AppointmentStatus = $Enums.AppointmentStatus

export const AppointmentStatus: typeof $Enums.AppointmentStatus

export type AchievementCategory = $Enums.AchievementCategory

export const AchievementCategory: typeof $Enums.AchievementCategory

export type BadgeType = $Enums.BadgeType

export const BadgeType: typeof $Enums.BadgeType

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

export type SubscriptionPeriod = $Enums.SubscriptionPeriod

export const SubscriptionPeriod: typeof $Enums.SubscriptionPeriod

export type PaymentStatus = $Enums.PaymentStatus

export const PaymentStatus: typeof $Enums.PaymentStatus

export type PaymentReferenceType = $Enums.PaymentReferenceType

export const PaymentReferenceType: typeof $Enums.PaymentReferenceType

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.teacherProfile`: Exposes CRUD operations for the **TeacherProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TeacherProfiles
    * const teacherProfiles = await prisma.teacherProfile.findMany()
    * ```
    */
  get teacherProfile(): Prisma.TeacherProfileDelegate<ExtArgs>;

  /**
   * `prisma.userAvailability`: Exposes CRUD operations for the **UserAvailability** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserAvailabilities
    * const userAvailabilities = await prisma.userAvailability.findMany()
    * ```
    */
  get userAvailability(): Prisma.UserAvailabilityDelegate<ExtArgs>;

  /**
   * `prisma.pointsTransaction`: Exposes CRUD operations for the **PointsTransaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PointsTransactions
    * const pointsTransactions = await prisma.pointsTransaction.findMany()
    * ```
    */
  get pointsTransaction(): Prisma.PointsTransactionDelegate<ExtArgs>;

  /**
   * `prisma.pointsPackage`: Exposes CRUD operations for the **PointsPackage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PointsPackages
    * const pointsPackages = await prisma.pointsPackage.findMany()
    * ```
    */
  get pointsPackage(): Prisma.PointsPackageDelegate<ExtArgs>;

  /**
   * `prisma.course`: Exposes CRUD operations for the **Course** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Courses
    * const courses = await prisma.course.findMany()
    * ```
    */
  get course(): Prisma.CourseDelegate<ExtArgs>;

  /**
   * `prisma.topic`: Exposes CRUD operations for the **Topic** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Topics
    * const topics = await prisma.topic.findMany()
    * ```
    */
  get topic(): Prisma.TopicDelegate<ExtArgs>;

  /**
   * `prisma.lesson`: Exposes CRUD operations for the **Lesson** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lessons
    * const lessons = await prisma.lesson.findMany()
    * ```
    */
  get lesson(): Prisma.LessonDelegate<ExtArgs>;

  /**
   * `prisma.quiz`: Exposes CRUD operations for the **Quiz** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Quizzes
    * const quizzes = await prisma.quiz.findMany()
    * ```
    */
  get quiz(): Prisma.QuizDelegate<ExtArgs>;

  /**
   * `prisma.question`: Exposes CRUD operations for the **Question** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Questions
    * const questions = await prisma.question.findMany()
    * ```
    */
  get question(): Prisma.QuestionDelegate<ExtArgs>;

  /**
   * `prisma.assignment`: Exposes CRUD operations for the **Assignment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Assignments
    * const assignments = await prisma.assignment.findMany()
    * ```
    */
  get assignment(): Prisma.AssignmentDelegate<ExtArgs>;

  /**
   * `prisma.enrollment`: Exposes CRUD operations for the **Enrollment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Enrollments
    * const enrollments = await prisma.enrollment.findMany()
    * ```
    */
  get enrollment(): Prisma.EnrollmentDelegate<ExtArgs>;

  /**
   * `prisma.savedCourse`: Exposes CRUD operations for the **SavedCourse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SavedCourses
    * const savedCourses = await prisma.savedCourse.findMany()
    * ```
    */
  get savedCourse(): Prisma.SavedCourseDelegate<ExtArgs>;

  /**
   * `prisma.likedCourse`: Exposes CRUD operations for the **LikedCourse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LikedCourses
    * const likedCourses = await prisma.likedCourse.findMany()
    * ```
    */
  get likedCourse(): Prisma.LikedCourseDelegate<ExtArgs>;

  /**
   * `prisma.lessonProgress`: Exposes CRUD operations for the **LessonProgress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LessonProgresses
    * const lessonProgresses = await prisma.lessonProgress.findMany()
    * ```
    */
  get lessonProgress(): Prisma.LessonProgressDelegate<ExtArgs>;

  /**
   * `prisma.quizAttempt`: Exposes CRUD operations for the **QuizAttempt** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuizAttempts
    * const quizAttempts = await prisma.quizAttempt.findMany()
    * ```
    */
  get quizAttempt(): Prisma.QuizAttemptDelegate<ExtArgs>;

  /**
   * `prisma.assignmentSubmission`: Exposes CRUD operations for the **AssignmentSubmission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AssignmentSubmissions
    * const assignmentSubmissions = await prisma.assignmentSubmission.findMany()
    * ```
    */
  get assignmentSubmission(): Prisma.AssignmentSubmissionDelegate<ExtArgs>;

  /**
   * `prisma.courseReview`: Exposes CRUD operations for the **CourseReview** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CourseReviews
    * const courseReviews = await prisma.courseReview.findMany()
    * ```
    */
  get courseReview(): Prisma.CourseReviewDelegate<ExtArgs>;

  /**
   * `prisma.tutoringSession`: Exposes CRUD operations for the **TutoringSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TutoringSessions
    * const tutoringSessions = await prisma.tutoringSession.findMany()
    * ```
    */
  get tutoringSession(): Prisma.TutoringSessionDelegate<ExtArgs>;

  /**
   * `prisma.tutoringAvailability`: Exposes CRUD operations for the **TutoringAvailability** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TutoringAvailabilities
    * const tutoringAvailabilities = await prisma.tutoringAvailability.findMany()
    * ```
    */
  get tutoringAvailability(): Prisma.TutoringAvailabilityDelegate<ExtArgs>;

  /**
   * `prisma.tutoringRequest`: Exposes CRUD operations for the **TutoringRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TutoringRequests
    * const tutoringRequests = await prisma.tutoringRequest.findMany()
    * ```
    */
  get tutoringRequest(): Prisma.TutoringRequestDelegate<ExtArgs>;

  /**
   * `prisma.tutoringAppointment`: Exposes CRUD operations for the **TutoringAppointment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TutoringAppointments
    * const tutoringAppointments = await prisma.tutoringAppointment.findMany()
    * ```
    */
  get tutoringAppointment(): Prisma.TutoringAppointmentDelegate<ExtArgs>;

  /**
   * `prisma.tutoringReview`: Exposes CRUD operations for the **TutoringReview** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TutoringReviews
    * const tutoringReviews = await prisma.tutoringReview.findMany()
    * ```
    */
  get tutoringReview(): Prisma.TutoringReviewDelegate<ExtArgs>;

  /**
   * `prisma.tutoringMessage`: Exposes CRUD operations for the **TutoringMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TutoringMessages
    * const tutoringMessages = await prisma.tutoringMessage.findMany()
    * ```
    */
  get tutoringMessage(): Prisma.TutoringMessageDelegate<ExtArgs>;

  /**
   * `prisma.achievement`: Exposes CRUD operations for the **Achievement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Achievements
    * const achievements = await prisma.achievement.findMany()
    * ```
    */
  get achievement(): Prisma.AchievementDelegate<ExtArgs>;

  /**
   * `prisma.userAchievement`: Exposes CRUD operations for the **UserAchievement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserAchievements
    * const userAchievements = await prisma.userAchievement.findMany()
    * ```
    */
  get userAchievement(): Prisma.UserAchievementDelegate<ExtArgs>;

  /**
   * `prisma.badge`: Exposes CRUD operations for the **Badge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Badges
    * const badges = await prisma.badge.findMany()
    * ```
    */
  get badge(): Prisma.BadgeDelegate<ExtArgs>;

  /**
   * `prisma.certificate`: Exposes CRUD operations for the **Certificate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Certificates
    * const certificates = await prisma.certificate.findMany()
    * ```
    */
  get certificate(): Prisma.CertificateDelegate<ExtArgs>;

  /**
   * `prisma.conversation`: Exposes CRUD operations for the **Conversation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Conversations
    * const conversations = await prisma.conversation.findMany()
    * ```
    */
  get conversation(): Prisma.ConversationDelegate<ExtArgs>;

  /**
   * `prisma.conversationParticipant`: Exposes CRUD operations for the **ConversationParticipant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConversationParticipants
    * const conversationParticipants = await prisma.conversationParticipant.findMany()
    * ```
    */
  get conversationParticipant(): Prisma.ConversationParticipantDelegate<ExtArgs>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<ExtArgs>;

  /**
   * `prisma.attachment`: Exposes CRUD operations for the **Attachment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Attachments
    * const attachments = await prisma.attachment.findMany()
    * ```
    */
  get attachment(): Prisma.AttachmentDelegate<ExtArgs>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs>;

  /**
   * `prisma.subscriptionPlan`: Exposes CRUD operations for the **SubscriptionPlan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubscriptionPlans
    * const subscriptionPlans = await prisma.subscriptionPlan.findMany()
    * ```
    */
  get subscriptionPlan(): Prisma.SubscriptionPlanDelegate<ExtArgs>;

  /**
   * `prisma.courseBundle`: Exposes CRUD operations for the **CourseBundle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CourseBundles
    * const courseBundles = await prisma.courseBundle.findMany()
    * ```
    */
  get courseBundle(): Prisma.CourseBundleDelegate<ExtArgs>;

  /**
   * `prisma.bundleCourse`: Exposes CRUD operations for the **BundleCourse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BundleCourses
    * const bundleCourses = await prisma.bundleCourse.findMany()
    * ```
    */
  get bundleCourse(): Prisma.BundleCourseDelegate<ExtArgs>;

  /**
   * `prisma.userSubscription`: Exposes CRUD operations for the **UserSubscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserSubscriptions
    * const userSubscriptions = await prisma.userSubscription.findMany()
    * ```
    */
  get userSubscription(): Prisma.UserSubscriptionDelegate<ExtArgs>;

  /**
   * `prisma.userBundle`: Exposes CRUD operations for the **UserBundle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserBundles
    * const userBundles = await prisma.userBundle.findMany()
    * ```
    */
  get userBundle(): Prisma.UserBundleDelegate<ExtArgs>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs>;

  /**
   * `prisma.calendarEvent`: Exposes CRUD operations for the **CalendarEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CalendarEvents
    * const calendarEvents = await prisma.calendarEvent.findMany()
    * ```
    */
  get calendarEvent(): Prisma.CalendarEventDelegate<ExtArgs>;

  /**
   * `prisma.blogPost`: Exposes CRUD operations for the **BlogPost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BlogPosts
    * const blogPosts = await prisma.blogPost.findMany()
    * ```
    */
  get blogPost(): Prisma.BlogPostDelegate<ExtArgs>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<ExtArgs>;

  /**
   * `prisma.postCategory`: Exposes CRUD operations for the **PostCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PostCategories
    * const postCategories = await prisma.postCategory.findMany()
    * ```
    */
  get postCategory(): Prisma.PostCategoryDelegate<ExtArgs>;

  /**
   * `prisma.tag`: Exposes CRUD operations for the **Tag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tags
    * const tags = await prisma.tag.findMany()
    * ```
    */
  get tag(): Prisma.TagDelegate<ExtArgs>;

  /**
   * `prisma.postTag`: Exposes CRUD operations for the **PostTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PostTags
    * const postTags = await prisma.postTag.findMany()
    * ```
    */
  get postTag(): Prisma.PostTagDelegate<ExtArgs>;

  /**
   * `prisma.blogComment`: Exposes CRUD operations for the **BlogComment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BlogComments
    * const blogComments = await prisma.blogComment.findMany()
    * ```
    */
  get blogComment(): Prisma.BlogCommentDelegate<ExtArgs>;

  /**
   * `prisma.referralCode`: Exposes CRUD operations for the **ReferralCode** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReferralCodes
    * const referralCodes = await prisma.referralCode.findMany()
    * ```
    */
  get referralCode(): Prisma.ReferralCodeDelegate<ExtArgs>;

  /**
   * `prisma.referralUse`: Exposes CRUD operations for the **ReferralUse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReferralUses
    * const referralUses = await prisma.referralUse.findMany()
    * ```
    */
  get referralUse(): Prisma.ReferralUseDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    TeacherProfile: 'TeacherProfile',
    UserAvailability: 'UserAvailability',
    PointsTransaction: 'PointsTransaction',
    PointsPackage: 'PointsPackage',
    Course: 'Course',
    Topic: 'Topic',
    Lesson: 'Lesson',
    Quiz: 'Quiz',
    Question: 'Question',
    Assignment: 'Assignment',
    Enrollment: 'Enrollment',
    SavedCourse: 'SavedCourse',
    LikedCourse: 'LikedCourse',
    LessonProgress: 'LessonProgress',
    QuizAttempt: 'QuizAttempt',
    AssignmentSubmission: 'AssignmentSubmission',
    CourseReview: 'CourseReview',
    TutoringSession: 'TutoringSession',
    TutoringAvailability: 'TutoringAvailability',
    TutoringRequest: 'TutoringRequest',
    TutoringAppointment: 'TutoringAppointment',
    TutoringReview: 'TutoringReview',
    TutoringMessage: 'TutoringMessage',
    Achievement: 'Achievement',
    UserAchievement: 'UserAchievement',
    Badge: 'Badge',
    Certificate: 'Certificate',
    Conversation: 'Conversation',
    ConversationParticipant: 'ConversationParticipant',
    Message: 'Message',
    Attachment: 'Attachment',
    Notification: 'Notification',
    SubscriptionPlan: 'SubscriptionPlan',
    CourseBundle: 'CourseBundle',
    BundleCourse: 'BundleCourse',
    UserSubscription: 'UserSubscription',
    UserBundle: 'UserBundle',
    Payment: 'Payment',
    CalendarEvent: 'CalendarEvent',
    BlogPost: 'BlogPost',
    Category: 'Category',
    PostCategory: 'PostCategory',
    Tag: 'Tag',
    PostTag: 'PostTag',
    BlogComment: 'BlogComment',
    ReferralCode: 'ReferralCode',
    ReferralUse: 'ReferralUse'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "teacherProfile" | "userAvailability" | "pointsTransaction" | "pointsPackage" | "course" | "topic" | "lesson" | "quiz" | "question" | "assignment" | "enrollment" | "savedCourse" | "likedCourse" | "lessonProgress" | "quizAttempt" | "assignmentSubmission" | "courseReview" | "tutoringSession" | "tutoringAvailability" | "tutoringRequest" | "tutoringAppointment" | "tutoringReview" | "tutoringMessage" | "achievement" | "userAchievement" | "badge" | "certificate" | "conversation" | "conversationParticipant" | "message" | "attachment" | "notification" | "subscriptionPlan" | "courseBundle" | "bundleCourse" | "userSubscription" | "userBundle" | "payment" | "calendarEvent" | "blogPost" | "category" | "postCategory" | "tag" | "postTag" | "blogComment" | "referralCode" | "referralUse"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      TeacherProfile: {
        payload: Prisma.$TeacherProfilePayload<ExtArgs>
        fields: Prisma.TeacherProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeacherProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeacherProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherProfilePayload>
          }
          findFirst: {
            args: Prisma.TeacherProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeacherProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherProfilePayload>
          }
          findMany: {
            args: Prisma.TeacherProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherProfilePayload>[]
          }
          create: {
            args: Prisma.TeacherProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherProfilePayload>
          }
          createMany: {
            args: Prisma.TeacherProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TeacherProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherProfilePayload>[]
          }
          delete: {
            args: Prisma.TeacherProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherProfilePayload>
          }
          update: {
            args: Prisma.TeacherProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherProfilePayload>
          }
          deleteMany: {
            args: Prisma.TeacherProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeacherProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TeacherProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherProfilePayload>
          }
          aggregate: {
            args: Prisma.TeacherProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeacherProfile>
          }
          groupBy: {
            args: Prisma.TeacherProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeacherProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeacherProfileCountArgs<ExtArgs>
            result: $Utils.Optional<TeacherProfileCountAggregateOutputType> | number
          }
        }
      }
      UserAvailability: {
        payload: Prisma.$UserAvailabilityPayload<ExtArgs>
        fields: Prisma.UserAvailabilityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserAvailabilityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAvailabilityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserAvailabilityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAvailabilityPayload>
          }
          findFirst: {
            args: Prisma.UserAvailabilityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAvailabilityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserAvailabilityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAvailabilityPayload>
          }
          findMany: {
            args: Prisma.UserAvailabilityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAvailabilityPayload>[]
          }
          create: {
            args: Prisma.UserAvailabilityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAvailabilityPayload>
          }
          createMany: {
            args: Prisma.UserAvailabilityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserAvailabilityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAvailabilityPayload>[]
          }
          delete: {
            args: Prisma.UserAvailabilityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAvailabilityPayload>
          }
          update: {
            args: Prisma.UserAvailabilityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAvailabilityPayload>
          }
          deleteMany: {
            args: Prisma.UserAvailabilityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserAvailabilityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserAvailabilityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAvailabilityPayload>
          }
          aggregate: {
            args: Prisma.UserAvailabilityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserAvailability>
          }
          groupBy: {
            args: Prisma.UserAvailabilityGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserAvailabilityGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserAvailabilityCountArgs<ExtArgs>
            result: $Utils.Optional<UserAvailabilityCountAggregateOutputType> | number
          }
        }
      }
      PointsTransaction: {
        payload: Prisma.$PointsTransactionPayload<ExtArgs>
        fields: Prisma.PointsTransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PointsTransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointsTransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PointsTransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointsTransactionPayload>
          }
          findFirst: {
            args: Prisma.PointsTransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointsTransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PointsTransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointsTransactionPayload>
          }
          findMany: {
            args: Prisma.PointsTransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointsTransactionPayload>[]
          }
          create: {
            args: Prisma.PointsTransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointsTransactionPayload>
          }
          createMany: {
            args: Prisma.PointsTransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PointsTransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointsTransactionPayload>[]
          }
          delete: {
            args: Prisma.PointsTransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointsTransactionPayload>
          }
          update: {
            args: Prisma.PointsTransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointsTransactionPayload>
          }
          deleteMany: {
            args: Prisma.PointsTransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PointsTransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PointsTransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointsTransactionPayload>
          }
          aggregate: {
            args: Prisma.PointsTransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePointsTransaction>
          }
          groupBy: {
            args: Prisma.PointsTransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PointsTransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PointsTransactionCountArgs<ExtArgs>
            result: $Utils.Optional<PointsTransactionCountAggregateOutputType> | number
          }
        }
      }
      PointsPackage: {
        payload: Prisma.$PointsPackagePayload<ExtArgs>
        fields: Prisma.PointsPackageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PointsPackageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointsPackagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PointsPackageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointsPackagePayload>
          }
          findFirst: {
            args: Prisma.PointsPackageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointsPackagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PointsPackageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointsPackagePayload>
          }
          findMany: {
            args: Prisma.PointsPackageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointsPackagePayload>[]
          }
          create: {
            args: Prisma.PointsPackageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointsPackagePayload>
          }
          createMany: {
            args: Prisma.PointsPackageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PointsPackageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointsPackagePayload>[]
          }
          delete: {
            args: Prisma.PointsPackageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointsPackagePayload>
          }
          update: {
            args: Prisma.PointsPackageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointsPackagePayload>
          }
          deleteMany: {
            args: Prisma.PointsPackageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PointsPackageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PointsPackageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointsPackagePayload>
          }
          aggregate: {
            args: Prisma.PointsPackageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePointsPackage>
          }
          groupBy: {
            args: Prisma.PointsPackageGroupByArgs<ExtArgs>
            result: $Utils.Optional<PointsPackageGroupByOutputType>[]
          }
          count: {
            args: Prisma.PointsPackageCountArgs<ExtArgs>
            result: $Utils.Optional<PointsPackageCountAggregateOutputType> | number
          }
        }
      }
      Course: {
        payload: Prisma.$CoursePayload<ExtArgs>
        fields: Prisma.CourseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          findFirst: {
            args: Prisma.CourseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          findMany: {
            args: Prisma.CourseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>[]
          }
          create: {
            args: Prisma.CourseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          createMany: {
            args: Prisma.CourseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CourseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>[]
          }
          delete: {
            args: Prisma.CourseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          update: {
            args: Prisma.CourseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          deleteMany: {
            args: Prisma.CourseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CourseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          aggregate: {
            args: Prisma.CourseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourse>
          }
          groupBy: {
            args: Prisma.CourseGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourseGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourseCountArgs<ExtArgs>
            result: $Utils.Optional<CourseCountAggregateOutputType> | number
          }
        }
      }
      Topic: {
        payload: Prisma.$TopicPayload<ExtArgs>
        fields: Prisma.TopicFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TopicFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TopicFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>
          }
          findFirst: {
            args: Prisma.TopicFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TopicFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>
          }
          findMany: {
            args: Prisma.TopicFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>[]
          }
          create: {
            args: Prisma.TopicCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>
          }
          createMany: {
            args: Prisma.TopicCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TopicCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>[]
          }
          delete: {
            args: Prisma.TopicDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>
          }
          update: {
            args: Prisma.TopicUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>
          }
          deleteMany: {
            args: Prisma.TopicDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TopicUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TopicUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>
          }
          aggregate: {
            args: Prisma.TopicAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTopic>
          }
          groupBy: {
            args: Prisma.TopicGroupByArgs<ExtArgs>
            result: $Utils.Optional<TopicGroupByOutputType>[]
          }
          count: {
            args: Prisma.TopicCountArgs<ExtArgs>
            result: $Utils.Optional<TopicCountAggregateOutputType> | number
          }
        }
      }
      Lesson: {
        payload: Prisma.$LessonPayload<ExtArgs>
        fields: Prisma.LessonFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LessonFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LessonFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          findFirst: {
            args: Prisma.LessonFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LessonFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          findMany: {
            args: Prisma.LessonFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>[]
          }
          create: {
            args: Prisma.LessonCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          createMany: {
            args: Prisma.LessonCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LessonCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>[]
          }
          delete: {
            args: Prisma.LessonDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          update: {
            args: Prisma.LessonUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          deleteMany: {
            args: Prisma.LessonDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LessonUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LessonUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          aggregate: {
            args: Prisma.LessonAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLesson>
          }
          groupBy: {
            args: Prisma.LessonGroupByArgs<ExtArgs>
            result: $Utils.Optional<LessonGroupByOutputType>[]
          }
          count: {
            args: Prisma.LessonCountArgs<ExtArgs>
            result: $Utils.Optional<LessonCountAggregateOutputType> | number
          }
        }
      }
      Quiz: {
        payload: Prisma.$QuizPayload<ExtArgs>
        fields: Prisma.QuizFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuizFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuizFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>
          }
          findFirst: {
            args: Prisma.QuizFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuizFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>
          }
          findMany: {
            args: Prisma.QuizFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>[]
          }
          create: {
            args: Prisma.QuizCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>
          }
          createMany: {
            args: Prisma.QuizCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuizCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>[]
          }
          delete: {
            args: Prisma.QuizDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>
          }
          update: {
            args: Prisma.QuizUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>
          }
          deleteMany: {
            args: Prisma.QuizDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuizUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.QuizUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>
          }
          aggregate: {
            args: Prisma.QuizAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuiz>
          }
          groupBy: {
            args: Prisma.QuizGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuizGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuizCountArgs<ExtArgs>
            result: $Utils.Optional<QuizCountAggregateOutputType> | number
          }
        }
      }
      Question: {
        payload: Prisma.$QuestionPayload<ExtArgs>
        fields: Prisma.QuestionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuestionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuestionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          findFirst: {
            args: Prisma.QuestionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuestionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          findMany: {
            args: Prisma.QuestionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>[]
          }
          create: {
            args: Prisma.QuestionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          createMany: {
            args: Prisma.QuestionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuestionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>[]
          }
          delete: {
            args: Prisma.QuestionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          update: {
            args: Prisma.QuestionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          deleteMany: {
            args: Prisma.QuestionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuestionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.QuestionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          aggregate: {
            args: Prisma.QuestionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuestion>
          }
          groupBy: {
            args: Prisma.QuestionGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuestionGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuestionCountArgs<ExtArgs>
            result: $Utils.Optional<QuestionCountAggregateOutputType> | number
          }
        }
      }
      Assignment: {
        payload: Prisma.$AssignmentPayload<ExtArgs>
        fields: Prisma.AssignmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AssignmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AssignmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>
          }
          findFirst: {
            args: Prisma.AssignmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AssignmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>
          }
          findMany: {
            args: Prisma.AssignmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>[]
          }
          create: {
            args: Prisma.AssignmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>
          }
          createMany: {
            args: Prisma.AssignmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AssignmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>[]
          }
          delete: {
            args: Prisma.AssignmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>
          }
          update: {
            args: Prisma.AssignmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>
          }
          deleteMany: {
            args: Prisma.AssignmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AssignmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AssignmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>
          }
          aggregate: {
            args: Prisma.AssignmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAssignment>
          }
          groupBy: {
            args: Prisma.AssignmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AssignmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AssignmentCountArgs<ExtArgs>
            result: $Utils.Optional<AssignmentCountAggregateOutputType> | number
          }
        }
      }
      Enrollment: {
        payload: Prisma.$EnrollmentPayload<ExtArgs>
        fields: Prisma.EnrollmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EnrollmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EnrollmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>
          }
          findFirst: {
            args: Prisma.EnrollmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EnrollmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>
          }
          findMany: {
            args: Prisma.EnrollmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>[]
          }
          create: {
            args: Prisma.EnrollmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>
          }
          createMany: {
            args: Prisma.EnrollmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EnrollmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>[]
          }
          delete: {
            args: Prisma.EnrollmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>
          }
          update: {
            args: Prisma.EnrollmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>
          }
          deleteMany: {
            args: Prisma.EnrollmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EnrollmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EnrollmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>
          }
          aggregate: {
            args: Prisma.EnrollmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEnrollment>
          }
          groupBy: {
            args: Prisma.EnrollmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<EnrollmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.EnrollmentCountArgs<ExtArgs>
            result: $Utils.Optional<EnrollmentCountAggregateOutputType> | number
          }
        }
      }
      SavedCourse: {
        payload: Prisma.$SavedCoursePayload<ExtArgs>
        fields: Prisma.SavedCourseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SavedCourseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedCoursePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SavedCourseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedCoursePayload>
          }
          findFirst: {
            args: Prisma.SavedCourseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedCoursePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SavedCourseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedCoursePayload>
          }
          findMany: {
            args: Prisma.SavedCourseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedCoursePayload>[]
          }
          create: {
            args: Prisma.SavedCourseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedCoursePayload>
          }
          createMany: {
            args: Prisma.SavedCourseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SavedCourseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedCoursePayload>[]
          }
          delete: {
            args: Prisma.SavedCourseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedCoursePayload>
          }
          update: {
            args: Prisma.SavedCourseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedCoursePayload>
          }
          deleteMany: {
            args: Prisma.SavedCourseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SavedCourseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SavedCourseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedCoursePayload>
          }
          aggregate: {
            args: Prisma.SavedCourseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSavedCourse>
          }
          groupBy: {
            args: Prisma.SavedCourseGroupByArgs<ExtArgs>
            result: $Utils.Optional<SavedCourseGroupByOutputType>[]
          }
          count: {
            args: Prisma.SavedCourseCountArgs<ExtArgs>
            result: $Utils.Optional<SavedCourseCountAggregateOutputType> | number
          }
        }
      }
      LikedCourse: {
        payload: Prisma.$LikedCoursePayload<ExtArgs>
        fields: Prisma.LikedCourseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LikedCourseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikedCoursePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LikedCourseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikedCoursePayload>
          }
          findFirst: {
            args: Prisma.LikedCourseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikedCoursePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LikedCourseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikedCoursePayload>
          }
          findMany: {
            args: Prisma.LikedCourseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikedCoursePayload>[]
          }
          create: {
            args: Prisma.LikedCourseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikedCoursePayload>
          }
          createMany: {
            args: Prisma.LikedCourseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LikedCourseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikedCoursePayload>[]
          }
          delete: {
            args: Prisma.LikedCourseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikedCoursePayload>
          }
          update: {
            args: Prisma.LikedCourseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikedCoursePayload>
          }
          deleteMany: {
            args: Prisma.LikedCourseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LikedCourseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LikedCourseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikedCoursePayload>
          }
          aggregate: {
            args: Prisma.LikedCourseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLikedCourse>
          }
          groupBy: {
            args: Prisma.LikedCourseGroupByArgs<ExtArgs>
            result: $Utils.Optional<LikedCourseGroupByOutputType>[]
          }
          count: {
            args: Prisma.LikedCourseCountArgs<ExtArgs>
            result: $Utils.Optional<LikedCourseCountAggregateOutputType> | number
          }
        }
      }
      LessonProgress: {
        payload: Prisma.$LessonProgressPayload<ExtArgs>
        fields: Prisma.LessonProgressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LessonProgressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonProgressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LessonProgressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonProgressPayload>
          }
          findFirst: {
            args: Prisma.LessonProgressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonProgressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LessonProgressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonProgressPayload>
          }
          findMany: {
            args: Prisma.LessonProgressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonProgressPayload>[]
          }
          create: {
            args: Prisma.LessonProgressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonProgressPayload>
          }
          createMany: {
            args: Prisma.LessonProgressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LessonProgressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonProgressPayload>[]
          }
          delete: {
            args: Prisma.LessonProgressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonProgressPayload>
          }
          update: {
            args: Prisma.LessonProgressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonProgressPayload>
          }
          deleteMany: {
            args: Prisma.LessonProgressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LessonProgressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LessonProgressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonProgressPayload>
          }
          aggregate: {
            args: Prisma.LessonProgressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLessonProgress>
          }
          groupBy: {
            args: Prisma.LessonProgressGroupByArgs<ExtArgs>
            result: $Utils.Optional<LessonProgressGroupByOutputType>[]
          }
          count: {
            args: Prisma.LessonProgressCountArgs<ExtArgs>
            result: $Utils.Optional<LessonProgressCountAggregateOutputType> | number
          }
        }
      }
      QuizAttempt: {
        payload: Prisma.$QuizAttemptPayload<ExtArgs>
        fields: Prisma.QuizAttemptFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuizAttemptFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAttemptPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuizAttemptFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAttemptPayload>
          }
          findFirst: {
            args: Prisma.QuizAttemptFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAttemptPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuizAttemptFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAttemptPayload>
          }
          findMany: {
            args: Prisma.QuizAttemptFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAttemptPayload>[]
          }
          create: {
            args: Prisma.QuizAttemptCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAttemptPayload>
          }
          createMany: {
            args: Prisma.QuizAttemptCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuizAttemptCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAttemptPayload>[]
          }
          delete: {
            args: Prisma.QuizAttemptDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAttemptPayload>
          }
          update: {
            args: Prisma.QuizAttemptUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAttemptPayload>
          }
          deleteMany: {
            args: Prisma.QuizAttemptDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuizAttemptUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.QuizAttemptUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAttemptPayload>
          }
          aggregate: {
            args: Prisma.QuizAttemptAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuizAttempt>
          }
          groupBy: {
            args: Prisma.QuizAttemptGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuizAttemptGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuizAttemptCountArgs<ExtArgs>
            result: $Utils.Optional<QuizAttemptCountAggregateOutputType> | number
          }
        }
      }
      AssignmentSubmission: {
        payload: Prisma.$AssignmentSubmissionPayload<ExtArgs>
        fields: Prisma.AssignmentSubmissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AssignmentSubmissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentSubmissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AssignmentSubmissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentSubmissionPayload>
          }
          findFirst: {
            args: Prisma.AssignmentSubmissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentSubmissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AssignmentSubmissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentSubmissionPayload>
          }
          findMany: {
            args: Prisma.AssignmentSubmissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentSubmissionPayload>[]
          }
          create: {
            args: Prisma.AssignmentSubmissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentSubmissionPayload>
          }
          createMany: {
            args: Prisma.AssignmentSubmissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AssignmentSubmissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentSubmissionPayload>[]
          }
          delete: {
            args: Prisma.AssignmentSubmissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentSubmissionPayload>
          }
          update: {
            args: Prisma.AssignmentSubmissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentSubmissionPayload>
          }
          deleteMany: {
            args: Prisma.AssignmentSubmissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AssignmentSubmissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AssignmentSubmissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentSubmissionPayload>
          }
          aggregate: {
            args: Prisma.AssignmentSubmissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAssignmentSubmission>
          }
          groupBy: {
            args: Prisma.AssignmentSubmissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<AssignmentSubmissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.AssignmentSubmissionCountArgs<ExtArgs>
            result: $Utils.Optional<AssignmentSubmissionCountAggregateOutputType> | number
          }
        }
      }
      CourseReview: {
        payload: Prisma.$CourseReviewPayload<ExtArgs>
        fields: Prisma.CourseReviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourseReviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseReviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourseReviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseReviewPayload>
          }
          findFirst: {
            args: Prisma.CourseReviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseReviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourseReviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseReviewPayload>
          }
          findMany: {
            args: Prisma.CourseReviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseReviewPayload>[]
          }
          create: {
            args: Prisma.CourseReviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseReviewPayload>
          }
          createMany: {
            args: Prisma.CourseReviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CourseReviewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseReviewPayload>[]
          }
          delete: {
            args: Prisma.CourseReviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseReviewPayload>
          }
          update: {
            args: Prisma.CourseReviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseReviewPayload>
          }
          deleteMany: {
            args: Prisma.CourseReviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourseReviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CourseReviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseReviewPayload>
          }
          aggregate: {
            args: Prisma.CourseReviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourseReview>
          }
          groupBy: {
            args: Prisma.CourseReviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourseReviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourseReviewCountArgs<ExtArgs>
            result: $Utils.Optional<CourseReviewCountAggregateOutputType> | number
          }
        }
      }
      TutoringSession: {
        payload: Prisma.$TutoringSessionPayload<ExtArgs>
        fields: Prisma.TutoringSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TutoringSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutoringSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TutoringSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutoringSessionPayload>
          }
          findFirst: {
            args: Prisma.TutoringSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutoringSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TutoringSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutoringSessionPayload>
          }
          findMany: {
            args: Prisma.TutoringSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutoringSessionPayload>[]
          }
          create: {
            args: Prisma.TutoringSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutoringSessionPayload>
          }
          createMany: {
            args: Prisma.TutoringSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TutoringSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutoringSessionPayload>[]
          }
          delete: {
            args: Prisma.TutoringSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutoringSessionPayload>
          }
          update: {
            args: Prisma.TutoringSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutoringSessionPayload>
          }
          deleteMany: {
            args: Prisma.TutoringSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TutoringSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TutoringSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutoringSessionPayload>
          }
          aggregate: {
            args: Prisma.TutoringSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTutoringSession>
          }
          groupBy: {
            args: Prisma.TutoringSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TutoringSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TutoringSessionCountArgs<ExtArgs>
            result: $Utils.Optional<TutoringSessionCountAggregateOutputType> | number
          }
        }
      }
      TutoringAvailability: {
        payload: Prisma.$TutoringAvailabilityPayload<ExtArgs>
        fields: Prisma.TutoringAvailabilityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TutoringAvailabilityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutoringAvailabilityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TutoringAvailabilityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutoringAvailabilityPayload>
          }
          findFirst: {
            args: Prisma.TutoringAvailabilityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutoringAvailabilityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TutoringAvailabilityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutoringAvailabilityPayload>
          }
          findMany: {
            args: Prisma.TutoringAvailabilityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutoringAvailabilityPayload>[]
          }
          create: {
            args: Prisma.TutoringAvailabilityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutoringAvailabilityPayload>
          }
          createMany: {
            args: Prisma.TutoringAvailabilityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TutoringAvailabilityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutoringAvailabilityPayload>[]
          }
          delete: {
            args: Prisma.TutoringAvailabilityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutoringAvailabilityPayload>
          }
          update: {
            args: Prisma.TutoringAvailabilityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutoringAvailabilityPayload>
          }
          deleteMany: {
            args: Prisma.TutoringAvailabilityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TutoringAvailabilityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TutoringAvailabilityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutoringAvailabilityPayload>
          }
          aggregate: {
            args: Prisma.TutoringAvailabilityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTutoringAvailability>
          }
          groupBy: {
            args: Prisma.TutoringAvailabilityGroupByArgs<ExtArgs>
            result: $Utils.Optional<TutoringAvailabilityGroupByOutputType>[]
          }
          count: {
            args: Prisma.TutoringAvailabilityCountArgs<ExtArgs>
            result: $Utils.Optional<TutoringAvailabilityCountAggregateOutputType> | number
          }
        }
      }
      TutoringRequest: {
        payload: Prisma.$TutoringRequestPayload<ExtArgs>
        fields: Prisma.TutoringRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TutoringRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutoringRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TutoringRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutoringRequestPayload>
          }
          findFirst: {
            args: Prisma.TutoringRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutoringRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TutoringRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutoringRequestPayload>
          }
          findMany: {
            args: Prisma.TutoringRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutoringRequestPayload>[]
          }
          create: {
            args: Prisma.TutoringRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutoringRequestPayload>
          }
          createMany: {
            args: Prisma.TutoringRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TutoringRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutoringRequestPayload>[]
          }
          delete: {
            args: Prisma.TutoringRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutoringRequestPayload>
          }
          update: {
            args: Prisma.TutoringRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutoringRequestPayload>
          }
          deleteMany: {
            args: Prisma.TutoringRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TutoringRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TutoringRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutoringRequestPayload>
          }
          aggregate: {
            args: Prisma.TutoringRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTutoringRequest>
          }
          groupBy: {
            args: Prisma.TutoringRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<TutoringRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.TutoringRequestCountArgs<ExtArgs>
            result: $Utils.Optional<TutoringRequestCountAggregateOutputType> | number
          }
        }
      }
      TutoringAppointment: {
        payload: Prisma.$TutoringAppointmentPayload<ExtArgs>
        fields: Prisma.TutoringAppointmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TutoringAppointmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutoringAppointmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TutoringAppointmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutoringAppointmentPayload>
          }
          findFirst: {
            args: Prisma.TutoringAppointmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutoringAppointmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TutoringAppointmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutoringAppointmentPayload>
          }
          findMany: {
            args: Prisma.TutoringAppointmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutoringAppointmentPayload>[]
          }
          create: {
            args: Prisma.TutoringAppointmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutoringAppointmentPayload>
          }
          createMany: {
            args: Prisma.TutoringAppointmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TutoringAppointmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutoringAppointmentPayload>[]
          }
          delete: {
            args: Prisma.TutoringAppointmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutoringAppointmentPayload>
          }
          update: {
            args: Prisma.TutoringAppointmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutoringAppointmentPayload>
          }
          deleteMany: {
            args: Prisma.TutoringAppointmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TutoringAppointmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TutoringAppointmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutoringAppointmentPayload>
          }
          aggregate: {
            args: Prisma.TutoringAppointmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTutoringAppointment>
          }
          groupBy: {
            args: Prisma.TutoringAppointmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<TutoringAppointmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.TutoringAppointmentCountArgs<ExtArgs>
            result: $Utils.Optional<TutoringAppointmentCountAggregateOutputType> | number
          }
        }
      }
      TutoringReview: {
        payload: Prisma.$TutoringReviewPayload<ExtArgs>
        fields: Prisma.TutoringReviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TutoringReviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutoringReviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TutoringReviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutoringReviewPayload>
          }
          findFirst: {
            args: Prisma.TutoringReviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutoringReviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TutoringReviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutoringReviewPayload>
          }
          findMany: {
            args: Prisma.TutoringReviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutoringReviewPayload>[]
          }
          create: {
            args: Prisma.TutoringReviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutoringReviewPayload>
          }
          createMany: {
            args: Prisma.TutoringReviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TutoringReviewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutoringReviewPayload>[]
          }
          delete: {
            args: Prisma.TutoringReviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutoringReviewPayload>
          }
          update: {
            args: Prisma.TutoringReviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutoringReviewPayload>
          }
          deleteMany: {
            args: Prisma.TutoringReviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TutoringReviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TutoringReviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutoringReviewPayload>
          }
          aggregate: {
            args: Prisma.TutoringReviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTutoringReview>
          }
          groupBy: {
            args: Prisma.TutoringReviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<TutoringReviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.TutoringReviewCountArgs<ExtArgs>
            result: $Utils.Optional<TutoringReviewCountAggregateOutputType> | number
          }
        }
      }
      TutoringMessage: {
        payload: Prisma.$TutoringMessagePayload<ExtArgs>
        fields: Prisma.TutoringMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TutoringMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutoringMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TutoringMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutoringMessagePayload>
          }
          findFirst: {
            args: Prisma.TutoringMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutoringMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TutoringMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutoringMessagePayload>
          }
          findMany: {
            args: Prisma.TutoringMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutoringMessagePayload>[]
          }
          create: {
            args: Prisma.TutoringMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutoringMessagePayload>
          }
          createMany: {
            args: Prisma.TutoringMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TutoringMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutoringMessagePayload>[]
          }
          delete: {
            args: Prisma.TutoringMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutoringMessagePayload>
          }
          update: {
            args: Prisma.TutoringMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutoringMessagePayload>
          }
          deleteMany: {
            args: Prisma.TutoringMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TutoringMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TutoringMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutoringMessagePayload>
          }
          aggregate: {
            args: Prisma.TutoringMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTutoringMessage>
          }
          groupBy: {
            args: Prisma.TutoringMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<TutoringMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.TutoringMessageCountArgs<ExtArgs>
            result: $Utils.Optional<TutoringMessageCountAggregateOutputType> | number
          }
        }
      }
      Achievement: {
        payload: Prisma.$AchievementPayload<ExtArgs>
        fields: Prisma.AchievementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AchievementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AchievementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          findFirst: {
            args: Prisma.AchievementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AchievementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          findMany: {
            args: Prisma.AchievementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>[]
          }
          create: {
            args: Prisma.AchievementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          createMany: {
            args: Prisma.AchievementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AchievementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>[]
          }
          delete: {
            args: Prisma.AchievementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          update: {
            args: Prisma.AchievementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          deleteMany: {
            args: Prisma.AchievementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AchievementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AchievementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          aggregate: {
            args: Prisma.AchievementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAchievement>
          }
          groupBy: {
            args: Prisma.AchievementGroupByArgs<ExtArgs>
            result: $Utils.Optional<AchievementGroupByOutputType>[]
          }
          count: {
            args: Prisma.AchievementCountArgs<ExtArgs>
            result: $Utils.Optional<AchievementCountAggregateOutputType> | number
          }
        }
      }
      UserAchievement: {
        payload: Prisma.$UserAchievementPayload<ExtArgs>
        fields: Prisma.UserAchievementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserAchievementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserAchievementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          findFirst: {
            args: Prisma.UserAchievementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserAchievementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          findMany: {
            args: Prisma.UserAchievementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>[]
          }
          create: {
            args: Prisma.UserAchievementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          createMany: {
            args: Prisma.UserAchievementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserAchievementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>[]
          }
          delete: {
            args: Prisma.UserAchievementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          update: {
            args: Prisma.UserAchievementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          deleteMany: {
            args: Prisma.UserAchievementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserAchievementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserAchievementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          aggregate: {
            args: Prisma.UserAchievementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserAchievement>
          }
          groupBy: {
            args: Prisma.UserAchievementGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserAchievementGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserAchievementCountArgs<ExtArgs>
            result: $Utils.Optional<UserAchievementCountAggregateOutputType> | number
          }
        }
      }
      Badge: {
        payload: Prisma.$BadgePayload<ExtArgs>
        fields: Prisma.BadgeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BadgeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BadgeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          findFirst: {
            args: Prisma.BadgeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BadgeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          findMany: {
            args: Prisma.BadgeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>[]
          }
          create: {
            args: Prisma.BadgeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          createMany: {
            args: Prisma.BadgeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BadgeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>[]
          }
          delete: {
            args: Prisma.BadgeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          update: {
            args: Prisma.BadgeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          deleteMany: {
            args: Prisma.BadgeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BadgeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BadgeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          aggregate: {
            args: Prisma.BadgeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBadge>
          }
          groupBy: {
            args: Prisma.BadgeGroupByArgs<ExtArgs>
            result: $Utils.Optional<BadgeGroupByOutputType>[]
          }
          count: {
            args: Prisma.BadgeCountArgs<ExtArgs>
            result: $Utils.Optional<BadgeCountAggregateOutputType> | number
          }
        }
      }
      Certificate: {
        payload: Prisma.$CertificatePayload<ExtArgs>
        fields: Prisma.CertificateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CertificateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CertificateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>
          }
          findFirst: {
            args: Prisma.CertificateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CertificateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>
          }
          findMany: {
            args: Prisma.CertificateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>[]
          }
          create: {
            args: Prisma.CertificateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>
          }
          createMany: {
            args: Prisma.CertificateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CertificateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>[]
          }
          delete: {
            args: Prisma.CertificateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>
          }
          update: {
            args: Prisma.CertificateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>
          }
          deleteMany: {
            args: Prisma.CertificateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CertificateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CertificateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>
          }
          aggregate: {
            args: Prisma.CertificateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCertificate>
          }
          groupBy: {
            args: Prisma.CertificateGroupByArgs<ExtArgs>
            result: $Utils.Optional<CertificateGroupByOutputType>[]
          }
          count: {
            args: Prisma.CertificateCountArgs<ExtArgs>
            result: $Utils.Optional<CertificateCountAggregateOutputType> | number
          }
        }
      }
      Conversation: {
        payload: Prisma.$ConversationPayload<ExtArgs>
        fields: Prisma.ConversationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConversationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConversationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          findFirst: {
            args: Prisma.ConversationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConversationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          findMany: {
            args: Prisma.ConversationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>[]
          }
          create: {
            args: Prisma.ConversationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          createMany: {
            args: Prisma.ConversationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConversationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>[]
          }
          delete: {
            args: Prisma.ConversationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          update: {
            args: Prisma.ConversationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          deleteMany: {
            args: Prisma.ConversationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConversationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ConversationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          aggregate: {
            args: Prisma.ConversationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConversation>
          }
          groupBy: {
            args: Prisma.ConversationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConversationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConversationCountArgs<ExtArgs>
            result: $Utils.Optional<ConversationCountAggregateOutputType> | number
          }
        }
      }
      ConversationParticipant: {
        payload: Prisma.$ConversationParticipantPayload<ExtArgs>
        fields: Prisma.ConversationParticipantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConversationParticipantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationParticipantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConversationParticipantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationParticipantPayload>
          }
          findFirst: {
            args: Prisma.ConversationParticipantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationParticipantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConversationParticipantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationParticipantPayload>
          }
          findMany: {
            args: Prisma.ConversationParticipantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationParticipantPayload>[]
          }
          create: {
            args: Prisma.ConversationParticipantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationParticipantPayload>
          }
          createMany: {
            args: Prisma.ConversationParticipantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConversationParticipantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationParticipantPayload>[]
          }
          delete: {
            args: Prisma.ConversationParticipantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationParticipantPayload>
          }
          update: {
            args: Prisma.ConversationParticipantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationParticipantPayload>
          }
          deleteMany: {
            args: Prisma.ConversationParticipantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConversationParticipantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ConversationParticipantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationParticipantPayload>
          }
          aggregate: {
            args: Prisma.ConversationParticipantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConversationParticipant>
          }
          groupBy: {
            args: Prisma.ConversationParticipantGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConversationParticipantGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConversationParticipantCountArgs<ExtArgs>
            result: $Utils.Optional<ConversationParticipantCountAggregateOutputType> | number
          }
        }
      }
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>
        fields: Prisma.MessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      Attachment: {
        payload: Prisma.$AttachmentPayload<ExtArgs>
        fields: Prisma.AttachmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AttachmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AttachmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          findFirst: {
            args: Prisma.AttachmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AttachmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          findMany: {
            args: Prisma.AttachmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>[]
          }
          create: {
            args: Prisma.AttachmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          createMany: {
            args: Prisma.AttachmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AttachmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>[]
          }
          delete: {
            args: Prisma.AttachmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          update: {
            args: Prisma.AttachmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          deleteMany: {
            args: Prisma.AttachmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AttachmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AttachmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          aggregate: {
            args: Prisma.AttachmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttachment>
          }
          groupBy: {
            args: Prisma.AttachmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttachmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AttachmentCountArgs<ExtArgs>
            result: $Utils.Optional<AttachmentCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      SubscriptionPlan: {
        payload: Prisma.$SubscriptionPlanPayload<ExtArgs>
        fields: Prisma.SubscriptionPlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubscriptionPlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubscriptionPlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>
          }
          findFirst: {
            args: Prisma.SubscriptionPlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubscriptionPlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>
          }
          findMany: {
            args: Prisma.SubscriptionPlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>[]
          }
          create: {
            args: Prisma.SubscriptionPlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>
          }
          createMany: {
            args: Prisma.SubscriptionPlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubscriptionPlanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>[]
          }
          delete: {
            args: Prisma.SubscriptionPlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>
          }
          update: {
            args: Prisma.SubscriptionPlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>
          }
          deleteMany: {
            args: Prisma.SubscriptionPlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubscriptionPlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SubscriptionPlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>
          }
          aggregate: {
            args: Prisma.SubscriptionPlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscriptionPlan>
          }
          groupBy: {
            args: Prisma.SubscriptionPlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionPlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubscriptionPlanCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionPlanCountAggregateOutputType> | number
          }
        }
      }
      CourseBundle: {
        payload: Prisma.$CourseBundlePayload<ExtArgs>
        fields: Prisma.CourseBundleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourseBundleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseBundlePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourseBundleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseBundlePayload>
          }
          findFirst: {
            args: Prisma.CourseBundleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseBundlePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourseBundleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseBundlePayload>
          }
          findMany: {
            args: Prisma.CourseBundleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseBundlePayload>[]
          }
          create: {
            args: Prisma.CourseBundleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseBundlePayload>
          }
          createMany: {
            args: Prisma.CourseBundleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CourseBundleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseBundlePayload>[]
          }
          delete: {
            args: Prisma.CourseBundleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseBundlePayload>
          }
          update: {
            args: Prisma.CourseBundleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseBundlePayload>
          }
          deleteMany: {
            args: Prisma.CourseBundleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourseBundleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CourseBundleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseBundlePayload>
          }
          aggregate: {
            args: Prisma.CourseBundleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourseBundle>
          }
          groupBy: {
            args: Prisma.CourseBundleGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourseBundleGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourseBundleCountArgs<ExtArgs>
            result: $Utils.Optional<CourseBundleCountAggregateOutputType> | number
          }
        }
      }
      BundleCourse: {
        payload: Prisma.$BundleCoursePayload<ExtArgs>
        fields: Prisma.BundleCourseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BundleCourseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BundleCoursePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BundleCourseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BundleCoursePayload>
          }
          findFirst: {
            args: Prisma.BundleCourseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BundleCoursePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BundleCourseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BundleCoursePayload>
          }
          findMany: {
            args: Prisma.BundleCourseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BundleCoursePayload>[]
          }
          create: {
            args: Prisma.BundleCourseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BundleCoursePayload>
          }
          createMany: {
            args: Prisma.BundleCourseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BundleCourseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BundleCoursePayload>[]
          }
          delete: {
            args: Prisma.BundleCourseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BundleCoursePayload>
          }
          update: {
            args: Prisma.BundleCourseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BundleCoursePayload>
          }
          deleteMany: {
            args: Prisma.BundleCourseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BundleCourseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BundleCourseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BundleCoursePayload>
          }
          aggregate: {
            args: Prisma.BundleCourseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBundleCourse>
          }
          groupBy: {
            args: Prisma.BundleCourseGroupByArgs<ExtArgs>
            result: $Utils.Optional<BundleCourseGroupByOutputType>[]
          }
          count: {
            args: Prisma.BundleCourseCountArgs<ExtArgs>
            result: $Utils.Optional<BundleCourseCountAggregateOutputType> | number
          }
        }
      }
      UserSubscription: {
        payload: Prisma.$UserSubscriptionPayload<ExtArgs>
        fields: Prisma.UserSubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserSubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserSubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload>
          }
          findFirst: {
            args: Prisma.UserSubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserSubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload>
          }
          findMany: {
            args: Prisma.UserSubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload>[]
          }
          create: {
            args: Prisma.UserSubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload>
          }
          createMany: {
            args: Prisma.UserSubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserSubscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload>[]
          }
          delete: {
            args: Prisma.UserSubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload>
          }
          update: {
            args: Prisma.UserSubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.UserSubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserSubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserSubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload>
          }
          aggregate: {
            args: Prisma.UserSubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserSubscription>
          }
          groupBy: {
            args: Prisma.UserSubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserSubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserSubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<UserSubscriptionCountAggregateOutputType> | number
          }
        }
      }
      UserBundle: {
        payload: Prisma.$UserBundlePayload<ExtArgs>
        fields: Prisma.UserBundleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserBundleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBundlePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserBundleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBundlePayload>
          }
          findFirst: {
            args: Prisma.UserBundleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBundlePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserBundleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBundlePayload>
          }
          findMany: {
            args: Prisma.UserBundleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBundlePayload>[]
          }
          create: {
            args: Prisma.UserBundleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBundlePayload>
          }
          createMany: {
            args: Prisma.UserBundleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserBundleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBundlePayload>[]
          }
          delete: {
            args: Prisma.UserBundleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBundlePayload>
          }
          update: {
            args: Prisma.UserBundleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBundlePayload>
          }
          deleteMany: {
            args: Prisma.UserBundleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserBundleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserBundleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBundlePayload>
          }
          aggregate: {
            args: Prisma.UserBundleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserBundle>
          }
          groupBy: {
            args: Prisma.UserBundleGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserBundleGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserBundleCountArgs<ExtArgs>
            result: $Utils.Optional<UserBundleCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      CalendarEvent: {
        payload: Prisma.$CalendarEventPayload<ExtArgs>
        fields: Prisma.CalendarEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CalendarEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CalendarEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventPayload>
          }
          findFirst: {
            args: Prisma.CalendarEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CalendarEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventPayload>
          }
          findMany: {
            args: Prisma.CalendarEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventPayload>[]
          }
          create: {
            args: Prisma.CalendarEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventPayload>
          }
          createMany: {
            args: Prisma.CalendarEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CalendarEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventPayload>[]
          }
          delete: {
            args: Prisma.CalendarEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventPayload>
          }
          update: {
            args: Prisma.CalendarEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventPayload>
          }
          deleteMany: {
            args: Prisma.CalendarEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CalendarEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CalendarEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventPayload>
          }
          aggregate: {
            args: Prisma.CalendarEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCalendarEvent>
          }
          groupBy: {
            args: Prisma.CalendarEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<CalendarEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.CalendarEventCountArgs<ExtArgs>
            result: $Utils.Optional<CalendarEventCountAggregateOutputType> | number
          }
        }
      }
      BlogPost: {
        payload: Prisma.$BlogPostPayload<ExtArgs>
        fields: Prisma.BlogPostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BlogPostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BlogPostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          findFirst: {
            args: Prisma.BlogPostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BlogPostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          findMany: {
            args: Prisma.BlogPostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>[]
          }
          create: {
            args: Prisma.BlogPostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          createMany: {
            args: Prisma.BlogPostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BlogPostCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>[]
          }
          delete: {
            args: Prisma.BlogPostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          update: {
            args: Prisma.BlogPostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          deleteMany: {
            args: Prisma.BlogPostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BlogPostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BlogPostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          aggregate: {
            args: Prisma.BlogPostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlogPost>
          }
          groupBy: {
            args: Prisma.BlogPostGroupByArgs<ExtArgs>
            result: $Utils.Optional<BlogPostGroupByOutputType>[]
          }
          count: {
            args: Prisma.BlogPostCountArgs<ExtArgs>
            result: $Utils.Optional<BlogPostCountAggregateOutputType> | number
          }
        }
      }
      Category: {
        payload: Prisma.$CategoryPayload<ExtArgs>
        fields: Prisma.CategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findFirst: {
            args: Prisma.CategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findMany: {
            args: Prisma.CategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          create: {
            args: Prisma.CategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          createMany: {
            args: Prisma.CategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          delete: {
            args: Prisma.CategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          update: {
            args: Prisma.CategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          deleteMany: {
            args: Prisma.CategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategory>
          }
          groupBy: {
            args: Prisma.CategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoryCountArgs<ExtArgs>
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
          }
        }
      }
      PostCategory: {
        payload: Prisma.$PostCategoryPayload<ExtArgs>
        fields: Prisma.PostCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PostCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PostCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostCategoryPayload>
          }
          findFirst: {
            args: Prisma.PostCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PostCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostCategoryPayload>
          }
          findMany: {
            args: Prisma.PostCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostCategoryPayload>[]
          }
          create: {
            args: Prisma.PostCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostCategoryPayload>
          }
          createMany: {
            args: Prisma.PostCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PostCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostCategoryPayload>[]
          }
          delete: {
            args: Prisma.PostCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostCategoryPayload>
          }
          update: {
            args: Prisma.PostCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostCategoryPayload>
          }
          deleteMany: {
            args: Prisma.PostCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PostCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PostCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostCategoryPayload>
          }
          aggregate: {
            args: Prisma.PostCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePostCategory>
          }
          groupBy: {
            args: Prisma.PostCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<PostCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.PostCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<PostCategoryCountAggregateOutputType> | number
          }
        }
      }
      Tag: {
        payload: Prisma.$TagPayload<ExtArgs>
        fields: Prisma.TagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findFirst: {
            args: Prisma.TagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findMany: {
            args: Prisma.TagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          create: {
            args: Prisma.TagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          createMany: {
            args: Prisma.TagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          delete: {
            args: Prisma.TagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          update: {
            args: Prisma.TagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          deleteMany: {
            args: Prisma.TagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          aggregate: {
            args: Prisma.TagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTag>
          }
          groupBy: {
            args: Prisma.TagGroupByArgs<ExtArgs>
            result: $Utils.Optional<TagGroupByOutputType>[]
          }
          count: {
            args: Prisma.TagCountArgs<ExtArgs>
            result: $Utils.Optional<TagCountAggregateOutputType> | number
          }
        }
      }
      PostTag: {
        payload: Prisma.$PostTagPayload<ExtArgs>
        fields: Prisma.PostTagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PostTagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostTagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PostTagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostTagPayload>
          }
          findFirst: {
            args: Prisma.PostTagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostTagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PostTagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostTagPayload>
          }
          findMany: {
            args: Prisma.PostTagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostTagPayload>[]
          }
          create: {
            args: Prisma.PostTagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostTagPayload>
          }
          createMany: {
            args: Prisma.PostTagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PostTagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostTagPayload>[]
          }
          delete: {
            args: Prisma.PostTagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostTagPayload>
          }
          update: {
            args: Prisma.PostTagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostTagPayload>
          }
          deleteMany: {
            args: Prisma.PostTagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PostTagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PostTagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostTagPayload>
          }
          aggregate: {
            args: Prisma.PostTagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePostTag>
          }
          groupBy: {
            args: Prisma.PostTagGroupByArgs<ExtArgs>
            result: $Utils.Optional<PostTagGroupByOutputType>[]
          }
          count: {
            args: Prisma.PostTagCountArgs<ExtArgs>
            result: $Utils.Optional<PostTagCountAggregateOutputType> | number
          }
        }
      }
      BlogComment: {
        payload: Prisma.$BlogCommentPayload<ExtArgs>
        fields: Prisma.BlogCommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BlogCommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogCommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BlogCommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogCommentPayload>
          }
          findFirst: {
            args: Prisma.BlogCommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogCommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BlogCommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogCommentPayload>
          }
          findMany: {
            args: Prisma.BlogCommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogCommentPayload>[]
          }
          create: {
            args: Prisma.BlogCommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogCommentPayload>
          }
          createMany: {
            args: Prisma.BlogCommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BlogCommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogCommentPayload>[]
          }
          delete: {
            args: Prisma.BlogCommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogCommentPayload>
          }
          update: {
            args: Prisma.BlogCommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogCommentPayload>
          }
          deleteMany: {
            args: Prisma.BlogCommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BlogCommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BlogCommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogCommentPayload>
          }
          aggregate: {
            args: Prisma.BlogCommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlogComment>
          }
          groupBy: {
            args: Prisma.BlogCommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<BlogCommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.BlogCommentCountArgs<ExtArgs>
            result: $Utils.Optional<BlogCommentCountAggregateOutputType> | number
          }
        }
      }
      ReferralCode: {
        payload: Prisma.$ReferralCodePayload<ExtArgs>
        fields: Prisma.ReferralCodeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReferralCodeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralCodePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReferralCodeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralCodePayload>
          }
          findFirst: {
            args: Prisma.ReferralCodeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralCodePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReferralCodeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralCodePayload>
          }
          findMany: {
            args: Prisma.ReferralCodeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralCodePayload>[]
          }
          create: {
            args: Prisma.ReferralCodeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralCodePayload>
          }
          createMany: {
            args: Prisma.ReferralCodeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReferralCodeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralCodePayload>[]
          }
          delete: {
            args: Prisma.ReferralCodeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralCodePayload>
          }
          update: {
            args: Prisma.ReferralCodeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralCodePayload>
          }
          deleteMany: {
            args: Prisma.ReferralCodeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReferralCodeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReferralCodeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralCodePayload>
          }
          aggregate: {
            args: Prisma.ReferralCodeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReferralCode>
          }
          groupBy: {
            args: Prisma.ReferralCodeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReferralCodeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReferralCodeCountArgs<ExtArgs>
            result: $Utils.Optional<ReferralCodeCountAggregateOutputType> | number
          }
        }
      }
      ReferralUse: {
        payload: Prisma.$ReferralUsePayload<ExtArgs>
        fields: Prisma.ReferralUseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReferralUseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralUsePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReferralUseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralUsePayload>
          }
          findFirst: {
            args: Prisma.ReferralUseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralUsePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReferralUseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralUsePayload>
          }
          findMany: {
            args: Prisma.ReferralUseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralUsePayload>[]
          }
          create: {
            args: Prisma.ReferralUseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralUsePayload>
          }
          createMany: {
            args: Prisma.ReferralUseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReferralUseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralUsePayload>[]
          }
          delete: {
            args: Prisma.ReferralUseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralUsePayload>
          }
          update: {
            args: Prisma.ReferralUseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralUsePayload>
          }
          deleteMany: {
            args: Prisma.ReferralUseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReferralUseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReferralUseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralUsePayload>
          }
          aggregate: {
            args: Prisma.ReferralUseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReferralUse>
          }
          groupBy: {
            args: Prisma.ReferralUseGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReferralUseGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReferralUseCountArgs<ExtArgs>
            result: $Utils.Optional<ReferralUseCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    referrals: number
    availability: number
    pointsTransactions: number
    courses: number
    enrollments: number
    savedCourses: number
    likedCourses: number
    lessonProgress: number
    quizAttempts: number
    assignmentSubs: number
    courseReviews: number
    tutoringSessions: number
    tutoringRequests: number
    tutoringAppointmentsAsTeacher: number
    tutoringAppointmentsAsStudent: number
    tutoringReviews: number
    tutoringMessages: number
    achievements: number
    certificates: number
    conversationParts: number
    sentMessages: number
    attachments: number
    notifications: number
    subscriptionRecords: number
    bundlesOwned: number
    payments: number
    calendarEvents: number
    eventsAsTeacher: number
    eventsAsStudent: number
    blogPosts: number
    blogComments: number
    submissionsGraded: number
    referralCodesOwned: number
    referralUsesGained: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    referrals?: boolean | UserCountOutputTypeCountReferralsArgs
    availability?: boolean | UserCountOutputTypeCountAvailabilityArgs
    pointsTransactions?: boolean | UserCountOutputTypeCountPointsTransactionsArgs
    courses?: boolean | UserCountOutputTypeCountCoursesArgs
    enrollments?: boolean | UserCountOutputTypeCountEnrollmentsArgs
    savedCourses?: boolean | UserCountOutputTypeCountSavedCoursesArgs
    likedCourses?: boolean | UserCountOutputTypeCountLikedCoursesArgs
    lessonProgress?: boolean | UserCountOutputTypeCountLessonProgressArgs
    quizAttempts?: boolean | UserCountOutputTypeCountQuizAttemptsArgs
    assignmentSubs?: boolean | UserCountOutputTypeCountAssignmentSubsArgs
    courseReviews?: boolean | UserCountOutputTypeCountCourseReviewsArgs
    tutoringSessions?: boolean | UserCountOutputTypeCountTutoringSessionsArgs
    tutoringRequests?: boolean | UserCountOutputTypeCountTutoringRequestsArgs
    tutoringAppointmentsAsTeacher?: boolean | UserCountOutputTypeCountTutoringAppointmentsAsTeacherArgs
    tutoringAppointmentsAsStudent?: boolean | UserCountOutputTypeCountTutoringAppointmentsAsStudentArgs
    tutoringReviews?: boolean | UserCountOutputTypeCountTutoringReviewsArgs
    tutoringMessages?: boolean | UserCountOutputTypeCountTutoringMessagesArgs
    achievements?: boolean | UserCountOutputTypeCountAchievementsArgs
    certificates?: boolean | UserCountOutputTypeCountCertificatesArgs
    conversationParts?: boolean | UserCountOutputTypeCountConversationPartsArgs
    sentMessages?: boolean | UserCountOutputTypeCountSentMessagesArgs
    attachments?: boolean | UserCountOutputTypeCountAttachmentsArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    subscriptionRecords?: boolean | UserCountOutputTypeCountSubscriptionRecordsArgs
    bundlesOwned?: boolean | UserCountOutputTypeCountBundlesOwnedArgs
    payments?: boolean | UserCountOutputTypeCountPaymentsArgs
    calendarEvents?: boolean | UserCountOutputTypeCountCalendarEventsArgs
    eventsAsTeacher?: boolean | UserCountOutputTypeCountEventsAsTeacherArgs
    eventsAsStudent?: boolean | UserCountOutputTypeCountEventsAsStudentArgs
    blogPosts?: boolean | UserCountOutputTypeCountBlogPostsArgs
    blogComments?: boolean | UserCountOutputTypeCountBlogCommentsArgs
    submissionsGraded?: boolean | UserCountOutputTypeCountSubmissionsGradedArgs
    referralCodesOwned?: boolean | UserCountOutputTypeCountReferralCodesOwnedArgs
    referralUsesGained?: boolean | UserCountOutputTypeCountReferralUsesGainedArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReferralsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAvailabilityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAvailabilityWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPointsTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PointsTransactionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEnrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnrollmentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSavedCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SavedCourseWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLikedCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LikedCourseWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLessonProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonProgressWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountQuizAttemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizAttemptWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAssignmentSubsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssignmentSubmissionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCourseReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseReviewWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTutoringSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TutoringSessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTutoringRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TutoringRequestWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTutoringAppointmentsAsTeacherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TutoringAppointmentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTutoringAppointmentsAsStudentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TutoringAppointmentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTutoringReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TutoringReviewWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTutoringMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TutoringMessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAchievementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAchievementWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCertificatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CertificateWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountConversationPartsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationParticipantWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSentMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttachmentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSubscriptionRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSubscriptionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBundlesOwnedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserBundleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCalendarEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CalendarEventWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEventsAsTeacherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CalendarEventWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEventsAsStudentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CalendarEventWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBlogPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogPostWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBlogCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogCommentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSubmissionsGradedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssignmentSubmissionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReferralCodesOwnedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferralCodeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReferralUsesGainedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferralUseWhereInput
  }


  /**
   * Count Type CourseCountOutputType
   */

  export type CourseCountOutputType = {
    topics: number
    enrollments: number
    savedBy: number
    likedBy: number
    reviews: number
    lessons: number
    quizAttempts: number
    certificates: number
    bundleCourses: number
    calendarEvents: number
  }

  export type CourseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    topics?: boolean | CourseCountOutputTypeCountTopicsArgs
    enrollments?: boolean | CourseCountOutputTypeCountEnrollmentsArgs
    savedBy?: boolean | CourseCountOutputTypeCountSavedByArgs
    likedBy?: boolean | CourseCountOutputTypeCountLikedByArgs
    reviews?: boolean | CourseCountOutputTypeCountReviewsArgs
    lessons?: boolean | CourseCountOutputTypeCountLessonsArgs
    quizAttempts?: boolean | CourseCountOutputTypeCountQuizAttemptsArgs
    certificates?: boolean | CourseCountOutputTypeCountCertificatesArgs
    bundleCourses?: boolean | CourseCountOutputTypeCountBundleCoursesArgs
    calendarEvents?: boolean | CourseCountOutputTypeCountCalendarEventsArgs
  }

  // Custom InputTypes
  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseCountOutputType
     */
    select?: CourseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountTopicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TopicWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountEnrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnrollmentWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountSavedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SavedCourseWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountLikedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LikedCourseWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseReviewWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountLessonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountQuizAttemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizAttemptWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountCertificatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CertificateWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountBundleCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BundleCourseWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountCalendarEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CalendarEventWhereInput
  }


  /**
   * Count Type TopicCountOutputType
   */

  export type TopicCountOutputType = {
    lessons: number
  }

  export type TopicCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lessons?: boolean | TopicCountOutputTypeCountLessonsArgs
  }

  // Custom InputTypes
  /**
   * TopicCountOutputType without action
   */
  export type TopicCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopicCountOutputType
     */
    select?: TopicCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TopicCountOutputType without action
   */
  export type TopicCountOutputTypeCountLessonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonWhereInput
  }


  /**
   * Count Type LessonCountOutputType
   */

  export type LessonCountOutputType = {
    progress: number
    calendarEvents: number
  }

  export type LessonCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    progress?: boolean | LessonCountOutputTypeCountProgressArgs
    calendarEvents?: boolean | LessonCountOutputTypeCountCalendarEventsArgs
  }

  // Custom InputTypes
  /**
   * LessonCountOutputType without action
   */
  export type LessonCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonCountOutputType
     */
    select?: LessonCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LessonCountOutputType without action
   */
  export type LessonCountOutputTypeCountProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonProgressWhereInput
  }

  /**
   * LessonCountOutputType without action
   */
  export type LessonCountOutputTypeCountCalendarEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CalendarEventWhereInput
  }


  /**
   * Count Type QuizCountOutputType
   */

  export type QuizCountOutputType = {
    questions: number
    attempts: number
  }

  export type QuizCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    questions?: boolean | QuizCountOutputTypeCountQuestionsArgs
    attempts?: boolean | QuizCountOutputTypeCountAttemptsArgs
  }

  // Custom InputTypes
  /**
   * QuizCountOutputType without action
   */
  export type QuizCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizCountOutputType
     */
    select?: QuizCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QuizCountOutputType without action
   */
  export type QuizCountOutputTypeCountQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionWhereInput
  }

  /**
   * QuizCountOutputType without action
   */
  export type QuizCountOutputTypeCountAttemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizAttemptWhereInput
  }


  /**
   * Count Type AssignmentCountOutputType
   */

  export type AssignmentCountOutputType = {
    submissions: number
  }

  export type AssignmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    submissions?: boolean | AssignmentCountOutputTypeCountSubmissionsArgs
  }

  // Custom InputTypes
  /**
   * AssignmentCountOutputType without action
   */
  export type AssignmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentCountOutputType
     */
    select?: AssignmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AssignmentCountOutputType without action
   */
  export type AssignmentCountOutputTypeCountSubmissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssignmentSubmissionWhereInput
  }


  /**
   * Count Type TutoringSessionCountOutputType
   */

  export type TutoringSessionCountOutputType = {
    availability: number
    requests: number
    appointments: number
    reviews: number
    certificates: number
  }

  export type TutoringSessionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    availability?: boolean | TutoringSessionCountOutputTypeCountAvailabilityArgs
    requests?: boolean | TutoringSessionCountOutputTypeCountRequestsArgs
    appointments?: boolean | TutoringSessionCountOutputTypeCountAppointmentsArgs
    reviews?: boolean | TutoringSessionCountOutputTypeCountReviewsArgs
    certificates?: boolean | TutoringSessionCountOutputTypeCountCertificatesArgs
  }

  // Custom InputTypes
  /**
   * TutoringSessionCountOutputType without action
   */
  export type TutoringSessionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutoringSessionCountOutputType
     */
    select?: TutoringSessionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TutoringSessionCountOutputType without action
   */
  export type TutoringSessionCountOutputTypeCountAvailabilityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TutoringAvailabilityWhereInput
  }

  /**
   * TutoringSessionCountOutputType without action
   */
  export type TutoringSessionCountOutputTypeCountRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TutoringRequestWhereInput
  }

  /**
   * TutoringSessionCountOutputType without action
   */
  export type TutoringSessionCountOutputTypeCountAppointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TutoringAppointmentWhereInput
  }

  /**
   * TutoringSessionCountOutputType without action
   */
  export type TutoringSessionCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TutoringReviewWhereInput
  }

  /**
   * TutoringSessionCountOutputType without action
   */
  export type TutoringSessionCountOutputTypeCountCertificatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CertificateWhereInput
  }


  /**
   * Count Type TutoringRequestCountOutputType
   */

  export type TutoringRequestCountOutputType = {
    messages: number
  }

  export type TutoringRequestCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | TutoringRequestCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * TutoringRequestCountOutputType without action
   */
  export type TutoringRequestCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutoringRequestCountOutputType
     */
    select?: TutoringRequestCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TutoringRequestCountOutputType without action
   */
  export type TutoringRequestCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TutoringMessageWhereInput
  }


  /**
   * Count Type AchievementCountOutputType
   */

  export type AchievementCountOutputType = {
    users: number
  }

  export type AchievementCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | AchievementCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * AchievementCountOutputType without action
   */
  export type AchievementCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AchievementCountOutputType
     */
    select?: AchievementCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AchievementCountOutputType without action
   */
  export type AchievementCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAchievementWhereInput
  }


  /**
   * Count Type BadgeCountOutputType
   */

  export type BadgeCountOutputType = {
    certificates: number
  }

  export type BadgeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    certificates?: boolean | BadgeCountOutputTypeCountCertificatesArgs
  }

  // Custom InputTypes
  /**
   * BadgeCountOutputType without action
   */
  export type BadgeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BadgeCountOutputType
     */
    select?: BadgeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BadgeCountOutputType without action
   */
  export type BadgeCountOutputTypeCountCertificatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CertificateWhereInput
  }


  /**
   * Count Type ConversationCountOutputType
   */

  export type ConversationCountOutputType = {
    participants: number
    messages: number
  }

  export type ConversationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    participants?: boolean | ConversationCountOutputTypeCountParticipantsArgs
    messages?: boolean | ConversationCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationCountOutputType
     */
    select?: ConversationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeCountParticipantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationParticipantWhereInput
  }

  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }


  /**
   * Count Type MessageCountOutputType
   */

  export type MessageCountOutputType = {
    attachments: number
  }

  export type MessageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attachments?: boolean | MessageCountOutputTypeCountAttachmentsArgs
  }

  // Custom InputTypes
  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageCountOutputType
     */
    select?: MessageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeCountAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttachmentWhereInput
  }


  /**
   * Count Type SubscriptionPlanCountOutputType
   */

  export type SubscriptionPlanCountOutputType = {
    users: number
  }

  export type SubscriptionPlanCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | SubscriptionPlanCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * SubscriptionPlanCountOutputType without action
   */
  export type SubscriptionPlanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlanCountOutputType
     */
    select?: SubscriptionPlanCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubscriptionPlanCountOutputType without action
   */
  export type SubscriptionPlanCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSubscriptionWhereInput
  }


  /**
   * Count Type CourseBundleCountOutputType
   */

  export type CourseBundleCountOutputType = {
    courses: number
    owners: number
  }

  export type CourseBundleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courses?: boolean | CourseBundleCountOutputTypeCountCoursesArgs
    owners?: boolean | CourseBundleCountOutputTypeCountOwnersArgs
  }

  // Custom InputTypes
  /**
   * CourseBundleCountOutputType without action
   */
  export type CourseBundleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseBundleCountOutputType
     */
    select?: CourseBundleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CourseBundleCountOutputType without action
   */
  export type CourseBundleCountOutputTypeCountCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BundleCourseWhereInput
  }

  /**
   * CourseBundleCountOutputType without action
   */
  export type CourseBundleCountOutputTypeCountOwnersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserBundleWhereInput
  }


  /**
   * Count Type BlogPostCountOutputType
   */

  export type BlogPostCountOutputType = {
    categories: number
    tags: number
    comments: number
  }

  export type BlogPostCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categories?: boolean | BlogPostCountOutputTypeCountCategoriesArgs
    tags?: boolean | BlogPostCountOutputTypeCountTagsArgs
    comments?: boolean | BlogPostCountOutputTypeCountCommentsArgs
  }

  // Custom InputTypes
  /**
   * BlogPostCountOutputType without action
   */
  export type BlogPostCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPostCountOutputType
     */
    select?: BlogPostCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BlogPostCountOutputType without action
   */
  export type BlogPostCountOutputTypeCountCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostCategoryWhereInput
  }

  /**
   * BlogPostCountOutputType without action
   */
  export type BlogPostCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostTagWhereInput
  }

  /**
   * BlogPostCountOutputType without action
   */
  export type BlogPostCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogCommentWhereInput
  }


  /**
   * Count Type CategoryCountOutputType
   */

  export type CategoryCountOutputType = {
    posts: number
  }

  export type CategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posts?: boolean | CategoryCountOutputTypeCountPostsArgs
  }

  // Custom InputTypes
  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostCategoryWhereInput
  }


  /**
   * Count Type TagCountOutputType
   */

  export type TagCountOutputType = {
    posts: number
  }

  export type TagCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posts?: boolean | TagCountOutputTypeCountPostsArgs
  }

  // Custom InputTypes
  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagCountOutputType
     */
    select?: TagCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostTagWhereInput
  }


  /**
   * Count Type BlogCommentCountOutputType
   */

  export type BlogCommentCountOutputType = {
    replies: number
  }

  export type BlogCommentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    replies?: boolean | BlogCommentCountOutputTypeCountRepliesArgs
  }

  // Custom InputTypes
  /**
   * BlogCommentCountOutputType without action
   */
  export type BlogCommentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogCommentCountOutputType
     */
    select?: BlogCommentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BlogCommentCountOutputType without action
   */
  export type BlogCommentCountOutputTypeCountRepliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogCommentWhereInput
  }


  /**
   * Count Type ReferralCodeCountOutputType
   */

  export type ReferralCodeCountOutputType = {
    uses: number
  }

  export type ReferralCodeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    uses?: boolean | ReferralCodeCountOutputTypeCountUsesArgs
  }

  // Custom InputTypes
  /**
   * ReferralCodeCountOutputType without action
   */
  export type ReferralCodeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralCodeCountOutputType
     */
    select?: ReferralCodeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ReferralCodeCountOutputType without action
   */
  export type ReferralCodeCountOutputTypeCountUsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferralUseWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    points: number | null
  }

  export type UserSumAggregateOutputType = {
    points: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    passwordHash: string | null
    role: $Enums.Role | null
    avatar: string | null
    bio: string | null
    createdAt: Date | null
    points: number | null
    referralCode: string | null
    referredById: string | null
    lastLogin: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    passwordHash: string | null
    role: $Enums.Role | null
    avatar: string | null
    bio: string | null
    createdAt: Date | null
    points: number | null
    referralCode: string | null
    referredById: string | null
    lastLogin: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    passwordHash: number
    role: number
    avatar: number
    bio: number
    createdAt: number
    points: number
    referralCode: number
    referredById: number
    lastLogin: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    points?: true
  }

  export type UserSumAggregateInputType = {
    points?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    passwordHash?: true
    role?: true
    avatar?: true
    bio?: true
    createdAt?: true
    points?: true
    referralCode?: true
    referredById?: true
    lastLogin?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    passwordHash?: true
    role?: true
    avatar?: true
    bio?: true
    createdAt?: true
    points?: true
    referralCode?: true
    referredById?: true
    lastLogin?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    passwordHash?: true
    role?: true
    avatar?: true
    bio?: true
    createdAt?: true
    points?: true
    referralCode?: true
    referredById?: true
    lastLogin?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    avatar: string | null
    bio: string | null
    createdAt: Date
    points: number
    referralCode: string | null
    referredById: string | null
    lastLogin: Date | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    passwordHash?: boolean
    role?: boolean
    avatar?: boolean
    bio?: boolean
    createdAt?: boolean
    points?: boolean
    referralCode?: boolean
    referredById?: boolean
    lastLogin?: boolean
    referredBy?: boolean | User$referredByArgs<ExtArgs>
    referrals?: boolean | User$referralsArgs<ExtArgs>
    teacherProfile?: boolean | User$teacherProfileArgs<ExtArgs>
    availability?: boolean | User$availabilityArgs<ExtArgs>
    pointsTransactions?: boolean | User$pointsTransactionsArgs<ExtArgs>
    courses?: boolean | User$coursesArgs<ExtArgs>
    enrollments?: boolean | User$enrollmentsArgs<ExtArgs>
    savedCourses?: boolean | User$savedCoursesArgs<ExtArgs>
    likedCourses?: boolean | User$likedCoursesArgs<ExtArgs>
    lessonProgress?: boolean | User$lessonProgressArgs<ExtArgs>
    quizAttempts?: boolean | User$quizAttemptsArgs<ExtArgs>
    assignmentSubs?: boolean | User$assignmentSubsArgs<ExtArgs>
    courseReviews?: boolean | User$courseReviewsArgs<ExtArgs>
    tutoringSessions?: boolean | User$tutoringSessionsArgs<ExtArgs>
    tutoringRequests?: boolean | User$tutoringRequestsArgs<ExtArgs>
    tutoringAppointmentsAsTeacher?: boolean | User$tutoringAppointmentsAsTeacherArgs<ExtArgs>
    tutoringAppointmentsAsStudent?: boolean | User$tutoringAppointmentsAsStudentArgs<ExtArgs>
    tutoringReviews?: boolean | User$tutoringReviewsArgs<ExtArgs>
    tutoringMessages?: boolean | User$tutoringMessagesArgs<ExtArgs>
    achievements?: boolean | User$achievementsArgs<ExtArgs>
    certificates?: boolean | User$certificatesArgs<ExtArgs>
    conversationParts?: boolean | User$conversationPartsArgs<ExtArgs>
    sentMessages?: boolean | User$sentMessagesArgs<ExtArgs>
    attachments?: boolean | User$attachmentsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    subscriptionRecords?: boolean | User$subscriptionRecordsArgs<ExtArgs>
    bundlesOwned?: boolean | User$bundlesOwnedArgs<ExtArgs>
    payments?: boolean | User$paymentsArgs<ExtArgs>
    calendarEvents?: boolean | User$calendarEventsArgs<ExtArgs>
    eventsAsTeacher?: boolean | User$eventsAsTeacherArgs<ExtArgs>
    eventsAsStudent?: boolean | User$eventsAsStudentArgs<ExtArgs>
    blogPosts?: boolean | User$blogPostsArgs<ExtArgs>
    blogComments?: boolean | User$blogCommentsArgs<ExtArgs>
    submissionsGraded?: boolean | User$submissionsGradedArgs<ExtArgs>
    referralCodesOwned?: boolean | User$referralCodesOwnedArgs<ExtArgs>
    referralUsesGained?: boolean | User$referralUsesGainedArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    passwordHash?: boolean
    role?: boolean
    avatar?: boolean
    bio?: boolean
    createdAt?: boolean
    points?: boolean
    referralCode?: boolean
    referredById?: boolean
    lastLogin?: boolean
    referredBy?: boolean | User$referredByArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    passwordHash?: boolean
    role?: boolean
    avatar?: boolean
    bio?: boolean
    createdAt?: boolean
    points?: boolean
    referralCode?: boolean
    referredById?: boolean
    lastLogin?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    referredBy?: boolean | User$referredByArgs<ExtArgs>
    referrals?: boolean | User$referralsArgs<ExtArgs>
    teacherProfile?: boolean | User$teacherProfileArgs<ExtArgs>
    availability?: boolean | User$availabilityArgs<ExtArgs>
    pointsTransactions?: boolean | User$pointsTransactionsArgs<ExtArgs>
    courses?: boolean | User$coursesArgs<ExtArgs>
    enrollments?: boolean | User$enrollmentsArgs<ExtArgs>
    savedCourses?: boolean | User$savedCoursesArgs<ExtArgs>
    likedCourses?: boolean | User$likedCoursesArgs<ExtArgs>
    lessonProgress?: boolean | User$lessonProgressArgs<ExtArgs>
    quizAttempts?: boolean | User$quizAttemptsArgs<ExtArgs>
    assignmentSubs?: boolean | User$assignmentSubsArgs<ExtArgs>
    courseReviews?: boolean | User$courseReviewsArgs<ExtArgs>
    tutoringSessions?: boolean | User$tutoringSessionsArgs<ExtArgs>
    tutoringRequests?: boolean | User$tutoringRequestsArgs<ExtArgs>
    tutoringAppointmentsAsTeacher?: boolean | User$tutoringAppointmentsAsTeacherArgs<ExtArgs>
    tutoringAppointmentsAsStudent?: boolean | User$tutoringAppointmentsAsStudentArgs<ExtArgs>
    tutoringReviews?: boolean | User$tutoringReviewsArgs<ExtArgs>
    tutoringMessages?: boolean | User$tutoringMessagesArgs<ExtArgs>
    achievements?: boolean | User$achievementsArgs<ExtArgs>
    certificates?: boolean | User$certificatesArgs<ExtArgs>
    conversationParts?: boolean | User$conversationPartsArgs<ExtArgs>
    sentMessages?: boolean | User$sentMessagesArgs<ExtArgs>
    attachments?: boolean | User$attachmentsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    subscriptionRecords?: boolean | User$subscriptionRecordsArgs<ExtArgs>
    bundlesOwned?: boolean | User$bundlesOwnedArgs<ExtArgs>
    payments?: boolean | User$paymentsArgs<ExtArgs>
    calendarEvents?: boolean | User$calendarEventsArgs<ExtArgs>
    eventsAsTeacher?: boolean | User$eventsAsTeacherArgs<ExtArgs>
    eventsAsStudent?: boolean | User$eventsAsStudentArgs<ExtArgs>
    blogPosts?: boolean | User$blogPostsArgs<ExtArgs>
    blogComments?: boolean | User$blogCommentsArgs<ExtArgs>
    submissionsGraded?: boolean | User$submissionsGradedArgs<ExtArgs>
    referralCodesOwned?: boolean | User$referralCodesOwnedArgs<ExtArgs>
    referralUsesGained?: boolean | User$referralUsesGainedArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    referredBy?: boolean | User$referredByArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      referredBy: Prisma.$UserPayload<ExtArgs> | null
      referrals: Prisma.$UserPayload<ExtArgs>[]
      teacherProfile: Prisma.$TeacherProfilePayload<ExtArgs> | null
      availability: Prisma.$UserAvailabilityPayload<ExtArgs>[]
      pointsTransactions: Prisma.$PointsTransactionPayload<ExtArgs>[]
      courses: Prisma.$CoursePayload<ExtArgs>[]
      enrollments: Prisma.$EnrollmentPayload<ExtArgs>[]
      savedCourses: Prisma.$SavedCoursePayload<ExtArgs>[]
      likedCourses: Prisma.$LikedCoursePayload<ExtArgs>[]
      lessonProgress: Prisma.$LessonProgressPayload<ExtArgs>[]
      quizAttempts: Prisma.$QuizAttemptPayload<ExtArgs>[]
      assignmentSubs: Prisma.$AssignmentSubmissionPayload<ExtArgs>[]
      courseReviews: Prisma.$CourseReviewPayload<ExtArgs>[]
      tutoringSessions: Prisma.$TutoringSessionPayload<ExtArgs>[]
      tutoringRequests: Prisma.$TutoringRequestPayload<ExtArgs>[]
      tutoringAppointmentsAsTeacher: Prisma.$TutoringAppointmentPayload<ExtArgs>[]
      tutoringAppointmentsAsStudent: Prisma.$TutoringAppointmentPayload<ExtArgs>[]
      tutoringReviews: Prisma.$TutoringReviewPayload<ExtArgs>[]
      tutoringMessages: Prisma.$TutoringMessagePayload<ExtArgs>[]
      achievements: Prisma.$UserAchievementPayload<ExtArgs>[]
      certificates: Prisma.$CertificatePayload<ExtArgs>[]
      conversationParts: Prisma.$ConversationParticipantPayload<ExtArgs>[]
      sentMessages: Prisma.$MessagePayload<ExtArgs>[]
      attachments: Prisma.$AttachmentPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      subscriptionRecords: Prisma.$UserSubscriptionPayload<ExtArgs>[]
      bundlesOwned: Prisma.$UserBundlePayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      calendarEvents: Prisma.$CalendarEventPayload<ExtArgs>[]
      eventsAsTeacher: Prisma.$CalendarEventPayload<ExtArgs>[]
      eventsAsStudent: Prisma.$CalendarEventPayload<ExtArgs>[]
      blogPosts: Prisma.$BlogPostPayload<ExtArgs>[]
      blogComments: Prisma.$BlogCommentPayload<ExtArgs>[]
      submissionsGraded: Prisma.$AssignmentSubmissionPayload<ExtArgs>[]
      referralCodesOwned: Prisma.$ReferralCodePayload<ExtArgs>[]
      referralUsesGained: Prisma.$ReferralUsePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      passwordHash: string
      role: $Enums.Role
      avatar: string | null
      bio: string | null
      createdAt: Date
      points: number
      referralCode: string | null
      referredById: string | null
      lastLogin: Date | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    referredBy<T extends User$referredByArgs<ExtArgs> = {}>(args?: Subset<T, User$referredByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    referrals<T extends User$referralsArgs<ExtArgs> = {}>(args?: Subset<T, User$referralsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    teacherProfile<T extends User$teacherProfileArgs<ExtArgs> = {}>(args?: Subset<T, User$teacherProfileArgs<ExtArgs>>): Prisma__TeacherProfileClient<$Result.GetResult<Prisma.$TeacherProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    availability<T extends User$availabilityArgs<ExtArgs> = {}>(args?: Subset<T, User$availabilityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAvailabilityPayload<ExtArgs>, T, "findMany"> | Null>
    pointsTransactions<T extends User$pointsTransactionsArgs<ExtArgs> = {}>(args?: Subset<T, User$pointsTransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PointsTransactionPayload<ExtArgs>, T, "findMany"> | Null>
    courses<T extends User$coursesArgs<ExtArgs> = {}>(args?: Subset<T, User$coursesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findMany"> | Null>
    enrollments<T extends User$enrollmentsArgs<ExtArgs> = {}>(args?: Subset<T, User$enrollmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findMany"> | Null>
    savedCourses<T extends User$savedCoursesArgs<ExtArgs> = {}>(args?: Subset<T, User$savedCoursesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SavedCoursePayload<ExtArgs>, T, "findMany"> | Null>
    likedCourses<T extends User$likedCoursesArgs<ExtArgs> = {}>(args?: Subset<T, User$likedCoursesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LikedCoursePayload<ExtArgs>, T, "findMany"> | Null>
    lessonProgress<T extends User$lessonProgressArgs<ExtArgs> = {}>(args?: Subset<T, User$lessonProgressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonProgressPayload<ExtArgs>, T, "findMany"> | Null>
    quizAttempts<T extends User$quizAttemptsArgs<ExtArgs> = {}>(args?: Subset<T, User$quizAttemptsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizAttemptPayload<ExtArgs>, T, "findMany"> | Null>
    assignmentSubs<T extends User$assignmentSubsArgs<ExtArgs> = {}>(args?: Subset<T, User$assignmentSubsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssignmentSubmissionPayload<ExtArgs>, T, "findMany"> | Null>
    courseReviews<T extends User$courseReviewsArgs<ExtArgs> = {}>(args?: Subset<T, User$courseReviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseReviewPayload<ExtArgs>, T, "findMany"> | Null>
    tutoringSessions<T extends User$tutoringSessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$tutoringSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TutoringSessionPayload<ExtArgs>, T, "findMany"> | Null>
    tutoringRequests<T extends User$tutoringRequestsArgs<ExtArgs> = {}>(args?: Subset<T, User$tutoringRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TutoringRequestPayload<ExtArgs>, T, "findMany"> | Null>
    tutoringAppointmentsAsTeacher<T extends User$tutoringAppointmentsAsTeacherArgs<ExtArgs> = {}>(args?: Subset<T, User$tutoringAppointmentsAsTeacherArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TutoringAppointmentPayload<ExtArgs>, T, "findMany"> | Null>
    tutoringAppointmentsAsStudent<T extends User$tutoringAppointmentsAsStudentArgs<ExtArgs> = {}>(args?: Subset<T, User$tutoringAppointmentsAsStudentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TutoringAppointmentPayload<ExtArgs>, T, "findMany"> | Null>
    tutoringReviews<T extends User$tutoringReviewsArgs<ExtArgs> = {}>(args?: Subset<T, User$tutoringReviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TutoringReviewPayload<ExtArgs>, T, "findMany"> | Null>
    tutoringMessages<T extends User$tutoringMessagesArgs<ExtArgs> = {}>(args?: Subset<T, User$tutoringMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TutoringMessagePayload<ExtArgs>, T, "findMany"> | Null>
    achievements<T extends User$achievementsArgs<ExtArgs> = {}>(args?: Subset<T, User$achievementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findMany"> | Null>
    certificates<T extends User$certificatesArgs<ExtArgs> = {}>(args?: Subset<T, User$certificatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findMany"> | Null>
    conversationParts<T extends User$conversationPartsArgs<ExtArgs> = {}>(args?: Subset<T, User$conversationPartsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "findMany"> | Null>
    sentMessages<T extends User$sentMessagesArgs<ExtArgs> = {}>(args?: Subset<T, User$sentMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany"> | Null>
    attachments<T extends User$attachmentsArgs<ExtArgs> = {}>(args?: Subset<T, User$attachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findMany"> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany"> | Null>
    subscriptionRecords<T extends User$subscriptionRecordsArgs<ExtArgs> = {}>(args?: Subset<T, User$subscriptionRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "findMany"> | Null>
    bundlesOwned<T extends User$bundlesOwnedArgs<ExtArgs> = {}>(args?: Subset<T, User$bundlesOwnedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBundlePayload<ExtArgs>, T, "findMany"> | Null>
    payments<T extends User$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, User$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany"> | Null>
    calendarEvents<T extends User$calendarEventsArgs<ExtArgs> = {}>(args?: Subset<T, User$calendarEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "findMany"> | Null>
    eventsAsTeacher<T extends User$eventsAsTeacherArgs<ExtArgs> = {}>(args?: Subset<T, User$eventsAsTeacherArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "findMany"> | Null>
    eventsAsStudent<T extends User$eventsAsStudentArgs<ExtArgs> = {}>(args?: Subset<T, User$eventsAsStudentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "findMany"> | Null>
    blogPosts<T extends User$blogPostsArgs<ExtArgs> = {}>(args?: Subset<T, User$blogPostsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findMany"> | Null>
    blogComments<T extends User$blogCommentsArgs<ExtArgs> = {}>(args?: Subset<T, User$blogCommentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogCommentPayload<ExtArgs>, T, "findMany"> | Null>
    submissionsGraded<T extends User$submissionsGradedArgs<ExtArgs> = {}>(args?: Subset<T, User$submissionsGradedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssignmentSubmissionPayload<ExtArgs>, T, "findMany"> | Null>
    referralCodesOwned<T extends User$referralCodesOwnedArgs<ExtArgs> = {}>(args?: Subset<T, User$referralCodesOwnedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralCodePayload<ExtArgs>, T, "findMany"> | Null>
    referralUsesGained<T extends User$referralUsesGainedArgs<ExtArgs> = {}>(args?: Subset<T, User$referralUsesGainedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralUsePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
    readonly avatar: FieldRef<"User", 'String'>
    readonly bio: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly points: FieldRef<"User", 'Int'>
    readonly referralCode: FieldRef<"User", 'String'>
    readonly referredById: FieldRef<"User", 'String'>
    readonly lastLogin: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.referredBy
   */
  export type User$referredByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * User.referrals
   */
  export type User$referralsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User.teacherProfile
   */
  export type User$teacherProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherProfile
     */
    select?: TeacherProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherProfileInclude<ExtArgs> | null
    where?: TeacherProfileWhereInput
  }

  /**
   * User.availability
   */
  export type User$availabilityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAvailability
     */
    select?: UserAvailabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAvailabilityInclude<ExtArgs> | null
    where?: UserAvailabilityWhereInput
    orderBy?: UserAvailabilityOrderByWithRelationInput | UserAvailabilityOrderByWithRelationInput[]
    cursor?: UserAvailabilityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserAvailabilityScalarFieldEnum | UserAvailabilityScalarFieldEnum[]
  }

  /**
   * User.pointsTransactions
   */
  export type User$pointsTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointsTransaction
     */
    select?: PointsTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointsTransactionInclude<ExtArgs> | null
    where?: PointsTransactionWhereInput
    orderBy?: PointsTransactionOrderByWithRelationInput | PointsTransactionOrderByWithRelationInput[]
    cursor?: PointsTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PointsTransactionScalarFieldEnum | PointsTransactionScalarFieldEnum[]
  }

  /**
   * User.courses
   */
  export type User$coursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    where?: CourseWhereInput
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    cursor?: CourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * User.enrollments
   */
  export type User$enrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    where?: EnrollmentWhereInput
    orderBy?: EnrollmentOrderByWithRelationInput | EnrollmentOrderByWithRelationInput[]
    cursor?: EnrollmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EnrollmentScalarFieldEnum | EnrollmentScalarFieldEnum[]
  }

  /**
   * User.savedCourses
   */
  export type User$savedCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedCourse
     */
    select?: SavedCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedCourseInclude<ExtArgs> | null
    where?: SavedCourseWhereInput
    orderBy?: SavedCourseOrderByWithRelationInput | SavedCourseOrderByWithRelationInput[]
    cursor?: SavedCourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SavedCourseScalarFieldEnum | SavedCourseScalarFieldEnum[]
  }

  /**
   * User.likedCourses
   */
  export type User$likedCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikedCourse
     */
    select?: LikedCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikedCourseInclude<ExtArgs> | null
    where?: LikedCourseWhereInput
    orderBy?: LikedCourseOrderByWithRelationInput | LikedCourseOrderByWithRelationInput[]
    cursor?: LikedCourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LikedCourseScalarFieldEnum | LikedCourseScalarFieldEnum[]
  }

  /**
   * User.lessonProgress
   */
  export type User$lessonProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonProgress
     */
    select?: LessonProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonProgressInclude<ExtArgs> | null
    where?: LessonProgressWhereInput
    orderBy?: LessonProgressOrderByWithRelationInput | LessonProgressOrderByWithRelationInput[]
    cursor?: LessonProgressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LessonProgressScalarFieldEnum | LessonProgressScalarFieldEnum[]
  }

  /**
   * User.quizAttempts
   */
  export type User$quizAttemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptInclude<ExtArgs> | null
    where?: QuizAttemptWhereInput
    orderBy?: QuizAttemptOrderByWithRelationInput | QuizAttemptOrderByWithRelationInput[]
    cursor?: QuizAttemptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuizAttemptScalarFieldEnum | QuizAttemptScalarFieldEnum[]
  }

  /**
   * User.assignmentSubs
   */
  export type User$assignmentSubsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentSubmission
     */
    select?: AssignmentSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentSubmissionInclude<ExtArgs> | null
    where?: AssignmentSubmissionWhereInput
    orderBy?: AssignmentSubmissionOrderByWithRelationInput | AssignmentSubmissionOrderByWithRelationInput[]
    cursor?: AssignmentSubmissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssignmentSubmissionScalarFieldEnum | AssignmentSubmissionScalarFieldEnum[]
  }

  /**
   * User.courseReviews
   */
  export type User$courseReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseReview
     */
    select?: CourseReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseReviewInclude<ExtArgs> | null
    where?: CourseReviewWhereInput
    orderBy?: CourseReviewOrderByWithRelationInput | CourseReviewOrderByWithRelationInput[]
    cursor?: CourseReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseReviewScalarFieldEnum | CourseReviewScalarFieldEnum[]
  }

  /**
   * User.tutoringSessions
   */
  export type User$tutoringSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutoringSession
     */
    select?: TutoringSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutoringSessionInclude<ExtArgs> | null
    where?: TutoringSessionWhereInput
    orderBy?: TutoringSessionOrderByWithRelationInput | TutoringSessionOrderByWithRelationInput[]
    cursor?: TutoringSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TutoringSessionScalarFieldEnum | TutoringSessionScalarFieldEnum[]
  }

  /**
   * User.tutoringRequests
   */
  export type User$tutoringRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutoringRequest
     */
    select?: TutoringRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutoringRequestInclude<ExtArgs> | null
    where?: TutoringRequestWhereInput
    orderBy?: TutoringRequestOrderByWithRelationInput | TutoringRequestOrderByWithRelationInput[]
    cursor?: TutoringRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TutoringRequestScalarFieldEnum | TutoringRequestScalarFieldEnum[]
  }

  /**
   * User.tutoringAppointmentsAsTeacher
   */
  export type User$tutoringAppointmentsAsTeacherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutoringAppointment
     */
    select?: TutoringAppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutoringAppointmentInclude<ExtArgs> | null
    where?: TutoringAppointmentWhereInput
    orderBy?: TutoringAppointmentOrderByWithRelationInput | TutoringAppointmentOrderByWithRelationInput[]
    cursor?: TutoringAppointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TutoringAppointmentScalarFieldEnum | TutoringAppointmentScalarFieldEnum[]
  }

  /**
   * User.tutoringAppointmentsAsStudent
   */
  export type User$tutoringAppointmentsAsStudentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutoringAppointment
     */
    select?: TutoringAppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutoringAppointmentInclude<ExtArgs> | null
    where?: TutoringAppointmentWhereInput
    orderBy?: TutoringAppointmentOrderByWithRelationInput | TutoringAppointmentOrderByWithRelationInput[]
    cursor?: TutoringAppointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TutoringAppointmentScalarFieldEnum | TutoringAppointmentScalarFieldEnum[]
  }

  /**
   * User.tutoringReviews
   */
  export type User$tutoringReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutoringReview
     */
    select?: TutoringReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutoringReviewInclude<ExtArgs> | null
    where?: TutoringReviewWhereInput
    orderBy?: TutoringReviewOrderByWithRelationInput | TutoringReviewOrderByWithRelationInput[]
    cursor?: TutoringReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TutoringReviewScalarFieldEnum | TutoringReviewScalarFieldEnum[]
  }

  /**
   * User.tutoringMessages
   */
  export type User$tutoringMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutoringMessage
     */
    select?: TutoringMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutoringMessageInclude<ExtArgs> | null
    where?: TutoringMessageWhereInput
    orderBy?: TutoringMessageOrderByWithRelationInput | TutoringMessageOrderByWithRelationInput[]
    cursor?: TutoringMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TutoringMessageScalarFieldEnum | TutoringMessageScalarFieldEnum[]
  }

  /**
   * User.achievements
   */
  export type User$achievementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    where?: UserAchievementWhereInput
    orderBy?: UserAchievementOrderByWithRelationInput | UserAchievementOrderByWithRelationInput[]
    cursor?: UserAchievementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserAchievementScalarFieldEnum | UserAchievementScalarFieldEnum[]
  }

  /**
   * User.certificates
   */
  export type User$certificatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    where?: CertificateWhereInput
    orderBy?: CertificateOrderByWithRelationInput | CertificateOrderByWithRelationInput[]
    cursor?: CertificateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CertificateScalarFieldEnum | CertificateScalarFieldEnum[]
  }

  /**
   * User.conversationParts
   */
  export type User$conversationPartsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    where?: ConversationParticipantWhereInput
    orderBy?: ConversationParticipantOrderByWithRelationInput | ConversationParticipantOrderByWithRelationInput[]
    cursor?: ConversationParticipantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationParticipantScalarFieldEnum | ConversationParticipantScalarFieldEnum[]
  }

  /**
   * User.sentMessages
   */
  export type User$sentMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * User.attachments
   */
  export type User$attachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    where?: AttachmentWhereInput
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    cursor?: AttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttachmentScalarFieldEnum | AttachmentScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.subscriptionRecords
   */
  export type User$subscriptionRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionInclude<ExtArgs> | null
    where?: UserSubscriptionWhereInput
    orderBy?: UserSubscriptionOrderByWithRelationInput | UserSubscriptionOrderByWithRelationInput[]
    cursor?: UserSubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserSubscriptionScalarFieldEnum | UserSubscriptionScalarFieldEnum[]
  }

  /**
   * User.bundlesOwned
   */
  export type User$bundlesOwnedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBundle
     */
    select?: UserBundleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBundleInclude<ExtArgs> | null
    where?: UserBundleWhereInput
    orderBy?: UserBundleOrderByWithRelationInput | UserBundleOrderByWithRelationInput[]
    cursor?: UserBundleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserBundleScalarFieldEnum | UserBundleScalarFieldEnum[]
  }

  /**
   * User.payments
   */
  export type User$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * User.calendarEvents
   */
  export type User$calendarEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventInclude<ExtArgs> | null
    where?: CalendarEventWhereInput
    orderBy?: CalendarEventOrderByWithRelationInput | CalendarEventOrderByWithRelationInput[]
    cursor?: CalendarEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CalendarEventScalarFieldEnum | CalendarEventScalarFieldEnum[]
  }

  /**
   * User.eventsAsTeacher
   */
  export type User$eventsAsTeacherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventInclude<ExtArgs> | null
    where?: CalendarEventWhereInput
    orderBy?: CalendarEventOrderByWithRelationInput | CalendarEventOrderByWithRelationInput[]
    cursor?: CalendarEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CalendarEventScalarFieldEnum | CalendarEventScalarFieldEnum[]
  }

  /**
   * User.eventsAsStudent
   */
  export type User$eventsAsStudentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventInclude<ExtArgs> | null
    where?: CalendarEventWhereInput
    orderBy?: CalendarEventOrderByWithRelationInput | CalendarEventOrderByWithRelationInput[]
    cursor?: CalendarEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CalendarEventScalarFieldEnum | CalendarEventScalarFieldEnum[]
  }

  /**
   * User.blogPosts
   */
  export type User$blogPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    where?: BlogPostWhereInput
    orderBy?: BlogPostOrderByWithRelationInput | BlogPostOrderByWithRelationInput[]
    cursor?: BlogPostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlogPostScalarFieldEnum | BlogPostScalarFieldEnum[]
  }

  /**
   * User.blogComments
   */
  export type User$blogCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogComment
     */
    select?: BlogCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogCommentInclude<ExtArgs> | null
    where?: BlogCommentWhereInput
    orderBy?: BlogCommentOrderByWithRelationInput | BlogCommentOrderByWithRelationInput[]
    cursor?: BlogCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlogCommentScalarFieldEnum | BlogCommentScalarFieldEnum[]
  }

  /**
   * User.submissionsGraded
   */
  export type User$submissionsGradedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentSubmission
     */
    select?: AssignmentSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentSubmissionInclude<ExtArgs> | null
    where?: AssignmentSubmissionWhereInput
    orderBy?: AssignmentSubmissionOrderByWithRelationInput | AssignmentSubmissionOrderByWithRelationInput[]
    cursor?: AssignmentSubmissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssignmentSubmissionScalarFieldEnum | AssignmentSubmissionScalarFieldEnum[]
  }

  /**
   * User.referralCodesOwned
   */
  export type User$referralCodesOwnedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralCode
     */
    select?: ReferralCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralCodeInclude<ExtArgs> | null
    where?: ReferralCodeWhereInput
    orderBy?: ReferralCodeOrderByWithRelationInput | ReferralCodeOrderByWithRelationInput[]
    cursor?: ReferralCodeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReferralCodeScalarFieldEnum | ReferralCodeScalarFieldEnum[]
  }

  /**
   * User.referralUsesGained
   */
  export type User$referralUsesGainedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralUse
     */
    select?: ReferralUseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralUseInclude<ExtArgs> | null
    where?: ReferralUseWhereInput
    orderBy?: ReferralUseOrderByWithRelationInput | ReferralUseOrderByWithRelationInput[]
    cursor?: ReferralUseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReferralUseScalarFieldEnum | ReferralUseScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model TeacherProfile
   */

  export type AggregateTeacherProfile = {
    _count: TeacherProfileCountAggregateOutputType | null
    _avg: TeacherProfileAvgAggregateOutputType | null
    _sum: TeacherProfileSumAggregateOutputType | null
    _min: TeacherProfileMinAggregateOutputType | null
    _max: TeacherProfileMaxAggregateOutputType | null
  }

  export type TeacherProfileAvgAggregateOutputType = {
    rating: Decimal | null
    students: number | null
  }

  export type TeacherProfileSumAggregateOutputType = {
    rating: Decimal | null
    students: number | null
  }

  export type TeacherProfileMinAggregateOutputType = {
    userId: string | null
    rating: Decimal | null
    students: number | null
    education: string | null
    experience: string | null
  }

  export type TeacherProfileMaxAggregateOutputType = {
    userId: string | null
    rating: Decimal | null
    students: number | null
    education: string | null
    experience: string | null
  }

  export type TeacherProfileCountAggregateOutputType = {
    userId: number
    specialization: number
    rating: number
    students: number
    education: number
    experience: number
    certificates: number
    _all: number
  }


  export type TeacherProfileAvgAggregateInputType = {
    rating?: true
    students?: true
  }

  export type TeacherProfileSumAggregateInputType = {
    rating?: true
    students?: true
  }

  export type TeacherProfileMinAggregateInputType = {
    userId?: true
    rating?: true
    students?: true
    education?: true
    experience?: true
  }

  export type TeacherProfileMaxAggregateInputType = {
    userId?: true
    rating?: true
    students?: true
    education?: true
    experience?: true
  }

  export type TeacherProfileCountAggregateInputType = {
    userId?: true
    specialization?: true
    rating?: true
    students?: true
    education?: true
    experience?: true
    certificates?: true
    _all?: true
  }

  export type TeacherProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeacherProfile to aggregate.
     */
    where?: TeacherProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherProfiles to fetch.
     */
    orderBy?: TeacherProfileOrderByWithRelationInput | TeacherProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeacherProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TeacherProfiles
    **/
    _count?: true | TeacherProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TeacherProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TeacherProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeacherProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeacherProfileMaxAggregateInputType
  }

  export type GetTeacherProfileAggregateType<T extends TeacherProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateTeacherProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeacherProfile[P]>
      : GetScalarType<T[P], AggregateTeacherProfile[P]>
  }




  export type TeacherProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeacherProfileWhereInput
    orderBy?: TeacherProfileOrderByWithAggregationInput | TeacherProfileOrderByWithAggregationInput[]
    by: TeacherProfileScalarFieldEnum[] | TeacherProfileScalarFieldEnum
    having?: TeacherProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeacherProfileCountAggregateInputType | true
    _avg?: TeacherProfileAvgAggregateInputType
    _sum?: TeacherProfileSumAggregateInputType
    _min?: TeacherProfileMinAggregateInputType
    _max?: TeacherProfileMaxAggregateInputType
  }

  export type TeacherProfileGroupByOutputType = {
    userId: string
    specialization: string[]
    rating: Decimal | null
    students: number
    education: string | null
    experience: string | null
    certificates: string[]
    _count: TeacherProfileCountAggregateOutputType | null
    _avg: TeacherProfileAvgAggregateOutputType | null
    _sum: TeacherProfileSumAggregateOutputType | null
    _min: TeacherProfileMinAggregateOutputType | null
    _max: TeacherProfileMaxAggregateOutputType | null
  }

  type GetTeacherProfileGroupByPayload<T extends TeacherProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeacherProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeacherProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeacherProfileGroupByOutputType[P]>
            : GetScalarType<T[P], TeacherProfileGroupByOutputType[P]>
        }
      >
    >


  export type TeacherProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    specialization?: boolean
    rating?: boolean
    students?: boolean
    education?: boolean
    experience?: boolean
    certificates?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teacherProfile"]>

  export type TeacherProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    specialization?: boolean
    rating?: boolean
    students?: boolean
    education?: boolean
    experience?: boolean
    certificates?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teacherProfile"]>

  export type TeacherProfileSelectScalar = {
    userId?: boolean
    specialization?: boolean
    rating?: boolean
    students?: boolean
    education?: boolean
    experience?: boolean
    certificates?: boolean
  }

  export type TeacherProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TeacherProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TeacherProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TeacherProfile"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      specialization: string[]
      rating: Prisma.Decimal | null
      students: number
      education: string | null
      experience: string | null
      certificates: string[]
    }, ExtArgs["result"]["teacherProfile"]>
    composites: {}
  }

  type TeacherProfileGetPayload<S extends boolean | null | undefined | TeacherProfileDefaultArgs> = $Result.GetResult<Prisma.$TeacherProfilePayload, S>

  type TeacherProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TeacherProfileFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TeacherProfileCountAggregateInputType | true
    }

  export interface TeacherProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TeacherProfile'], meta: { name: 'TeacherProfile' } }
    /**
     * Find zero or one TeacherProfile that matches the filter.
     * @param {TeacherProfileFindUniqueArgs} args - Arguments to find a TeacherProfile
     * @example
     * // Get one TeacherProfile
     * const teacherProfile = await prisma.teacherProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeacherProfileFindUniqueArgs>(args: SelectSubset<T, TeacherProfileFindUniqueArgs<ExtArgs>>): Prisma__TeacherProfileClient<$Result.GetResult<Prisma.$TeacherProfilePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TeacherProfile that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TeacherProfileFindUniqueOrThrowArgs} args - Arguments to find a TeacherProfile
     * @example
     * // Get one TeacherProfile
     * const teacherProfile = await prisma.teacherProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeacherProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, TeacherProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeacherProfileClient<$Result.GetResult<Prisma.$TeacherProfilePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TeacherProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherProfileFindFirstArgs} args - Arguments to find a TeacherProfile
     * @example
     * // Get one TeacherProfile
     * const teacherProfile = await prisma.teacherProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeacherProfileFindFirstArgs>(args?: SelectSubset<T, TeacherProfileFindFirstArgs<ExtArgs>>): Prisma__TeacherProfileClient<$Result.GetResult<Prisma.$TeacherProfilePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TeacherProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherProfileFindFirstOrThrowArgs} args - Arguments to find a TeacherProfile
     * @example
     * // Get one TeacherProfile
     * const teacherProfile = await prisma.teacherProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeacherProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, TeacherProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeacherProfileClient<$Result.GetResult<Prisma.$TeacherProfilePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TeacherProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TeacherProfiles
     * const teacherProfiles = await prisma.teacherProfile.findMany()
     * 
     * // Get first 10 TeacherProfiles
     * const teacherProfiles = await prisma.teacherProfile.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const teacherProfileWithUserIdOnly = await prisma.teacherProfile.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends TeacherProfileFindManyArgs>(args?: SelectSubset<T, TeacherProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherProfilePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TeacherProfile.
     * @param {TeacherProfileCreateArgs} args - Arguments to create a TeacherProfile.
     * @example
     * // Create one TeacherProfile
     * const TeacherProfile = await prisma.teacherProfile.create({
     *   data: {
     *     // ... data to create a TeacherProfile
     *   }
     * })
     * 
     */
    create<T extends TeacherProfileCreateArgs>(args: SelectSubset<T, TeacherProfileCreateArgs<ExtArgs>>): Prisma__TeacherProfileClient<$Result.GetResult<Prisma.$TeacherProfilePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TeacherProfiles.
     * @param {TeacherProfileCreateManyArgs} args - Arguments to create many TeacherProfiles.
     * @example
     * // Create many TeacherProfiles
     * const teacherProfile = await prisma.teacherProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeacherProfileCreateManyArgs>(args?: SelectSubset<T, TeacherProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TeacherProfiles and returns the data saved in the database.
     * @param {TeacherProfileCreateManyAndReturnArgs} args - Arguments to create many TeacherProfiles.
     * @example
     * // Create many TeacherProfiles
     * const teacherProfile = await prisma.teacherProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TeacherProfiles and only return the `userId`
     * const teacherProfileWithUserIdOnly = await prisma.teacherProfile.createManyAndReturn({ 
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TeacherProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, TeacherProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherProfilePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TeacherProfile.
     * @param {TeacherProfileDeleteArgs} args - Arguments to delete one TeacherProfile.
     * @example
     * // Delete one TeacherProfile
     * const TeacherProfile = await prisma.teacherProfile.delete({
     *   where: {
     *     // ... filter to delete one TeacherProfile
     *   }
     * })
     * 
     */
    delete<T extends TeacherProfileDeleteArgs>(args: SelectSubset<T, TeacherProfileDeleteArgs<ExtArgs>>): Prisma__TeacherProfileClient<$Result.GetResult<Prisma.$TeacherProfilePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TeacherProfile.
     * @param {TeacherProfileUpdateArgs} args - Arguments to update one TeacherProfile.
     * @example
     * // Update one TeacherProfile
     * const teacherProfile = await prisma.teacherProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeacherProfileUpdateArgs>(args: SelectSubset<T, TeacherProfileUpdateArgs<ExtArgs>>): Prisma__TeacherProfileClient<$Result.GetResult<Prisma.$TeacherProfilePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TeacherProfiles.
     * @param {TeacherProfileDeleteManyArgs} args - Arguments to filter TeacherProfiles to delete.
     * @example
     * // Delete a few TeacherProfiles
     * const { count } = await prisma.teacherProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeacherProfileDeleteManyArgs>(args?: SelectSubset<T, TeacherProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeacherProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TeacherProfiles
     * const teacherProfile = await prisma.teacherProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeacherProfileUpdateManyArgs>(args: SelectSubset<T, TeacherProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TeacherProfile.
     * @param {TeacherProfileUpsertArgs} args - Arguments to update or create a TeacherProfile.
     * @example
     * // Update or create a TeacherProfile
     * const teacherProfile = await prisma.teacherProfile.upsert({
     *   create: {
     *     // ... data to create a TeacherProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TeacherProfile we want to update
     *   }
     * })
     */
    upsert<T extends TeacherProfileUpsertArgs>(args: SelectSubset<T, TeacherProfileUpsertArgs<ExtArgs>>): Prisma__TeacherProfileClient<$Result.GetResult<Prisma.$TeacherProfilePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TeacherProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherProfileCountArgs} args - Arguments to filter TeacherProfiles to count.
     * @example
     * // Count the number of TeacherProfiles
     * const count = await prisma.teacherProfile.count({
     *   where: {
     *     // ... the filter for the TeacherProfiles we want to count
     *   }
     * })
    **/
    count<T extends TeacherProfileCountArgs>(
      args?: Subset<T, TeacherProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeacherProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TeacherProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeacherProfileAggregateArgs>(args: Subset<T, TeacherProfileAggregateArgs>): Prisma.PrismaPromise<GetTeacherProfileAggregateType<T>>

    /**
     * Group by TeacherProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeacherProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeacherProfileGroupByArgs['orderBy'] }
        : { orderBy?: TeacherProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeacherProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeacherProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TeacherProfile model
   */
  readonly fields: TeacherProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TeacherProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeacherProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TeacherProfile model
   */ 
  interface TeacherProfileFieldRefs {
    readonly userId: FieldRef<"TeacherProfile", 'String'>
    readonly specialization: FieldRef<"TeacherProfile", 'String[]'>
    readonly rating: FieldRef<"TeacherProfile", 'Decimal'>
    readonly students: FieldRef<"TeacherProfile", 'Int'>
    readonly education: FieldRef<"TeacherProfile", 'String'>
    readonly experience: FieldRef<"TeacherProfile", 'String'>
    readonly certificates: FieldRef<"TeacherProfile", 'String[]'>
  }
    

  // Custom InputTypes
  /**
   * TeacherProfile findUnique
   */
  export type TeacherProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherProfile
     */
    select?: TeacherProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherProfileInclude<ExtArgs> | null
    /**
     * Filter, which TeacherProfile to fetch.
     */
    where: TeacherProfileWhereUniqueInput
  }

  /**
   * TeacherProfile findUniqueOrThrow
   */
  export type TeacherProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherProfile
     */
    select?: TeacherProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherProfileInclude<ExtArgs> | null
    /**
     * Filter, which TeacherProfile to fetch.
     */
    where: TeacherProfileWhereUniqueInput
  }

  /**
   * TeacherProfile findFirst
   */
  export type TeacherProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherProfile
     */
    select?: TeacherProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherProfileInclude<ExtArgs> | null
    /**
     * Filter, which TeacherProfile to fetch.
     */
    where?: TeacherProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherProfiles to fetch.
     */
    orderBy?: TeacherProfileOrderByWithRelationInput | TeacherProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeacherProfiles.
     */
    cursor?: TeacherProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeacherProfiles.
     */
    distinct?: TeacherProfileScalarFieldEnum | TeacherProfileScalarFieldEnum[]
  }

  /**
   * TeacherProfile findFirstOrThrow
   */
  export type TeacherProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherProfile
     */
    select?: TeacherProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherProfileInclude<ExtArgs> | null
    /**
     * Filter, which TeacherProfile to fetch.
     */
    where?: TeacherProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherProfiles to fetch.
     */
    orderBy?: TeacherProfileOrderByWithRelationInput | TeacherProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeacherProfiles.
     */
    cursor?: TeacherProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeacherProfiles.
     */
    distinct?: TeacherProfileScalarFieldEnum | TeacherProfileScalarFieldEnum[]
  }

  /**
   * TeacherProfile findMany
   */
  export type TeacherProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherProfile
     */
    select?: TeacherProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherProfileInclude<ExtArgs> | null
    /**
     * Filter, which TeacherProfiles to fetch.
     */
    where?: TeacherProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherProfiles to fetch.
     */
    orderBy?: TeacherProfileOrderByWithRelationInput | TeacherProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TeacherProfiles.
     */
    cursor?: TeacherProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherProfiles.
     */
    skip?: number
    distinct?: TeacherProfileScalarFieldEnum | TeacherProfileScalarFieldEnum[]
  }

  /**
   * TeacherProfile create
   */
  export type TeacherProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherProfile
     */
    select?: TeacherProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a TeacherProfile.
     */
    data: XOR<TeacherProfileCreateInput, TeacherProfileUncheckedCreateInput>
  }

  /**
   * TeacherProfile createMany
   */
  export type TeacherProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TeacherProfiles.
     */
    data: TeacherProfileCreateManyInput | TeacherProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TeacherProfile createManyAndReturn
   */
  export type TeacherProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherProfile
     */
    select?: TeacherProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TeacherProfiles.
     */
    data: TeacherProfileCreateManyInput | TeacherProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TeacherProfile update
   */
  export type TeacherProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherProfile
     */
    select?: TeacherProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a TeacherProfile.
     */
    data: XOR<TeacherProfileUpdateInput, TeacherProfileUncheckedUpdateInput>
    /**
     * Choose, which TeacherProfile to update.
     */
    where: TeacherProfileWhereUniqueInput
  }

  /**
   * TeacherProfile updateMany
   */
  export type TeacherProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TeacherProfiles.
     */
    data: XOR<TeacherProfileUpdateManyMutationInput, TeacherProfileUncheckedUpdateManyInput>
    /**
     * Filter which TeacherProfiles to update
     */
    where?: TeacherProfileWhereInput
  }

  /**
   * TeacherProfile upsert
   */
  export type TeacherProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherProfile
     */
    select?: TeacherProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the TeacherProfile to update in case it exists.
     */
    where: TeacherProfileWhereUniqueInput
    /**
     * In case the TeacherProfile found by the `where` argument doesn't exist, create a new TeacherProfile with this data.
     */
    create: XOR<TeacherProfileCreateInput, TeacherProfileUncheckedCreateInput>
    /**
     * In case the TeacherProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeacherProfileUpdateInput, TeacherProfileUncheckedUpdateInput>
  }

  /**
   * TeacherProfile delete
   */
  export type TeacherProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherProfile
     */
    select?: TeacherProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherProfileInclude<ExtArgs> | null
    /**
     * Filter which TeacherProfile to delete.
     */
    where: TeacherProfileWhereUniqueInput
  }

  /**
   * TeacherProfile deleteMany
   */
  export type TeacherProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeacherProfiles to delete
     */
    where?: TeacherProfileWhereInput
  }

  /**
   * TeacherProfile without action
   */
  export type TeacherProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherProfile
     */
    select?: TeacherProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherProfileInclude<ExtArgs> | null
  }


  /**
   * Model UserAvailability
   */

  export type AggregateUserAvailability = {
    _count: UserAvailabilityCountAggregateOutputType | null
    _avg: UserAvailabilityAvgAggregateOutputType | null
    _sum: UserAvailabilitySumAggregateOutputType | null
    _min: UserAvailabilityMinAggregateOutputType | null
    _max: UserAvailabilityMaxAggregateOutputType | null
  }

  export type UserAvailabilityAvgAggregateOutputType = {
    dayOfWeek: number | null
  }

  export type UserAvailabilitySumAggregateOutputType = {
    dayOfWeek: number | null
  }

  export type UserAvailabilityMinAggregateOutputType = {
    id: string | null
    userId: string | null
    dayOfWeek: number | null
    startTime: Date | null
    endTime: Date | null
  }

  export type UserAvailabilityMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    dayOfWeek: number | null
    startTime: Date | null
    endTime: Date | null
  }

  export type UserAvailabilityCountAggregateOutputType = {
    id: number
    userId: number
    dayOfWeek: number
    startTime: number
    endTime: number
    _all: number
  }


  export type UserAvailabilityAvgAggregateInputType = {
    dayOfWeek?: true
  }

  export type UserAvailabilitySumAggregateInputType = {
    dayOfWeek?: true
  }

  export type UserAvailabilityMinAggregateInputType = {
    id?: true
    userId?: true
    dayOfWeek?: true
    startTime?: true
    endTime?: true
  }

  export type UserAvailabilityMaxAggregateInputType = {
    id?: true
    userId?: true
    dayOfWeek?: true
    startTime?: true
    endTime?: true
  }

  export type UserAvailabilityCountAggregateInputType = {
    id?: true
    userId?: true
    dayOfWeek?: true
    startTime?: true
    endTime?: true
    _all?: true
  }

  export type UserAvailabilityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAvailability to aggregate.
     */
    where?: UserAvailabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAvailabilities to fetch.
     */
    orderBy?: UserAvailabilityOrderByWithRelationInput | UserAvailabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserAvailabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAvailabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAvailabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserAvailabilities
    **/
    _count?: true | UserAvailabilityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvailabilityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserAvailabilitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserAvailabilityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserAvailabilityMaxAggregateInputType
  }

  export type GetUserAvailabilityAggregateType<T extends UserAvailabilityAggregateArgs> = {
        [P in keyof T & keyof AggregateUserAvailability]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserAvailability[P]>
      : GetScalarType<T[P], AggregateUserAvailability[P]>
  }




  export type UserAvailabilityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAvailabilityWhereInput
    orderBy?: UserAvailabilityOrderByWithAggregationInput | UserAvailabilityOrderByWithAggregationInput[]
    by: UserAvailabilityScalarFieldEnum[] | UserAvailabilityScalarFieldEnum
    having?: UserAvailabilityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserAvailabilityCountAggregateInputType | true
    _avg?: UserAvailabilityAvgAggregateInputType
    _sum?: UserAvailabilitySumAggregateInputType
    _min?: UserAvailabilityMinAggregateInputType
    _max?: UserAvailabilityMaxAggregateInputType
  }

  export type UserAvailabilityGroupByOutputType = {
    id: string
    userId: string
    dayOfWeek: number
    startTime: Date
    endTime: Date
    _count: UserAvailabilityCountAggregateOutputType | null
    _avg: UserAvailabilityAvgAggregateOutputType | null
    _sum: UserAvailabilitySumAggregateOutputType | null
    _min: UserAvailabilityMinAggregateOutputType | null
    _max: UserAvailabilityMaxAggregateOutputType | null
  }

  type GetUserAvailabilityGroupByPayload<T extends UserAvailabilityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserAvailabilityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserAvailabilityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserAvailabilityGroupByOutputType[P]>
            : GetScalarType<T[P], UserAvailabilityGroupByOutputType[P]>
        }
      >
    >


  export type UserAvailabilitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    dayOfWeek?: boolean
    startTime?: boolean
    endTime?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAvailability"]>

  export type UserAvailabilitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    dayOfWeek?: boolean
    startTime?: boolean
    endTime?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAvailability"]>

  export type UserAvailabilitySelectScalar = {
    id?: boolean
    userId?: boolean
    dayOfWeek?: boolean
    startTime?: boolean
    endTime?: boolean
  }

  export type UserAvailabilityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserAvailabilityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserAvailabilityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserAvailability"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      dayOfWeek: number
      startTime: Date
      endTime: Date
    }, ExtArgs["result"]["userAvailability"]>
    composites: {}
  }

  type UserAvailabilityGetPayload<S extends boolean | null | undefined | UserAvailabilityDefaultArgs> = $Result.GetResult<Prisma.$UserAvailabilityPayload, S>

  type UserAvailabilityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserAvailabilityFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserAvailabilityCountAggregateInputType | true
    }

  export interface UserAvailabilityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserAvailability'], meta: { name: 'UserAvailability' } }
    /**
     * Find zero or one UserAvailability that matches the filter.
     * @param {UserAvailabilityFindUniqueArgs} args - Arguments to find a UserAvailability
     * @example
     * // Get one UserAvailability
     * const userAvailability = await prisma.userAvailability.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserAvailabilityFindUniqueArgs>(args: SelectSubset<T, UserAvailabilityFindUniqueArgs<ExtArgs>>): Prisma__UserAvailabilityClient<$Result.GetResult<Prisma.$UserAvailabilityPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserAvailability that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserAvailabilityFindUniqueOrThrowArgs} args - Arguments to find a UserAvailability
     * @example
     * // Get one UserAvailability
     * const userAvailability = await prisma.userAvailability.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserAvailabilityFindUniqueOrThrowArgs>(args: SelectSubset<T, UserAvailabilityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserAvailabilityClient<$Result.GetResult<Prisma.$UserAvailabilityPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserAvailability that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAvailabilityFindFirstArgs} args - Arguments to find a UserAvailability
     * @example
     * // Get one UserAvailability
     * const userAvailability = await prisma.userAvailability.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserAvailabilityFindFirstArgs>(args?: SelectSubset<T, UserAvailabilityFindFirstArgs<ExtArgs>>): Prisma__UserAvailabilityClient<$Result.GetResult<Prisma.$UserAvailabilityPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserAvailability that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAvailabilityFindFirstOrThrowArgs} args - Arguments to find a UserAvailability
     * @example
     * // Get one UserAvailability
     * const userAvailability = await prisma.userAvailability.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserAvailabilityFindFirstOrThrowArgs>(args?: SelectSubset<T, UserAvailabilityFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserAvailabilityClient<$Result.GetResult<Prisma.$UserAvailabilityPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserAvailabilities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAvailabilityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserAvailabilities
     * const userAvailabilities = await prisma.userAvailability.findMany()
     * 
     * // Get first 10 UserAvailabilities
     * const userAvailabilities = await prisma.userAvailability.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userAvailabilityWithIdOnly = await prisma.userAvailability.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserAvailabilityFindManyArgs>(args?: SelectSubset<T, UserAvailabilityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAvailabilityPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserAvailability.
     * @param {UserAvailabilityCreateArgs} args - Arguments to create a UserAvailability.
     * @example
     * // Create one UserAvailability
     * const UserAvailability = await prisma.userAvailability.create({
     *   data: {
     *     // ... data to create a UserAvailability
     *   }
     * })
     * 
     */
    create<T extends UserAvailabilityCreateArgs>(args: SelectSubset<T, UserAvailabilityCreateArgs<ExtArgs>>): Prisma__UserAvailabilityClient<$Result.GetResult<Prisma.$UserAvailabilityPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserAvailabilities.
     * @param {UserAvailabilityCreateManyArgs} args - Arguments to create many UserAvailabilities.
     * @example
     * // Create many UserAvailabilities
     * const userAvailability = await prisma.userAvailability.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserAvailabilityCreateManyArgs>(args?: SelectSubset<T, UserAvailabilityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserAvailabilities and returns the data saved in the database.
     * @param {UserAvailabilityCreateManyAndReturnArgs} args - Arguments to create many UserAvailabilities.
     * @example
     * // Create many UserAvailabilities
     * const userAvailability = await prisma.userAvailability.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserAvailabilities and only return the `id`
     * const userAvailabilityWithIdOnly = await prisma.userAvailability.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserAvailabilityCreateManyAndReturnArgs>(args?: SelectSubset<T, UserAvailabilityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAvailabilityPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserAvailability.
     * @param {UserAvailabilityDeleteArgs} args - Arguments to delete one UserAvailability.
     * @example
     * // Delete one UserAvailability
     * const UserAvailability = await prisma.userAvailability.delete({
     *   where: {
     *     // ... filter to delete one UserAvailability
     *   }
     * })
     * 
     */
    delete<T extends UserAvailabilityDeleteArgs>(args: SelectSubset<T, UserAvailabilityDeleteArgs<ExtArgs>>): Prisma__UserAvailabilityClient<$Result.GetResult<Prisma.$UserAvailabilityPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserAvailability.
     * @param {UserAvailabilityUpdateArgs} args - Arguments to update one UserAvailability.
     * @example
     * // Update one UserAvailability
     * const userAvailability = await prisma.userAvailability.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserAvailabilityUpdateArgs>(args: SelectSubset<T, UserAvailabilityUpdateArgs<ExtArgs>>): Prisma__UserAvailabilityClient<$Result.GetResult<Prisma.$UserAvailabilityPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserAvailabilities.
     * @param {UserAvailabilityDeleteManyArgs} args - Arguments to filter UserAvailabilities to delete.
     * @example
     * // Delete a few UserAvailabilities
     * const { count } = await prisma.userAvailability.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserAvailabilityDeleteManyArgs>(args?: SelectSubset<T, UserAvailabilityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserAvailabilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAvailabilityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserAvailabilities
     * const userAvailability = await prisma.userAvailability.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserAvailabilityUpdateManyArgs>(args: SelectSubset<T, UserAvailabilityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserAvailability.
     * @param {UserAvailabilityUpsertArgs} args - Arguments to update or create a UserAvailability.
     * @example
     * // Update or create a UserAvailability
     * const userAvailability = await prisma.userAvailability.upsert({
     *   create: {
     *     // ... data to create a UserAvailability
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserAvailability we want to update
     *   }
     * })
     */
    upsert<T extends UserAvailabilityUpsertArgs>(args: SelectSubset<T, UserAvailabilityUpsertArgs<ExtArgs>>): Prisma__UserAvailabilityClient<$Result.GetResult<Prisma.$UserAvailabilityPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserAvailabilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAvailabilityCountArgs} args - Arguments to filter UserAvailabilities to count.
     * @example
     * // Count the number of UserAvailabilities
     * const count = await prisma.userAvailability.count({
     *   where: {
     *     // ... the filter for the UserAvailabilities we want to count
     *   }
     * })
    **/
    count<T extends UserAvailabilityCountArgs>(
      args?: Subset<T, UserAvailabilityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserAvailabilityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserAvailability.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAvailabilityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAvailabilityAggregateArgs>(args: Subset<T, UserAvailabilityAggregateArgs>): Prisma.PrismaPromise<GetUserAvailabilityAggregateType<T>>

    /**
     * Group by UserAvailability.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAvailabilityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserAvailabilityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserAvailabilityGroupByArgs['orderBy'] }
        : { orderBy?: UserAvailabilityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserAvailabilityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserAvailabilityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserAvailability model
   */
  readonly fields: UserAvailabilityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserAvailability.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserAvailabilityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserAvailability model
   */ 
  interface UserAvailabilityFieldRefs {
    readonly id: FieldRef<"UserAvailability", 'String'>
    readonly userId: FieldRef<"UserAvailability", 'String'>
    readonly dayOfWeek: FieldRef<"UserAvailability", 'Int'>
    readonly startTime: FieldRef<"UserAvailability", 'DateTime'>
    readonly endTime: FieldRef<"UserAvailability", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserAvailability findUnique
   */
  export type UserAvailabilityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAvailability
     */
    select?: UserAvailabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAvailabilityInclude<ExtArgs> | null
    /**
     * Filter, which UserAvailability to fetch.
     */
    where: UserAvailabilityWhereUniqueInput
  }

  /**
   * UserAvailability findUniqueOrThrow
   */
  export type UserAvailabilityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAvailability
     */
    select?: UserAvailabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAvailabilityInclude<ExtArgs> | null
    /**
     * Filter, which UserAvailability to fetch.
     */
    where: UserAvailabilityWhereUniqueInput
  }

  /**
   * UserAvailability findFirst
   */
  export type UserAvailabilityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAvailability
     */
    select?: UserAvailabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAvailabilityInclude<ExtArgs> | null
    /**
     * Filter, which UserAvailability to fetch.
     */
    where?: UserAvailabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAvailabilities to fetch.
     */
    orderBy?: UserAvailabilityOrderByWithRelationInput | UserAvailabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAvailabilities.
     */
    cursor?: UserAvailabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAvailabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAvailabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAvailabilities.
     */
    distinct?: UserAvailabilityScalarFieldEnum | UserAvailabilityScalarFieldEnum[]
  }

  /**
   * UserAvailability findFirstOrThrow
   */
  export type UserAvailabilityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAvailability
     */
    select?: UserAvailabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAvailabilityInclude<ExtArgs> | null
    /**
     * Filter, which UserAvailability to fetch.
     */
    where?: UserAvailabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAvailabilities to fetch.
     */
    orderBy?: UserAvailabilityOrderByWithRelationInput | UserAvailabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAvailabilities.
     */
    cursor?: UserAvailabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAvailabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAvailabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAvailabilities.
     */
    distinct?: UserAvailabilityScalarFieldEnum | UserAvailabilityScalarFieldEnum[]
  }

  /**
   * UserAvailability findMany
   */
  export type UserAvailabilityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAvailability
     */
    select?: UserAvailabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAvailabilityInclude<ExtArgs> | null
    /**
     * Filter, which UserAvailabilities to fetch.
     */
    where?: UserAvailabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAvailabilities to fetch.
     */
    orderBy?: UserAvailabilityOrderByWithRelationInput | UserAvailabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserAvailabilities.
     */
    cursor?: UserAvailabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAvailabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAvailabilities.
     */
    skip?: number
    distinct?: UserAvailabilityScalarFieldEnum | UserAvailabilityScalarFieldEnum[]
  }

  /**
   * UserAvailability create
   */
  export type UserAvailabilityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAvailability
     */
    select?: UserAvailabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAvailabilityInclude<ExtArgs> | null
    /**
     * The data needed to create a UserAvailability.
     */
    data: XOR<UserAvailabilityCreateInput, UserAvailabilityUncheckedCreateInput>
  }

  /**
   * UserAvailability createMany
   */
  export type UserAvailabilityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserAvailabilities.
     */
    data: UserAvailabilityCreateManyInput | UserAvailabilityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserAvailability createManyAndReturn
   */
  export type UserAvailabilityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAvailability
     */
    select?: UserAvailabilitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserAvailabilities.
     */
    data: UserAvailabilityCreateManyInput | UserAvailabilityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAvailabilityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserAvailability update
   */
  export type UserAvailabilityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAvailability
     */
    select?: UserAvailabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAvailabilityInclude<ExtArgs> | null
    /**
     * The data needed to update a UserAvailability.
     */
    data: XOR<UserAvailabilityUpdateInput, UserAvailabilityUncheckedUpdateInput>
    /**
     * Choose, which UserAvailability to update.
     */
    where: UserAvailabilityWhereUniqueInput
  }

  /**
   * UserAvailability updateMany
   */
  export type UserAvailabilityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserAvailabilities.
     */
    data: XOR<UserAvailabilityUpdateManyMutationInput, UserAvailabilityUncheckedUpdateManyInput>
    /**
     * Filter which UserAvailabilities to update
     */
    where?: UserAvailabilityWhereInput
  }

  /**
   * UserAvailability upsert
   */
  export type UserAvailabilityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAvailability
     */
    select?: UserAvailabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAvailabilityInclude<ExtArgs> | null
    /**
     * The filter to search for the UserAvailability to update in case it exists.
     */
    where: UserAvailabilityWhereUniqueInput
    /**
     * In case the UserAvailability found by the `where` argument doesn't exist, create a new UserAvailability with this data.
     */
    create: XOR<UserAvailabilityCreateInput, UserAvailabilityUncheckedCreateInput>
    /**
     * In case the UserAvailability was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserAvailabilityUpdateInput, UserAvailabilityUncheckedUpdateInput>
  }

  /**
   * UserAvailability delete
   */
  export type UserAvailabilityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAvailability
     */
    select?: UserAvailabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAvailabilityInclude<ExtArgs> | null
    /**
     * Filter which UserAvailability to delete.
     */
    where: UserAvailabilityWhereUniqueInput
  }

  /**
   * UserAvailability deleteMany
   */
  export type UserAvailabilityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAvailabilities to delete
     */
    where?: UserAvailabilityWhereInput
  }

  /**
   * UserAvailability without action
   */
  export type UserAvailabilityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAvailability
     */
    select?: UserAvailabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAvailabilityInclude<ExtArgs> | null
  }


  /**
   * Model PointsTransaction
   */

  export type AggregatePointsTransaction = {
    _count: PointsTransactionCountAggregateOutputType | null
    _avg: PointsTransactionAvgAggregateOutputType | null
    _sum: PointsTransactionSumAggregateOutputType | null
    _min: PointsTransactionMinAggregateOutputType | null
    _max: PointsTransactionMaxAggregateOutputType | null
  }

  export type PointsTransactionAvgAggregateOutputType = {
    amount: number | null
  }

  export type PointsTransactionSumAggregateOutputType = {
    amount: number | null
  }

  export type PointsTransactionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    amount: number | null
    type: $Enums.PointsTxnType | null
    description: string | null
    createdAt: Date | null
  }

  export type PointsTransactionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    amount: number | null
    type: $Enums.PointsTxnType | null
    description: string | null
    createdAt: Date | null
  }

  export type PointsTransactionCountAggregateOutputType = {
    id: number
    userId: number
    amount: number
    type: number
    description: number
    createdAt: number
    _all: number
  }


  export type PointsTransactionAvgAggregateInputType = {
    amount?: true
  }

  export type PointsTransactionSumAggregateInputType = {
    amount?: true
  }

  export type PointsTransactionMinAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    type?: true
    description?: true
    createdAt?: true
  }

  export type PointsTransactionMaxAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    type?: true
    description?: true
    createdAt?: true
  }

  export type PointsTransactionCountAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    type?: true
    description?: true
    createdAt?: true
    _all?: true
  }

  export type PointsTransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PointsTransaction to aggregate.
     */
    where?: PointsTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PointsTransactions to fetch.
     */
    orderBy?: PointsTransactionOrderByWithRelationInput | PointsTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PointsTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PointsTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PointsTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PointsTransactions
    **/
    _count?: true | PointsTransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PointsTransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PointsTransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PointsTransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PointsTransactionMaxAggregateInputType
  }

  export type GetPointsTransactionAggregateType<T extends PointsTransactionAggregateArgs> = {
        [P in keyof T & keyof AggregatePointsTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePointsTransaction[P]>
      : GetScalarType<T[P], AggregatePointsTransaction[P]>
  }




  export type PointsTransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PointsTransactionWhereInput
    orderBy?: PointsTransactionOrderByWithAggregationInput | PointsTransactionOrderByWithAggregationInput[]
    by: PointsTransactionScalarFieldEnum[] | PointsTransactionScalarFieldEnum
    having?: PointsTransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PointsTransactionCountAggregateInputType | true
    _avg?: PointsTransactionAvgAggregateInputType
    _sum?: PointsTransactionSumAggregateInputType
    _min?: PointsTransactionMinAggregateInputType
    _max?: PointsTransactionMaxAggregateInputType
  }

  export type PointsTransactionGroupByOutputType = {
    id: string
    userId: string
    amount: number
    type: $Enums.PointsTxnType
    description: string | null
    createdAt: Date
    _count: PointsTransactionCountAggregateOutputType | null
    _avg: PointsTransactionAvgAggregateOutputType | null
    _sum: PointsTransactionSumAggregateOutputType | null
    _min: PointsTransactionMinAggregateOutputType | null
    _max: PointsTransactionMaxAggregateOutputType | null
  }

  type GetPointsTransactionGroupByPayload<T extends PointsTransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PointsTransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PointsTransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PointsTransactionGroupByOutputType[P]>
            : GetScalarType<T[P], PointsTransactionGroupByOutputType[P]>
        }
      >
    >


  export type PointsTransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    amount?: boolean
    type?: boolean
    description?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pointsTransaction"]>

  export type PointsTransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    amount?: boolean
    type?: boolean
    description?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pointsTransaction"]>

  export type PointsTransactionSelectScalar = {
    id?: boolean
    userId?: boolean
    amount?: boolean
    type?: boolean
    description?: boolean
    createdAt?: boolean
  }

  export type PointsTransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PointsTransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PointsTransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PointsTransaction"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      amount: number
      type: $Enums.PointsTxnType
      description: string | null
      createdAt: Date
    }, ExtArgs["result"]["pointsTransaction"]>
    composites: {}
  }

  type PointsTransactionGetPayload<S extends boolean | null | undefined | PointsTransactionDefaultArgs> = $Result.GetResult<Prisma.$PointsTransactionPayload, S>

  type PointsTransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PointsTransactionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PointsTransactionCountAggregateInputType | true
    }

  export interface PointsTransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PointsTransaction'], meta: { name: 'PointsTransaction' } }
    /**
     * Find zero or one PointsTransaction that matches the filter.
     * @param {PointsTransactionFindUniqueArgs} args - Arguments to find a PointsTransaction
     * @example
     * // Get one PointsTransaction
     * const pointsTransaction = await prisma.pointsTransaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PointsTransactionFindUniqueArgs>(args: SelectSubset<T, PointsTransactionFindUniqueArgs<ExtArgs>>): Prisma__PointsTransactionClient<$Result.GetResult<Prisma.$PointsTransactionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PointsTransaction that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PointsTransactionFindUniqueOrThrowArgs} args - Arguments to find a PointsTransaction
     * @example
     * // Get one PointsTransaction
     * const pointsTransaction = await prisma.pointsTransaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PointsTransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, PointsTransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PointsTransactionClient<$Result.GetResult<Prisma.$PointsTransactionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PointsTransaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointsTransactionFindFirstArgs} args - Arguments to find a PointsTransaction
     * @example
     * // Get one PointsTransaction
     * const pointsTransaction = await prisma.pointsTransaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PointsTransactionFindFirstArgs>(args?: SelectSubset<T, PointsTransactionFindFirstArgs<ExtArgs>>): Prisma__PointsTransactionClient<$Result.GetResult<Prisma.$PointsTransactionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PointsTransaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointsTransactionFindFirstOrThrowArgs} args - Arguments to find a PointsTransaction
     * @example
     * // Get one PointsTransaction
     * const pointsTransaction = await prisma.pointsTransaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PointsTransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, PointsTransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PointsTransactionClient<$Result.GetResult<Prisma.$PointsTransactionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PointsTransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointsTransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PointsTransactions
     * const pointsTransactions = await prisma.pointsTransaction.findMany()
     * 
     * // Get first 10 PointsTransactions
     * const pointsTransactions = await prisma.pointsTransaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pointsTransactionWithIdOnly = await prisma.pointsTransaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PointsTransactionFindManyArgs>(args?: SelectSubset<T, PointsTransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PointsTransactionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PointsTransaction.
     * @param {PointsTransactionCreateArgs} args - Arguments to create a PointsTransaction.
     * @example
     * // Create one PointsTransaction
     * const PointsTransaction = await prisma.pointsTransaction.create({
     *   data: {
     *     // ... data to create a PointsTransaction
     *   }
     * })
     * 
     */
    create<T extends PointsTransactionCreateArgs>(args: SelectSubset<T, PointsTransactionCreateArgs<ExtArgs>>): Prisma__PointsTransactionClient<$Result.GetResult<Prisma.$PointsTransactionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PointsTransactions.
     * @param {PointsTransactionCreateManyArgs} args - Arguments to create many PointsTransactions.
     * @example
     * // Create many PointsTransactions
     * const pointsTransaction = await prisma.pointsTransaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PointsTransactionCreateManyArgs>(args?: SelectSubset<T, PointsTransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PointsTransactions and returns the data saved in the database.
     * @param {PointsTransactionCreateManyAndReturnArgs} args - Arguments to create many PointsTransactions.
     * @example
     * // Create many PointsTransactions
     * const pointsTransaction = await prisma.pointsTransaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PointsTransactions and only return the `id`
     * const pointsTransactionWithIdOnly = await prisma.pointsTransaction.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PointsTransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, PointsTransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PointsTransactionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PointsTransaction.
     * @param {PointsTransactionDeleteArgs} args - Arguments to delete one PointsTransaction.
     * @example
     * // Delete one PointsTransaction
     * const PointsTransaction = await prisma.pointsTransaction.delete({
     *   where: {
     *     // ... filter to delete one PointsTransaction
     *   }
     * })
     * 
     */
    delete<T extends PointsTransactionDeleteArgs>(args: SelectSubset<T, PointsTransactionDeleteArgs<ExtArgs>>): Prisma__PointsTransactionClient<$Result.GetResult<Prisma.$PointsTransactionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PointsTransaction.
     * @param {PointsTransactionUpdateArgs} args - Arguments to update one PointsTransaction.
     * @example
     * // Update one PointsTransaction
     * const pointsTransaction = await prisma.pointsTransaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PointsTransactionUpdateArgs>(args: SelectSubset<T, PointsTransactionUpdateArgs<ExtArgs>>): Prisma__PointsTransactionClient<$Result.GetResult<Prisma.$PointsTransactionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PointsTransactions.
     * @param {PointsTransactionDeleteManyArgs} args - Arguments to filter PointsTransactions to delete.
     * @example
     * // Delete a few PointsTransactions
     * const { count } = await prisma.pointsTransaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PointsTransactionDeleteManyArgs>(args?: SelectSubset<T, PointsTransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PointsTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointsTransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PointsTransactions
     * const pointsTransaction = await prisma.pointsTransaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PointsTransactionUpdateManyArgs>(args: SelectSubset<T, PointsTransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PointsTransaction.
     * @param {PointsTransactionUpsertArgs} args - Arguments to update or create a PointsTransaction.
     * @example
     * // Update or create a PointsTransaction
     * const pointsTransaction = await prisma.pointsTransaction.upsert({
     *   create: {
     *     // ... data to create a PointsTransaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PointsTransaction we want to update
     *   }
     * })
     */
    upsert<T extends PointsTransactionUpsertArgs>(args: SelectSubset<T, PointsTransactionUpsertArgs<ExtArgs>>): Prisma__PointsTransactionClient<$Result.GetResult<Prisma.$PointsTransactionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PointsTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointsTransactionCountArgs} args - Arguments to filter PointsTransactions to count.
     * @example
     * // Count the number of PointsTransactions
     * const count = await prisma.pointsTransaction.count({
     *   where: {
     *     // ... the filter for the PointsTransactions we want to count
     *   }
     * })
    **/
    count<T extends PointsTransactionCountArgs>(
      args?: Subset<T, PointsTransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PointsTransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PointsTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointsTransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PointsTransactionAggregateArgs>(args: Subset<T, PointsTransactionAggregateArgs>): Prisma.PrismaPromise<GetPointsTransactionAggregateType<T>>

    /**
     * Group by PointsTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointsTransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PointsTransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PointsTransactionGroupByArgs['orderBy'] }
        : { orderBy?: PointsTransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PointsTransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPointsTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PointsTransaction model
   */
  readonly fields: PointsTransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PointsTransaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PointsTransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PointsTransaction model
   */ 
  interface PointsTransactionFieldRefs {
    readonly id: FieldRef<"PointsTransaction", 'String'>
    readonly userId: FieldRef<"PointsTransaction", 'String'>
    readonly amount: FieldRef<"PointsTransaction", 'Int'>
    readonly type: FieldRef<"PointsTransaction", 'PointsTxnType'>
    readonly description: FieldRef<"PointsTransaction", 'String'>
    readonly createdAt: FieldRef<"PointsTransaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PointsTransaction findUnique
   */
  export type PointsTransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointsTransaction
     */
    select?: PointsTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointsTransactionInclude<ExtArgs> | null
    /**
     * Filter, which PointsTransaction to fetch.
     */
    where: PointsTransactionWhereUniqueInput
  }

  /**
   * PointsTransaction findUniqueOrThrow
   */
  export type PointsTransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointsTransaction
     */
    select?: PointsTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointsTransactionInclude<ExtArgs> | null
    /**
     * Filter, which PointsTransaction to fetch.
     */
    where: PointsTransactionWhereUniqueInput
  }

  /**
   * PointsTransaction findFirst
   */
  export type PointsTransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointsTransaction
     */
    select?: PointsTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointsTransactionInclude<ExtArgs> | null
    /**
     * Filter, which PointsTransaction to fetch.
     */
    where?: PointsTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PointsTransactions to fetch.
     */
    orderBy?: PointsTransactionOrderByWithRelationInput | PointsTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PointsTransactions.
     */
    cursor?: PointsTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PointsTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PointsTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PointsTransactions.
     */
    distinct?: PointsTransactionScalarFieldEnum | PointsTransactionScalarFieldEnum[]
  }

  /**
   * PointsTransaction findFirstOrThrow
   */
  export type PointsTransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointsTransaction
     */
    select?: PointsTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointsTransactionInclude<ExtArgs> | null
    /**
     * Filter, which PointsTransaction to fetch.
     */
    where?: PointsTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PointsTransactions to fetch.
     */
    orderBy?: PointsTransactionOrderByWithRelationInput | PointsTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PointsTransactions.
     */
    cursor?: PointsTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PointsTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PointsTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PointsTransactions.
     */
    distinct?: PointsTransactionScalarFieldEnum | PointsTransactionScalarFieldEnum[]
  }

  /**
   * PointsTransaction findMany
   */
  export type PointsTransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointsTransaction
     */
    select?: PointsTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointsTransactionInclude<ExtArgs> | null
    /**
     * Filter, which PointsTransactions to fetch.
     */
    where?: PointsTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PointsTransactions to fetch.
     */
    orderBy?: PointsTransactionOrderByWithRelationInput | PointsTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PointsTransactions.
     */
    cursor?: PointsTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PointsTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PointsTransactions.
     */
    skip?: number
    distinct?: PointsTransactionScalarFieldEnum | PointsTransactionScalarFieldEnum[]
  }

  /**
   * PointsTransaction create
   */
  export type PointsTransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointsTransaction
     */
    select?: PointsTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointsTransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a PointsTransaction.
     */
    data: XOR<PointsTransactionCreateInput, PointsTransactionUncheckedCreateInput>
  }

  /**
   * PointsTransaction createMany
   */
  export type PointsTransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PointsTransactions.
     */
    data: PointsTransactionCreateManyInput | PointsTransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PointsTransaction createManyAndReturn
   */
  export type PointsTransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointsTransaction
     */
    select?: PointsTransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PointsTransactions.
     */
    data: PointsTransactionCreateManyInput | PointsTransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointsTransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PointsTransaction update
   */
  export type PointsTransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointsTransaction
     */
    select?: PointsTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointsTransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a PointsTransaction.
     */
    data: XOR<PointsTransactionUpdateInput, PointsTransactionUncheckedUpdateInput>
    /**
     * Choose, which PointsTransaction to update.
     */
    where: PointsTransactionWhereUniqueInput
  }

  /**
   * PointsTransaction updateMany
   */
  export type PointsTransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PointsTransactions.
     */
    data: XOR<PointsTransactionUpdateManyMutationInput, PointsTransactionUncheckedUpdateManyInput>
    /**
     * Filter which PointsTransactions to update
     */
    where?: PointsTransactionWhereInput
  }

  /**
   * PointsTransaction upsert
   */
  export type PointsTransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointsTransaction
     */
    select?: PointsTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointsTransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the PointsTransaction to update in case it exists.
     */
    where: PointsTransactionWhereUniqueInput
    /**
     * In case the PointsTransaction found by the `where` argument doesn't exist, create a new PointsTransaction with this data.
     */
    create: XOR<PointsTransactionCreateInput, PointsTransactionUncheckedCreateInput>
    /**
     * In case the PointsTransaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PointsTransactionUpdateInput, PointsTransactionUncheckedUpdateInput>
  }

  /**
   * PointsTransaction delete
   */
  export type PointsTransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointsTransaction
     */
    select?: PointsTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointsTransactionInclude<ExtArgs> | null
    /**
     * Filter which PointsTransaction to delete.
     */
    where: PointsTransactionWhereUniqueInput
  }

  /**
   * PointsTransaction deleteMany
   */
  export type PointsTransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PointsTransactions to delete
     */
    where?: PointsTransactionWhereInput
  }

  /**
   * PointsTransaction without action
   */
  export type PointsTransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointsTransaction
     */
    select?: PointsTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointsTransactionInclude<ExtArgs> | null
  }


  /**
   * Model PointsPackage
   */

  export type AggregatePointsPackage = {
    _count: PointsPackageCountAggregateOutputType | null
    _avg: PointsPackageAvgAggregateOutputType | null
    _sum: PointsPackageSumAggregateOutputType | null
    _min: PointsPackageMinAggregateOutputType | null
    _max: PointsPackageMaxAggregateOutputType | null
  }

  export type PointsPackageAvgAggregateOutputType = {
    points: number | null
    price: Decimal | null
  }

  export type PointsPackageSumAggregateOutputType = {
    points: number | null
    price: Decimal | null
  }

  export type PointsPackageMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    points: number | null
    price: Decimal | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PointsPackageMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    points: number | null
    price: Decimal | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PointsPackageCountAggregateOutputType = {
    id: number
    name: number
    description: number
    points: number
    price: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PointsPackageAvgAggregateInputType = {
    points?: true
    price?: true
  }

  export type PointsPackageSumAggregateInputType = {
    points?: true
    price?: true
  }

  export type PointsPackageMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    points?: true
    price?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PointsPackageMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    points?: true
    price?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PointsPackageCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    points?: true
    price?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PointsPackageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PointsPackage to aggregate.
     */
    where?: PointsPackageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PointsPackages to fetch.
     */
    orderBy?: PointsPackageOrderByWithRelationInput | PointsPackageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PointsPackageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PointsPackages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PointsPackages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PointsPackages
    **/
    _count?: true | PointsPackageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PointsPackageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PointsPackageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PointsPackageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PointsPackageMaxAggregateInputType
  }

  export type GetPointsPackageAggregateType<T extends PointsPackageAggregateArgs> = {
        [P in keyof T & keyof AggregatePointsPackage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePointsPackage[P]>
      : GetScalarType<T[P], AggregatePointsPackage[P]>
  }




  export type PointsPackageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PointsPackageWhereInput
    orderBy?: PointsPackageOrderByWithAggregationInput | PointsPackageOrderByWithAggregationInput[]
    by: PointsPackageScalarFieldEnum[] | PointsPackageScalarFieldEnum
    having?: PointsPackageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PointsPackageCountAggregateInputType | true
    _avg?: PointsPackageAvgAggregateInputType
    _sum?: PointsPackageSumAggregateInputType
    _min?: PointsPackageMinAggregateInputType
    _max?: PointsPackageMaxAggregateInputType
  }

  export type PointsPackageGroupByOutputType = {
    id: string
    name: string
    description: string | null
    points: number
    price: Decimal
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: PointsPackageCountAggregateOutputType | null
    _avg: PointsPackageAvgAggregateOutputType | null
    _sum: PointsPackageSumAggregateOutputType | null
    _min: PointsPackageMinAggregateOutputType | null
    _max: PointsPackageMaxAggregateOutputType | null
  }

  type GetPointsPackageGroupByPayload<T extends PointsPackageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PointsPackageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PointsPackageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PointsPackageGroupByOutputType[P]>
            : GetScalarType<T[P], PointsPackageGroupByOutputType[P]>
        }
      >
    >


  export type PointsPackageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    points?: boolean
    price?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["pointsPackage"]>

  export type PointsPackageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    points?: boolean
    price?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["pointsPackage"]>

  export type PointsPackageSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    points?: boolean
    price?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $PointsPackagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PointsPackage"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      points: number
      price: Prisma.Decimal
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["pointsPackage"]>
    composites: {}
  }

  type PointsPackageGetPayload<S extends boolean | null | undefined | PointsPackageDefaultArgs> = $Result.GetResult<Prisma.$PointsPackagePayload, S>

  type PointsPackageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PointsPackageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PointsPackageCountAggregateInputType | true
    }

  export interface PointsPackageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PointsPackage'], meta: { name: 'PointsPackage' } }
    /**
     * Find zero or one PointsPackage that matches the filter.
     * @param {PointsPackageFindUniqueArgs} args - Arguments to find a PointsPackage
     * @example
     * // Get one PointsPackage
     * const pointsPackage = await prisma.pointsPackage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PointsPackageFindUniqueArgs>(args: SelectSubset<T, PointsPackageFindUniqueArgs<ExtArgs>>): Prisma__PointsPackageClient<$Result.GetResult<Prisma.$PointsPackagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PointsPackage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PointsPackageFindUniqueOrThrowArgs} args - Arguments to find a PointsPackage
     * @example
     * // Get one PointsPackage
     * const pointsPackage = await prisma.pointsPackage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PointsPackageFindUniqueOrThrowArgs>(args: SelectSubset<T, PointsPackageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PointsPackageClient<$Result.GetResult<Prisma.$PointsPackagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PointsPackage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointsPackageFindFirstArgs} args - Arguments to find a PointsPackage
     * @example
     * // Get one PointsPackage
     * const pointsPackage = await prisma.pointsPackage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PointsPackageFindFirstArgs>(args?: SelectSubset<T, PointsPackageFindFirstArgs<ExtArgs>>): Prisma__PointsPackageClient<$Result.GetResult<Prisma.$PointsPackagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PointsPackage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointsPackageFindFirstOrThrowArgs} args - Arguments to find a PointsPackage
     * @example
     * // Get one PointsPackage
     * const pointsPackage = await prisma.pointsPackage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PointsPackageFindFirstOrThrowArgs>(args?: SelectSubset<T, PointsPackageFindFirstOrThrowArgs<ExtArgs>>): Prisma__PointsPackageClient<$Result.GetResult<Prisma.$PointsPackagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PointsPackages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointsPackageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PointsPackages
     * const pointsPackages = await prisma.pointsPackage.findMany()
     * 
     * // Get first 10 PointsPackages
     * const pointsPackages = await prisma.pointsPackage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pointsPackageWithIdOnly = await prisma.pointsPackage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PointsPackageFindManyArgs>(args?: SelectSubset<T, PointsPackageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PointsPackagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PointsPackage.
     * @param {PointsPackageCreateArgs} args - Arguments to create a PointsPackage.
     * @example
     * // Create one PointsPackage
     * const PointsPackage = await prisma.pointsPackage.create({
     *   data: {
     *     // ... data to create a PointsPackage
     *   }
     * })
     * 
     */
    create<T extends PointsPackageCreateArgs>(args: SelectSubset<T, PointsPackageCreateArgs<ExtArgs>>): Prisma__PointsPackageClient<$Result.GetResult<Prisma.$PointsPackagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PointsPackages.
     * @param {PointsPackageCreateManyArgs} args - Arguments to create many PointsPackages.
     * @example
     * // Create many PointsPackages
     * const pointsPackage = await prisma.pointsPackage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PointsPackageCreateManyArgs>(args?: SelectSubset<T, PointsPackageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PointsPackages and returns the data saved in the database.
     * @param {PointsPackageCreateManyAndReturnArgs} args - Arguments to create many PointsPackages.
     * @example
     * // Create many PointsPackages
     * const pointsPackage = await prisma.pointsPackage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PointsPackages and only return the `id`
     * const pointsPackageWithIdOnly = await prisma.pointsPackage.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PointsPackageCreateManyAndReturnArgs>(args?: SelectSubset<T, PointsPackageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PointsPackagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PointsPackage.
     * @param {PointsPackageDeleteArgs} args - Arguments to delete one PointsPackage.
     * @example
     * // Delete one PointsPackage
     * const PointsPackage = await prisma.pointsPackage.delete({
     *   where: {
     *     // ... filter to delete one PointsPackage
     *   }
     * })
     * 
     */
    delete<T extends PointsPackageDeleteArgs>(args: SelectSubset<T, PointsPackageDeleteArgs<ExtArgs>>): Prisma__PointsPackageClient<$Result.GetResult<Prisma.$PointsPackagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PointsPackage.
     * @param {PointsPackageUpdateArgs} args - Arguments to update one PointsPackage.
     * @example
     * // Update one PointsPackage
     * const pointsPackage = await prisma.pointsPackage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PointsPackageUpdateArgs>(args: SelectSubset<T, PointsPackageUpdateArgs<ExtArgs>>): Prisma__PointsPackageClient<$Result.GetResult<Prisma.$PointsPackagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PointsPackages.
     * @param {PointsPackageDeleteManyArgs} args - Arguments to filter PointsPackages to delete.
     * @example
     * // Delete a few PointsPackages
     * const { count } = await prisma.pointsPackage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PointsPackageDeleteManyArgs>(args?: SelectSubset<T, PointsPackageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PointsPackages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointsPackageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PointsPackages
     * const pointsPackage = await prisma.pointsPackage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PointsPackageUpdateManyArgs>(args: SelectSubset<T, PointsPackageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PointsPackage.
     * @param {PointsPackageUpsertArgs} args - Arguments to update or create a PointsPackage.
     * @example
     * // Update or create a PointsPackage
     * const pointsPackage = await prisma.pointsPackage.upsert({
     *   create: {
     *     // ... data to create a PointsPackage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PointsPackage we want to update
     *   }
     * })
     */
    upsert<T extends PointsPackageUpsertArgs>(args: SelectSubset<T, PointsPackageUpsertArgs<ExtArgs>>): Prisma__PointsPackageClient<$Result.GetResult<Prisma.$PointsPackagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PointsPackages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointsPackageCountArgs} args - Arguments to filter PointsPackages to count.
     * @example
     * // Count the number of PointsPackages
     * const count = await prisma.pointsPackage.count({
     *   where: {
     *     // ... the filter for the PointsPackages we want to count
     *   }
     * })
    **/
    count<T extends PointsPackageCountArgs>(
      args?: Subset<T, PointsPackageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PointsPackageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PointsPackage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointsPackageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PointsPackageAggregateArgs>(args: Subset<T, PointsPackageAggregateArgs>): Prisma.PrismaPromise<GetPointsPackageAggregateType<T>>

    /**
     * Group by PointsPackage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointsPackageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PointsPackageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PointsPackageGroupByArgs['orderBy'] }
        : { orderBy?: PointsPackageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PointsPackageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPointsPackageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PointsPackage model
   */
  readonly fields: PointsPackageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PointsPackage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PointsPackageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PointsPackage model
   */ 
  interface PointsPackageFieldRefs {
    readonly id: FieldRef<"PointsPackage", 'String'>
    readonly name: FieldRef<"PointsPackage", 'String'>
    readonly description: FieldRef<"PointsPackage", 'String'>
    readonly points: FieldRef<"PointsPackage", 'Int'>
    readonly price: FieldRef<"PointsPackage", 'Decimal'>
    readonly active: FieldRef<"PointsPackage", 'Boolean'>
    readonly createdAt: FieldRef<"PointsPackage", 'DateTime'>
    readonly updatedAt: FieldRef<"PointsPackage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PointsPackage findUnique
   */
  export type PointsPackageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointsPackage
     */
    select?: PointsPackageSelect<ExtArgs> | null
    /**
     * Filter, which PointsPackage to fetch.
     */
    where: PointsPackageWhereUniqueInput
  }

  /**
   * PointsPackage findUniqueOrThrow
   */
  export type PointsPackageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointsPackage
     */
    select?: PointsPackageSelect<ExtArgs> | null
    /**
     * Filter, which PointsPackage to fetch.
     */
    where: PointsPackageWhereUniqueInput
  }

  /**
   * PointsPackage findFirst
   */
  export type PointsPackageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointsPackage
     */
    select?: PointsPackageSelect<ExtArgs> | null
    /**
     * Filter, which PointsPackage to fetch.
     */
    where?: PointsPackageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PointsPackages to fetch.
     */
    orderBy?: PointsPackageOrderByWithRelationInput | PointsPackageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PointsPackages.
     */
    cursor?: PointsPackageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PointsPackages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PointsPackages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PointsPackages.
     */
    distinct?: PointsPackageScalarFieldEnum | PointsPackageScalarFieldEnum[]
  }

  /**
   * PointsPackage findFirstOrThrow
   */
  export type PointsPackageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointsPackage
     */
    select?: PointsPackageSelect<ExtArgs> | null
    /**
     * Filter, which PointsPackage to fetch.
     */
    where?: PointsPackageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PointsPackages to fetch.
     */
    orderBy?: PointsPackageOrderByWithRelationInput | PointsPackageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PointsPackages.
     */
    cursor?: PointsPackageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PointsPackages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PointsPackages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PointsPackages.
     */
    distinct?: PointsPackageScalarFieldEnum | PointsPackageScalarFieldEnum[]
  }

  /**
   * PointsPackage findMany
   */
  export type PointsPackageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointsPackage
     */
    select?: PointsPackageSelect<ExtArgs> | null
    /**
     * Filter, which PointsPackages to fetch.
     */
    where?: PointsPackageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PointsPackages to fetch.
     */
    orderBy?: PointsPackageOrderByWithRelationInput | PointsPackageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PointsPackages.
     */
    cursor?: PointsPackageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PointsPackages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PointsPackages.
     */
    skip?: number
    distinct?: PointsPackageScalarFieldEnum | PointsPackageScalarFieldEnum[]
  }

  /**
   * PointsPackage create
   */
  export type PointsPackageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointsPackage
     */
    select?: PointsPackageSelect<ExtArgs> | null
    /**
     * The data needed to create a PointsPackage.
     */
    data: XOR<PointsPackageCreateInput, PointsPackageUncheckedCreateInput>
  }

  /**
   * PointsPackage createMany
   */
  export type PointsPackageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PointsPackages.
     */
    data: PointsPackageCreateManyInput | PointsPackageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PointsPackage createManyAndReturn
   */
  export type PointsPackageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointsPackage
     */
    select?: PointsPackageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PointsPackages.
     */
    data: PointsPackageCreateManyInput | PointsPackageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PointsPackage update
   */
  export type PointsPackageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointsPackage
     */
    select?: PointsPackageSelect<ExtArgs> | null
    /**
     * The data needed to update a PointsPackage.
     */
    data: XOR<PointsPackageUpdateInput, PointsPackageUncheckedUpdateInput>
    /**
     * Choose, which PointsPackage to update.
     */
    where: PointsPackageWhereUniqueInput
  }

  /**
   * PointsPackage updateMany
   */
  export type PointsPackageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PointsPackages.
     */
    data: XOR<PointsPackageUpdateManyMutationInput, PointsPackageUncheckedUpdateManyInput>
    /**
     * Filter which PointsPackages to update
     */
    where?: PointsPackageWhereInput
  }

  /**
   * PointsPackage upsert
   */
  export type PointsPackageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointsPackage
     */
    select?: PointsPackageSelect<ExtArgs> | null
    /**
     * The filter to search for the PointsPackage to update in case it exists.
     */
    where: PointsPackageWhereUniqueInput
    /**
     * In case the PointsPackage found by the `where` argument doesn't exist, create a new PointsPackage with this data.
     */
    create: XOR<PointsPackageCreateInput, PointsPackageUncheckedCreateInput>
    /**
     * In case the PointsPackage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PointsPackageUpdateInput, PointsPackageUncheckedUpdateInput>
  }

  /**
   * PointsPackage delete
   */
  export type PointsPackageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointsPackage
     */
    select?: PointsPackageSelect<ExtArgs> | null
    /**
     * Filter which PointsPackage to delete.
     */
    where: PointsPackageWhereUniqueInput
  }

  /**
   * PointsPackage deleteMany
   */
  export type PointsPackageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PointsPackages to delete
     */
    where?: PointsPackageWhereInput
  }

  /**
   * PointsPackage without action
   */
  export type PointsPackageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointsPackage
     */
    select?: PointsPackageSelect<ExtArgs> | null
  }


  /**
   * Model Course
   */

  export type AggregateCourse = {
    _count: CourseCountAggregateOutputType | null
    _avg: CourseAvgAggregateOutputType | null
    _sum: CourseSumAggregateOutputType | null
    _min: CourseMinAggregateOutputType | null
    _max: CourseMaxAggregateOutputType | null
  }

  export type CourseAvgAggregateOutputType = {
    price: Decimal | null
    pointsPrice: number | null
    students: number | null
    rating: Decimal | null
  }

  export type CourseSumAggregateOutputType = {
    price: Decimal | null
    pointsPrice: number | null
    students: number | null
    rating: Decimal | null
  }

  export type CourseMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    subject: string | null
    image: string | null
    price: Decimal | null
    pointsPrice: number | null
    teacherId: string | null
    students: number | null
    rating: Decimal | null
    status: $Enums.CourseStatus | null
    featured: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CourseMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    subject: string | null
    image: string | null
    price: Decimal | null
    pointsPrice: number | null
    teacherId: string | null
    students: number | null
    rating: Decimal | null
    status: $Enums.CourseStatus | null
    featured: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CourseCountAggregateOutputType = {
    id: number
    title: number
    description: number
    subject: number
    image: number
    price: number
    pointsPrice: number
    teacherId: number
    students: number
    rating: number
    status: number
    featured: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CourseAvgAggregateInputType = {
    price?: true
    pointsPrice?: true
    students?: true
    rating?: true
  }

  export type CourseSumAggregateInputType = {
    price?: true
    pointsPrice?: true
    students?: true
    rating?: true
  }

  export type CourseMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    subject?: true
    image?: true
    price?: true
    pointsPrice?: true
    teacherId?: true
    students?: true
    rating?: true
    status?: true
    featured?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CourseMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    subject?: true
    image?: true
    price?: true
    pointsPrice?: true
    teacherId?: true
    students?: true
    rating?: true
    status?: true
    featured?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CourseCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    subject?: true
    image?: true
    price?: true
    pointsPrice?: true
    teacherId?: true
    students?: true
    rating?: true
    status?: true
    featured?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CourseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Course to aggregate.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Courses
    **/
    _count?: true | CourseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CourseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CourseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseMaxAggregateInputType
  }

  export type GetCourseAggregateType<T extends CourseAggregateArgs> = {
        [P in keyof T & keyof AggregateCourse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourse[P]>
      : GetScalarType<T[P], AggregateCourse[P]>
  }




  export type CourseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseWhereInput
    orderBy?: CourseOrderByWithAggregationInput | CourseOrderByWithAggregationInput[]
    by: CourseScalarFieldEnum[] | CourseScalarFieldEnum
    having?: CourseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseCountAggregateInputType | true
    _avg?: CourseAvgAggregateInputType
    _sum?: CourseSumAggregateInputType
    _min?: CourseMinAggregateInputType
    _max?: CourseMaxAggregateInputType
  }

  export type CourseGroupByOutputType = {
    id: string
    title: string
    description: string | null
    subject: string
    image: string | null
    price: Decimal
    pointsPrice: number
    teacherId: string
    students: number
    rating: Decimal | null
    status: $Enums.CourseStatus
    featured: boolean
    createdAt: Date
    updatedAt: Date
    _count: CourseCountAggregateOutputType | null
    _avg: CourseAvgAggregateOutputType | null
    _sum: CourseSumAggregateOutputType | null
    _min: CourseMinAggregateOutputType | null
    _max: CourseMaxAggregateOutputType | null
  }

  type GetCourseGroupByPayload<T extends CourseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseGroupByOutputType[P]>
            : GetScalarType<T[P], CourseGroupByOutputType[P]>
        }
      >
    >


  export type CourseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    subject?: boolean
    image?: boolean
    price?: boolean
    pointsPrice?: boolean
    teacherId?: boolean
    students?: boolean
    rating?: boolean
    status?: boolean
    featured?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    teacher?: boolean | UserDefaultArgs<ExtArgs>
    topics?: boolean | Course$topicsArgs<ExtArgs>
    enrollments?: boolean | Course$enrollmentsArgs<ExtArgs>
    savedBy?: boolean | Course$savedByArgs<ExtArgs>
    likedBy?: boolean | Course$likedByArgs<ExtArgs>
    reviews?: boolean | Course$reviewsArgs<ExtArgs>
    lessons?: boolean | Course$lessonsArgs<ExtArgs>
    quizAttempts?: boolean | Course$quizAttemptsArgs<ExtArgs>
    certificates?: boolean | Course$certificatesArgs<ExtArgs>
    bundleCourses?: boolean | Course$bundleCoursesArgs<ExtArgs>
    calendarEvents?: boolean | Course$calendarEventsArgs<ExtArgs>
    _count?: boolean | CourseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["course"]>

  export type CourseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    subject?: boolean
    image?: boolean
    price?: boolean
    pointsPrice?: boolean
    teacherId?: boolean
    students?: boolean
    rating?: boolean
    status?: boolean
    featured?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    teacher?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["course"]>

  export type CourseSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    subject?: boolean
    image?: boolean
    price?: boolean
    pointsPrice?: boolean
    teacherId?: boolean
    students?: boolean
    rating?: boolean
    status?: boolean
    featured?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CourseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teacher?: boolean | UserDefaultArgs<ExtArgs>
    topics?: boolean | Course$topicsArgs<ExtArgs>
    enrollments?: boolean | Course$enrollmentsArgs<ExtArgs>
    savedBy?: boolean | Course$savedByArgs<ExtArgs>
    likedBy?: boolean | Course$likedByArgs<ExtArgs>
    reviews?: boolean | Course$reviewsArgs<ExtArgs>
    lessons?: boolean | Course$lessonsArgs<ExtArgs>
    quizAttempts?: boolean | Course$quizAttemptsArgs<ExtArgs>
    certificates?: boolean | Course$certificatesArgs<ExtArgs>
    bundleCourses?: boolean | Course$bundleCoursesArgs<ExtArgs>
    calendarEvents?: boolean | Course$calendarEventsArgs<ExtArgs>
    _count?: boolean | CourseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CourseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teacher?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CoursePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Course"
    objects: {
      teacher: Prisma.$UserPayload<ExtArgs>
      topics: Prisma.$TopicPayload<ExtArgs>[]
      enrollments: Prisma.$EnrollmentPayload<ExtArgs>[]
      savedBy: Prisma.$SavedCoursePayload<ExtArgs>[]
      likedBy: Prisma.$LikedCoursePayload<ExtArgs>[]
      reviews: Prisma.$CourseReviewPayload<ExtArgs>[]
      lessons: Prisma.$LessonPayload<ExtArgs>[]
      quizAttempts: Prisma.$QuizAttemptPayload<ExtArgs>[]
      certificates: Prisma.$CertificatePayload<ExtArgs>[]
      bundleCourses: Prisma.$BundleCoursePayload<ExtArgs>[]
      calendarEvents: Prisma.$CalendarEventPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      subject: string
      image: string | null
      price: Prisma.Decimal
      pointsPrice: number
      teacherId: string
      students: number
      rating: Prisma.Decimal | null
      status: $Enums.CourseStatus
      featured: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["course"]>
    composites: {}
  }

  type CourseGetPayload<S extends boolean | null | undefined | CourseDefaultArgs> = $Result.GetResult<Prisma.$CoursePayload, S>

  type CourseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CourseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CourseCountAggregateInputType | true
    }

  export interface CourseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Course'], meta: { name: 'Course' } }
    /**
     * Find zero or one Course that matches the filter.
     * @param {CourseFindUniqueArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourseFindUniqueArgs>(args: SelectSubset<T, CourseFindUniqueArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Course that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CourseFindUniqueOrThrowArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourseFindUniqueOrThrowArgs>(args: SelectSubset<T, CourseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Course that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindFirstArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourseFindFirstArgs>(args?: SelectSubset<T, CourseFindFirstArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Course that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindFirstOrThrowArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourseFindFirstOrThrowArgs>(args?: SelectSubset<T, CourseFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Courses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Courses
     * const courses = await prisma.course.findMany()
     * 
     * // Get first 10 Courses
     * const courses = await prisma.course.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const courseWithIdOnly = await prisma.course.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CourseFindManyArgs>(args?: SelectSubset<T, CourseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Course.
     * @param {CourseCreateArgs} args - Arguments to create a Course.
     * @example
     * // Create one Course
     * const Course = await prisma.course.create({
     *   data: {
     *     // ... data to create a Course
     *   }
     * })
     * 
     */
    create<T extends CourseCreateArgs>(args: SelectSubset<T, CourseCreateArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Courses.
     * @param {CourseCreateManyArgs} args - Arguments to create many Courses.
     * @example
     * // Create many Courses
     * const course = await prisma.course.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourseCreateManyArgs>(args?: SelectSubset<T, CourseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Courses and returns the data saved in the database.
     * @param {CourseCreateManyAndReturnArgs} args - Arguments to create many Courses.
     * @example
     * // Create many Courses
     * const course = await prisma.course.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Courses and only return the `id`
     * const courseWithIdOnly = await prisma.course.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CourseCreateManyAndReturnArgs>(args?: SelectSubset<T, CourseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Course.
     * @param {CourseDeleteArgs} args - Arguments to delete one Course.
     * @example
     * // Delete one Course
     * const Course = await prisma.course.delete({
     *   where: {
     *     // ... filter to delete one Course
     *   }
     * })
     * 
     */
    delete<T extends CourseDeleteArgs>(args: SelectSubset<T, CourseDeleteArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Course.
     * @param {CourseUpdateArgs} args - Arguments to update one Course.
     * @example
     * // Update one Course
     * const course = await prisma.course.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourseUpdateArgs>(args: SelectSubset<T, CourseUpdateArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Courses.
     * @param {CourseDeleteManyArgs} args - Arguments to filter Courses to delete.
     * @example
     * // Delete a few Courses
     * const { count } = await prisma.course.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourseDeleteManyArgs>(args?: SelectSubset<T, CourseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Courses
     * const course = await prisma.course.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourseUpdateManyArgs>(args: SelectSubset<T, CourseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Course.
     * @param {CourseUpsertArgs} args - Arguments to update or create a Course.
     * @example
     * // Update or create a Course
     * const course = await prisma.course.upsert({
     *   create: {
     *     // ... data to create a Course
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Course we want to update
     *   }
     * })
     */
    upsert<T extends CourseUpsertArgs>(args: SelectSubset<T, CourseUpsertArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseCountArgs} args - Arguments to filter Courses to count.
     * @example
     * // Count the number of Courses
     * const count = await prisma.course.count({
     *   where: {
     *     // ... the filter for the Courses we want to count
     *   }
     * })
    **/
    count<T extends CourseCountArgs>(
      args?: Subset<T, CourseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Course.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseAggregateArgs>(args: Subset<T, CourseAggregateArgs>): Prisma.PrismaPromise<GetCourseAggregateType<T>>

    /**
     * Group by Course.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseGroupByArgs['orderBy'] }
        : { orderBy?: CourseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Course model
   */
  readonly fields: CourseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Course.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    teacher<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    topics<T extends Course$topicsArgs<ExtArgs> = {}>(args?: Subset<T, Course$topicsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findMany"> | Null>
    enrollments<T extends Course$enrollmentsArgs<ExtArgs> = {}>(args?: Subset<T, Course$enrollmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findMany"> | Null>
    savedBy<T extends Course$savedByArgs<ExtArgs> = {}>(args?: Subset<T, Course$savedByArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SavedCoursePayload<ExtArgs>, T, "findMany"> | Null>
    likedBy<T extends Course$likedByArgs<ExtArgs> = {}>(args?: Subset<T, Course$likedByArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LikedCoursePayload<ExtArgs>, T, "findMany"> | Null>
    reviews<T extends Course$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, Course$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseReviewPayload<ExtArgs>, T, "findMany"> | Null>
    lessons<T extends Course$lessonsArgs<ExtArgs> = {}>(args?: Subset<T, Course$lessonsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findMany"> | Null>
    quizAttempts<T extends Course$quizAttemptsArgs<ExtArgs> = {}>(args?: Subset<T, Course$quizAttemptsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizAttemptPayload<ExtArgs>, T, "findMany"> | Null>
    certificates<T extends Course$certificatesArgs<ExtArgs> = {}>(args?: Subset<T, Course$certificatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findMany"> | Null>
    bundleCourses<T extends Course$bundleCoursesArgs<ExtArgs> = {}>(args?: Subset<T, Course$bundleCoursesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BundleCoursePayload<ExtArgs>, T, "findMany"> | Null>
    calendarEvents<T extends Course$calendarEventsArgs<ExtArgs> = {}>(args?: Subset<T, Course$calendarEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Course model
   */ 
  interface CourseFieldRefs {
    readonly id: FieldRef<"Course", 'String'>
    readonly title: FieldRef<"Course", 'String'>
    readonly description: FieldRef<"Course", 'String'>
    readonly subject: FieldRef<"Course", 'String'>
    readonly image: FieldRef<"Course", 'String'>
    readonly price: FieldRef<"Course", 'Decimal'>
    readonly pointsPrice: FieldRef<"Course", 'Int'>
    readonly teacherId: FieldRef<"Course", 'String'>
    readonly students: FieldRef<"Course", 'Int'>
    readonly rating: FieldRef<"Course", 'Decimal'>
    readonly status: FieldRef<"Course", 'CourseStatus'>
    readonly featured: FieldRef<"Course", 'Boolean'>
    readonly createdAt: FieldRef<"Course", 'DateTime'>
    readonly updatedAt: FieldRef<"Course", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Course findUnique
   */
  export type CourseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course findUniqueOrThrow
   */
  export type CourseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course findFirst
   */
  export type CourseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Courses.
     */
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course findFirstOrThrow
   */
  export type CourseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Courses.
     */
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course findMany
   */
  export type CourseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Courses to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course create
   */
  export type CourseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The data needed to create a Course.
     */
    data: XOR<CourseCreateInput, CourseUncheckedCreateInput>
  }

  /**
   * Course createMany
   */
  export type CourseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Courses.
     */
    data: CourseCreateManyInput | CourseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Course createManyAndReturn
   */
  export type CourseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Courses.
     */
    data: CourseCreateManyInput | CourseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Course update
   */
  export type CourseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The data needed to update a Course.
     */
    data: XOR<CourseUpdateInput, CourseUncheckedUpdateInput>
    /**
     * Choose, which Course to update.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course updateMany
   */
  export type CourseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Courses.
     */
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyInput>
    /**
     * Filter which Courses to update
     */
    where?: CourseWhereInput
  }

  /**
   * Course upsert
   */
  export type CourseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The filter to search for the Course to update in case it exists.
     */
    where: CourseWhereUniqueInput
    /**
     * In case the Course found by the `where` argument doesn't exist, create a new Course with this data.
     */
    create: XOR<CourseCreateInput, CourseUncheckedCreateInput>
    /**
     * In case the Course was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourseUpdateInput, CourseUncheckedUpdateInput>
  }

  /**
   * Course delete
   */
  export type CourseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter which Course to delete.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course deleteMany
   */
  export type CourseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Courses to delete
     */
    where?: CourseWhereInput
  }

  /**
   * Course.topics
   */
  export type Course$topicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    where?: TopicWhereInput
    orderBy?: TopicOrderByWithRelationInput | TopicOrderByWithRelationInput[]
    cursor?: TopicWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TopicScalarFieldEnum | TopicScalarFieldEnum[]
  }

  /**
   * Course.enrollments
   */
  export type Course$enrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    where?: EnrollmentWhereInput
    orderBy?: EnrollmentOrderByWithRelationInput | EnrollmentOrderByWithRelationInput[]
    cursor?: EnrollmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EnrollmentScalarFieldEnum | EnrollmentScalarFieldEnum[]
  }

  /**
   * Course.savedBy
   */
  export type Course$savedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedCourse
     */
    select?: SavedCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedCourseInclude<ExtArgs> | null
    where?: SavedCourseWhereInput
    orderBy?: SavedCourseOrderByWithRelationInput | SavedCourseOrderByWithRelationInput[]
    cursor?: SavedCourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SavedCourseScalarFieldEnum | SavedCourseScalarFieldEnum[]
  }

  /**
   * Course.likedBy
   */
  export type Course$likedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikedCourse
     */
    select?: LikedCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikedCourseInclude<ExtArgs> | null
    where?: LikedCourseWhereInput
    orderBy?: LikedCourseOrderByWithRelationInput | LikedCourseOrderByWithRelationInput[]
    cursor?: LikedCourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LikedCourseScalarFieldEnum | LikedCourseScalarFieldEnum[]
  }

  /**
   * Course.reviews
   */
  export type Course$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseReview
     */
    select?: CourseReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseReviewInclude<ExtArgs> | null
    where?: CourseReviewWhereInput
    orderBy?: CourseReviewOrderByWithRelationInput | CourseReviewOrderByWithRelationInput[]
    cursor?: CourseReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseReviewScalarFieldEnum | CourseReviewScalarFieldEnum[]
  }

  /**
   * Course.lessons
   */
  export type Course$lessonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    where?: LessonWhereInput
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    cursor?: LessonWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LessonScalarFieldEnum | LessonScalarFieldEnum[]
  }

  /**
   * Course.quizAttempts
   */
  export type Course$quizAttemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptInclude<ExtArgs> | null
    where?: QuizAttemptWhereInput
    orderBy?: QuizAttemptOrderByWithRelationInput | QuizAttemptOrderByWithRelationInput[]
    cursor?: QuizAttemptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuizAttemptScalarFieldEnum | QuizAttemptScalarFieldEnum[]
  }

  /**
   * Course.certificates
   */
  export type Course$certificatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    where?: CertificateWhereInput
    orderBy?: CertificateOrderByWithRelationInput | CertificateOrderByWithRelationInput[]
    cursor?: CertificateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CertificateScalarFieldEnum | CertificateScalarFieldEnum[]
  }

  /**
   * Course.bundleCourses
   */
  export type Course$bundleCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BundleCourse
     */
    select?: BundleCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BundleCourseInclude<ExtArgs> | null
    where?: BundleCourseWhereInput
    orderBy?: BundleCourseOrderByWithRelationInput | BundleCourseOrderByWithRelationInput[]
    cursor?: BundleCourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BundleCourseScalarFieldEnum | BundleCourseScalarFieldEnum[]
  }

  /**
   * Course.calendarEvents
   */
  export type Course$calendarEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventInclude<ExtArgs> | null
    where?: CalendarEventWhereInput
    orderBy?: CalendarEventOrderByWithRelationInput | CalendarEventOrderByWithRelationInput[]
    cursor?: CalendarEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CalendarEventScalarFieldEnum | CalendarEventScalarFieldEnum[]
  }

  /**
   * Course without action
   */
  export type CourseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
  }


  /**
   * Model Topic
   */

  export type AggregateTopic = {
    _count: TopicCountAggregateOutputType | null
    _avg: TopicAvgAggregateOutputType | null
    _sum: TopicSumAggregateOutputType | null
    _min: TopicMinAggregateOutputType | null
    _max: TopicMaxAggregateOutputType | null
  }

  export type TopicAvgAggregateOutputType = {
    orderIndex: number | null
  }

  export type TopicSumAggregateOutputType = {
    orderIndex: number | null
  }

  export type TopicMinAggregateOutputType = {
    id: string | null
    courseId: string | null
    title: string | null
    description: string | null
    orderIndex: number | null
  }

  export type TopicMaxAggregateOutputType = {
    id: string | null
    courseId: string | null
    title: string | null
    description: string | null
    orderIndex: number | null
  }

  export type TopicCountAggregateOutputType = {
    id: number
    courseId: number
    title: number
    description: number
    orderIndex: number
    _all: number
  }


  export type TopicAvgAggregateInputType = {
    orderIndex?: true
  }

  export type TopicSumAggregateInputType = {
    orderIndex?: true
  }

  export type TopicMinAggregateInputType = {
    id?: true
    courseId?: true
    title?: true
    description?: true
    orderIndex?: true
  }

  export type TopicMaxAggregateInputType = {
    id?: true
    courseId?: true
    title?: true
    description?: true
    orderIndex?: true
  }

  export type TopicCountAggregateInputType = {
    id?: true
    courseId?: true
    title?: true
    description?: true
    orderIndex?: true
    _all?: true
  }

  export type TopicAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Topic to aggregate.
     */
    where?: TopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Topics to fetch.
     */
    orderBy?: TopicOrderByWithRelationInput | TopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Topics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Topics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Topics
    **/
    _count?: true | TopicCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TopicAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TopicSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TopicMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TopicMaxAggregateInputType
  }

  export type GetTopicAggregateType<T extends TopicAggregateArgs> = {
        [P in keyof T & keyof AggregateTopic]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTopic[P]>
      : GetScalarType<T[P], AggregateTopic[P]>
  }




  export type TopicGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TopicWhereInput
    orderBy?: TopicOrderByWithAggregationInput | TopicOrderByWithAggregationInput[]
    by: TopicScalarFieldEnum[] | TopicScalarFieldEnum
    having?: TopicScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TopicCountAggregateInputType | true
    _avg?: TopicAvgAggregateInputType
    _sum?: TopicSumAggregateInputType
    _min?: TopicMinAggregateInputType
    _max?: TopicMaxAggregateInputType
  }

  export type TopicGroupByOutputType = {
    id: string
    courseId: string
    title: string
    description: string | null
    orderIndex: number
    _count: TopicCountAggregateOutputType | null
    _avg: TopicAvgAggregateOutputType | null
    _sum: TopicSumAggregateOutputType | null
    _min: TopicMinAggregateOutputType | null
    _max: TopicMaxAggregateOutputType | null
  }

  type GetTopicGroupByPayload<T extends TopicGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TopicGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TopicGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TopicGroupByOutputType[P]>
            : GetScalarType<T[P], TopicGroupByOutputType[P]>
        }
      >
    >


  export type TopicSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    title?: boolean
    description?: boolean
    orderIndex?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
    lessons?: boolean | Topic$lessonsArgs<ExtArgs>
    _count?: boolean | TopicCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["topic"]>

  export type TopicSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    title?: boolean
    description?: boolean
    orderIndex?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["topic"]>

  export type TopicSelectScalar = {
    id?: boolean
    courseId?: boolean
    title?: boolean
    description?: boolean
    orderIndex?: boolean
  }

  export type TopicInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
    lessons?: boolean | Topic$lessonsArgs<ExtArgs>
    _count?: boolean | TopicCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TopicIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }

  export type $TopicPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Topic"
    objects: {
      course: Prisma.$CoursePayload<ExtArgs>
      lessons: Prisma.$LessonPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      courseId: string
      title: string
      description: string | null
      orderIndex: number
    }, ExtArgs["result"]["topic"]>
    composites: {}
  }

  type TopicGetPayload<S extends boolean | null | undefined | TopicDefaultArgs> = $Result.GetResult<Prisma.$TopicPayload, S>

  type TopicCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TopicFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TopicCountAggregateInputType | true
    }

  export interface TopicDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Topic'], meta: { name: 'Topic' } }
    /**
     * Find zero or one Topic that matches the filter.
     * @param {TopicFindUniqueArgs} args - Arguments to find a Topic
     * @example
     * // Get one Topic
     * const topic = await prisma.topic.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TopicFindUniqueArgs>(args: SelectSubset<T, TopicFindUniqueArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Topic that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TopicFindUniqueOrThrowArgs} args - Arguments to find a Topic
     * @example
     * // Get one Topic
     * const topic = await prisma.topic.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TopicFindUniqueOrThrowArgs>(args: SelectSubset<T, TopicFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Topic that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicFindFirstArgs} args - Arguments to find a Topic
     * @example
     * // Get one Topic
     * const topic = await prisma.topic.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TopicFindFirstArgs>(args?: SelectSubset<T, TopicFindFirstArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Topic that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicFindFirstOrThrowArgs} args - Arguments to find a Topic
     * @example
     * // Get one Topic
     * const topic = await prisma.topic.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TopicFindFirstOrThrowArgs>(args?: SelectSubset<T, TopicFindFirstOrThrowArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Topics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Topics
     * const topics = await prisma.topic.findMany()
     * 
     * // Get first 10 Topics
     * const topics = await prisma.topic.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const topicWithIdOnly = await prisma.topic.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TopicFindManyArgs>(args?: SelectSubset<T, TopicFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Topic.
     * @param {TopicCreateArgs} args - Arguments to create a Topic.
     * @example
     * // Create one Topic
     * const Topic = await prisma.topic.create({
     *   data: {
     *     // ... data to create a Topic
     *   }
     * })
     * 
     */
    create<T extends TopicCreateArgs>(args: SelectSubset<T, TopicCreateArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Topics.
     * @param {TopicCreateManyArgs} args - Arguments to create many Topics.
     * @example
     * // Create many Topics
     * const topic = await prisma.topic.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TopicCreateManyArgs>(args?: SelectSubset<T, TopicCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Topics and returns the data saved in the database.
     * @param {TopicCreateManyAndReturnArgs} args - Arguments to create many Topics.
     * @example
     * // Create many Topics
     * const topic = await prisma.topic.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Topics and only return the `id`
     * const topicWithIdOnly = await prisma.topic.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TopicCreateManyAndReturnArgs>(args?: SelectSubset<T, TopicCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Topic.
     * @param {TopicDeleteArgs} args - Arguments to delete one Topic.
     * @example
     * // Delete one Topic
     * const Topic = await prisma.topic.delete({
     *   where: {
     *     // ... filter to delete one Topic
     *   }
     * })
     * 
     */
    delete<T extends TopicDeleteArgs>(args: SelectSubset<T, TopicDeleteArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Topic.
     * @param {TopicUpdateArgs} args - Arguments to update one Topic.
     * @example
     * // Update one Topic
     * const topic = await prisma.topic.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TopicUpdateArgs>(args: SelectSubset<T, TopicUpdateArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Topics.
     * @param {TopicDeleteManyArgs} args - Arguments to filter Topics to delete.
     * @example
     * // Delete a few Topics
     * const { count } = await prisma.topic.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TopicDeleteManyArgs>(args?: SelectSubset<T, TopicDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Topics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Topics
     * const topic = await prisma.topic.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TopicUpdateManyArgs>(args: SelectSubset<T, TopicUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Topic.
     * @param {TopicUpsertArgs} args - Arguments to update or create a Topic.
     * @example
     * // Update or create a Topic
     * const topic = await prisma.topic.upsert({
     *   create: {
     *     // ... data to create a Topic
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Topic we want to update
     *   }
     * })
     */
    upsert<T extends TopicUpsertArgs>(args: SelectSubset<T, TopicUpsertArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Topics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicCountArgs} args - Arguments to filter Topics to count.
     * @example
     * // Count the number of Topics
     * const count = await prisma.topic.count({
     *   where: {
     *     // ... the filter for the Topics we want to count
     *   }
     * })
    **/
    count<T extends TopicCountArgs>(
      args?: Subset<T, TopicCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TopicCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Topic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TopicAggregateArgs>(args: Subset<T, TopicAggregateArgs>): Prisma.PrismaPromise<GetTopicAggregateType<T>>

    /**
     * Group by Topic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TopicGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TopicGroupByArgs['orderBy'] }
        : { orderBy?: TopicGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TopicGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTopicGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Topic model
   */
  readonly fields: TopicFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Topic.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TopicClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    lessons<T extends Topic$lessonsArgs<ExtArgs> = {}>(args?: Subset<T, Topic$lessonsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Topic model
   */ 
  interface TopicFieldRefs {
    readonly id: FieldRef<"Topic", 'String'>
    readonly courseId: FieldRef<"Topic", 'String'>
    readonly title: FieldRef<"Topic", 'String'>
    readonly description: FieldRef<"Topic", 'String'>
    readonly orderIndex: FieldRef<"Topic", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Topic findUnique
   */
  export type TopicFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * Filter, which Topic to fetch.
     */
    where: TopicWhereUniqueInput
  }

  /**
   * Topic findUniqueOrThrow
   */
  export type TopicFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * Filter, which Topic to fetch.
     */
    where: TopicWhereUniqueInput
  }

  /**
   * Topic findFirst
   */
  export type TopicFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * Filter, which Topic to fetch.
     */
    where?: TopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Topics to fetch.
     */
    orderBy?: TopicOrderByWithRelationInput | TopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Topics.
     */
    cursor?: TopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Topics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Topics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Topics.
     */
    distinct?: TopicScalarFieldEnum | TopicScalarFieldEnum[]
  }

  /**
   * Topic findFirstOrThrow
   */
  export type TopicFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * Filter, which Topic to fetch.
     */
    where?: TopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Topics to fetch.
     */
    orderBy?: TopicOrderByWithRelationInput | TopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Topics.
     */
    cursor?: TopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Topics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Topics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Topics.
     */
    distinct?: TopicScalarFieldEnum | TopicScalarFieldEnum[]
  }

  /**
   * Topic findMany
   */
  export type TopicFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * Filter, which Topics to fetch.
     */
    where?: TopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Topics to fetch.
     */
    orderBy?: TopicOrderByWithRelationInput | TopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Topics.
     */
    cursor?: TopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Topics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Topics.
     */
    skip?: number
    distinct?: TopicScalarFieldEnum | TopicScalarFieldEnum[]
  }

  /**
   * Topic create
   */
  export type TopicCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * The data needed to create a Topic.
     */
    data: XOR<TopicCreateInput, TopicUncheckedCreateInput>
  }

  /**
   * Topic createMany
   */
  export type TopicCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Topics.
     */
    data: TopicCreateManyInput | TopicCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Topic createManyAndReturn
   */
  export type TopicCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Topics.
     */
    data: TopicCreateManyInput | TopicCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Topic update
   */
  export type TopicUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * The data needed to update a Topic.
     */
    data: XOR<TopicUpdateInput, TopicUncheckedUpdateInput>
    /**
     * Choose, which Topic to update.
     */
    where: TopicWhereUniqueInput
  }

  /**
   * Topic updateMany
   */
  export type TopicUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Topics.
     */
    data: XOR<TopicUpdateManyMutationInput, TopicUncheckedUpdateManyInput>
    /**
     * Filter which Topics to update
     */
    where?: TopicWhereInput
  }

  /**
   * Topic upsert
   */
  export type TopicUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * The filter to search for the Topic to update in case it exists.
     */
    where: TopicWhereUniqueInput
    /**
     * In case the Topic found by the `where` argument doesn't exist, create a new Topic with this data.
     */
    create: XOR<TopicCreateInput, TopicUncheckedCreateInput>
    /**
     * In case the Topic was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TopicUpdateInput, TopicUncheckedUpdateInput>
  }

  /**
   * Topic delete
   */
  export type TopicDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * Filter which Topic to delete.
     */
    where: TopicWhereUniqueInput
  }

  /**
   * Topic deleteMany
   */
  export type TopicDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Topics to delete
     */
    where?: TopicWhereInput
  }

  /**
   * Topic.lessons
   */
  export type Topic$lessonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    where?: LessonWhereInput
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    cursor?: LessonWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LessonScalarFieldEnum | LessonScalarFieldEnum[]
  }

  /**
   * Topic without action
   */
  export type TopicDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
  }


  /**
   * Model Lesson
   */

  export type AggregateLesson = {
    _count: LessonCountAggregateOutputType | null
    _avg: LessonAvgAggregateOutputType | null
    _sum: LessonSumAggregateOutputType | null
    _min: LessonMinAggregateOutputType | null
    _max: LessonMaxAggregateOutputType | null
  }

  export type LessonAvgAggregateOutputType = {
    duration: number | null
    orderIndex: number | null
  }

  export type LessonSumAggregateOutputType = {
    duration: number | null
    orderIndex: number | null
  }

  export type LessonMinAggregateOutputType = {
    id: string | null
    topicId: string | null
    title: string | null
    description: string | null
    videoUrl: string | null
    content: string | null
    duration: number | null
    orderIndex: number | null
    type: $Enums.LessonType | null
    courseId: string | null
  }

  export type LessonMaxAggregateOutputType = {
    id: string | null
    topicId: string | null
    title: string | null
    description: string | null
    videoUrl: string | null
    content: string | null
    duration: number | null
    orderIndex: number | null
    type: $Enums.LessonType | null
    courseId: string | null
  }

  export type LessonCountAggregateOutputType = {
    id: number
    topicId: number
    title: number
    description: number
    videoUrl: number
    content: number
    duration: number
    orderIndex: number
    type: number
    courseId: number
    _all: number
  }


  export type LessonAvgAggregateInputType = {
    duration?: true
    orderIndex?: true
  }

  export type LessonSumAggregateInputType = {
    duration?: true
    orderIndex?: true
  }

  export type LessonMinAggregateInputType = {
    id?: true
    topicId?: true
    title?: true
    description?: true
    videoUrl?: true
    content?: true
    duration?: true
    orderIndex?: true
    type?: true
    courseId?: true
  }

  export type LessonMaxAggregateInputType = {
    id?: true
    topicId?: true
    title?: true
    description?: true
    videoUrl?: true
    content?: true
    duration?: true
    orderIndex?: true
    type?: true
    courseId?: true
  }

  export type LessonCountAggregateInputType = {
    id?: true
    topicId?: true
    title?: true
    description?: true
    videoUrl?: true
    content?: true
    duration?: true
    orderIndex?: true
    type?: true
    courseId?: true
    _all?: true
  }

  export type LessonAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lesson to aggregate.
     */
    where?: LessonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lessons to fetch.
     */
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LessonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lessons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Lessons
    **/
    _count?: true | LessonCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LessonAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LessonSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LessonMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LessonMaxAggregateInputType
  }

  export type GetLessonAggregateType<T extends LessonAggregateArgs> = {
        [P in keyof T & keyof AggregateLesson]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLesson[P]>
      : GetScalarType<T[P], AggregateLesson[P]>
  }




  export type LessonGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonWhereInput
    orderBy?: LessonOrderByWithAggregationInput | LessonOrderByWithAggregationInput[]
    by: LessonScalarFieldEnum[] | LessonScalarFieldEnum
    having?: LessonScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LessonCountAggregateInputType | true
    _avg?: LessonAvgAggregateInputType
    _sum?: LessonSumAggregateInputType
    _min?: LessonMinAggregateInputType
    _max?: LessonMaxAggregateInputType
  }

  export type LessonGroupByOutputType = {
    id: string
    topicId: string
    title: string
    description: string | null
    videoUrl: string | null
    content: string | null
    duration: number | null
    orderIndex: number
    type: $Enums.LessonType
    courseId: string | null
    _count: LessonCountAggregateOutputType | null
    _avg: LessonAvgAggregateOutputType | null
    _sum: LessonSumAggregateOutputType | null
    _min: LessonMinAggregateOutputType | null
    _max: LessonMaxAggregateOutputType | null
  }

  type GetLessonGroupByPayload<T extends LessonGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LessonGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LessonGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LessonGroupByOutputType[P]>
            : GetScalarType<T[P], LessonGroupByOutputType[P]>
        }
      >
    >


  export type LessonSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    topicId?: boolean
    title?: boolean
    description?: boolean
    videoUrl?: boolean
    content?: boolean
    duration?: boolean
    orderIndex?: boolean
    type?: boolean
    courseId?: boolean
    topic?: boolean | TopicDefaultArgs<ExtArgs>
    quiz?: boolean | Lesson$quizArgs<ExtArgs>
    assignment?: boolean | Lesson$assignmentArgs<ExtArgs>
    progress?: boolean | Lesson$progressArgs<ExtArgs>
    calendarEvents?: boolean | Lesson$calendarEventsArgs<ExtArgs>
    course?: boolean | Lesson$courseArgs<ExtArgs>
    _count?: boolean | LessonCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lesson"]>

  export type LessonSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    topicId?: boolean
    title?: boolean
    description?: boolean
    videoUrl?: boolean
    content?: boolean
    duration?: boolean
    orderIndex?: boolean
    type?: boolean
    courseId?: boolean
    topic?: boolean | TopicDefaultArgs<ExtArgs>
    course?: boolean | Lesson$courseArgs<ExtArgs>
  }, ExtArgs["result"]["lesson"]>

  export type LessonSelectScalar = {
    id?: boolean
    topicId?: boolean
    title?: boolean
    description?: boolean
    videoUrl?: boolean
    content?: boolean
    duration?: boolean
    orderIndex?: boolean
    type?: boolean
    courseId?: boolean
  }

  export type LessonInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    topic?: boolean | TopicDefaultArgs<ExtArgs>
    quiz?: boolean | Lesson$quizArgs<ExtArgs>
    assignment?: boolean | Lesson$assignmentArgs<ExtArgs>
    progress?: boolean | Lesson$progressArgs<ExtArgs>
    calendarEvents?: boolean | Lesson$calendarEventsArgs<ExtArgs>
    course?: boolean | Lesson$courseArgs<ExtArgs>
    _count?: boolean | LessonCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LessonIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    topic?: boolean | TopicDefaultArgs<ExtArgs>
    course?: boolean | Lesson$courseArgs<ExtArgs>
  }

  export type $LessonPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Lesson"
    objects: {
      topic: Prisma.$TopicPayload<ExtArgs>
      quiz: Prisma.$QuizPayload<ExtArgs> | null
      assignment: Prisma.$AssignmentPayload<ExtArgs> | null
      progress: Prisma.$LessonProgressPayload<ExtArgs>[]
      calendarEvents: Prisma.$CalendarEventPayload<ExtArgs>[]
      course: Prisma.$CoursePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      topicId: string
      title: string
      description: string | null
      videoUrl: string | null
      content: string | null
      duration: number | null
      orderIndex: number
      type: $Enums.LessonType
      courseId: string | null
    }, ExtArgs["result"]["lesson"]>
    composites: {}
  }

  type LessonGetPayload<S extends boolean | null | undefined | LessonDefaultArgs> = $Result.GetResult<Prisma.$LessonPayload, S>

  type LessonCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LessonFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LessonCountAggregateInputType | true
    }

  export interface LessonDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Lesson'], meta: { name: 'Lesson' } }
    /**
     * Find zero or one Lesson that matches the filter.
     * @param {LessonFindUniqueArgs} args - Arguments to find a Lesson
     * @example
     * // Get one Lesson
     * const lesson = await prisma.lesson.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LessonFindUniqueArgs>(args: SelectSubset<T, LessonFindUniqueArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Lesson that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LessonFindUniqueOrThrowArgs} args - Arguments to find a Lesson
     * @example
     * // Get one Lesson
     * const lesson = await prisma.lesson.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LessonFindUniqueOrThrowArgs>(args: SelectSubset<T, LessonFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Lesson that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonFindFirstArgs} args - Arguments to find a Lesson
     * @example
     * // Get one Lesson
     * const lesson = await prisma.lesson.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LessonFindFirstArgs>(args?: SelectSubset<T, LessonFindFirstArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Lesson that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonFindFirstOrThrowArgs} args - Arguments to find a Lesson
     * @example
     * // Get one Lesson
     * const lesson = await prisma.lesson.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LessonFindFirstOrThrowArgs>(args?: SelectSubset<T, LessonFindFirstOrThrowArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Lessons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lessons
     * const lessons = await prisma.lesson.findMany()
     * 
     * // Get first 10 Lessons
     * const lessons = await prisma.lesson.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lessonWithIdOnly = await prisma.lesson.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LessonFindManyArgs>(args?: SelectSubset<T, LessonFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Lesson.
     * @param {LessonCreateArgs} args - Arguments to create a Lesson.
     * @example
     * // Create one Lesson
     * const Lesson = await prisma.lesson.create({
     *   data: {
     *     // ... data to create a Lesson
     *   }
     * })
     * 
     */
    create<T extends LessonCreateArgs>(args: SelectSubset<T, LessonCreateArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Lessons.
     * @param {LessonCreateManyArgs} args - Arguments to create many Lessons.
     * @example
     * // Create many Lessons
     * const lesson = await prisma.lesson.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LessonCreateManyArgs>(args?: SelectSubset<T, LessonCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Lessons and returns the data saved in the database.
     * @param {LessonCreateManyAndReturnArgs} args - Arguments to create many Lessons.
     * @example
     * // Create many Lessons
     * const lesson = await prisma.lesson.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Lessons and only return the `id`
     * const lessonWithIdOnly = await prisma.lesson.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LessonCreateManyAndReturnArgs>(args?: SelectSubset<T, LessonCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Lesson.
     * @param {LessonDeleteArgs} args - Arguments to delete one Lesson.
     * @example
     * // Delete one Lesson
     * const Lesson = await prisma.lesson.delete({
     *   where: {
     *     // ... filter to delete one Lesson
     *   }
     * })
     * 
     */
    delete<T extends LessonDeleteArgs>(args: SelectSubset<T, LessonDeleteArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Lesson.
     * @param {LessonUpdateArgs} args - Arguments to update one Lesson.
     * @example
     * // Update one Lesson
     * const lesson = await prisma.lesson.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LessonUpdateArgs>(args: SelectSubset<T, LessonUpdateArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Lessons.
     * @param {LessonDeleteManyArgs} args - Arguments to filter Lessons to delete.
     * @example
     * // Delete a few Lessons
     * const { count } = await prisma.lesson.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LessonDeleteManyArgs>(args?: SelectSubset<T, LessonDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lessons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lessons
     * const lesson = await prisma.lesson.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LessonUpdateManyArgs>(args: SelectSubset<T, LessonUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Lesson.
     * @param {LessonUpsertArgs} args - Arguments to update or create a Lesson.
     * @example
     * // Update or create a Lesson
     * const lesson = await prisma.lesson.upsert({
     *   create: {
     *     // ... data to create a Lesson
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lesson we want to update
     *   }
     * })
     */
    upsert<T extends LessonUpsertArgs>(args: SelectSubset<T, LessonUpsertArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Lessons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonCountArgs} args - Arguments to filter Lessons to count.
     * @example
     * // Count the number of Lessons
     * const count = await prisma.lesson.count({
     *   where: {
     *     // ... the filter for the Lessons we want to count
     *   }
     * })
    **/
    count<T extends LessonCountArgs>(
      args?: Subset<T, LessonCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LessonCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lesson.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LessonAggregateArgs>(args: Subset<T, LessonAggregateArgs>): Prisma.PrismaPromise<GetLessonAggregateType<T>>

    /**
     * Group by Lesson.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LessonGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LessonGroupByArgs['orderBy'] }
        : { orderBy?: LessonGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LessonGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLessonGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Lesson model
   */
  readonly fields: LessonFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Lesson.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LessonClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    topic<T extends TopicDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TopicDefaultArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    quiz<T extends Lesson$quizArgs<ExtArgs> = {}>(args?: Subset<T, Lesson$quizArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    assignment<T extends Lesson$assignmentArgs<ExtArgs> = {}>(args?: Subset<T, Lesson$assignmentArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    progress<T extends Lesson$progressArgs<ExtArgs> = {}>(args?: Subset<T, Lesson$progressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonProgressPayload<ExtArgs>, T, "findMany"> | Null>
    calendarEvents<T extends Lesson$calendarEventsArgs<ExtArgs> = {}>(args?: Subset<T, Lesson$calendarEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "findMany"> | Null>
    course<T extends Lesson$courseArgs<ExtArgs> = {}>(args?: Subset<T, Lesson$courseArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Lesson model
   */ 
  interface LessonFieldRefs {
    readonly id: FieldRef<"Lesson", 'String'>
    readonly topicId: FieldRef<"Lesson", 'String'>
    readonly title: FieldRef<"Lesson", 'String'>
    readonly description: FieldRef<"Lesson", 'String'>
    readonly videoUrl: FieldRef<"Lesson", 'String'>
    readonly content: FieldRef<"Lesson", 'String'>
    readonly duration: FieldRef<"Lesson", 'Int'>
    readonly orderIndex: FieldRef<"Lesson", 'Int'>
    readonly type: FieldRef<"Lesson", 'LessonType'>
    readonly courseId: FieldRef<"Lesson", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Lesson findUnique
   */
  export type LessonFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter, which Lesson to fetch.
     */
    where: LessonWhereUniqueInput
  }

  /**
   * Lesson findUniqueOrThrow
   */
  export type LessonFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter, which Lesson to fetch.
     */
    where: LessonWhereUniqueInput
  }

  /**
   * Lesson findFirst
   */
  export type LessonFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter, which Lesson to fetch.
     */
    where?: LessonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lessons to fetch.
     */
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lessons.
     */
    cursor?: LessonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lessons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lessons.
     */
    distinct?: LessonScalarFieldEnum | LessonScalarFieldEnum[]
  }

  /**
   * Lesson findFirstOrThrow
   */
  export type LessonFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter, which Lesson to fetch.
     */
    where?: LessonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lessons to fetch.
     */
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lessons.
     */
    cursor?: LessonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lessons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lessons.
     */
    distinct?: LessonScalarFieldEnum | LessonScalarFieldEnum[]
  }

  /**
   * Lesson findMany
   */
  export type LessonFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter, which Lessons to fetch.
     */
    where?: LessonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lessons to fetch.
     */
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Lessons.
     */
    cursor?: LessonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lessons.
     */
    skip?: number
    distinct?: LessonScalarFieldEnum | LessonScalarFieldEnum[]
  }

  /**
   * Lesson create
   */
  export type LessonCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * The data needed to create a Lesson.
     */
    data: XOR<LessonCreateInput, LessonUncheckedCreateInput>
  }

  /**
   * Lesson createMany
   */
  export type LessonCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Lessons.
     */
    data: LessonCreateManyInput | LessonCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Lesson createManyAndReturn
   */
  export type LessonCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Lessons.
     */
    data: LessonCreateManyInput | LessonCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lesson update
   */
  export type LessonUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * The data needed to update a Lesson.
     */
    data: XOR<LessonUpdateInput, LessonUncheckedUpdateInput>
    /**
     * Choose, which Lesson to update.
     */
    where: LessonWhereUniqueInput
  }

  /**
   * Lesson updateMany
   */
  export type LessonUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Lessons.
     */
    data: XOR<LessonUpdateManyMutationInput, LessonUncheckedUpdateManyInput>
    /**
     * Filter which Lessons to update
     */
    where?: LessonWhereInput
  }

  /**
   * Lesson upsert
   */
  export type LessonUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * The filter to search for the Lesson to update in case it exists.
     */
    where: LessonWhereUniqueInput
    /**
     * In case the Lesson found by the `where` argument doesn't exist, create a new Lesson with this data.
     */
    create: XOR<LessonCreateInput, LessonUncheckedCreateInput>
    /**
     * In case the Lesson was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LessonUpdateInput, LessonUncheckedUpdateInput>
  }

  /**
   * Lesson delete
   */
  export type LessonDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter which Lesson to delete.
     */
    where: LessonWhereUniqueInput
  }

  /**
   * Lesson deleteMany
   */
  export type LessonDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lessons to delete
     */
    where?: LessonWhereInput
  }

  /**
   * Lesson.quiz
   */
  export type Lesson$quizArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    where?: QuizWhereInput
  }

  /**
   * Lesson.assignment
   */
  export type Lesson$assignmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    where?: AssignmentWhereInput
  }

  /**
   * Lesson.progress
   */
  export type Lesson$progressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonProgress
     */
    select?: LessonProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonProgressInclude<ExtArgs> | null
    where?: LessonProgressWhereInput
    orderBy?: LessonProgressOrderByWithRelationInput | LessonProgressOrderByWithRelationInput[]
    cursor?: LessonProgressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LessonProgressScalarFieldEnum | LessonProgressScalarFieldEnum[]
  }

  /**
   * Lesson.calendarEvents
   */
  export type Lesson$calendarEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventInclude<ExtArgs> | null
    where?: CalendarEventWhereInput
    orderBy?: CalendarEventOrderByWithRelationInput | CalendarEventOrderByWithRelationInput[]
    cursor?: CalendarEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CalendarEventScalarFieldEnum | CalendarEventScalarFieldEnum[]
  }

  /**
   * Lesson.course
   */
  export type Lesson$courseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    where?: CourseWhereInput
  }

  /**
   * Lesson without action
   */
  export type LessonDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
  }


  /**
   * Model Quiz
   */

  export type AggregateQuiz = {
    _count: QuizCountAggregateOutputType | null
    _avg: QuizAvgAggregateOutputType | null
    _sum: QuizSumAggregateOutputType | null
    _min: QuizMinAggregateOutputType | null
    _max: QuizMaxAggregateOutputType | null
  }

  export type QuizAvgAggregateOutputType = {
    timeLimit: number | null
  }

  export type QuizSumAggregateOutputType = {
    timeLimit: number | null
  }

  export type QuizMinAggregateOutputType = {
    id: string | null
    lessonId: string | null
    title: string | null
    description: string | null
    timeLimit: number | null
  }

  export type QuizMaxAggregateOutputType = {
    id: string | null
    lessonId: string | null
    title: string | null
    description: string | null
    timeLimit: number | null
  }

  export type QuizCountAggregateOutputType = {
    id: number
    lessonId: number
    title: number
    description: number
    timeLimit: number
    _all: number
  }


  export type QuizAvgAggregateInputType = {
    timeLimit?: true
  }

  export type QuizSumAggregateInputType = {
    timeLimit?: true
  }

  export type QuizMinAggregateInputType = {
    id?: true
    lessonId?: true
    title?: true
    description?: true
    timeLimit?: true
  }

  export type QuizMaxAggregateInputType = {
    id?: true
    lessonId?: true
    title?: true
    description?: true
    timeLimit?: true
  }

  export type QuizCountAggregateInputType = {
    id?: true
    lessonId?: true
    title?: true
    description?: true
    timeLimit?: true
    _all?: true
  }

  export type QuizAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Quiz to aggregate.
     */
    where?: QuizWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quizzes to fetch.
     */
    orderBy?: QuizOrderByWithRelationInput | QuizOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuizWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quizzes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quizzes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Quizzes
    **/
    _count?: true | QuizCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuizAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuizSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuizMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuizMaxAggregateInputType
  }

  export type GetQuizAggregateType<T extends QuizAggregateArgs> = {
        [P in keyof T & keyof AggregateQuiz]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuiz[P]>
      : GetScalarType<T[P], AggregateQuiz[P]>
  }




  export type QuizGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizWhereInput
    orderBy?: QuizOrderByWithAggregationInput | QuizOrderByWithAggregationInput[]
    by: QuizScalarFieldEnum[] | QuizScalarFieldEnum
    having?: QuizScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuizCountAggregateInputType | true
    _avg?: QuizAvgAggregateInputType
    _sum?: QuizSumAggregateInputType
    _min?: QuizMinAggregateInputType
    _max?: QuizMaxAggregateInputType
  }

  export type QuizGroupByOutputType = {
    id: string
    lessonId: string
    title: string
    description: string | null
    timeLimit: number | null
    _count: QuizCountAggregateOutputType | null
    _avg: QuizAvgAggregateOutputType | null
    _sum: QuizSumAggregateOutputType | null
    _min: QuizMinAggregateOutputType | null
    _max: QuizMaxAggregateOutputType | null
  }

  type GetQuizGroupByPayload<T extends QuizGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuizGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuizGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuizGroupByOutputType[P]>
            : GetScalarType<T[P], QuizGroupByOutputType[P]>
        }
      >
    >


  export type QuizSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lessonId?: boolean
    title?: boolean
    description?: boolean
    timeLimit?: boolean
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
    questions?: boolean | Quiz$questionsArgs<ExtArgs>
    attempts?: boolean | Quiz$attemptsArgs<ExtArgs>
    _count?: boolean | QuizCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quiz"]>

  export type QuizSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lessonId?: boolean
    title?: boolean
    description?: boolean
    timeLimit?: boolean
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quiz"]>

  export type QuizSelectScalar = {
    id?: boolean
    lessonId?: boolean
    title?: boolean
    description?: boolean
    timeLimit?: boolean
  }

  export type QuizInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
    questions?: boolean | Quiz$questionsArgs<ExtArgs>
    attempts?: boolean | Quiz$attemptsArgs<ExtArgs>
    _count?: boolean | QuizCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type QuizIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
  }

  export type $QuizPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Quiz"
    objects: {
      lesson: Prisma.$LessonPayload<ExtArgs>
      questions: Prisma.$QuestionPayload<ExtArgs>[]
      attempts: Prisma.$QuizAttemptPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      lessonId: string
      title: string
      description: string | null
      timeLimit: number | null
    }, ExtArgs["result"]["quiz"]>
    composites: {}
  }

  type QuizGetPayload<S extends boolean | null | undefined | QuizDefaultArgs> = $Result.GetResult<Prisma.$QuizPayload, S>

  type QuizCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<QuizFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: QuizCountAggregateInputType | true
    }

  export interface QuizDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Quiz'], meta: { name: 'Quiz' } }
    /**
     * Find zero or one Quiz that matches the filter.
     * @param {QuizFindUniqueArgs} args - Arguments to find a Quiz
     * @example
     * // Get one Quiz
     * const quiz = await prisma.quiz.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuizFindUniqueArgs>(args: SelectSubset<T, QuizFindUniqueArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Quiz that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {QuizFindUniqueOrThrowArgs} args - Arguments to find a Quiz
     * @example
     * // Get one Quiz
     * const quiz = await prisma.quiz.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuizFindUniqueOrThrowArgs>(args: SelectSubset<T, QuizFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Quiz that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizFindFirstArgs} args - Arguments to find a Quiz
     * @example
     * // Get one Quiz
     * const quiz = await prisma.quiz.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuizFindFirstArgs>(args?: SelectSubset<T, QuizFindFirstArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Quiz that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizFindFirstOrThrowArgs} args - Arguments to find a Quiz
     * @example
     * // Get one Quiz
     * const quiz = await prisma.quiz.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuizFindFirstOrThrowArgs>(args?: SelectSubset<T, QuizFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Quizzes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Quizzes
     * const quizzes = await prisma.quiz.findMany()
     * 
     * // Get first 10 Quizzes
     * const quizzes = await prisma.quiz.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quizWithIdOnly = await prisma.quiz.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuizFindManyArgs>(args?: SelectSubset<T, QuizFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Quiz.
     * @param {QuizCreateArgs} args - Arguments to create a Quiz.
     * @example
     * // Create one Quiz
     * const Quiz = await prisma.quiz.create({
     *   data: {
     *     // ... data to create a Quiz
     *   }
     * })
     * 
     */
    create<T extends QuizCreateArgs>(args: SelectSubset<T, QuizCreateArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Quizzes.
     * @param {QuizCreateManyArgs} args - Arguments to create many Quizzes.
     * @example
     * // Create many Quizzes
     * const quiz = await prisma.quiz.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuizCreateManyArgs>(args?: SelectSubset<T, QuizCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Quizzes and returns the data saved in the database.
     * @param {QuizCreateManyAndReturnArgs} args - Arguments to create many Quizzes.
     * @example
     * // Create many Quizzes
     * const quiz = await prisma.quiz.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Quizzes and only return the `id`
     * const quizWithIdOnly = await prisma.quiz.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuizCreateManyAndReturnArgs>(args?: SelectSubset<T, QuizCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Quiz.
     * @param {QuizDeleteArgs} args - Arguments to delete one Quiz.
     * @example
     * // Delete one Quiz
     * const Quiz = await prisma.quiz.delete({
     *   where: {
     *     // ... filter to delete one Quiz
     *   }
     * })
     * 
     */
    delete<T extends QuizDeleteArgs>(args: SelectSubset<T, QuizDeleteArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Quiz.
     * @param {QuizUpdateArgs} args - Arguments to update one Quiz.
     * @example
     * // Update one Quiz
     * const quiz = await prisma.quiz.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuizUpdateArgs>(args: SelectSubset<T, QuizUpdateArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Quizzes.
     * @param {QuizDeleteManyArgs} args - Arguments to filter Quizzes to delete.
     * @example
     * // Delete a few Quizzes
     * const { count } = await prisma.quiz.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuizDeleteManyArgs>(args?: SelectSubset<T, QuizDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Quizzes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Quizzes
     * const quiz = await prisma.quiz.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuizUpdateManyArgs>(args: SelectSubset<T, QuizUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Quiz.
     * @param {QuizUpsertArgs} args - Arguments to update or create a Quiz.
     * @example
     * // Update or create a Quiz
     * const quiz = await prisma.quiz.upsert({
     *   create: {
     *     // ... data to create a Quiz
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Quiz we want to update
     *   }
     * })
     */
    upsert<T extends QuizUpsertArgs>(args: SelectSubset<T, QuizUpsertArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Quizzes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizCountArgs} args - Arguments to filter Quizzes to count.
     * @example
     * // Count the number of Quizzes
     * const count = await prisma.quiz.count({
     *   where: {
     *     // ... the filter for the Quizzes we want to count
     *   }
     * })
    **/
    count<T extends QuizCountArgs>(
      args?: Subset<T, QuizCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuizCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Quiz.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuizAggregateArgs>(args: Subset<T, QuizAggregateArgs>): Prisma.PrismaPromise<GetQuizAggregateType<T>>

    /**
     * Group by Quiz.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuizGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuizGroupByArgs['orderBy'] }
        : { orderBy?: QuizGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuizGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuizGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Quiz model
   */
  readonly fields: QuizFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Quiz.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuizClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lesson<T extends LessonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LessonDefaultArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    questions<T extends Quiz$questionsArgs<ExtArgs> = {}>(args?: Subset<T, Quiz$questionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findMany"> | Null>
    attempts<T extends Quiz$attemptsArgs<ExtArgs> = {}>(args?: Subset<T, Quiz$attemptsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizAttemptPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Quiz model
   */ 
  interface QuizFieldRefs {
    readonly id: FieldRef<"Quiz", 'String'>
    readonly lessonId: FieldRef<"Quiz", 'String'>
    readonly title: FieldRef<"Quiz", 'String'>
    readonly description: FieldRef<"Quiz", 'String'>
    readonly timeLimit: FieldRef<"Quiz", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Quiz findUnique
   */
  export type QuizFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * Filter, which Quiz to fetch.
     */
    where: QuizWhereUniqueInput
  }

  /**
   * Quiz findUniqueOrThrow
   */
  export type QuizFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * Filter, which Quiz to fetch.
     */
    where: QuizWhereUniqueInput
  }

  /**
   * Quiz findFirst
   */
  export type QuizFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * Filter, which Quiz to fetch.
     */
    where?: QuizWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quizzes to fetch.
     */
    orderBy?: QuizOrderByWithRelationInput | QuizOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Quizzes.
     */
    cursor?: QuizWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quizzes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quizzes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Quizzes.
     */
    distinct?: QuizScalarFieldEnum | QuizScalarFieldEnum[]
  }

  /**
   * Quiz findFirstOrThrow
   */
  export type QuizFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * Filter, which Quiz to fetch.
     */
    where?: QuizWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quizzes to fetch.
     */
    orderBy?: QuizOrderByWithRelationInput | QuizOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Quizzes.
     */
    cursor?: QuizWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quizzes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quizzes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Quizzes.
     */
    distinct?: QuizScalarFieldEnum | QuizScalarFieldEnum[]
  }

  /**
   * Quiz findMany
   */
  export type QuizFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * Filter, which Quizzes to fetch.
     */
    where?: QuizWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quizzes to fetch.
     */
    orderBy?: QuizOrderByWithRelationInput | QuizOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Quizzes.
     */
    cursor?: QuizWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quizzes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quizzes.
     */
    skip?: number
    distinct?: QuizScalarFieldEnum | QuizScalarFieldEnum[]
  }

  /**
   * Quiz create
   */
  export type QuizCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * The data needed to create a Quiz.
     */
    data: XOR<QuizCreateInput, QuizUncheckedCreateInput>
  }

  /**
   * Quiz createMany
   */
  export type QuizCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Quizzes.
     */
    data: QuizCreateManyInput | QuizCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Quiz createManyAndReturn
   */
  export type QuizCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Quizzes.
     */
    data: QuizCreateManyInput | QuizCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Quiz update
   */
  export type QuizUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * The data needed to update a Quiz.
     */
    data: XOR<QuizUpdateInput, QuizUncheckedUpdateInput>
    /**
     * Choose, which Quiz to update.
     */
    where: QuizWhereUniqueInput
  }

  /**
   * Quiz updateMany
   */
  export type QuizUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Quizzes.
     */
    data: XOR<QuizUpdateManyMutationInput, QuizUncheckedUpdateManyInput>
    /**
     * Filter which Quizzes to update
     */
    where?: QuizWhereInput
  }

  /**
   * Quiz upsert
   */
  export type QuizUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * The filter to search for the Quiz to update in case it exists.
     */
    where: QuizWhereUniqueInput
    /**
     * In case the Quiz found by the `where` argument doesn't exist, create a new Quiz with this data.
     */
    create: XOR<QuizCreateInput, QuizUncheckedCreateInput>
    /**
     * In case the Quiz was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuizUpdateInput, QuizUncheckedUpdateInput>
  }

  /**
   * Quiz delete
   */
  export type QuizDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * Filter which Quiz to delete.
     */
    where: QuizWhereUniqueInput
  }

  /**
   * Quiz deleteMany
   */
  export type QuizDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Quizzes to delete
     */
    where?: QuizWhereInput
  }

  /**
   * Quiz.questions
   */
  export type Quiz$questionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    where?: QuestionWhereInput
    orderBy?: QuestionOrderByWithRelationInput | QuestionOrderByWithRelationInput[]
    cursor?: QuestionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestionScalarFieldEnum | QuestionScalarFieldEnum[]
  }

  /**
   * Quiz.attempts
   */
  export type Quiz$attemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptInclude<ExtArgs> | null
    where?: QuizAttemptWhereInput
    orderBy?: QuizAttemptOrderByWithRelationInput | QuizAttemptOrderByWithRelationInput[]
    cursor?: QuizAttemptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuizAttemptScalarFieldEnum | QuizAttemptScalarFieldEnum[]
  }

  /**
   * Quiz without action
   */
  export type QuizDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
  }


  /**
   * Model Question
   */

  export type AggregateQuestion = {
    _count: QuestionCountAggregateOutputType | null
    _avg: QuestionAvgAggregateOutputType | null
    _sum: QuestionSumAggregateOutputType | null
    _min: QuestionMinAggregateOutputType | null
    _max: QuestionMaxAggregateOutputType | null
  }

  export type QuestionAvgAggregateOutputType = {
    correctOptions: number | null
    orderIndex: number | null
  }

  export type QuestionSumAggregateOutputType = {
    correctOptions: number[]
    orderIndex: number | null
  }

  export type QuestionMinAggregateOutputType = {
    id: string | null
    quizId: string | null
    questionText: string | null
    type: $Enums.QuestionType | null
    orderIndex: number | null
  }

  export type QuestionMaxAggregateOutputType = {
    id: string | null
    quizId: string | null
    questionText: string | null
    type: $Enums.QuestionType | null
    orderIndex: number | null
  }

  export type QuestionCountAggregateOutputType = {
    id: number
    quizId: number
    questionText: number
    type: number
    options: number
    correctOptions: number
    orderIndex: number
    _all: number
  }


  export type QuestionAvgAggregateInputType = {
    correctOptions?: true
    orderIndex?: true
  }

  export type QuestionSumAggregateInputType = {
    correctOptions?: true
    orderIndex?: true
  }

  export type QuestionMinAggregateInputType = {
    id?: true
    quizId?: true
    questionText?: true
    type?: true
    orderIndex?: true
  }

  export type QuestionMaxAggregateInputType = {
    id?: true
    quizId?: true
    questionText?: true
    type?: true
    orderIndex?: true
  }

  export type QuestionCountAggregateInputType = {
    id?: true
    quizId?: true
    questionText?: true
    type?: true
    options?: true
    correctOptions?: true
    orderIndex?: true
    _all?: true
  }

  export type QuestionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Question to aggregate.
     */
    where?: QuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Questions to fetch.
     */
    orderBy?: QuestionOrderByWithRelationInput | QuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Questions
    **/
    _count?: true | QuestionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuestionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuestionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuestionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuestionMaxAggregateInputType
  }

  export type GetQuestionAggregateType<T extends QuestionAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestion[P]>
      : GetScalarType<T[P], AggregateQuestion[P]>
  }




  export type QuestionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionWhereInput
    orderBy?: QuestionOrderByWithAggregationInput | QuestionOrderByWithAggregationInput[]
    by: QuestionScalarFieldEnum[] | QuestionScalarFieldEnum
    having?: QuestionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuestionCountAggregateInputType | true
    _avg?: QuestionAvgAggregateInputType
    _sum?: QuestionSumAggregateInputType
    _min?: QuestionMinAggregateInputType
    _max?: QuestionMaxAggregateInputType
  }

  export type QuestionGroupByOutputType = {
    id: string
    quizId: string
    questionText: string
    type: $Enums.QuestionType
    options: JsonValue
    correctOptions: number[]
    orderIndex: number | null
    _count: QuestionCountAggregateOutputType | null
    _avg: QuestionAvgAggregateOutputType | null
    _sum: QuestionSumAggregateOutputType | null
    _min: QuestionMinAggregateOutputType | null
    _max: QuestionMaxAggregateOutputType | null
  }

  type GetQuestionGroupByPayload<T extends QuestionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuestionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuestionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestionGroupByOutputType[P]>
            : GetScalarType<T[P], QuestionGroupByOutputType[P]>
        }
      >
    >


  export type QuestionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quizId?: boolean
    questionText?: boolean
    type?: boolean
    options?: boolean
    correctOptions?: boolean
    orderIndex?: boolean
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["question"]>

  export type QuestionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quizId?: boolean
    questionText?: boolean
    type?: boolean
    options?: boolean
    correctOptions?: boolean
    orderIndex?: boolean
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["question"]>

  export type QuestionSelectScalar = {
    id?: boolean
    quizId?: boolean
    questionText?: boolean
    type?: boolean
    options?: boolean
    correctOptions?: boolean
    orderIndex?: boolean
  }

  export type QuestionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
  }
  export type QuestionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
  }

  export type $QuestionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Question"
    objects: {
      quiz: Prisma.$QuizPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      quizId: string
      questionText: string
      type: $Enums.QuestionType
      options: Prisma.JsonValue
      correctOptions: number[]
      orderIndex: number | null
    }, ExtArgs["result"]["question"]>
    composites: {}
  }

  type QuestionGetPayload<S extends boolean | null | undefined | QuestionDefaultArgs> = $Result.GetResult<Prisma.$QuestionPayload, S>

  type QuestionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<QuestionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: QuestionCountAggregateInputType | true
    }

  export interface QuestionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Question'], meta: { name: 'Question' } }
    /**
     * Find zero or one Question that matches the filter.
     * @param {QuestionFindUniqueArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuestionFindUniqueArgs>(args: SelectSubset<T, QuestionFindUniqueArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Question that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {QuestionFindUniqueOrThrowArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuestionFindUniqueOrThrowArgs>(args: SelectSubset<T, QuestionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Question that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionFindFirstArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuestionFindFirstArgs>(args?: SelectSubset<T, QuestionFindFirstArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Question that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionFindFirstOrThrowArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuestionFindFirstOrThrowArgs>(args?: SelectSubset<T, QuestionFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Questions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Questions
     * const questions = await prisma.question.findMany()
     * 
     * // Get first 10 Questions
     * const questions = await prisma.question.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const questionWithIdOnly = await prisma.question.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuestionFindManyArgs>(args?: SelectSubset<T, QuestionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Question.
     * @param {QuestionCreateArgs} args - Arguments to create a Question.
     * @example
     * // Create one Question
     * const Question = await prisma.question.create({
     *   data: {
     *     // ... data to create a Question
     *   }
     * })
     * 
     */
    create<T extends QuestionCreateArgs>(args: SelectSubset<T, QuestionCreateArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Questions.
     * @param {QuestionCreateManyArgs} args - Arguments to create many Questions.
     * @example
     * // Create many Questions
     * const question = await prisma.question.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuestionCreateManyArgs>(args?: SelectSubset<T, QuestionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Questions and returns the data saved in the database.
     * @param {QuestionCreateManyAndReturnArgs} args - Arguments to create many Questions.
     * @example
     * // Create many Questions
     * const question = await prisma.question.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Questions and only return the `id`
     * const questionWithIdOnly = await prisma.question.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuestionCreateManyAndReturnArgs>(args?: SelectSubset<T, QuestionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Question.
     * @param {QuestionDeleteArgs} args - Arguments to delete one Question.
     * @example
     * // Delete one Question
     * const Question = await prisma.question.delete({
     *   where: {
     *     // ... filter to delete one Question
     *   }
     * })
     * 
     */
    delete<T extends QuestionDeleteArgs>(args: SelectSubset<T, QuestionDeleteArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Question.
     * @param {QuestionUpdateArgs} args - Arguments to update one Question.
     * @example
     * // Update one Question
     * const question = await prisma.question.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuestionUpdateArgs>(args: SelectSubset<T, QuestionUpdateArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Questions.
     * @param {QuestionDeleteManyArgs} args - Arguments to filter Questions to delete.
     * @example
     * // Delete a few Questions
     * const { count } = await prisma.question.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuestionDeleteManyArgs>(args?: SelectSubset<T, QuestionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Questions
     * const question = await prisma.question.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuestionUpdateManyArgs>(args: SelectSubset<T, QuestionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Question.
     * @param {QuestionUpsertArgs} args - Arguments to update or create a Question.
     * @example
     * // Update or create a Question
     * const question = await prisma.question.upsert({
     *   create: {
     *     // ... data to create a Question
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Question we want to update
     *   }
     * })
     */
    upsert<T extends QuestionUpsertArgs>(args: SelectSubset<T, QuestionUpsertArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionCountArgs} args - Arguments to filter Questions to count.
     * @example
     * // Count the number of Questions
     * const count = await prisma.question.count({
     *   where: {
     *     // ... the filter for the Questions we want to count
     *   }
     * })
    **/
    count<T extends QuestionCountArgs>(
      args?: Subset<T, QuestionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Question.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestionAggregateArgs>(args: Subset<T, QuestionAggregateArgs>): Prisma.PrismaPromise<GetQuestionAggregateType<T>>

    /**
     * Group by Question.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuestionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuestionGroupByArgs['orderBy'] }
        : { orderBy?: QuestionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuestionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Question model
   */
  readonly fields: QuestionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Question.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuestionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    quiz<T extends QuizDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuizDefaultArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Question model
   */ 
  interface QuestionFieldRefs {
    readonly id: FieldRef<"Question", 'String'>
    readonly quizId: FieldRef<"Question", 'String'>
    readonly questionText: FieldRef<"Question", 'String'>
    readonly type: FieldRef<"Question", 'QuestionType'>
    readonly options: FieldRef<"Question", 'Json'>
    readonly correctOptions: FieldRef<"Question", 'Int[]'>
    readonly orderIndex: FieldRef<"Question", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Question findUnique
   */
  export type QuestionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter, which Question to fetch.
     */
    where: QuestionWhereUniqueInput
  }

  /**
   * Question findUniqueOrThrow
   */
  export type QuestionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter, which Question to fetch.
     */
    where: QuestionWhereUniqueInput
  }

  /**
   * Question findFirst
   */
  export type QuestionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter, which Question to fetch.
     */
    where?: QuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Questions to fetch.
     */
    orderBy?: QuestionOrderByWithRelationInput | QuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Questions.
     */
    cursor?: QuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Questions.
     */
    distinct?: QuestionScalarFieldEnum | QuestionScalarFieldEnum[]
  }

  /**
   * Question findFirstOrThrow
   */
  export type QuestionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter, which Question to fetch.
     */
    where?: QuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Questions to fetch.
     */
    orderBy?: QuestionOrderByWithRelationInput | QuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Questions.
     */
    cursor?: QuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Questions.
     */
    distinct?: QuestionScalarFieldEnum | QuestionScalarFieldEnum[]
  }

  /**
   * Question findMany
   */
  export type QuestionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter, which Questions to fetch.
     */
    where?: QuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Questions to fetch.
     */
    orderBy?: QuestionOrderByWithRelationInput | QuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Questions.
     */
    cursor?: QuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Questions.
     */
    skip?: number
    distinct?: QuestionScalarFieldEnum | QuestionScalarFieldEnum[]
  }

  /**
   * Question create
   */
  export type QuestionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * The data needed to create a Question.
     */
    data: XOR<QuestionCreateInput, QuestionUncheckedCreateInput>
  }

  /**
   * Question createMany
   */
  export type QuestionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Questions.
     */
    data: QuestionCreateManyInput | QuestionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Question createManyAndReturn
   */
  export type QuestionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Questions.
     */
    data: QuestionCreateManyInput | QuestionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Question update
   */
  export type QuestionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * The data needed to update a Question.
     */
    data: XOR<QuestionUpdateInput, QuestionUncheckedUpdateInput>
    /**
     * Choose, which Question to update.
     */
    where: QuestionWhereUniqueInput
  }

  /**
   * Question updateMany
   */
  export type QuestionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Questions.
     */
    data: XOR<QuestionUpdateManyMutationInput, QuestionUncheckedUpdateManyInput>
    /**
     * Filter which Questions to update
     */
    where?: QuestionWhereInput
  }

  /**
   * Question upsert
   */
  export type QuestionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * The filter to search for the Question to update in case it exists.
     */
    where: QuestionWhereUniqueInput
    /**
     * In case the Question found by the `where` argument doesn't exist, create a new Question with this data.
     */
    create: XOR<QuestionCreateInput, QuestionUncheckedCreateInput>
    /**
     * In case the Question was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuestionUpdateInput, QuestionUncheckedUpdateInput>
  }

  /**
   * Question delete
   */
  export type QuestionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter which Question to delete.
     */
    where: QuestionWhereUniqueInput
  }

  /**
   * Question deleteMany
   */
  export type QuestionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Questions to delete
     */
    where?: QuestionWhereInput
  }

  /**
   * Question without action
   */
  export type QuestionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
  }


  /**
   * Model Assignment
   */

  export type AggregateAssignment = {
    _count: AssignmentCountAggregateOutputType | null
    _avg: AssignmentAvgAggregateOutputType | null
    _sum: AssignmentSumAggregateOutputType | null
    _min: AssignmentMinAggregateOutputType | null
    _max: AssignmentMaxAggregateOutputType | null
  }

  export type AssignmentAvgAggregateOutputType = {
    maxScore: number | null
  }

  export type AssignmentSumAggregateOutputType = {
    maxScore: number | null
  }

  export type AssignmentMinAggregateOutputType = {
    id: string | null
    lessonId: string | null
    title: string | null
    description: string | null
    dueDate: Date | null
    maxScore: number | null
    allowFileUpload: boolean | null
  }

  export type AssignmentMaxAggregateOutputType = {
    id: string | null
    lessonId: string | null
    title: string | null
    description: string | null
    dueDate: Date | null
    maxScore: number | null
    allowFileUpload: boolean | null
  }

  export type AssignmentCountAggregateOutputType = {
    id: number
    lessonId: number
    title: number
    description: number
    dueDate: number
    maxScore: number
    allowFileUpload: number
    allowedFileTypes: number
    unitTests: number
    _all: number
  }


  export type AssignmentAvgAggregateInputType = {
    maxScore?: true
  }

  export type AssignmentSumAggregateInputType = {
    maxScore?: true
  }

  export type AssignmentMinAggregateInputType = {
    id?: true
    lessonId?: true
    title?: true
    description?: true
    dueDate?: true
    maxScore?: true
    allowFileUpload?: true
  }

  export type AssignmentMaxAggregateInputType = {
    id?: true
    lessonId?: true
    title?: true
    description?: true
    dueDate?: true
    maxScore?: true
    allowFileUpload?: true
  }

  export type AssignmentCountAggregateInputType = {
    id?: true
    lessonId?: true
    title?: true
    description?: true
    dueDate?: true
    maxScore?: true
    allowFileUpload?: true
    allowedFileTypes?: true
    unitTests?: true
    _all?: true
  }

  export type AssignmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Assignment to aggregate.
     */
    where?: AssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assignments to fetch.
     */
    orderBy?: AssignmentOrderByWithRelationInput | AssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Assignments
    **/
    _count?: true | AssignmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AssignmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AssignmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AssignmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AssignmentMaxAggregateInputType
  }

  export type GetAssignmentAggregateType<T extends AssignmentAggregateArgs> = {
        [P in keyof T & keyof AggregateAssignment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAssignment[P]>
      : GetScalarType<T[P], AggregateAssignment[P]>
  }




  export type AssignmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssignmentWhereInput
    orderBy?: AssignmentOrderByWithAggregationInput | AssignmentOrderByWithAggregationInput[]
    by: AssignmentScalarFieldEnum[] | AssignmentScalarFieldEnum
    having?: AssignmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AssignmentCountAggregateInputType | true
    _avg?: AssignmentAvgAggregateInputType
    _sum?: AssignmentSumAggregateInputType
    _min?: AssignmentMinAggregateInputType
    _max?: AssignmentMaxAggregateInputType
  }

  export type AssignmentGroupByOutputType = {
    id: string
    lessonId: string
    title: string
    description: string | null
    dueDate: Date | null
    maxScore: number
    allowFileUpload: boolean
    allowedFileTypes: string[]
    unitTests: JsonValue | null
    _count: AssignmentCountAggregateOutputType | null
    _avg: AssignmentAvgAggregateOutputType | null
    _sum: AssignmentSumAggregateOutputType | null
    _min: AssignmentMinAggregateOutputType | null
    _max: AssignmentMaxAggregateOutputType | null
  }

  type GetAssignmentGroupByPayload<T extends AssignmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AssignmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AssignmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssignmentGroupByOutputType[P]>
            : GetScalarType<T[P], AssignmentGroupByOutputType[P]>
        }
      >
    >


  export type AssignmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lessonId?: boolean
    title?: boolean
    description?: boolean
    dueDate?: boolean
    maxScore?: boolean
    allowFileUpload?: boolean
    allowedFileTypes?: boolean
    unitTests?: boolean
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
    submissions?: boolean | Assignment$submissionsArgs<ExtArgs>
    _count?: boolean | AssignmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assignment"]>

  export type AssignmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lessonId?: boolean
    title?: boolean
    description?: boolean
    dueDate?: boolean
    maxScore?: boolean
    allowFileUpload?: boolean
    allowedFileTypes?: boolean
    unitTests?: boolean
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assignment"]>

  export type AssignmentSelectScalar = {
    id?: boolean
    lessonId?: boolean
    title?: boolean
    description?: boolean
    dueDate?: boolean
    maxScore?: boolean
    allowFileUpload?: boolean
    allowedFileTypes?: boolean
    unitTests?: boolean
  }

  export type AssignmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
    submissions?: boolean | Assignment$submissionsArgs<ExtArgs>
    _count?: boolean | AssignmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AssignmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
  }

  export type $AssignmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Assignment"
    objects: {
      lesson: Prisma.$LessonPayload<ExtArgs>
      submissions: Prisma.$AssignmentSubmissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      lessonId: string
      title: string
      description: string | null
      dueDate: Date | null
      maxScore: number
      allowFileUpload: boolean
      allowedFileTypes: string[]
      unitTests: Prisma.JsonValue | null
    }, ExtArgs["result"]["assignment"]>
    composites: {}
  }

  type AssignmentGetPayload<S extends boolean | null | undefined | AssignmentDefaultArgs> = $Result.GetResult<Prisma.$AssignmentPayload, S>

  type AssignmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AssignmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AssignmentCountAggregateInputType | true
    }

  export interface AssignmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Assignment'], meta: { name: 'Assignment' } }
    /**
     * Find zero or one Assignment that matches the filter.
     * @param {AssignmentFindUniqueArgs} args - Arguments to find a Assignment
     * @example
     * // Get one Assignment
     * const assignment = await prisma.assignment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AssignmentFindUniqueArgs>(args: SelectSubset<T, AssignmentFindUniqueArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Assignment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AssignmentFindUniqueOrThrowArgs} args - Arguments to find a Assignment
     * @example
     * // Get one Assignment
     * const assignment = await prisma.assignment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AssignmentFindUniqueOrThrowArgs>(args: SelectSubset<T, AssignmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Assignment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentFindFirstArgs} args - Arguments to find a Assignment
     * @example
     * // Get one Assignment
     * const assignment = await prisma.assignment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AssignmentFindFirstArgs>(args?: SelectSubset<T, AssignmentFindFirstArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Assignment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentFindFirstOrThrowArgs} args - Arguments to find a Assignment
     * @example
     * // Get one Assignment
     * const assignment = await prisma.assignment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AssignmentFindFirstOrThrowArgs>(args?: SelectSubset<T, AssignmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Assignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Assignments
     * const assignments = await prisma.assignment.findMany()
     * 
     * // Get first 10 Assignments
     * const assignments = await prisma.assignment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const assignmentWithIdOnly = await prisma.assignment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AssignmentFindManyArgs>(args?: SelectSubset<T, AssignmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Assignment.
     * @param {AssignmentCreateArgs} args - Arguments to create a Assignment.
     * @example
     * // Create one Assignment
     * const Assignment = await prisma.assignment.create({
     *   data: {
     *     // ... data to create a Assignment
     *   }
     * })
     * 
     */
    create<T extends AssignmentCreateArgs>(args: SelectSubset<T, AssignmentCreateArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Assignments.
     * @param {AssignmentCreateManyArgs} args - Arguments to create many Assignments.
     * @example
     * // Create many Assignments
     * const assignment = await prisma.assignment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AssignmentCreateManyArgs>(args?: SelectSubset<T, AssignmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Assignments and returns the data saved in the database.
     * @param {AssignmentCreateManyAndReturnArgs} args - Arguments to create many Assignments.
     * @example
     * // Create many Assignments
     * const assignment = await prisma.assignment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Assignments and only return the `id`
     * const assignmentWithIdOnly = await prisma.assignment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AssignmentCreateManyAndReturnArgs>(args?: SelectSubset<T, AssignmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Assignment.
     * @param {AssignmentDeleteArgs} args - Arguments to delete one Assignment.
     * @example
     * // Delete one Assignment
     * const Assignment = await prisma.assignment.delete({
     *   where: {
     *     // ... filter to delete one Assignment
     *   }
     * })
     * 
     */
    delete<T extends AssignmentDeleteArgs>(args: SelectSubset<T, AssignmentDeleteArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Assignment.
     * @param {AssignmentUpdateArgs} args - Arguments to update one Assignment.
     * @example
     * // Update one Assignment
     * const assignment = await prisma.assignment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AssignmentUpdateArgs>(args: SelectSubset<T, AssignmentUpdateArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Assignments.
     * @param {AssignmentDeleteManyArgs} args - Arguments to filter Assignments to delete.
     * @example
     * // Delete a few Assignments
     * const { count } = await prisma.assignment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AssignmentDeleteManyArgs>(args?: SelectSubset<T, AssignmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Assignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Assignments
     * const assignment = await prisma.assignment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AssignmentUpdateManyArgs>(args: SelectSubset<T, AssignmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Assignment.
     * @param {AssignmentUpsertArgs} args - Arguments to update or create a Assignment.
     * @example
     * // Update or create a Assignment
     * const assignment = await prisma.assignment.upsert({
     *   create: {
     *     // ... data to create a Assignment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Assignment we want to update
     *   }
     * })
     */
    upsert<T extends AssignmentUpsertArgs>(args: SelectSubset<T, AssignmentUpsertArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Assignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentCountArgs} args - Arguments to filter Assignments to count.
     * @example
     * // Count the number of Assignments
     * const count = await prisma.assignment.count({
     *   where: {
     *     // ... the filter for the Assignments we want to count
     *   }
     * })
    **/
    count<T extends AssignmentCountArgs>(
      args?: Subset<T, AssignmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AssignmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Assignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AssignmentAggregateArgs>(args: Subset<T, AssignmentAggregateArgs>): Prisma.PrismaPromise<GetAssignmentAggregateType<T>>

    /**
     * Group by Assignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AssignmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AssignmentGroupByArgs['orderBy'] }
        : { orderBy?: AssignmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AssignmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssignmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Assignment model
   */
  readonly fields: AssignmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Assignment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AssignmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lesson<T extends LessonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LessonDefaultArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    submissions<T extends Assignment$submissionsArgs<ExtArgs> = {}>(args?: Subset<T, Assignment$submissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssignmentSubmissionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Assignment model
   */ 
  interface AssignmentFieldRefs {
    readonly id: FieldRef<"Assignment", 'String'>
    readonly lessonId: FieldRef<"Assignment", 'String'>
    readonly title: FieldRef<"Assignment", 'String'>
    readonly description: FieldRef<"Assignment", 'String'>
    readonly dueDate: FieldRef<"Assignment", 'DateTime'>
    readonly maxScore: FieldRef<"Assignment", 'Int'>
    readonly allowFileUpload: FieldRef<"Assignment", 'Boolean'>
    readonly allowedFileTypes: FieldRef<"Assignment", 'String[]'>
    readonly unitTests: FieldRef<"Assignment", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Assignment findUnique
   */
  export type AssignmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * Filter, which Assignment to fetch.
     */
    where: AssignmentWhereUniqueInput
  }

  /**
   * Assignment findUniqueOrThrow
   */
  export type AssignmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * Filter, which Assignment to fetch.
     */
    where: AssignmentWhereUniqueInput
  }

  /**
   * Assignment findFirst
   */
  export type AssignmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * Filter, which Assignment to fetch.
     */
    where?: AssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assignments to fetch.
     */
    orderBy?: AssignmentOrderByWithRelationInput | AssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Assignments.
     */
    cursor?: AssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Assignments.
     */
    distinct?: AssignmentScalarFieldEnum | AssignmentScalarFieldEnum[]
  }

  /**
   * Assignment findFirstOrThrow
   */
  export type AssignmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * Filter, which Assignment to fetch.
     */
    where?: AssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assignments to fetch.
     */
    orderBy?: AssignmentOrderByWithRelationInput | AssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Assignments.
     */
    cursor?: AssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Assignments.
     */
    distinct?: AssignmentScalarFieldEnum | AssignmentScalarFieldEnum[]
  }

  /**
   * Assignment findMany
   */
  export type AssignmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * Filter, which Assignments to fetch.
     */
    where?: AssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assignments to fetch.
     */
    orderBy?: AssignmentOrderByWithRelationInput | AssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Assignments.
     */
    cursor?: AssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assignments.
     */
    skip?: number
    distinct?: AssignmentScalarFieldEnum | AssignmentScalarFieldEnum[]
  }

  /**
   * Assignment create
   */
  export type AssignmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Assignment.
     */
    data: XOR<AssignmentCreateInput, AssignmentUncheckedCreateInput>
  }

  /**
   * Assignment createMany
   */
  export type AssignmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Assignments.
     */
    data: AssignmentCreateManyInput | AssignmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Assignment createManyAndReturn
   */
  export type AssignmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Assignments.
     */
    data: AssignmentCreateManyInput | AssignmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Assignment update
   */
  export type AssignmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Assignment.
     */
    data: XOR<AssignmentUpdateInput, AssignmentUncheckedUpdateInput>
    /**
     * Choose, which Assignment to update.
     */
    where: AssignmentWhereUniqueInput
  }

  /**
   * Assignment updateMany
   */
  export type AssignmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Assignments.
     */
    data: XOR<AssignmentUpdateManyMutationInput, AssignmentUncheckedUpdateManyInput>
    /**
     * Filter which Assignments to update
     */
    where?: AssignmentWhereInput
  }

  /**
   * Assignment upsert
   */
  export type AssignmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Assignment to update in case it exists.
     */
    where: AssignmentWhereUniqueInput
    /**
     * In case the Assignment found by the `where` argument doesn't exist, create a new Assignment with this data.
     */
    create: XOR<AssignmentCreateInput, AssignmentUncheckedCreateInput>
    /**
     * In case the Assignment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AssignmentUpdateInput, AssignmentUncheckedUpdateInput>
  }

  /**
   * Assignment delete
   */
  export type AssignmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * Filter which Assignment to delete.
     */
    where: AssignmentWhereUniqueInput
  }

  /**
   * Assignment deleteMany
   */
  export type AssignmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Assignments to delete
     */
    where?: AssignmentWhereInput
  }

  /**
   * Assignment.submissions
   */
  export type Assignment$submissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentSubmission
     */
    select?: AssignmentSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentSubmissionInclude<ExtArgs> | null
    where?: AssignmentSubmissionWhereInput
    orderBy?: AssignmentSubmissionOrderByWithRelationInput | AssignmentSubmissionOrderByWithRelationInput[]
    cursor?: AssignmentSubmissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssignmentSubmissionScalarFieldEnum | AssignmentSubmissionScalarFieldEnum[]
  }

  /**
   * Assignment without action
   */
  export type AssignmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
  }


  /**
   * Model Enrollment
   */

  export type AggregateEnrollment = {
    _count: EnrollmentCountAggregateOutputType | null
    _min: EnrollmentMinAggregateOutputType | null
    _max: EnrollmentMaxAggregateOutputType | null
  }

  export type EnrollmentMinAggregateOutputType = {
    id: string | null
    userId: string | null
    courseId: string | null
    enrolledAt: Date | null
    completed: boolean | null
    completedAt: Date | null
    status: string | null
  }

  export type EnrollmentMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    courseId: string | null
    enrolledAt: Date | null
    completed: boolean | null
    completedAt: Date | null
    status: string | null
  }

  export type EnrollmentCountAggregateOutputType = {
    id: number
    userId: number
    courseId: number
    enrolledAt: number
    completed: number
    completedAt: number
    status: number
    _all: number
  }


  export type EnrollmentMinAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    enrolledAt?: true
    completed?: true
    completedAt?: true
    status?: true
  }

  export type EnrollmentMaxAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    enrolledAt?: true
    completed?: true
    completedAt?: true
    status?: true
  }

  export type EnrollmentCountAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    enrolledAt?: true
    completed?: true
    completedAt?: true
    status?: true
    _all?: true
  }

  export type EnrollmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Enrollment to aggregate.
     */
    where?: EnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enrollments to fetch.
     */
    orderBy?: EnrollmentOrderByWithRelationInput | EnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Enrollments
    **/
    _count?: true | EnrollmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EnrollmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EnrollmentMaxAggregateInputType
  }

  export type GetEnrollmentAggregateType<T extends EnrollmentAggregateArgs> = {
        [P in keyof T & keyof AggregateEnrollment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEnrollment[P]>
      : GetScalarType<T[P], AggregateEnrollment[P]>
  }




  export type EnrollmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnrollmentWhereInput
    orderBy?: EnrollmentOrderByWithAggregationInput | EnrollmentOrderByWithAggregationInput[]
    by: EnrollmentScalarFieldEnum[] | EnrollmentScalarFieldEnum
    having?: EnrollmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EnrollmentCountAggregateInputType | true
    _min?: EnrollmentMinAggregateInputType
    _max?: EnrollmentMaxAggregateInputType
  }

  export type EnrollmentGroupByOutputType = {
    id: string
    userId: string
    courseId: string
    enrolledAt: Date
    completed: boolean
    completedAt: Date | null
    status: string
    _count: EnrollmentCountAggregateOutputType | null
    _min: EnrollmentMinAggregateOutputType | null
    _max: EnrollmentMaxAggregateOutputType | null
  }

  type GetEnrollmentGroupByPayload<T extends EnrollmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EnrollmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EnrollmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EnrollmentGroupByOutputType[P]>
            : GetScalarType<T[P], EnrollmentGroupByOutputType[P]>
        }
      >
    >


  export type EnrollmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    courseId?: boolean
    enrolledAt?: boolean
    completed?: boolean
    completedAt?: boolean
    status?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["enrollment"]>

  export type EnrollmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    courseId?: boolean
    enrolledAt?: boolean
    completed?: boolean
    completedAt?: boolean
    status?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["enrollment"]>

  export type EnrollmentSelectScalar = {
    id?: boolean
    userId?: boolean
    courseId?: boolean
    enrolledAt?: boolean
    completed?: boolean
    completedAt?: boolean
    status?: boolean
  }

  export type EnrollmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }
  export type EnrollmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }

  export type $EnrollmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Enrollment"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      course: Prisma.$CoursePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      courseId: string
      enrolledAt: Date
      completed: boolean
      completedAt: Date | null
      status: string
    }, ExtArgs["result"]["enrollment"]>
    composites: {}
  }

  type EnrollmentGetPayload<S extends boolean | null | undefined | EnrollmentDefaultArgs> = $Result.GetResult<Prisma.$EnrollmentPayload, S>

  type EnrollmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EnrollmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EnrollmentCountAggregateInputType | true
    }

  export interface EnrollmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Enrollment'], meta: { name: 'Enrollment' } }
    /**
     * Find zero or one Enrollment that matches the filter.
     * @param {EnrollmentFindUniqueArgs} args - Arguments to find a Enrollment
     * @example
     * // Get one Enrollment
     * const enrollment = await prisma.enrollment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EnrollmentFindUniqueArgs>(args: SelectSubset<T, EnrollmentFindUniqueArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Enrollment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EnrollmentFindUniqueOrThrowArgs} args - Arguments to find a Enrollment
     * @example
     * // Get one Enrollment
     * const enrollment = await prisma.enrollment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EnrollmentFindUniqueOrThrowArgs>(args: SelectSubset<T, EnrollmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Enrollment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentFindFirstArgs} args - Arguments to find a Enrollment
     * @example
     * // Get one Enrollment
     * const enrollment = await prisma.enrollment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EnrollmentFindFirstArgs>(args?: SelectSubset<T, EnrollmentFindFirstArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Enrollment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentFindFirstOrThrowArgs} args - Arguments to find a Enrollment
     * @example
     * // Get one Enrollment
     * const enrollment = await prisma.enrollment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EnrollmentFindFirstOrThrowArgs>(args?: SelectSubset<T, EnrollmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Enrollments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Enrollments
     * const enrollments = await prisma.enrollment.findMany()
     * 
     * // Get first 10 Enrollments
     * const enrollments = await prisma.enrollment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const enrollmentWithIdOnly = await prisma.enrollment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EnrollmentFindManyArgs>(args?: SelectSubset<T, EnrollmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Enrollment.
     * @param {EnrollmentCreateArgs} args - Arguments to create a Enrollment.
     * @example
     * // Create one Enrollment
     * const Enrollment = await prisma.enrollment.create({
     *   data: {
     *     // ... data to create a Enrollment
     *   }
     * })
     * 
     */
    create<T extends EnrollmentCreateArgs>(args: SelectSubset<T, EnrollmentCreateArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Enrollments.
     * @param {EnrollmentCreateManyArgs} args - Arguments to create many Enrollments.
     * @example
     * // Create many Enrollments
     * const enrollment = await prisma.enrollment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EnrollmentCreateManyArgs>(args?: SelectSubset<T, EnrollmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Enrollments and returns the data saved in the database.
     * @param {EnrollmentCreateManyAndReturnArgs} args - Arguments to create many Enrollments.
     * @example
     * // Create many Enrollments
     * const enrollment = await prisma.enrollment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Enrollments and only return the `id`
     * const enrollmentWithIdOnly = await prisma.enrollment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EnrollmentCreateManyAndReturnArgs>(args?: SelectSubset<T, EnrollmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Enrollment.
     * @param {EnrollmentDeleteArgs} args - Arguments to delete one Enrollment.
     * @example
     * // Delete one Enrollment
     * const Enrollment = await prisma.enrollment.delete({
     *   where: {
     *     // ... filter to delete one Enrollment
     *   }
     * })
     * 
     */
    delete<T extends EnrollmentDeleteArgs>(args: SelectSubset<T, EnrollmentDeleteArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Enrollment.
     * @param {EnrollmentUpdateArgs} args - Arguments to update one Enrollment.
     * @example
     * // Update one Enrollment
     * const enrollment = await prisma.enrollment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EnrollmentUpdateArgs>(args: SelectSubset<T, EnrollmentUpdateArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Enrollments.
     * @param {EnrollmentDeleteManyArgs} args - Arguments to filter Enrollments to delete.
     * @example
     * // Delete a few Enrollments
     * const { count } = await prisma.enrollment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EnrollmentDeleteManyArgs>(args?: SelectSubset<T, EnrollmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Enrollments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Enrollments
     * const enrollment = await prisma.enrollment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EnrollmentUpdateManyArgs>(args: SelectSubset<T, EnrollmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Enrollment.
     * @param {EnrollmentUpsertArgs} args - Arguments to update or create a Enrollment.
     * @example
     * // Update or create a Enrollment
     * const enrollment = await prisma.enrollment.upsert({
     *   create: {
     *     // ... data to create a Enrollment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Enrollment we want to update
     *   }
     * })
     */
    upsert<T extends EnrollmentUpsertArgs>(args: SelectSubset<T, EnrollmentUpsertArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Enrollments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentCountArgs} args - Arguments to filter Enrollments to count.
     * @example
     * // Count the number of Enrollments
     * const count = await prisma.enrollment.count({
     *   where: {
     *     // ... the filter for the Enrollments we want to count
     *   }
     * })
    **/
    count<T extends EnrollmentCountArgs>(
      args?: Subset<T, EnrollmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EnrollmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Enrollment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EnrollmentAggregateArgs>(args: Subset<T, EnrollmentAggregateArgs>): Prisma.PrismaPromise<GetEnrollmentAggregateType<T>>

    /**
     * Group by Enrollment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EnrollmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EnrollmentGroupByArgs['orderBy'] }
        : { orderBy?: EnrollmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EnrollmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEnrollmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Enrollment model
   */
  readonly fields: EnrollmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Enrollment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EnrollmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Enrollment model
   */ 
  interface EnrollmentFieldRefs {
    readonly id: FieldRef<"Enrollment", 'String'>
    readonly userId: FieldRef<"Enrollment", 'String'>
    readonly courseId: FieldRef<"Enrollment", 'String'>
    readonly enrolledAt: FieldRef<"Enrollment", 'DateTime'>
    readonly completed: FieldRef<"Enrollment", 'Boolean'>
    readonly completedAt: FieldRef<"Enrollment", 'DateTime'>
    readonly status: FieldRef<"Enrollment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Enrollment findUnique
   */
  export type EnrollmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which Enrollment to fetch.
     */
    where: EnrollmentWhereUniqueInput
  }

  /**
   * Enrollment findUniqueOrThrow
   */
  export type EnrollmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which Enrollment to fetch.
     */
    where: EnrollmentWhereUniqueInput
  }

  /**
   * Enrollment findFirst
   */
  export type EnrollmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which Enrollment to fetch.
     */
    where?: EnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enrollments to fetch.
     */
    orderBy?: EnrollmentOrderByWithRelationInput | EnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Enrollments.
     */
    cursor?: EnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Enrollments.
     */
    distinct?: EnrollmentScalarFieldEnum | EnrollmentScalarFieldEnum[]
  }

  /**
   * Enrollment findFirstOrThrow
   */
  export type EnrollmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which Enrollment to fetch.
     */
    where?: EnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enrollments to fetch.
     */
    orderBy?: EnrollmentOrderByWithRelationInput | EnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Enrollments.
     */
    cursor?: EnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Enrollments.
     */
    distinct?: EnrollmentScalarFieldEnum | EnrollmentScalarFieldEnum[]
  }

  /**
   * Enrollment findMany
   */
  export type EnrollmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which Enrollments to fetch.
     */
    where?: EnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enrollments to fetch.
     */
    orderBy?: EnrollmentOrderByWithRelationInput | EnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Enrollments.
     */
    cursor?: EnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enrollments.
     */
    skip?: number
    distinct?: EnrollmentScalarFieldEnum | EnrollmentScalarFieldEnum[]
  }

  /**
   * Enrollment create
   */
  export type EnrollmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Enrollment.
     */
    data: XOR<EnrollmentCreateInput, EnrollmentUncheckedCreateInput>
  }

  /**
   * Enrollment createMany
   */
  export type EnrollmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Enrollments.
     */
    data: EnrollmentCreateManyInput | EnrollmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Enrollment createManyAndReturn
   */
  export type EnrollmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Enrollments.
     */
    data: EnrollmentCreateManyInput | EnrollmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Enrollment update
   */
  export type EnrollmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Enrollment.
     */
    data: XOR<EnrollmentUpdateInput, EnrollmentUncheckedUpdateInput>
    /**
     * Choose, which Enrollment to update.
     */
    where: EnrollmentWhereUniqueInput
  }

  /**
   * Enrollment updateMany
   */
  export type EnrollmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Enrollments.
     */
    data: XOR<EnrollmentUpdateManyMutationInput, EnrollmentUncheckedUpdateManyInput>
    /**
     * Filter which Enrollments to update
     */
    where?: EnrollmentWhereInput
  }

  /**
   * Enrollment upsert
   */
  export type EnrollmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Enrollment to update in case it exists.
     */
    where: EnrollmentWhereUniqueInput
    /**
     * In case the Enrollment found by the `where` argument doesn't exist, create a new Enrollment with this data.
     */
    create: XOR<EnrollmentCreateInput, EnrollmentUncheckedCreateInput>
    /**
     * In case the Enrollment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EnrollmentUpdateInput, EnrollmentUncheckedUpdateInput>
  }

  /**
   * Enrollment delete
   */
  export type EnrollmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * Filter which Enrollment to delete.
     */
    where: EnrollmentWhereUniqueInput
  }

  /**
   * Enrollment deleteMany
   */
  export type EnrollmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Enrollments to delete
     */
    where?: EnrollmentWhereInput
  }

  /**
   * Enrollment without action
   */
  export type EnrollmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
  }


  /**
   * Model SavedCourse
   */

  export type AggregateSavedCourse = {
    _count: SavedCourseCountAggregateOutputType | null
    _min: SavedCourseMinAggregateOutputType | null
    _max: SavedCourseMaxAggregateOutputType | null
  }

  export type SavedCourseMinAggregateOutputType = {
    id: string | null
    userId: string | null
    courseId: string | null
    savedAt: Date | null
  }

  export type SavedCourseMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    courseId: string | null
    savedAt: Date | null
  }

  export type SavedCourseCountAggregateOutputType = {
    id: number
    userId: number
    courseId: number
    savedAt: number
    _all: number
  }


  export type SavedCourseMinAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    savedAt?: true
  }

  export type SavedCourseMaxAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    savedAt?: true
  }

  export type SavedCourseCountAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    savedAt?: true
    _all?: true
  }

  export type SavedCourseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SavedCourse to aggregate.
     */
    where?: SavedCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SavedCourses to fetch.
     */
    orderBy?: SavedCourseOrderByWithRelationInput | SavedCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SavedCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SavedCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SavedCourses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SavedCourses
    **/
    _count?: true | SavedCourseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SavedCourseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SavedCourseMaxAggregateInputType
  }

  export type GetSavedCourseAggregateType<T extends SavedCourseAggregateArgs> = {
        [P in keyof T & keyof AggregateSavedCourse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSavedCourse[P]>
      : GetScalarType<T[P], AggregateSavedCourse[P]>
  }




  export type SavedCourseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SavedCourseWhereInput
    orderBy?: SavedCourseOrderByWithAggregationInput | SavedCourseOrderByWithAggregationInput[]
    by: SavedCourseScalarFieldEnum[] | SavedCourseScalarFieldEnum
    having?: SavedCourseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SavedCourseCountAggregateInputType | true
    _min?: SavedCourseMinAggregateInputType
    _max?: SavedCourseMaxAggregateInputType
  }

  export type SavedCourseGroupByOutputType = {
    id: string
    userId: string
    courseId: string
    savedAt: Date
    _count: SavedCourseCountAggregateOutputType | null
    _min: SavedCourseMinAggregateOutputType | null
    _max: SavedCourseMaxAggregateOutputType | null
  }

  type GetSavedCourseGroupByPayload<T extends SavedCourseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SavedCourseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SavedCourseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SavedCourseGroupByOutputType[P]>
            : GetScalarType<T[P], SavedCourseGroupByOutputType[P]>
        }
      >
    >


  export type SavedCourseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    courseId?: boolean
    savedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["savedCourse"]>

  export type SavedCourseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    courseId?: boolean
    savedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["savedCourse"]>

  export type SavedCourseSelectScalar = {
    id?: boolean
    userId?: boolean
    courseId?: boolean
    savedAt?: boolean
  }

  export type SavedCourseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }
  export type SavedCourseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }

  export type $SavedCoursePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SavedCourse"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      course: Prisma.$CoursePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      courseId: string
      savedAt: Date
    }, ExtArgs["result"]["savedCourse"]>
    composites: {}
  }

  type SavedCourseGetPayload<S extends boolean | null | undefined | SavedCourseDefaultArgs> = $Result.GetResult<Prisma.$SavedCoursePayload, S>

  type SavedCourseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SavedCourseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SavedCourseCountAggregateInputType | true
    }

  export interface SavedCourseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SavedCourse'], meta: { name: 'SavedCourse' } }
    /**
     * Find zero or one SavedCourse that matches the filter.
     * @param {SavedCourseFindUniqueArgs} args - Arguments to find a SavedCourse
     * @example
     * // Get one SavedCourse
     * const savedCourse = await prisma.savedCourse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SavedCourseFindUniqueArgs>(args: SelectSubset<T, SavedCourseFindUniqueArgs<ExtArgs>>): Prisma__SavedCourseClient<$Result.GetResult<Prisma.$SavedCoursePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SavedCourse that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SavedCourseFindUniqueOrThrowArgs} args - Arguments to find a SavedCourse
     * @example
     * // Get one SavedCourse
     * const savedCourse = await prisma.savedCourse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SavedCourseFindUniqueOrThrowArgs>(args: SelectSubset<T, SavedCourseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SavedCourseClient<$Result.GetResult<Prisma.$SavedCoursePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SavedCourse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedCourseFindFirstArgs} args - Arguments to find a SavedCourse
     * @example
     * // Get one SavedCourse
     * const savedCourse = await prisma.savedCourse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SavedCourseFindFirstArgs>(args?: SelectSubset<T, SavedCourseFindFirstArgs<ExtArgs>>): Prisma__SavedCourseClient<$Result.GetResult<Prisma.$SavedCoursePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SavedCourse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedCourseFindFirstOrThrowArgs} args - Arguments to find a SavedCourse
     * @example
     * // Get one SavedCourse
     * const savedCourse = await prisma.savedCourse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SavedCourseFindFirstOrThrowArgs>(args?: SelectSubset<T, SavedCourseFindFirstOrThrowArgs<ExtArgs>>): Prisma__SavedCourseClient<$Result.GetResult<Prisma.$SavedCoursePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SavedCourses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedCourseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SavedCourses
     * const savedCourses = await prisma.savedCourse.findMany()
     * 
     * // Get first 10 SavedCourses
     * const savedCourses = await prisma.savedCourse.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const savedCourseWithIdOnly = await prisma.savedCourse.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SavedCourseFindManyArgs>(args?: SelectSubset<T, SavedCourseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SavedCoursePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SavedCourse.
     * @param {SavedCourseCreateArgs} args - Arguments to create a SavedCourse.
     * @example
     * // Create one SavedCourse
     * const SavedCourse = await prisma.savedCourse.create({
     *   data: {
     *     // ... data to create a SavedCourse
     *   }
     * })
     * 
     */
    create<T extends SavedCourseCreateArgs>(args: SelectSubset<T, SavedCourseCreateArgs<ExtArgs>>): Prisma__SavedCourseClient<$Result.GetResult<Prisma.$SavedCoursePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SavedCourses.
     * @param {SavedCourseCreateManyArgs} args - Arguments to create many SavedCourses.
     * @example
     * // Create many SavedCourses
     * const savedCourse = await prisma.savedCourse.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SavedCourseCreateManyArgs>(args?: SelectSubset<T, SavedCourseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SavedCourses and returns the data saved in the database.
     * @param {SavedCourseCreateManyAndReturnArgs} args - Arguments to create many SavedCourses.
     * @example
     * // Create many SavedCourses
     * const savedCourse = await prisma.savedCourse.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SavedCourses and only return the `id`
     * const savedCourseWithIdOnly = await prisma.savedCourse.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SavedCourseCreateManyAndReturnArgs>(args?: SelectSubset<T, SavedCourseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SavedCoursePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SavedCourse.
     * @param {SavedCourseDeleteArgs} args - Arguments to delete one SavedCourse.
     * @example
     * // Delete one SavedCourse
     * const SavedCourse = await prisma.savedCourse.delete({
     *   where: {
     *     // ... filter to delete one SavedCourse
     *   }
     * })
     * 
     */
    delete<T extends SavedCourseDeleteArgs>(args: SelectSubset<T, SavedCourseDeleteArgs<ExtArgs>>): Prisma__SavedCourseClient<$Result.GetResult<Prisma.$SavedCoursePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SavedCourse.
     * @param {SavedCourseUpdateArgs} args - Arguments to update one SavedCourse.
     * @example
     * // Update one SavedCourse
     * const savedCourse = await prisma.savedCourse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SavedCourseUpdateArgs>(args: SelectSubset<T, SavedCourseUpdateArgs<ExtArgs>>): Prisma__SavedCourseClient<$Result.GetResult<Prisma.$SavedCoursePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SavedCourses.
     * @param {SavedCourseDeleteManyArgs} args - Arguments to filter SavedCourses to delete.
     * @example
     * // Delete a few SavedCourses
     * const { count } = await prisma.savedCourse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SavedCourseDeleteManyArgs>(args?: SelectSubset<T, SavedCourseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SavedCourses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedCourseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SavedCourses
     * const savedCourse = await prisma.savedCourse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SavedCourseUpdateManyArgs>(args: SelectSubset<T, SavedCourseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SavedCourse.
     * @param {SavedCourseUpsertArgs} args - Arguments to update or create a SavedCourse.
     * @example
     * // Update or create a SavedCourse
     * const savedCourse = await prisma.savedCourse.upsert({
     *   create: {
     *     // ... data to create a SavedCourse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SavedCourse we want to update
     *   }
     * })
     */
    upsert<T extends SavedCourseUpsertArgs>(args: SelectSubset<T, SavedCourseUpsertArgs<ExtArgs>>): Prisma__SavedCourseClient<$Result.GetResult<Prisma.$SavedCoursePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SavedCourses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedCourseCountArgs} args - Arguments to filter SavedCourses to count.
     * @example
     * // Count the number of SavedCourses
     * const count = await prisma.savedCourse.count({
     *   where: {
     *     // ... the filter for the SavedCourses we want to count
     *   }
     * })
    **/
    count<T extends SavedCourseCountArgs>(
      args?: Subset<T, SavedCourseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SavedCourseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SavedCourse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedCourseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SavedCourseAggregateArgs>(args: Subset<T, SavedCourseAggregateArgs>): Prisma.PrismaPromise<GetSavedCourseAggregateType<T>>

    /**
     * Group by SavedCourse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedCourseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SavedCourseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SavedCourseGroupByArgs['orderBy'] }
        : { orderBy?: SavedCourseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SavedCourseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSavedCourseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SavedCourse model
   */
  readonly fields: SavedCourseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SavedCourse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SavedCourseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SavedCourse model
   */ 
  interface SavedCourseFieldRefs {
    readonly id: FieldRef<"SavedCourse", 'String'>
    readonly userId: FieldRef<"SavedCourse", 'String'>
    readonly courseId: FieldRef<"SavedCourse", 'String'>
    readonly savedAt: FieldRef<"SavedCourse", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SavedCourse findUnique
   */
  export type SavedCourseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedCourse
     */
    select?: SavedCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedCourseInclude<ExtArgs> | null
    /**
     * Filter, which SavedCourse to fetch.
     */
    where: SavedCourseWhereUniqueInput
  }

  /**
   * SavedCourse findUniqueOrThrow
   */
  export type SavedCourseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedCourse
     */
    select?: SavedCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedCourseInclude<ExtArgs> | null
    /**
     * Filter, which SavedCourse to fetch.
     */
    where: SavedCourseWhereUniqueInput
  }

  /**
   * SavedCourse findFirst
   */
  export type SavedCourseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedCourse
     */
    select?: SavedCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedCourseInclude<ExtArgs> | null
    /**
     * Filter, which SavedCourse to fetch.
     */
    where?: SavedCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SavedCourses to fetch.
     */
    orderBy?: SavedCourseOrderByWithRelationInput | SavedCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SavedCourses.
     */
    cursor?: SavedCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SavedCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SavedCourses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SavedCourses.
     */
    distinct?: SavedCourseScalarFieldEnum | SavedCourseScalarFieldEnum[]
  }

  /**
   * SavedCourse findFirstOrThrow
   */
  export type SavedCourseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedCourse
     */
    select?: SavedCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedCourseInclude<ExtArgs> | null
    /**
     * Filter, which SavedCourse to fetch.
     */
    where?: SavedCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SavedCourses to fetch.
     */
    orderBy?: SavedCourseOrderByWithRelationInput | SavedCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SavedCourses.
     */
    cursor?: SavedCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SavedCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SavedCourses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SavedCourses.
     */
    distinct?: SavedCourseScalarFieldEnum | SavedCourseScalarFieldEnum[]
  }

  /**
   * SavedCourse findMany
   */
  export type SavedCourseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedCourse
     */
    select?: SavedCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedCourseInclude<ExtArgs> | null
    /**
     * Filter, which SavedCourses to fetch.
     */
    where?: SavedCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SavedCourses to fetch.
     */
    orderBy?: SavedCourseOrderByWithRelationInput | SavedCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SavedCourses.
     */
    cursor?: SavedCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SavedCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SavedCourses.
     */
    skip?: number
    distinct?: SavedCourseScalarFieldEnum | SavedCourseScalarFieldEnum[]
  }

  /**
   * SavedCourse create
   */
  export type SavedCourseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedCourse
     */
    select?: SavedCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedCourseInclude<ExtArgs> | null
    /**
     * The data needed to create a SavedCourse.
     */
    data: XOR<SavedCourseCreateInput, SavedCourseUncheckedCreateInput>
  }

  /**
   * SavedCourse createMany
   */
  export type SavedCourseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SavedCourses.
     */
    data: SavedCourseCreateManyInput | SavedCourseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SavedCourse createManyAndReturn
   */
  export type SavedCourseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedCourse
     */
    select?: SavedCourseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SavedCourses.
     */
    data: SavedCourseCreateManyInput | SavedCourseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedCourseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SavedCourse update
   */
  export type SavedCourseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedCourse
     */
    select?: SavedCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedCourseInclude<ExtArgs> | null
    /**
     * The data needed to update a SavedCourse.
     */
    data: XOR<SavedCourseUpdateInput, SavedCourseUncheckedUpdateInput>
    /**
     * Choose, which SavedCourse to update.
     */
    where: SavedCourseWhereUniqueInput
  }

  /**
   * SavedCourse updateMany
   */
  export type SavedCourseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SavedCourses.
     */
    data: XOR<SavedCourseUpdateManyMutationInput, SavedCourseUncheckedUpdateManyInput>
    /**
     * Filter which SavedCourses to update
     */
    where?: SavedCourseWhereInput
  }

  /**
   * SavedCourse upsert
   */
  export type SavedCourseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedCourse
     */
    select?: SavedCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedCourseInclude<ExtArgs> | null
    /**
     * The filter to search for the SavedCourse to update in case it exists.
     */
    where: SavedCourseWhereUniqueInput
    /**
     * In case the SavedCourse found by the `where` argument doesn't exist, create a new SavedCourse with this data.
     */
    create: XOR<SavedCourseCreateInput, SavedCourseUncheckedCreateInput>
    /**
     * In case the SavedCourse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SavedCourseUpdateInput, SavedCourseUncheckedUpdateInput>
  }

  /**
   * SavedCourse delete
   */
  export type SavedCourseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedCourse
     */
    select?: SavedCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedCourseInclude<ExtArgs> | null
    /**
     * Filter which SavedCourse to delete.
     */
    where: SavedCourseWhereUniqueInput
  }

  /**
   * SavedCourse deleteMany
   */
  export type SavedCourseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SavedCourses to delete
     */
    where?: SavedCourseWhereInput
  }

  /**
   * SavedCourse without action
   */
  export type SavedCourseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedCourse
     */
    select?: SavedCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedCourseInclude<ExtArgs> | null
  }


  /**
   * Model LikedCourse
   */

  export type AggregateLikedCourse = {
    _count: LikedCourseCountAggregateOutputType | null
    _min: LikedCourseMinAggregateOutputType | null
    _max: LikedCourseMaxAggregateOutputType | null
  }

  export type LikedCourseMinAggregateOutputType = {
    id: string | null
    userId: string | null
    courseId: string | null
    likedAt: Date | null
  }

  export type LikedCourseMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    courseId: string | null
    likedAt: Date | null
  }

  export type LikedCourseCountAggregateOutputType = {
    id: number
    userId: number
    courseId: number
    likedAt: number
    _all: number
  }


  export type LikedCourseMinAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    likedAt?: true
  }

  export type LikedCourseMaxAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    likedAt?: true
  }

  export type LikedCourseCountAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    likedAt?: true
    _all?: true
  }

  export type LikedCourseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LikedCourse to aggregate.
     */
    where?: LikedCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LikedCourses to fetch.
     */
    orderBy?: LikedCourseOrderByWithRelationInput | LikedCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LikedCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LikedCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LikedCourses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LikedCourses
    **/
    _count?: true | LikedCourseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LikedCourseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LikedCourseMaxAggregateInputType
  }

  export type GetLikedCourseAggregateType<T extends LikedCourseAggregateArgs> = {
        [P in keyof T & keyof AggregateLikedCourse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLikedCourse[P]>
      : GetScalarType<T[P], AggregateLikedCourse[P]>
  }




  export type LikedCourseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LikedCourseWhereInput
    orderBy?: LikedCourseOrderByWithAggregationInput | LikedCourseOrderByWithAggregationInput[]
    by: LikedCourseScalarFieldEnum[] | LikedCourseScalarFieldEnum
    having?: LikedCourseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LikedCourseCountAggregateInputType | true
    _min?: LikedCourseMinAggregateInputType
    _max?: LikedCourseMaxAggregateInputType
  }

  export type LikedCourseGroupByOutputType = {
    id: string
    userId: string
    courseId: string
    likedAt: Date
    _count: LikedCourseCountAggregateOutputType | null
    _min: LikedCourseMinAggregateOutputType | null
    _max: LikedCourseMaxAggregateOutputType | null
  }

  type GetLikedCourseGroupByPayload<T extends LikedCourseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LikedCourseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LikedCourseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LikedCourseGroupByOutputType[P]>
            : GetScalarType<T[P], LikedCourseGroupByOutputType[P]>
        }
      >
    >


  export type LikedCourseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    courseId?: boolean
    likedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["likedCourse"]>

  export type LikedCourseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    courseId?: boolean
    likedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["likedCourse"]>

  export type LikedCourseSelectScalar = {
    id?: boolean
    userId?: boolean
    courseId?: boolean
    likedAt?: boolean
  }

  export type LikedCourseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }
  export type LikedCourseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }

  export type $LikedCoursePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LikedCourse"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      course: Prisma.$CoursePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      courseId: string
      likedAt: Date
    }, ExtArgs["result"]["likedCourse"]>
    composites: {}
  }

  type LikedCourseGetPayload<S extends boolean | null | undefined | LikedCourseDefaultArgs> = $Result.GetResult<Prisma.$LikedCoursePayload, S>

  type LikedCourseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LikedCourseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LikedCourseCountAggregateInputType | true
    }

  export interface LikedCourseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LikedCourse'], meta: { name: 'LikedCourse' } }
    /**
     * Find zero or one LikedCourse that matches the filter.
     * @param {LikedCourseFindUniqueArgs} args - Arguments to find a LikedCourse
     * @example
     * // Get one LikedCourse
     * const likedCourse = await prisma.likedCourse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LikedCourseFindUniqueArgs>(args: SelectSubset<T, LikedCourseFindUniqueArgs<ExtArgs>>): Prisma__LikedCourseClient<$Result.GetResult<Prisma.$LikedCoursePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LikedCourse that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LikedCourseFindUniqueOrThrowArgs} args - Arguments to find a LikedCourse
     * @example
     * // Get one LikedCourse
     * const likedCourse = await prisma.likedCourse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LikedCourseFindUniqueOrThrowArgs>(args: SelectSubset<T, LikedCourseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LikedCourseClient<$Result.GetResult<Prisma.$LikedCoursePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LikedCourse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikedCourseFindFirstArgs} args - Arguments to find a LikedCourse
     * @example
     * // Get one LikedCourse
     * const likedCourse = await prisma.likedCourse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LikedCourseFindFirstArgs>(args?: SelectSubset<T, LikedCourseFindFirstArgs<ExtArgs>>): Prisma__LikedCourseClient<$Result.GetResult<Prisma.$LikedCoursePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LikedCourse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikedCourseFindFirstOrThrowArgs} args - Arguments to find a LikedCourse
     * @example
     * // Get one LikedCourse
     * const likedCourse = await prisma.likedCourse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LikedCourseFindFirstOrThrowArgs>(args?: SelectSubset<T, LikedCourseFindFirstOrThrowArgs<ExtArgs>>): Prisma__LikedCourseClient<$Result.GetResult<Prisma.$LikedCoursePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LikedCourses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikedCourseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LikedCourses
     * const likedCourses = await prisma.likedCourse.findMany()
     * 
     * // Get first 10 LikedCourses
     * const likedCourses = await prisma.likedCourse.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const likedCourseWithIdOnly = await prisma.likedCourse.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LikedCourseFindManyArgs>(args?: SelectSubset<T, LikedCourseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LikedCoursePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LikedCourse.
     * @param {LikedCourseCreateArgs} args - Arguments to create a LikedCourse.
     * @example
     * // Create one LikedCourse
     * const LikedCourse = await prisma.likedCourse.create({
     *   data: {
     *     // ... data to create a LikedCourse
     *   }
     * })
     * 
     */
    create<T extends LikedCourseCreateArgs>(args: SelectSubset<T, LikedCourseCreateArgs<ExtArgs>>): Prisma__LikedCourseClient<$Result.GetResult<Prisma.$LikedCoursePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LikedCourses.
     * @param {LikedCourseCreateManyArgs} args - Arguments to create many LikedCourses.
     * @example
     * // Create many LikedCourses
     * const likedCourse = await prisma.likedCourse.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LikedCourseCreateManyArgs>(args?: SelectSubset<T, LikedCourseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LikedCourses and returns the data saved in the database.
     * @param {LikedCourseCreateManyAndReturnArgs} args - Arguments to create many LikedCourses.
     * @example
     * // Create many LikedCourses
     * const likedCourse = await prisma.likedCourse.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LikedCourses and only return the `id`
     * const likedCourseWithIdOnly = await prisma.likedCourse.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LikedCourseCreateManyAndReturnArgs>(args?: SelectSubset<T, LikedCourseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LikedCoursePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a LikedCourse.
     * @param {LikedCourseDeleteArgs} args - Arguments to delete one LikedCourse.
     * @example
     * // Delete one LikedCourse
     * const LikedCourse = await prisma.likedCourse.delete({
     *   where: {
     *     // ... filter to delete one LikedCourse
     *   }
     * })
     * 
     */
    delete<T extends LikedCourseDeleteArgs>(args: SelectSubset<T, LikedCourseDeleteArgs<ExtArgs>>): Prisma__LikedCourseClient<$Result.GetResult<Prisma.$LikedCoursePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LikedCourse.
     * @param {LikedCourseUpdateArgs} args - Arguments to update one LikedCourse.
     * @example
     * // Update one LikedCourse
     * const likedCourse = await prisma.likedCourse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LikedCourseUpdateArgs>(args: SelectSubset<T, LikedCourseUpdateArgs<ExtArgs>>): Prisma__LikedCourseClient<$Result.GetResult<Prisma.$LikedCoursePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LikedCourses.
     * @param {LikedCourseDeleteManyArgs} args - Arguments to filter LikedCourses to delete.
     * @example
     * // Delete a few LikedCourses
     * const { count } = await prisma.likedCourse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LikedCourseDeleteManyArgs>(args?: SelectSubset<T, LikedCourseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LikedCourses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikedCourseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LikedCourses
     * const likedCourse = await prisma.likedCourse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LikedCourseUpdateManyArgs>(args: SelectSubset<T, LikedCourseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LikedCourse.
     * @param {LikedCourseUpsertArgs} args - Arguments to update or create a LikedCourse.
     * @example
     * // Update or create a LikedCourse
     * const likedCourse = await prisma.likedCourse.upsert({
     *   create: {
     *     // ... data to create a LikedCourse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LikedCourse we want to update
     *   }
     * })
     */
    upsert<T extends LikedCourseUpsertArgs>(args: SelectSubset<T, LikedCourseUpsertArgs<ExtArgs>>): Prisma__LikedCourseClient<$Result.GetResult<Prisma.$LikedCoursePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LikedCourses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikedCourseCountArgs} args - Arguments to filter LikedCourses to count.
     * @example
     * // Count the number of LikedCourses
     * const count = await prisma.likedCourse.count({
     *   where: {
     *     // ... the filter for the LikedCourses we want to count
     *   }
     * })
    **/
    count<T extends LikedCourseCountArgs>(
      args?: Subset<T, LikedCourseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LikedCourseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LikedCourse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikedCourseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LikedCourseAggregateArgs>(args: Subset<T, LikedCourseAggregateArgs>): Prisma.PrismaPromise<GetLikedCourseAggregateType<T>>

    /**
     * Group by LikedCourse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikedCourseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LikedCourseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LikedCourseGroupByArgs['orderBy'] }
        : { orderBy?: LikedCourseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LikedCourseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLikedCourseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LikedCourse model
   */
  readonly fields: LikedCourseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LikedCourse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LikedCourseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LikedCourse model
   */ 
  interface LikedCourseFieldRefs {
    readonly id: FieldRef<"LikedCourse", 'String'>
    readonly userId: FieldRef<"LikedCourse", 'String'>
    readonly courseId: FieldRef<"LikedCourse", 'String'>
    readonly likedAt: FieldRef<"LikedCourse", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LikedCourse findUnique
   */
  export type LikedCourseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikedCourse
     */
    select?: LikedCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikedCourseInclude<ExtArgs> | null
    /**
     * Filter, which LikedCourse to fetch.
     */
    where: LikedCourseWhereUniqueInput
  }

  /**
   * LikedCourse findUniqueOrThrow
   */
  export type LikedCourseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikedCourse
     */
    select?: LikedCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikedCourseInclude<ExtArgs> | null
    /**
     * Filter, which LikedCourse to fetch.
     */
    where: LikedCourseWhereUniqueInput
  }

  /**
   * LikedCourse findFirst
   */
  export type LikedCourseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikedCourse
     */
    select?: LikedCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikedCourseInclude<ExtArgs> | null
    /**
     * Filter, which LikedCourse to fetch.
     */
    where?: LikedCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LikedCourses to fetch.
     */
    orderBy?: LikedCourseOrderByWithRelationInput | LikedCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LikedCourses.
     */
    cursor?: LikedCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LikedCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LikedCourses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LikedCourses.
     */
    distinct?: LikedCourseScalarFieldEnum | LikedCourseScalarFieldEnum[]
  }

  /**
   * LikedCourse findFirstOrThrow
   */
  export type LikedCourseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikedCourse
     */
    select?: LikedCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikedCourseInclude<ExtArgs> | null
    /**
     * Filter, which LikedCourse to fetch.
     */
    where?: LikedCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LikedCourses to fetch.
     */
    orderBy?: LikedCourseOrderByWithRelationInput | LikedCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LikedCourses.
     */
    cursor?: LikedCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LikedCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LikedCourses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LikedCourses.
     */
    distinct?: LikedCourseScalarFieldEnum | LikedCourseScalarFieldEnum[]
  }

  /**
   * LikedCourse findMany
   */
  export type LikedCourseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikedCourse
     */
    select?: LikedCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikedCourseInclude<ExtArgs> | null
    /**
     * Filter, which LikedCourses to fetch.
     */
    where?: LikedCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LikedCourses to fetch.
     */
    orderBy?: LikedCourseOrderByWithRelationInput | LikedCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LikedCourses.
     */
    cursor?: LikedCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LikedCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LikedCourses.
     */
    skip?: number
    distinct?: LikedCourseScalarFieldEnum | LikedCourseScalarFieldEnum[]
  }

  /**
   * LikedCourse create
   */
  export type LikedCourseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikedCourse
     */
    select?: LikedCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikedCourseInclude<ExtArgs> | null
    /**
     * The data needed to create a LikedCourse.
     */
    data: XOR<LikedCourseCreateInput, LikedCourseUncheckedCreateInput>
  }

  /**
   * LikedCourse createMany
   */
  export type LikedCourseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LikedCourses.
     */
    data: LikedCourseCreateManyInput | LikedCourseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LikedCourse createManyAndReturn
   */
  export type LikedCourseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikedCourse
     */
    select?: LikedCourseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many LikedCourses.
     */
    data: LikedCourseCreateManyInput | LikedCourseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikedCourseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LikedCourse update
   */
  export type LikedCourseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikedCourse
     */
    select?: LikedCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikedCourseInclude<ExtArgs> | null
    /**
     * The data needed to update a LikedCourse.
     */
    data: XOR<LikedCourseUpdateInput, LikedCourseUncheckedUpdateInput>
    /**
     * Choose, which LikedCourse to update.
     */
    where: LikedCourseWhereUniqueInput
  }

  /**
   * LikedCourse updateMany
   */
  export type LikedCourseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LikedCourses.
     */
    data: XOR<LikedCourseUpdateManyMutationInput, LikedCourseUncheckedUpdateManyInput>
    /**
     * Filter which LikedCourses to update
     */
    where?: LikedCourseWhereInput
  }

  /**
   * LikedCourse upsert
   */
  export type LikedCourseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikedCourse
     */
    select?: LikedCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikedCourseInclude<ExtArgs> | null
    /**
     * The filter to search for the LikedCourse to update in case it exists.
     */
    where: LikedCourseWhereUniqueInput
    /**
     * In case the LikedCourse found by the `where` argument doesn't exist, create a new LikedCourse with this data.
     */
    create: XOR<LikedCourseCreateInput, LikedCourseUncheckedCreateInput>
    /**
     * In case the LikedCourse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LikedCourseUpdateInput, LikedCourseUncheckedUpdateInput>
  }

  /**
   * LikedCourse delete
   */
  export type LikedCourseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikedCourse
     */
    select?: LikedCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikedCourseInclude<ExtArgs> | null
    /**
     * Filter which LikedCourse to delete.
     */
    where: LikedCourseWhereUniqueInput
  }

  /**
   * LikedCourse deleteMany
   */
  export type LikedCourseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LikedCourses to delete
     */
    where?: LikedCourseWhereInput
  }

  /**
   * LikedCourse without action
   */
  export type LikedCourseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikedCourse
     */
    select?: LikedCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikedCourseInclude<ExtArgs> | null
  }


  /**
   * Model LessonProgress
   */

  export type AggregateLessonProgress = {
    _count: LessonProgressCountAggregateOutputType | null
    _avg: LessonProgressAvgAggregateOutputType | null
    _sum: LessonProgressSumAggregateOutputType | null
    _min: LessonProgressMinAggregateOutputType | null
    _max: LessonProgressMaxAggregateOutputType | null
  }

  export type LessonProgressAvgAggregateOutputType = {
    lastPosition: number | null
  }

  export type LessonProgressSumAggregateOutputType = {
    lastPosition: number | null
  }

  export type LessonProgressMinAggregateOutputType = {
    id: string | null
    userId: string | null
    lessonId: string | null
    completed: boolean | null
    completedAt: Date | null
    lastPosition: number | null
  }

  export type LessonProgressMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    lessonId: string | null
    completed: boolean | null
    completedAt: Date | null
    lastPosition: number | null
  }

  export type LessonProgressCountAggregateOutputType = {
    id: number
    userId: number
    lessonId: number
    completed: number
    completedAt: number
    lastPosition: number
    _all: number
  }


  export type LessonProgressAvgAggregateInputType = {
    lastPosition?: true
  }

  export type LessonProgressSumAggregateInputType = {
    lastPosition?: true
  }

  export type LessonProgressMinAggregateInputType = {
    id?: true
    userId?: true
    lessonId?: true
    completed?: true
    completedAt?: true
    lastPosition?: true
  }

  export type LessonProgressMaxAggregateInputType = {
    id?: true
    userId?: true
    lessonId?: true
    completed?: true
    completedAt?: true
    lastPosition?: true
  }

  export type LessonProgressCountAggregateInputType = {
    id?: true
    userId?: true
    lessonId?: true
    completed?: true
    completedAt?: true
    lastPosition?: true
    _all?: true
  }

  export type LessonProgressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LessonProgress to aggregate.
     */
    where?: LessonProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LessonProgresses to fetch.
     */
    orderBy?: LessonProgressOrderByWithRelationInput | LessonProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LessonProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LessonProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LessonProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LessonProgresses
    **/
    _count?: true | LessonProgressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LessonProgressAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LessonProgressSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LessonProgressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LessonProgressMaxAggregateInputType
  }

  export type GetLessonProgressAggregateType<T extends LessonProgressAggregateArgs> = {
        [P in keyof T & keyof AggregateLessonProgress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLessonProgress[P]>
      : GetScalarType<T[P], AggregateLessonProgress[P]>
  }




  export type LessonProgressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonProgressWhereInput
    orderBy?: LessonProgressOrderByWithAggregationInput | LessonProgressOrderByWithAggregationInput[]
    by: LessonProgressScalarFieldEnum[] | LessonProgressScalarFieldEnum
    having?: LessonProgressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LessonProgressCountAggregateInputType | true
    _avg?: LessonProgressAvgAggregateInputType
    _sum?: LessonProgressSumAggregateInputType
    _min?: LessonProgressMinAggregateInputType
    _max?: LessonProgressMaxAggregateInputType
  }

  export type LessonProgressGroupByOutputType = {
    id: string
    userId: string
    lessonId: string
    completed: boolean
    completedAt: Date | null
    lastPosition: number
    _count: LessonProgressCountAggregateOutputType | null
    _avg: LessonProgressAvgAggregateOutputType | null
    _sum: LessonProgressSumAggregateOutputType | null
    _min: LessonProgressMinAggregateOutputType | null
    _max: LessonProgressMaxAggregateOutputType | null
  }

  type GetLessonProgressGroupByPayload<T extends LessonProgressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LessonProgressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LessonProgressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LessonProgressGroupByOutputType[P]>
            : GetScalarType<T[P], LessonProgressGroupByOutputType[P]>
        }
      >
    >


  export type LessonProgressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    lessonId?: boolean
    completed?: boolean
    completedAt?: boolean
    lastPosition?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lessonProgress"]>

  export type LessonProgressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    lessonId?: boolean
    completed?: boolean
    completedAt?: boolean
    lastPosition?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lessonProgress"]>

  export type LessonProgressSelectScalar = {
    id?: boolean
    userId?: boolean
    lessonId?: boolean
    completed?: boolean
    completedAt?: boolean
    lastPosition?: boolean
  }

  export type LessonProgressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
  }
  export type LessonProgressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
  }

  export type $LessonProgressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LessonProgress"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      lesson: Prisma.$LessonPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      lessonId: string
      completed: boolean
      completedAt: Date | null
      lastPosition: number
    }, ExtArgs["result"]["lessonProgress"]>
    composites: {}
  }

  type LessonProgressGetPayload<S extends boolean | null | undefined | LessonProgressDefaultArgs> = $Result.GetResult<Prisma.$LessonProgressPayload, S>

  type LessonProgressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LessonProgressFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LessonProgressCountAggregateInputType | true
    }

  export interface LessonProgressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LessonProgress'], meta: { name: 'LessonProgress' } }
    /**
     * Find zero or one LessonProgress that matches the filter.
     * @param {LessonProgressFindUniqueArgs} args - Arguments to find a LessonProgress
     * @example
     * // Get one LessonProgress
     * const lessonProgress = await prisma.lessonProgress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LessonProgressFindUniqueArgs>(args: SelectSubset<T, LessonProgressFindUniqueArgs<ExtArgs>>): Prisma__LessonProgressClient<$Result.GetResult<Prisma.$LessonProgressPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LessonProgress that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LessonProgressFindUniqueOrThrowArgs} args - Arguments to find a LessonProgress
     * @example
     * // Get one LessonProgress
     * const lessonProgress = await prisma.lessonProgress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LessonProgressFindUniqueOrThrowArgs>(args: SelectSubset<T, LessonProgressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LessonProgressClient<$Result.GetResult<Prisma.$LessonProgressPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LessonProgress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonProgressFindFirstArgs} args - Arguments to find a LessonProgress
     * @example
     * // Get one LessonProgress
     * const lessonProgress = await prisma.lessonProgress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LessonProgressFindFirstArgs>(args?: SelectSubset<T, LessonProgressFindFirstArgs<ExtArgs>>): Prisma__LessonProgressClient<$Result.GetResult<Prisma.$LessonProgressPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LessonProgress that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonProgressFindFirstOrThrowArgs} args - Arguments to find a LessonProgress
     * @example
     * // Get one LessonProgress
     * const lessonProgress = await prisma.lessonProgress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LessonProgressFindFirstOrThrowArgs>(args?: SelectSubset<T, LessonProgressFindFirstOrThrowArgs<ExtArgs>>): Prisma__LessonProgressClient<$Result.GetResult<Prisma.$LessonProgressPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LessonProgresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonProgressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LessonProgresses
     * const lessonProgresses = await prisma.lessonProgress.findMany()
     * 
     * // Get first 10 LessonProgresses
     * const lessonProgresses = await prisma.lessonProgress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lessonProgressWithIdOnly = await prisma.lessonProgress.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LessonProgressFindManyArgs>(args?: SelectSubset<T, LessonProgressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonProgressPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LessonProgress.
     * @param {LessonProgressCreateArgs} args - Arguments to create a LessonProgress.
     * @example
     * // Create one LessonProgress
     * const LessonProgress = await prisma.lessonProgress.create({
     *   data: {
     *     // ... data to create a LessonProgress
     *   }
     * })
     * 
     */
    create<T extends LessonProgressCreateArgs>(args: SelectSubset<T, LessonProgressCreateArgs<ExtArgs>>): Prisma__LessonProgressClient<$Result.GetResult<Prisma.$LessonProgressPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LessonProgresses.
     * @param {LessonProgressCreateManyArgs} args - Arguments to create many LessonProgresses.
     * @example
     * // Create many LessonProgresses
     * const lessonProgress = await prisma.lessonProgress.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LessonProgressCreateManyArgs>(args?: SelectSubset<T, LessonProgressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LessonProgresses and returns the data saved in the database.
     * @param {LessonProgressCreateManyAndReturnArgs} args - Arguments to create many LessonProgresses.
     * @example
     * // Create many LessonProgresses
     * const lessonProgress = await prisma.lessonProgress.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LessonProgresses and only return the `id`
     * const lessonProgressWithIdOnly = await prisma.lessonProgress.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LessonProgressCreateManyAndReturnArgs>(args?: SelectSubset<T, LessonProgressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonProgressPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a LessonProgress.
     * @param {LessonProgressDeleteArgs} args - Arguments to delete one LessonProgress.
     * @example
     * // Delete one LessonProgress
     * const LessonProgress = await prisma.lessonProgress.delete({
     *   where: {
     *     // ... filter to delete one LessonProgress
     *   }
     * })
     * 
     */
    delete<T extends LessonProgressDeleteArgs>(args: SelectSubset<T, LessonProgressDeleteArgs<ExtArgs>>): Prisma__LessonProgressClient<$Result.GetResult<Prisma.$LessonProgressPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LessonProgress.
     * @param {LessonProgressUpdateArgs} args - Arguments to update one LessonProgress.
     * @example
     * // Update one LessonProgress
     * const lessonProgress = await prisma.lessonProgress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LessonProgressUpdateArgs>(args: SelectSubset<T, LessonProgressUpdateArgs<ExtArgs>>): Prisma__LessonProgressClient<$Result.GetResult<Prisma.$LessonProgressPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LessonProgresses.
     * @param {LessonProgressDeleteManyArgs} args - Arguments to filter LessonProgresses to delete.
     * @example
     * // Delete a few LessonProgresses
     * const { count } = await prisma.lessonProgress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LessonProgressDeleteManyArgs>(args?: SelectSubset<T, LessonProgressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LessonProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonProgressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LessonProgresses
     * const lessonProgress = await prisma.lessonProgress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LessonProgressUpdateManyArgs>(args: SelectSubset<T, LessonProgressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LessonProgress.
     * @param {LessonProgressUpsertArgs} args - Arguments to update or create a LessonProgress.
     * @example
     * // Update or create a LessonProgress
     * const lessonProgress = await prisma.lessonProgress.upsert({
     *   create: {
     *     // ... data to create a LessonProgress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LessonProgress we want to update
     *   }
     * })
     */
    upsert<T extends LessonProgressUpsertArgs>(args: SelectSubset<T, LessonProgressUpsertArgs<ExtArgs>>): Prisma__LessonProgressClient<$Result.GetResult<Prisma.$LessonProgressPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LessonProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonProgressCountArgs} args - Arguments to filter LessonProgresses to count.
     * @example
     * // Count the number of LessonProgresses
     * const count = await prisma.lessonProgress.count({
     *   where: {
     *     // ... the filter for the LessonProgresses we want to count
     *   }
     * })
    **/
    count<T extends LessonProgressCountArgs>(
      args?: Subset<T, LessonProgressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LessonProgressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LessonProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonProgressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LessonProgressAggregateArgs>(args: Subset<T, LessonProgressAggregateArgs>): Prisma.PrismaPromise<GetLessonProgressAggregateType<T>>

    /**
     * Group by LessonProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonProgressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LessonProgressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LessonProgressGroupByArgs['orderBy'] }
        : { orderBy?: LessonProgressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LessonProgressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLessonProgressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LessonProgress model
   */
  readonly fields: LessonProgressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LessonProgress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LessonProgressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    lesson<T extends LessonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LessonDefaultArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LessonProgress model
   */ 
  interface LessonProgressFieldRefs {
    readonly id: FieldRef<"LessonProgress", 'String'>
    readonly userId: FieldRef<"LessonProgress", 'String'>
    readonly lessonId: FieldRef<"LessonProgress", 'String'>
    readonly completed: FieldRef<"LessonProgress", 'Boolean'>
    readonly completedAt: FieldRef<"LessonProgress", 'DateTime'>
    readonly lastPosition: FieldRef<"LessonProgress", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * LessonProgress findUnique
   */
  export type LessonProgressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonProgress
     */
    select?: LessonProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonProgressInclude<ExtArgs> | null
    /**
     * Filter, which LessonProgress to fetch.
     */
    where: LessonProgressWhereUniqueInput
  }

  /**
   * LessonProgress findUniqueOrThrow
   */
  export type LessonProgressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonProgress
     */
    select?: LessonProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonProgressInclude<ExtArgs> | null
    /**
     * Filter, which LessonProgress to fetch.
     */
    where: LessonProgressWhereUniqueInput
  }

  /**
   * LessonProgress findFirst
   */
  export type LessonProgressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonProgress
     */
    select?: LessonProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonProgressInclude<ExtArgs> | null
    /**
     * Filter, which LessonProgress to fetch.
     */
    where?: LessonProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LessonProgresses to fetch.
     */
    orderBy?: LessonProgressOrderByWithRelationInput | LessonProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LessonProgresses.
     */
    cursor?: LessonProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LessonProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LessonProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LessonProgresses.
     */
    distinct?: LessonProgressScalarFieldEnum | LessonProgressScalarFieldEnum[]
  }

  /**
   * LessonProgress findFirstOrThrow
   */
  export type LessonProgressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonProgress
     */
    select?: LessonProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonProgressInclude<ExtArgs> | null
    /**
     * Filter, which LessonProgress to fetch.
     */
    where?: LessonProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LessonProgresses to fetch.
     */
    orderBy?: LessonProgressOrderByWithRelationInput | LessonProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LessonProgresses.
     */
    cursor?: LessonProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LessonProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LessonProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LessonProgresses.
     */
    distinct?: LessonProgressScalarFieldEnum | LessonProgressScalarFieldEnum[]
  }

  /**
   * LessonProgress findMany
   */
  export type LessonProgressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonProgress
     */
    select?: LessonProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonProgressInclude<ExtArgs> | null
    /**
     * Filter, which LessonProgresses to fetch.
     */
    where?: LessonProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LessonProgresses to fetch.
     */
    orderBy?: LessonProgressOrderByWithRelationInput | LessonProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LessonProgresses.
     */
    cursor?: LessonProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LessonProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LessonProgresses.
     */
    skip?: number
    distinct?: LessonProgressScalarFieldEnum | LessonProgressScalarFieldEnum[]
  }

  /**
   * LessonProgress create
   */
  export type LessonProgressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonProgress
     */
    select?: LessonProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonProgressInclude<ExtArgs> | null
    /**
     * The data needed to create a LessonProgress.
     */
    data: XOR<LessonProgressCreateInput, LessonProgressUncheckedCreateInput>
  }

  /**
   * LessonProgress createMany
   */
  export type LessonProgressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LessonProgresses.
     */
    data: LessonProgressCreateManyInput | LessonProgressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LessonProgress createManyAndReturn
   */
  export type LessonProgressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonProgress
     */
    select?: LessonProgressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many LessonProgresses.
     */
    data: LessonProgressCreateManyInput | LessonProgressCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonProgressIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LessonProgress update
   */
  export type LessonProgressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonProgress
     */
    select?: LessonProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonProgressInclude<ExtArgs> | null
    /**
     * The data needed to update a LessonProgress.
     */
    data: XOR<LessonProgressUpdateInput, LessonProgressUncheckedUpdateInput>
    /**
     * Choose, which LessonProgress to update.
     */
    where: LessonProgressWhereUniqueInput
  }

  /**
   * LessonProgress updateMany
   */
  export type LessonProgressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LessonProgresses.
     */
    data: XOR<LessonProgressUpdateManyMutationInput, LessonProgressUncheckedUpdateManyInput>
    /**
     * Filter which LessonProgresses to update
     */
    where?: LessonProgressWhereInput
  }

  /**
   * LessonProgress upsert
   */
  export type LessonProgressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonProgress
     */
    select?: LessonProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonProgressInclude<ExtArgs> | null
    /**
     * The filter to search for the LessonProgress to update in case it exists.
     */
    where: LessonProgressWhereUniqueInput
    /**
     * In case the LessonProgress found by the `where` argument doesn't exist, create a new LessonProgress with this data.
     */
    create: XOR<LessonProgressCreateInput, LessonProgressUncheckedCreateInput>
    /**
     * In case the LessonProgress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LessonProgressUpdateInput, LessonProgressUncheckedUpdateInput>
  }

  /**
   * LessonProgress delete
   */
  export type LessonProgressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonProgress
     */
    select?: LessonProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonProgressInclude<ExtArgs> | null
    /**
     * Filter which LessonProgress to delete.
     */
    where: LessonProgressWhereUniqueInput
  }

  /**
   * LessonProgress deleteMany
   */
  export type LessonProgressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LessonProgresses to delete
     */
    where?: LessonProgressWhereInput
  }

  /**
   * LessonProgress without action
   */
  export type LessonProgressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonProgress
     */
    select?: LessonProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonProgressInclude<ExtArgs> | null
  }


  /**
   * Model QuizAttempt
   */

  export type AggregateQuizAttempt = {
    _count: QuizAttemptCountAggregateOutputType | null
    _avg: QuizAttemptAvgAggregateOutputType | null
    _sum: QuizAttemptSumAggregateOutputType | null
    _min: QuizAttemptMinAggregateOutputType | null
    _max: QuizAttemptMaxAggregateOutputType | null
  }

  export type QuizAttemptAvgAggregateOutputType = {
    score: number | null
    duration: number | null
  }

  export type QuizAttemptSumAggregateOutputType = {
    score: number | null
    duration: number | null
  }

  export type QuizAttemptMinAggregateOutputType = {
    id: string | null
    userId: string | null
    quizId: string | null
    score: number | null
    duration: number | null
    completedAt: Date | null
    courseId: string | null
  }

  export type QuizAttemptMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    quizId: string | null
    score: number | null
    duration: number | null
    completedAt: Date | null
    courseId: string | null
  }

  export type QuizAttemptCountAggregateOutputType = {
    id: number
    userId: number
    quizId: number
    score: number
    duration: number
    completedAt: number
    answers: number
    courseId: number
    _all: number
  }


  export type QuizAttemptAvgAggregateInputType = {
    score?: true
    duration?: true
  }

  export type QuizAttemptSumAggregateInputType = {
    score?: true
    duration?: true
  }

  export type QuizAttemptMinAggregateInputType = {
    id?: true
    userId?: true
    quizId?: true
    score?: true
    duration?: true
    completedAt?: true
    courseId?: true
  }

  export type QuizAttemptMaxAggregateInputType = {
    id?: true
    userId?: true
    quizId?: true
    score?: true
    duration?: true
    completedAt?: true
    courseId?: true
  }

  export type QuizAttemptCountAggregateInputType = {
    id?: true
    userId?: true
    quizId?: true
    score?: true
    duration?: true
    completedAt?: true
    answers?: true
    courseId?: true
    _all?: true
  }

  export type QuizAttemptAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizAttempt to aggregate.
     */
    where?: QuizAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizAttempts to fetch.
     */
    orderBy?: QuizAttemptOrderByWithRelationInput | QuizAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuizAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuizAttempts
    **/
    _count?: true | QuizAttemptCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuizAttemptAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuizAttemptSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuizAttemptMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuizAttemptMaxAggregateInputType
  }

  export type GetQuizAttemptAggregateType<T extends QuizAttemptAggregateArgs> = {
        [P in keyof T & keyof AggregateQuizAttempt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuizAttempt[P]>
      : GetScalarType<T[P], AggregateQuizAttempt[P]>
  }




  export type QuizAttemptGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizAttemptWhereInput
    orderBy?: QuizAttemptOrderByWithAggregationInput | QuizAttemptOrderByWithAggregationInput[]
    by: QuizAttemptScalarFieldEnum[] | QuizAttemptScalarFieldEnum
    having?: QuizAttemptScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuizAttemptCountAggregateInputType | true
    _avg?: QuizAttemptAvgAggregateInputType
    _sum?: QuizAttemptSumAggregateInputType
    _min?: QuizAttemptMinAggregateInputType
    _max?: QuizAttemptMaxAggregateInputType
  }

  export type QuizAttemptGroupByOutputType = {
    id: string
    userId: string
    quizId: string
    score: number
    duration: number | null
    completedAt: Date
    answers: JsonValue
    courseId: string | null
    _count: QuizAttemptCountAggregateOutputType | null
    _avg: QuizAttemptAvgAggregateOutputType | null
    _sum: QuizAttemptSumAggregateOutputType | null
    _min: QuizAttemptMinAggregateOutputType | null
    _max: QuizAttemptMaxAggregateOutputType | null
  }

  type GetQuizAttemptGroupByPayload<T extends QuizAttemptGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuizAttemptGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuizAttemptGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuizAttemptGroupByOutputType[P]>
            : GetScalarType<T[P], QuizAttemptGroupByOutputType[P]>
        }
      >
    >


  export type QuizAttemptSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    quizId?: boolean
    score?: boolean
    duration?: boolean
    completedAt?: boolean
    answers?: boolean
    courseId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
    course?: boolean | QuizAttempt$courseArgs<ExtArgs>
  }, ExtArgs["result"]["quizAttempt"]>

  export type QuizAttemptSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    quizId?: boolean
    score?: boolean
    duration?: boolean
    completedAt?: boolean
    answers?: boolean
    courseId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
    course?: boolean | QuizAttempt$courseArgs<ExtArgs>
  }, ExtArgs["result"]["quizAttempt"]>

  export type QuizAttemptSelectScalar = {
    id?: boolean
    userId?: boolean
    quizId?: boolean
    score?: boolean
    duration?: boolean
    completedAt?: boolean
    answers?: boolean
    courseId?: boolean
  }

  export type QuizAttemptInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
    course?: boolean | QuizAttempt$courseArgs<ExtArgs>
  }
  export type QuizAttemptIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
    course?: boolean | QuizAttempt$courseArgs<ExtArgs>
  }

  export type $QuizAttemptPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuizAttempt"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      quiz: Prisma.$QuizPayload<ExtArgs>
      course: Prisma.$CoursePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      quizId: string
      score: number
      duration: number | null
      completedAt: Date
      answers: Prisma.JsonValue
      courseId: string | null
    }, ExtArgs["result"]["quizAttempt"]>
    composites: {}
  }

  type QuizAttemptGetPayload<S extends boolean | null | undefined | QuizAttemptDefaultArgs> = $Result.GetResult<Prisma.$QuizAttemptPayload, S>

  type QuizAttemptCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<QuizAttemptFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: QuizAttemptCountAggregateInputType | true
    }

  export interface QuizAttemptDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuizAttempt'], meta: { name: 'QuizAttempt' } }
    /**
     * Find zero or one QuizAttempt that matches the filter.
     * @param {QuizAttemptFindUniqueArgs} args - Arguments to find a QuizAttempt
     * @example
     * // Get one QuizAttempt
     * const quizAttempt = await prisma.quizAttempt.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuizAttemptFindUniqueArgs>(args: SelectSubset<T, QuizAttemptFindUniqueArgs<ExtArgs>>): Prisma__QuizAttemptClient<$Result.GetResult<Prisma.$QuizAttemptPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one QuizAttempt that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {QuizAttemptFindUniqueOrThrowArgs} args - Arguments to find a QuizAttempt
     * @example
     * // Get one QuizAttempt
     * const quizAttempt = await prisma.quizAttempt.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuizAttemptFindUniqueOrThrowArgs>(args: SelectSubset<T, QuizAttemptFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuizAttemptClient<$Result.GetResult<Prisma.$QuizAttemptPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first QuizAttempt that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAttemptFindFirstArgs} args - Arguments to find a QuizAttempt
     * @example
     * // Get one QuizAttempt
     * const quizAttempt = await prisma.quizAttempt.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuizAttemptFindFirstArgs>(args?: SelectSubset<T, QuizAttemptFindFirstArgs<ExtArgs>>): Prisma__QuizAttemptClient<$Result.GetResult<Prisma.$QuizAttemptPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first QuizAttempt that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAttemptFindFirstOrThrowArgs} args - Arguments to find a QuizAttempt
     * @example
     * // Get one QuizAttempt
     * const quizAttempt = await prisma.quizAttempt.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuizAttemptFindFirstOrThrowArgs>(args?: SelectSubset<T, QuizAttemptFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuizAttemptClient<$Result.GetResult<Prisma.$QuizAttemptPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more QuizAttempts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAttemptFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuizAttempts
     * const quizAttempts = await prisma.quizAttempt.findMany()
     * 
     * // Get first 10 QuizAttempts
     * const quizAttempts = await prisma.quizAttempt.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quizAttemptWithIdOnly = await prisma.quizAttempt.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuizAttemptFindManyArgs>(args?: SelectSubset<T, QuizAttemptFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizAttemptPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a QuizAttempt.
     * @param {QuizAttemptCreateArgs} args - Arguments to create a QuizAttempt.
     * @example
     * // Create one QuizAttempt
     * const QuizAttempt = await prisma.quizAttempt.create({
     *   data: {
     *     // ... data to create a QuizAttempt
     *   }
     * })
     * 
     */
    create<T extends QuizAttemptCreateArgs>(args: SelectSubset<T, QuizAttemptCreateArgs<ExtArgs>>): Prisma__QuizAttemptClient<$Result.GetResult<Prisma.$QuizAttemptPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many QuizAttempts.
     * @param {QuizAttemptCreateManyArgs} args - Arguments to create many QuizAttempts.
     * @example
     * // Create many QuizAttempts
     * const quizAttempt = await prisma.quizAttempt.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuizAttemptCreateManyArgs>(args?: SelectSubset<T, QuizAttemptCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuizAttempts and returns the data saved in the database.
     * @param {QuizAttemptCreateManyAndReturnArgs} args - Arguments to create many QuizAttempts.
     * @example
     * // Create many QuizAttempts
     * const quizAttempt = await prisma.quizAttempt.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuizAttempts and only return the `id`
     * const quizAttemptWithIdOnly = await prisma.quizAttempt.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuizAttemptCreateManyAndReturnArgs>(args?: SelectSubset<T, QuizAttemptCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizAttemptPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a QuizAttempt.
     * @param {QuizAttemptDeleteArgs} args - Arguments to delete one QuizAttempt.
     * @example
     * // Delete one QuizAttempt
     * const QuizAttempt = await prisma.quizAttempt.delete({
     *   where: {
     *     // ... filter to delete one QuizAttempt
     *   }
     * })
     * 
     */
    delete<T extends QuizAttemptDeleteArgs>(args: SelectSubset<T, QuizAttemptDeleteArgs<ExtArgs>>): Prisma__QuizAttemptClient<$Result.GetResult<Prisma.$QuizAttemptPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one QuizAttempt.
     * @param {QuizAttemptUpdateArgs} args - Arguments to update one QuizAttempt.
     * @example
     * // Update one QuizAttempt
     * const quizAttempt = await prisma.quizAttempt.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuizAttemptUpdateArgs>(args: SelectSubset<T, QuizAttemptUpdateArgs<ExtArgs>>): Prisma__QuizAttemptClient<$Result.GetResult<Prisma.$QuizAttemptPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more QuizAttempts.
     * @param {QuizAttemptDeleteManyArgs} args - Arguments to filter QuizAttempts to delete.
     * @example
     * // Delete a few QuizAttempts
     * const { count } = await prisma.quizAttempt.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuizAttemptDeleteManyArgs>(args?: SelectSubset<T, QuizAttemptDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizAttempts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAttemptUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuizAttempts
     * const quizAttempt = await prisma.quizAttempt.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuizAttemptUpdateManyArgs>(args: SelectSubset<T, QuizAttemptUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one QuizAttempt.
     * @param {QuizAttemptUpsertArgs} args - Arguments to update or create a QuizAttempt.
     * @example
     * // Update or create a QuizAttempt
     * const quizAttempt = await prisma.quizAttempt.upsert({
     *   create: {
     *     // ... data to create a QuizAttempt
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuizAttempt we want to update
     *   }
     * })
     */
    upsert<T extends QuizAttemptUpsertArgs>(args: SelectSubset<T, QuizAttemptUpsertArgs<ExtArgs>>): Prisma__QuizAttemptClient<$Result.GetResult<Prisma.$QuizAttemptPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of QuizAttempts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAttemptCountArgs} args - Arguments to filter QuizAttempts to count.
     * @example
     * // Count the number of QuizAttempts
     * const count = await prisma.quizAttempt.count({
     *   where: {
     *     // ... the filter for the QuizAttempts we want to count
     *   }
     * })
    **/
    count<T extends QuizAttemptCountArgs>(
      args?: Subset<T, QuizAttemptCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuizAttemptCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuizAttempt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAttemptAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuizAttemptAggregateArgs>(args: Subset<T, QuizAttemptAggregateArgs>): Prisma.PrismaPromise<GetQuizAttemptAggregateType<T>>

    /**
     * Group by QuizAttempt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAttemptGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuizAttemptGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuizAttemptGroupByArgs['orderBy'] }
        : { orderBy?: QuizAttemptGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuizAttemptGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuizAttemptGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuizAttempt model
   */
  readonly fields: QuizAttemptFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuizAttempt.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuizAttemptClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    quiz<T extends QuizDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuizDefaultArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    course<T extends QuizAttempt$courseArgs<ExtArgs> = {}>(args?: Subset<T, QuizAttempt$courseArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuizAttempt model
   */ 
  interface QuizAttemptFieldRefs {
    readonly id: FieldRef<"QuizAttempt", 'String'>
    readonly userId: FieldRef<"QuizAttempt", 'String'>
    readonly quizId: FieldRef<"QuizAttempt", 'String'>
    readonly score: FieldRef<"QuizAttempt", 'Int'>
    readonly duration: FieldRef<"QuizAttempt", 'Int'>
    readonly completedAt: FieldRef<"QuizAttempt", 'DateTime'>
    readonly answers: FieldRef<"QuizAttempt", 'Json'>
    readonly courseId: FieldRef<"QuizAttempt", 'String'>
  }
    

  // Custom InputTypes
  /**
   * QuizAttempt findUnique
   */
  export type QuizAttemptFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptInclude<ExtArgs> | null
    /**
     * Filter, which QuizAttempt to fetch.
     */
    where: QuizAttemptWhereUniqueInput
  }

  /**
   * QuizAttempt findUniqueOrThrow
   */
  export type QuizAttemptFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptInclude<ExtArgs> | null
    /**
     * Filter, which QuizAttempt to fetch.
     */
    where: QuizAttemptWhereUniqueInput
  }

  /**
   * QuizAttempt findFirst
   */
  export type QuizAttemptFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptInclude<ExtArgs> | null
    /**
     * Filter, which QuizAttempt to fetch.
     */
    where?: QuizAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizAttempts to fetch.
     */
    orderBy?: QuizAttemptOrderByWithRelationInput | QuizAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizAttempts.
     */
    cursor?: QuizAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizAttempts.
     */
    distinct?: QuizAttemptScalarFieldEnum | QuizAttemptScalarFieldEnum[]
  }

  /**
   * QuizAttempt findFirstOrThrow
   */
  export type QuizAttemptFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptInclude<ExtArgs> | null
    /**
     * Filter, which QuizAttempt to fetch.
     */
    where?: QuizAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizAttempts to fetch.
     */
    orderBy?: QuizAttemptOrderByWithRelationInput | QuizAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizAttempts.
     */
    cursor?: QuizAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizAttempts.
     */
    distinct?: QuizAttemptScalarFieldEnum | QuizAttemptScalarFieldEnum[]
  }

  /**
   * QuizAttempt findMany
   */
  export type QuizAttemptFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptInclude<ExtArgs> | null
    /**
     * Filter, which QuizAttempts to fetch.
     */
    where?: QuizAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizAttempts to fetch.
     */
    orderBy?: QuizAttemptOrderByWithRelationInput | QuizAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuizAttempts.
     */
    cursor?: QuizAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizAttempts.
     */
    skip?: number
    distinct?: QuizAttemptScalarFieldEnum | QuizAttemptScalarFieldEnum[]
  }

  /**
   * QuizAttempt create
   */
  export type QuizAttemptCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptInclude<ExtArgs> | null
    /**
     * The data needed to create a QuizAttempt.
     */
    data: XOR<QuizAttemptCreateInput, QuizAttemptUncheckedCreateInput>
  }

  /**
   * QuizAttempt createMany
   */
  export type QuizAttemptCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuizAttempts.
     */
    data: QuizAttemptCreateManyInput | QuizAttemptCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuizAttempt createManyAndReturn
   */
  export type QuizAttemptCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many QuizAttempts.
     */
    data: QuizAttemptCreateManyInput | QuizAttemptCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuizAttempt update
   */
  export type QuizAttemptUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptInclude<ExtArgs> | null
    /**
     * The data needed to update a QuizAttempt.
     */
    data: XOR<QuizAttemptUpdateInput, QuizAttemptUncheckedUpdateInput>
    /**
     * Choose, which QuizAttempt to update.
     */
    where: QuizAttemptWhereUniqueInput
  }

  /**
   * QuizAttempt updateMany
   */
  export type QuizAttemptUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuizAttempts.
     */
    data: XOR<QuizAttemptUpdateManyMutationInput, QuizAttemptUncheckedUpdateManyInput>
    /**
     * Filter which QuizAttempts to update
     */
    where?: QuizAttemptWhereInput
  }

  /**
   * QuizAttempt upsert
   */
  export type QuizAttemptUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptInclude<ExtArgs> | null
    /**
     * The filter to search for the QuizAttempt to update in case it exists.
     */
    where: QuizAttemptWhereUniqueInput
    /**
     * In case the QuizAttempt found by the `where` argument doesn't exist, create a new QuizAttempt with this data.
     */
    create: XOR<QuizAttemptCreateInput, QuizAttemptUncheckedCreateInput>
    /**
     * In case the QuizAttempt was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuizAttemptUpdateInput, QuizAttemptUncheckedUpdateInput>
  }

  /**
   * QuizAttempt delete
   */
  export type QuizAttemptDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptInclude<ExtArgs> | null
    /**
     * Filter which QuizAttempt to delete.
     */
    where: QuizAttemptWhereUniqueInput
  }

  /**
   * QuizAttempt deleteMany
   */
  export type QuizAttemptDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizAttempts to delete
     */
    where?: QuizAttemptWhereInput
  }

  /**
   * QuizAttempt.course
   */
  export type QuizAttempt$courseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    where?: CourseWhereInput
  }

  /**
   * QuizAttempt without action
   */
  export type QuizAttemptDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptInclude<ExtArgs> | null
  }


  /**
   * Model AssignmentSubmission
   */

  export type AggregateAssignmentSubmission = {
    _count: AssignmentSubmissionCountAggregateOutputType | null
    _avg: AssignmentSubmissionAvgAggregateOutputType | null
    _sum: AssignmentSubmissionSumAggregateOutputType | null
    _min: AssignmentSubmissionMinAggregateOutputType | null
    _max: AssignmentSubmissionMaxAggregateOutputType | null
  }

  export type AssignmentSubmissionAvgAggregateOutputType = {
    score: number | null
  }

  export type AssignmentSubmissionSumAggregateOutputType = {
    score: number | null
  }

  export type AssignmentSubmissionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    assignmentId: string | null
    content: string | null
    submittedAt: Date | null
    score: number | null
    feedback: string | null
    gradedAt: Date | null
    gradedById: string | null
  }

  export type AssignmentSubmissionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    assignmentId: string | null
    content: string | null
    submittedAt: Date | null
    score: number | null
    feedback: string | null
    gradedAt: Date | null
    gradedById: string | null
  }

  export type AssignmentSubmissionCountAggregateOutputType = {
    id: number
    userId: number
    assignmentId: number
    content: number
    fileUrls: number
    submittedAt: number
    score: number
    feedback: number
    gradedAt: number
    gradedById: number
    _all: number
  }


  export type AssignmentSubmissionAvgAggregateInputType = {
    score?: true
  }

  export type AssignmentSubmissionSumAggregateInputType = {
    score?: true
  }

  export type AssignmentSubmissionMinAggregateInputType = {
    id?: true
    userId?: true
    assignmentId?: true
    content?: true
    submittedAt?: true
    score?: true
    feedback?: true
    gradedAt?: true
    gradedById?: true
  }

  export type AssignmentSubmissionMaxAggregateInputType = {
    id?: true
    userId?: true
    assignmentId?: true
    content?: true
    submittedAt?: true
    score?: true
    feedback?: true
    gradedAt?: true
    gradedById?: true
  }

  export type AssignmentSubmissionCountAggregateInputType = {
    id?: true
    userId?: true
    assignmentId?: true
    content?: true
    fileUrls?: true
    submittedAt?: true
    score?: true
    feedback?: true
    gradedAt?: true
    gradedById?: true
    _all?: true
  }

  export type AssignmentSubmissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AssignmentSubmission to aggregate.
     */
    where?: AssignmentSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssignmentSubmissions to fetch.
     */
    orderBy?: AssignmentSubmissionOrderByWithRelationInput | AssignmentSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AssignmentSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssignmentSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssignmentSubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AssignmentSubmissions
    **/
    _count?: true | AssignmentSubmissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AssignmentSubmissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AssignmentSubmissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AssignmentSubmissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AssignmentSubmissionMaxAggregateInputType
  }

  export type GetAssignmentSubmissionAggregateType<T extends AssignmentSubmissionAggregateArgs> = {
        [P in keyof T & keyof AggregateAssignmentSubmission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAssignmentSubmission[P]>
      : GetScalarType<T[P], AggregateAssignmentSubmission[P]>
  }




  export type AssignmentSubmissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssignmentSubmissionWhereInput
    orderBy?: AssignmentSubmissionOrderByWithAggregationInput | AssignmentSubmissionOrderByWithAggregationInput[]
    by: AssignmentSubmissionScalarFieldEnum[] | AssignmentSubmissionScalarFieldEnum
    having?: AssignmentSubmissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AssignmentSubmissionCountAggregateInputType | true
    _avg?: AssignmentSubmissionAvgAggregateInputType
    _sum?: AssignmentSubmissionSumAggregateInputType
    _min?: AssignmentSubmissionMinAggregateInputType
    _max?: AssignmentSubmissionMaxAggregateInputType
  }

  export type AssignmentSubmissionGroupByOutputType = {
    id: string
    userId: string
    assignmentId: string
    content: string | null
    fileUrls: string[]
    submittedAt: Date
    score: number | null
    feedback: string | null
    gradedAt: Date | null
    gradedById: string | null
    _count: AssignmentSubmissionCountAggregateOutputType | null
    _avg: AssignmentSubmissionAvgAggregateOutputType | null
    _sum: AssignmentSubmissionSumAggregateOutputType | null
    _min: AssignmentSubmissionMinAggregateOutputType | null
    _max: AssignmentSubmissionMaxAggregateOutputType | null
  }

  type GetAssignmentSubmissionGroupByPayload<T extends AssignmentSubmissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AssignmentSubmissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AssignmentSubmissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssignmentSubmissionGroupByOutputType[P]>
            : GetScalarType<T[P], AssignmentSubmissionGroupByOutputType[P]>
        }
      >
    >


  export type AssignmentSubmissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    assignmentId?: boolean
    content?: boolean
    fileUrls?: boolean
    submittedAt?: boolean
    score?: boolean
    feedback?: boolean
    gradedAt?: boolean
    gradedById?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    assignment?: boolean | AssignmentDefaultArgs<ExtArgs>
    gradedBy?: boolean | AssignmentSubmission$gradedByArgs<ExtArgs>
  }, ExtArgs["result"]["assignmentSubmission"]>

  export type AssignmentSubmissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    assignmentId?: boolean
    content?: boolean
    fileUrls?: boolean
    submittedAt?: boolean
    score?: boolean
    feedback?: boolean
    gradedAt?: boolean
    gradedById?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    assignment?: boolean | AssignmentDefaultArgs<ExtArgs>
    gradedBy?: boolean | AssignmentSubmission$gradedByArgs<ExtArgs>
  }, ExtArgs["result"]["assignmentSubmission"]>

  export type AssignmentSubmissionSelectScalar = {
    id?: boolean
    userId?: boolean
    assignmentId?: boolean
    content?: boolean
    fileUrls?: boolean
    submittedAt?: boolean
    score?: boolean
    feedback?: boolean
    gradedAt?: boolean
    gradedById?: boolean
  }

  export type AssignmentSubmissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    assignment?: boolean | AssignmentDefaultArgs<ExtArgs>
    gradedBy?: boolean | AssignmentSubmission$gradedByArgs<ExtArgs>
  }
  export type AssignmentSubmissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    assignment?: boolean | AssignmentDefaultArgs<ExtArgs>
    gradedBy?: boolean | AssignmentSubmission$gradedByArgs<ExtArgs>
  }

  export type $AssignmentSubmissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AssignmentSubmission"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      assignment: Prisma.$AssignmentPayload<ExtArgs>
      gradedBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      assignmentId: string
      content: string | null
      fileUrls: string[]
      submittedAt: Date
      score: number | null
      feedback: string | null
      gradedAt: Date | null
      gradedById: string | null
    }, ExtArgs["result"]["assignmentSubmission"]>
    composites: {}
  }

  type AssignmentSubmissionGetPayload<S extends boolean | null | undefined | AssignmentSubmissionDefaultArgs> = $Result.GetResult<Prisma.$AssignmentSubmissionPayload, S>

  type AssignmentSubmissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AssignmentSubmissionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AssignmentSubmissionCountAggregateInputType | true
    }

  export interface AssignmentSubmissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AssignmentSubmission'], meta: { name: 'AssignmentSubmission' } }
    /**
     * Find zero or one AssignmentSubmission that matches the filter.
     * @param {AssignmentSubmissionFindUniqueArgs} args - Arguments to find a AssignmentSubmission
     * @example
     * // Get one AssignmentSubmission
     * const assignmentSubmission = await prisma.assignmentSubmission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AssignmentSubmissionFindUniqueArgs>(args: SelectSubset<T, AssignmentSubmissionFindUniqueArgs<ExtArgs>>): Prisma__AssignmentSubmissionClient<$Result.GetResult<Prisma.$AssignmentSubmissionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AssignmentSubmission that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AssignmentSubmissionFindUniqueOrThrowArgs} args - Arguments to find a AssignmentSubmission
     * @example
     * // Get one AssignmentSubmission
     * const assignmentSubmission = await prisma.assignmentSubmission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AssignmentSubmissionFindUniqueOrThrowArgs>(args: SelectSubset<T, AssignmentSubmissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AssignmentSubmissionClient<$Result.GetResult<Prisma.$AssignmentSubmissionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AssignmentSubmission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentSubmissionFindFirstArgs} args - Arguments to find a AssignmentSubmission
     * @example
     * // Get one AssignmentSubmission
     * const assignmentSubmission = await prisma.assignmentSubmission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AssignmentSubmissionFindFirstArgs>(args?: SelectSubset<T, AssignmentSubmissionFindFirstArgs<ExtArgs>>): Prisma__AssignmentSubmissionClient<$Result.GetResult<Prisma.$AssignmentSubmissionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AssignmentSubmission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentSubmissionFindFirstOrThrowArgs} args - Arguments to find a AssignmentSubmission
     * @example
     * // Get one AssignmentSubmission
     * const assignmentSubmission = await prisma.assignmentSubmission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AssignmentSubmissionFindFirstOrThrowArgs>(args?: SelectSubset<T, AssignmentSubmissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__AssignmentSubmissionClient<$Result.GetResult<Prisma.$AssignmentSubmissionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AssignmentSubmissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentSubmissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AssignmentSubmissions
     * const assignmentSubmissions = await prisma.assignmentSubmission.findMany()
     * 
     * // Get first 10 AssignmentSubmissions
     * const assignmentSubmissions = await prisma.assignmentSubmission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const assignmentSubmissionWithIdOnly = await prisma.assignmentSubmission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AssignmentSubmissionFindManyArgs>(args?: SelectSubset<T, AssignmentSubmissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssignmentSubmissionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AssignmentSubmission.
     * @param {AssignmentSubmissionCreateArgs} args - Arguments to create a AssignmentSubmission.
     * @example
     * // Create one AssignmentSubmission
     * const AssignmentSubmission = await prisma.assignmentSubmission.create({
     *   data: {
     *     // ... data to create a AssignmentSubmission
     *   }
     * })
     * 
     */
    create<T extends AssignmentSubmissionCreateArgs>(args: SelectSubset<T, AssignmentSubmissionCreateArgs<ExtArgs>>): Prisma__AssignmentSubmissionClient<$Result.GetResult<Prisma.$AssignmentSubmissionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AssignmentSubmissions.
     * @param {AssignmentSubmissionCreateManyArgs} args - Arguments to create many AssignmentSubmissions.
     * @example
     * // Create many AssignmentSubmissions
     * const assignmentSubmission = await prisma.assignmentSubmission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AssignmentSubmissionCreateManyArgs>(args?: SelectSubset<T, AssignmentSubmissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AssignmentSubmissions and returns the data saved in the database.
     * @param {AssignmentSubmissionCreateManyAndReturnArgs} args - Arguments to create many AssignmentSubmissions.
     * @example
     * // Create many AssignmentSubmissions
     * const assignmentSubmission = await prisma.assignmentSubmission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AssignmentSubmissions and only return the `id`
     * const assignmentSubmissionWithIdOnly = await prisma.assignmentSubmission.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AssignmentSubmissionCreateManyAndReturnArgs>(args?: SelectSubset<T, AssignmentSubmissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssignmentSubmissionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AssignmentSubmission.
     * @param {AssignmentSubmissionDeleteArgs} args - Arguments to delete one AssignmentSubmission.
     * @example
     * // Delete one AssignmentSubmission
     * const AssignmentSubmission = await prisma.assignmentSubmission.delete({
     *   where: {
     *     // ... filter to delete one AssignmentSubmission
     *   }
     * })
     * 
     */
    delete<T extends AssignmentSubmissionDeleteArgs>(args: SelectSubset<T, AssignmentSubmissionDeleteArgs<ExtArgs>>): Prisma__AssignmentSubmissionClient<$Result.GetResult<Prisma.$AssignmentSubmissionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AssignmentSubmission.
     * @param {AssignmentSubmissionUpdateArgs} args - Arguments to update one AssignmentSubmission.
     * @example
     * // Update one AssignmentSubmission
     * const assignmentSubmission = await prisma.assignmentSubmission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AssignmentSubmissionUpdateArgs>(args: SelectSubset<T, AssignmentSubmissionUpdateArgs<ExtArgs>>): Prisma__AssignmentSubmissionClient<$Result.GetResult<Prisma.$AssignmentSubmissionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AssignmentSubmissions.
     * @param {AssignmentSubmissionDeleteManyArgs} args - Arguments to filter AssignmentSubmissions to delete.
     * @example
     * // Delete a few AssignmentSubmissions
     * const { count } = await prisma.assignmentSubmission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AssignmentSubmissionDeleteManyArgs>(args?: SelectSubset<T, AssignmentSubmissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AssignmentSubmissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentSubmissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AssignmentSubmissions
     * const assignmentSubmission = await prisma.assignmentSubmission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AssignmentSubmissionUpdateManyArgs>(args: SelectSubset<T, AssignmentSubmissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AssignmentSubmission.
     * @param {AssignmentSubmissionUpsertArgs} args - Arguments to update or create a AssignmentSubmission.
     * @example
     * // Update or create a AssignmentSubmission
     * const assignmentSubmission = await prisma.assignmentSubmission.upsert({
     *   create: {
     *     // ... data to create a AssignmentSubmission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AssignmentSubmission we want to update
     *   }
     * })
     */
    upsert<T extends AssignmentSubmissionUpsertArgs>(args: SelectSubset<T, AssignmentSubmissionUpsertArgs<ExtArgs>>): Prisma__AssignmentSubmissionClient<$Result.GetResult<Prisma.$AssignmentSubmissionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AssignmentSubmissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentSubmissionCountArgs} args - Arguments to filter AssignmentSubmissions to count.
     * @example
     * // Count the number of AssignmentSubmissions
     * const count = await prisma.assignmentSubmission.count({
     *   where: {
     *     // ... the filter for the AssignmentSubmissions we want to count
     *   }
     * })
    **/
    count<T extends AssignmentSubmissionCountArgs>(
      args?: Subset<T, AssignmentSubmissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AssignmentSubmissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AssignmentSubmission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentSubmissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AssignmentSubmissionAggregateArgs>(args: Subset<T, AssignmentSubmissionAggregateArgs>): Prisma.PrismaPromise<GetAssignmentSubmissionAggregateType<T>>

    /**
     * Group by AssignmentSubmission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentSubmissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AssignmentSubmissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AssignmentSubmissionGroupByArgs['orderBy'] }
        : { orderBy?: AssignmentSubmissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AssignmentSubmissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssignmentSubmissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AssignmentSubmission model
   */
  readonly fields: AssignmentSubmissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AssignmentSubmission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AssignmentSubmissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    assignment<T extends AssignmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AssignmentDefaultArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    gradedBy<T extends AssignmentSubmission$gradedByArgs<ExtArgs> = {}>(args?: Subset<T, AssignmentSubmission$gradedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AssignmentSubmission model
   */ 
  interface AssignmentSubmissionFieldRefs {
    readonly id: FieldRef<"AssignmentSubmission", 'String'>
    readonly userId: FieldRef<"AssignmentSubmission", 'String'>
    readonly assignmentId: FieldRef<"AssignmentSubmission", 'String'>
    readonly content: FieldRef<"AssignmentSubmission", 'String'>
    readonly fileUrls: FieldRef<"AssignmentSubmission", 'String[]'>
    readonly submittedAt: FieldRef<"AssignmentSubmission", 'DateTime'>
    readonly score: FieldRef<"AssignmentSubmission", 'Int'>
    readonly feedback: FieldRef<"AssignmentSubmission", 'String'>
    readonly gradedAt: FieldRef<"AssignmentSubmission", 'DateTime'>
    readonly gradedById: FieldRef<"AssignmentSubmission", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AssignmentSubmission findUnique
   */
  export type AssignmentSubmissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentSubmission
     */
    select?: AssignmentSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which AssignmentSubmission to fetch.
     */
    where: AssignmentSubmissionWhereUniqueInput
  }

  /**
   * AssignmentSubmission findUniqueOrThrow
   */
  export type AssignmentSubmissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentSubmission
     */
    select?: AssignmentSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which AssignmentSubmission to fetch.
     */
    where: AssignmentSubmissionWhereUniqueInput
  }

  /**
   * AssignmentSubmission findFirst
   */
  export type AssignmentSubmissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentSubmission
     */
    select?: AssignmentSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which AssignmentSubmission to fetch.
     */
    where?: AssignmentSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssignmentSubmissions to fetch.
     */
    orderBy?: AssignmentSubmissionOrderByWithRelationInput | AssignmentSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AssignmentSubmissions.
     */
    cursor?: AssignmentSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssignmentSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssignmentSubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AssignmentSubmissions.
     */
    distinct?: AssignmentSubmissionScalarFieldEnum | AssignmentSubmissionScalarFieldEnum[]
  }

  /**
   * AssignmentSubmission findFirstOrThrow
   */
  export type AssignmentSubmissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentSubmission
     */
    select?: AssignmentSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which AssignmentSubmission to fetch.
     */
    where?: AssignmentSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssignmentSubmissions to fetch.
     */
    orderBy?: AssignmentSubmissionOrderByWithRelationInput | AssignmentSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AssignmentSubmissions.
     */
    cursor?: AssignmentSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssignmentSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssignmentSubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AssignmentSubmissions.
     */
    distinct?: AssignmentSubmissionScalarFieldEnum | AssignmentSubmissionScalarFieldEnum[]
  }

  /**
   * AssignmentSubmission findMany
   */
  export type AssignmentSubmissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentSubmission
     */
    select?: AssignmentSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which AssignmentSubmissions to fetch.
     */
    where?: AssignmentSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssignmentSubmissions to fetch.
     */
    orderBy?: AssignmentSubmissionOrderByWithRelationInput | AssignmentSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AssignmentSubmissions.
     */
    cursor?: AssignmentSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssignmentSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssignmentSubmissions.
     */
    skip?: number
    distinct?: AssignmentSubmissionScalarFieldEnum | AssignmentSubmissionScalarFieldEnum[]
  }

  /**
   * AssignmentSubmission create
   */
  export type AssignmentSubmissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentSubmission
     */
    select?: AssignmentSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentSubmissionInclude<ExtArgs> | null
    /**
     * The data needed to create a AssignmentSubmission.
     */
    data: XOR<AssignmentSubmissionCreateInput, AssignmentSubmissionUncheckedCreateInput>
  }

  /**
   * AssignmentSubmission createMany
   */
  export type AssignmentSubmissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AssignmentSubmissions.
     */
    data: AssignmentSubmissionCreateManyInput | AssignmentSubmissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AssignmentSubmission createManyAndReturn
   */
  export type AssignmentSubmissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentSubmission
     */
    select?: AssignmentSubmissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AssignmentSubmissions.
     */
    data: AssignmentSubmissionCreateManyInput | AssignmentSubmissionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentSubmissionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AssignmentSubmission update
   */
  export type AssignmentSubmissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentSubmission
     */
    select?: AssignmentSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentSubmissionInclude<ExtArgs> | null
    /**
     * The data needed to update a AssignmentSubmission.
     */
    data: XOR<AssignmentSubmissionUpdateInput, AssignmentSubmissionUncheckedUpdateInput>
    /**
     * Choose, which AssignmentSubmission to update.
     */
    where: AssignmentSubmissionWhereUniqueInput
  }

  /**
   * AssignmentSubmission updateMany
   */
  export type AssignmentSubmissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AssignmentSubmissions.
     */
    data: XOR<AssignmentSubmissionUpdateManyMutationInput, AssignmentSubmissionUncheckedUpdateManyInput>
    /**
     * Filter which AssignmentSubmissions to update
     */
    where?: AssignmentSubmissionWhereInput
  }

  /**
   * AssignmentSubmission upsert
   */
  export type AssignmentSubmissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentSubmission
     */
    select?: AssignmentSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentSubmissionInclude<ExtArgs> | null
    /**
     * The filter to search for the AssignmentSubmission to update in case it exists.
     */
    where: AssignmentSubmissionWhereUniqueInput
    /**
     * In case the AssignmentSubmission found by the `where` argument doesn't exist, create a new AssignmentSubmission with this data.
     */
    create: XOR<AssignmentSubmissionCreateInput, AssignmentSubmissionUncheckedCreateInput>
    /**
     * In case the AssignmentSubmission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AssignmentSubmissionUpdateInput, AssignmentSubmissionUncheckedUpdateInput>
  }

  /**
   * AssignmentSubmission delete
   */
  export type AssignmentSubmissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentSubmission
     */
    select?: AssignmentSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentSubmissionInclude<ExtArgs> | null
    /**
     * Filter which AssignmentSubmission to delete.
     */
    where: AssignmentSubmissionWhereUniqueInput
  }

  /**
   * AssignmentSubmission deleteMany
   */
  export type AssignmentSubmissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AssignmentSubmissions to delete
     */
    where?: AssignmentSubmissionWhereInput
  }

  /**
   * AssignmentSubmission.gradedBy
   */
  export type AssignmentSubmission$gradedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AssignmentSubmission without action
   */
  export type AssignmentSubmissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentSubmission
     */
    select?: AssignmentSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentSubmissionInclude<ExtArgs> | null
  }


  /**
   * Model CourseReview
   */

  export type AggregateCourseReview = {
    _count: CourseReviewCountAggregateOutputType | null
    _avg: CourseReviewAvgAggregateOutputType | null
    _sum: CourseReviewSumAggregateOutputType | null
    _min: CourseReviewMinAggregateOutputType | null
    _max: CourseReviewMaxAggregateOutputType | null
  }

  export type CourseReviewAvgAggregateOutputType = {
    rating: number | null
  }

  export type CourseReviewSumAggregateOutputType = {
    rating: number | null
  }

  export type CourseReviewMinAggregateOutputType = {
    id: string | null
    userId: string | null
    courseId: string | null
    rating: number | null
    comment: string | null
    createdAt: Date | null
  }

  export type CourseReviewMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    courseId: string | null
    rating: number | null
    comment: string | null
    createdAt: Date | null
  }

  export type CourseReviewCountAggregateOutputType = {
    id: number
    userId: number
    courseId: number
    rating: number
    comment: number
    createdAt: number
    _all: number
  }


  export type CourseReviewAvgAggregateInputType = {
    rating?: true
  }

  export type CourseReviewSumAggregateInputType = {
    rating?: true
  }

  export type CourseReviewMinAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    rating?: true
    comment?: true
    createdAt?: true
  }

  export type CourseReviewMaxAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    rating?: true
    comment?: true
    createdAt?: true
  }

  export type CourseReviewCountAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    rating?: true
    comment?: true
    createdAt?: true
    _all?: true
  }

  export type CourseReviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseReview to aggregate.
     */
    where?: CourseReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseReviews to fetch.
     */
    orderBy?: CourseReviewOrderByWithRelationInput | CourseReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourseReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CourseReviews
    **/
    _count?: true | CourseReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CourseReviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CourseReviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseReviewMaxAggregateInputType
  }

  export type GetCourseReviewAggregateType<T extends CourseReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateCourseReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourseReview[P]>
      : GetScalarType<T[P], AggregateCourseReview[P]>
  }




  export type CourseReviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseReviewWhereInput
    orderBy?: CourseReviewOrderByWithAggregationInput | CourseReviewOrderByWithAggregationInput[]
    by: CourseReviewScalarFieldEnum[] | CourseReviewScalarFieldEnum
    having?: CourseReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseReviewCountAggregateInputType | true
    _avg?: CourseReviewAvgAggregateInputType
    _sum?: CourseReviewSumAggregateInputType
    _min?: CourseReviewMinAggregateInputType
    _max?: CourseReviewMaxAggregateInputType
  }

  export type CourseReviewGroupByOutputType = {
    id: string
    userId: string
    courseId: string
    rating: number
    comment: string | null
    createdAt: Date
    _count: CourseReviewCountAggregateOutputType | null
    _avg: CourseReviewAvgAggregateOutputType | null
    _sum: CourseReviewSumAggregateOutputType | null
    _min: CourseReviewMinAggregateOutputType | null
    _max: CourseReviewMaxAggregateOutputType | null
  }

  type GetCourseReviewGroupByPayload<T extends CourseReviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourseReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseReviewGroupByOutputType[P]>
            : GetScalarType<T[P], CourseReviewGroupByOutputType[P]>
        }
      >
    >


  export type CourseReviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    courseId?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseReview"]>

  export type CourseReviewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    courseId?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseReview"]>

  export type CourseReviewSelectScalar = {
    id?: boolean
    userId?: boolean
    courseId?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
  }

  export type CourseReviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }
  export type CourseReviewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }

  export type $CourseReviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CourseReview"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      course: Prisma.$CoursePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      courseId: string
      rating: number
      comment: string | null
      createdAt: Date
    }, ExtArgs["result"]["courseReview"]>
    composites: {}
  }

  type CourseReviewGetPayload<S extends boolean | null | undefined | CourseReviewDefaultArgs> = $Result.GetResult<Prisma.$CourseReviewPayload, S>

  type CourseReviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CourseReviewFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CourseReviewCountAggregateInputType | true
    }

  export interface CourseReviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CourseReview'], meta: { name: 'CourseReview' } }
    /**
     * Find zero or one CourseReview that matches the filter.
     * @param {CourseReviewFindUniqueArgs} args - Arguments to find a CourseReview
     * @example
     * // Get one CourseReview
     * const courseReview = await prisma.courseReview.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourseReviewFindUniqueArgs>(args: SelectSubset<T, CourseReviewFindUniqueArgs<ExtArgs>>): Prisma__CourseReviewClient<$Result.GetResult<Prisma.$CourseReviewPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CourseReview that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CourseReviewFindUniqueOrThrowArgs} args - Arguments to find a CourseReview
     * @example
     * // Get one CourseReview
     * const courseReview = await prisma.courseReview.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourseReviewFindUniqueOrThrowArgs>(args: SelectSubset<T, CourseReviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourseReviewClient<$Result.GetResult<Prisma.$CourseReviewPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CourseReview that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseReviewFindFirstArgs} args - Arguments to find a CourseReview
     * @example
     * // Get one CourseReview
     * const courseReview = await prisma.courseReview.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourseReviewFindFirstArgs>(args?: SelectSubset<T, CourseReviewFindFirstArgs<ExtArgs>>): Prisma__CourseReviewClient<$Result.GetResult<Prisma.$CourseReviewPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CourseReview that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseReviewFindFirstOrThrowArgs} args - Arguments to find a CourseReview
     * @example
     * // Get one CourseReview
     * const courseReview = await prisma.courseReview.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourseReviewFindFirstOrThrowArgs>(args?: SelectSubset<T, CourseReviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourseReviewClient<$Result.GetResult<Prisma.$CourseReviewPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CourseReviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseReviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CourseReviews
     * const courseReviews = await prisma.courseReview.findMany()
     * 
     * // Get first 10 CourseReviews
     * const courseReviews = await prisma.courseReview.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const courseReviewWithIdOnly = await prisma.courseReview.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CourseReviewFindManyArgs>(args?: SelectSubset<T, CourseReviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseReviewPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CourseReview.
     * @param {CourseReviewCreateArgs} args - Arguments to create a CourseReview.
     * @example
     * // Create one CourseReview
     * const CourseReview = await prisma.courseReview.create({
     *   data: {
     *     // ... data to create a CourseReview
     *   }
     * })
     * 
     */
    create<T extends CourseReviewCreateArgs>(args: SelectSubset<T, CourseReviewCreateArgs<ExtArgs>>): Prisma__CourseReviewClient<$Result.GetResult<Prisma.$CourseReviewPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CourseReviews.
     * @param {CourseReviewCreateManyArgs} args - Arguments to create many CourseReviews.
     * @example
     * // Create many CourseReviews
     * const courseReview = await prisma.courseReview.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourseReviewCreateManyArgs>(args?: SelectSubset<T, CourseReviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CourseReviews and returns the data saved in the database.
     * @param {CourseReviewCreateManyAndReturnArgs} args - Arguments to create many CourseReviews.
     * @example
     * // Create many CourseReviews
     * const courseReview = await prisma.courseReview.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CourseReviews and only return the `id`
     * const courseReviewWithIdOnly = await prisma.courseReview.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CourseReviewCreateManyAndReturnArgs>(args?: SelectSubset<T, CourseReviewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseReviewPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CourseReview.
     * @param {CourseReviewDeleteArgs} args - Arguments to delete one CourseReview.
     * @example
     * // Delete one CourseReview
     * const CourseReview = await prisma.courseReview.delete({
     *   where: {
     *     // ... filter to delete one CourseReview
     *   }
     * })
     * 
     */
    delete<T extends CourseReviewDeleteArgs>(args: SelectSubset<T, CourseReviewDeleteArgs<ExtArgs>>): Prisma__CourseReviewClient<$Result.GetResult<Prisma.$CourseReviewPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CourseReview.
     * @param {CourseReviewUpdateArgs} args - Arguments to update one CourseReview.
     * @example
     * // Update one CourseReview
     * const courseReview = await prisma.courseReview.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourseReviewUpdateArgs>(args: SelectSubset<T, CourseReviewUpdateArgs<ExtArgs>>): Prisma__CourseReviewClient<$Result.GetResult<Prisma.$CourseReviewPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CourseReviews.
     * @param {CourseReviewDeleteManyArgs} args - Arguments to filter CourseReviews to delete.
     * @example
     * // Delete a few CourseReviews
     * const { count } = await prisma.courseReview.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourseReviewDeleteManyArgs>(args?: SelectSubset<T, CourseReviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourseReviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CourseReviews
     * const courseReview = await prisma.courseReview.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourseReviewUpdateManyArgs>(args: SelectSubset<T, CourseReviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CourseReview.
     * @param {CourseReviewUpsertArgs} args - Arguments to update or create a CourseReview.
     * @example
     * // Update or create a CourseReview
     * const courseReview = await prisma.courseReview.upsert({
     *   create: {
     *     // ... data to create a CourseReview
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CourseReview we want to update
     *   }
     * })
     */
    upsert<T extends CourseReviewUpsertArgs>(args: SelectSubset<T, CourseReviewUpsertArgs<ExtArgs>>): Prisma__CourseReviewClient<$Result.GetResult<Prisma.$CourseReviewPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CourseReviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseReviewCountArgs} args - Arguments to filter CourseReviews to count.
     * @example
     * // Count the number of CourseReviews
     * const count = await prisma.courseReview.count({
     *   where: {
     *     // ... the filter for the CourseReviews we want to count
     *   }
     * })
    **/
    count<T extends CourseReviewCountArgs>(
      args?: Subset<T, CourseReviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CourseReview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseReviewAggregateArgs>(args: Subset<T, CourseReviewAggregateArgs>): Prisma.PrismaPromise<GetCourseReviewAggregateType<T>>

    /**
     * Group by CourseReview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseReviewGroupByArgs['orderBy'] }
        : { orderBy?: CourseReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseReviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CourseReview model
   */
  readonly fields: CourseReviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CourseReview.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourseReviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CourseReview model
   */ 
  interface CourseReviewFieldRefs {
    readonly id: FieldRef<"CourseReview", 'String'>
    readonly userId: FieldRef<"CourseReview", 'String'>
    readonly courseId: FieldRef<"CourseReview", 'String'>
    readonly rating: FieldRef<"CourseReview", 'Int'>
    readonly comment: FieldRef<"CourseReview", 'String'>
    readonly createdAt: FieldRef<"CourseReview", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CourseReview findUnique
   */
  export type CourseReviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseReview
     */
    select?: CourseReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseReviewInclude<ExtArgs> | null
    /**
     * Filter, which CourseReview to fetch.
     */
    where: CourseReviewWhereUniqueInput
  }

  /**
   * CourseReview findUniqueOrThrow
   */
  export type CourseReviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseReview
     */
    select?: CourseReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseReviewInclude<ExtArgs> | null
    /**
     * Filter, which CourseReview to fetch.
     */
    where: CourseReviewWhereUniqueInput
  }

  /**
   * CourseReview findFirst
   */
  export type CourseReviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseReview
     */
    select?: CourseReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseReviewInclude<ExtArgs> | null
    /**
     * Filter, which CourseReview to fetch.
     */
    where?: CourseReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseReviews to fetch.
     */
    orderBy?: CourseReviewOrderByWithRelationInput | CourseReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseReviews.
     */
    cursor?: CourseReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseReviews.
     */
    distinct?: CourseReviewScalarFieldEnum | CourseReviewScalarFieldEnum[]
  }

  /**
   * CourseReview findFirstOrThrow
   */
  export type CourseReviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseReview
     */
    select?: CourseReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseReviewInclude<ExtArgs> | null
    /**
     * Filter, which CourseReview to fetch.
     */
    where?: CourseReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseReviews to fetch.
     */
    orderBy?: CourseReviewOrderByWithRelationInput | CourseReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseReviews.
     */
    cursor?: CourseReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseReviews.
     */
    distinct?: CourseReviewScalarFieldEnum | CourseReviewScalarFieldEnum[]
  }

  /**
   * CourseReview findMany
   */
  export type CourseReviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseReview
     */
    select?: CourseReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseReviewInclude<ExtArgs> | null
    /**
     * Filter, which CourseReviews to fetch.
     */
    where?: CourseReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseReviews to fetch.
     */
    orderBy?: CourseReviewOrderByWithRelationInput | CourseReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CourseReviews.
     */
    cursor?: CourseReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseReviews.
     */
    skip?: number
    distinct?: CourseReviewScalarFieldEnum | CourseReviewScalarFieldEnum[]
  }

  /**
   * CourseReview create
   */
  export type CourseReviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseReview
     */
    select?: CourseReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseReviewInclude<ExtArgs> | null
    /**
     * The data needed to create a CourseReview.
     */
    data: XOR<CourseReviewCreateInput, CourseReviewUncheckedCreateInput>
  }

  /**
   * CourseReview createMany
   */
  export type CourseReviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CourseReviews.
     */
    data: CourseReviewCreateManyInput | CourseReviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CourseReview createManyAndReturn
   */
  export type CourseReviewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseReview
     */
    select?: CourseReviewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CourseReviews.
     */
    data: CourseReviewCreateManyInput | CourseReviewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseReviewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CourseReview update
   */
  export type CourseReviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseReview
     */
    select?: CourseReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseReviewInclude<ExtArgs> | null
    /**
     * The data needed to update a CourseReview.
     */
    data: XOR<CourseReviewUpdateInput, CourseReviewUncheckedUpdateInput>
    /**
     * Choose, which CourseReview to update.
     */
    where: CourseReviewWhereUniqueInput
  }

  /**
   * CourseReview updateMany
   */
  export type CourseReviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CourseReviews.
     */
    data: XOR<CourseReviewUpdateManyMutationInput, CourseReviewUncheckedUpdateManyInput>
    /**
     * Filter which CourseReviews to update
     */
    where?: CourseReviewWhereInput
  }

  /**
   * CourseReview upsert
   */
  export type CourseReviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseReview
     */
    select?: CourseReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseReviewInclude<ExtArgs> | null
    /**
     * The filter to search for the CourseReview to update in case it exists.
     */
    where: CourseReviewWhereUniqueInput
    /**
     * In case the CourseReview found by the `where` argument doesn't exist, create a new CourseReview with this data.
     */
    create: XOR<CourseReviewCreateInput, CourseReviewUncheckedCreateInput>
    /**
     * In case the CourseReview was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourseReviewUpdateInput, CourseReviewUncheckedUpdateInput>
  }

  /**
   * CourseReview delete
   */
  export type CourseReviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseReview
     */
    select?: CourseReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseReviewInclude<ExtArgs> | null
    /**
     * Filter which CourseReview to delete.
     */
    where: CourseReviewWhereUniqueInput
  }

  /**
   * CourseReview deleteMany
   */
  export type CourseReviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseReviews to delete
     */
    where?: CourseReviewWhereInput
  }

  /**
   * CourseReview without action
   */
  export type CourseReviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseReview
     */
    select?: CourseReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseReviewInclude<ExtArgs> | null
  }


  /**
   * Model TutoringSession
   */

  export type AggregateTutoringSession = {
    _count: TutoringSessionCountAggregateOutputType | null
    _avg: TutoringSessionAvgAggregateOutputType | null
    _sum: TutoringSessionSumAggregateOutputType | null
    _min: TutoringSessionMinAggregateOutputType | null
    _max: TutoringSessionMaxAggregateOutputType | null
  }

  export type TutoringSessionAvgAggregateOutputType = {
    pricePerHour: Decimal | null
    maxStudents: number | null
  }

  export type TutoringSessionSumAggregateOutputType = {
    pricePerHour: Decimal | null
    maxStudents: number | null
  }

  export type TutoringSessionMinAggregateOutputType = {
    id: string | null
    teacherId: string | null
    subject: string | null
    description: string | null
    pricePerHour: Decimal | null
    locationType: $Enums.TutoringLocationType | null
    status: $Enums.TutoringStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    maxStudents: number | null
    level: string | null
    featured: boolean | null
  }

  export type TutoringSessionMaxAggregateOutputType = {
    id: string | null
    teacherId: string | null
    subject: string | null
    description: string | null
    pricePerHour: Decimal | null
    locationType: $Enums.TutoringLocationType | null
    status: $Enums.TutoringStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    maxStudents: number | null
    level: string | null
    featured: boolean | null
  }

  export type TutoringSessionCountAggregateOutputType = {
    id: number
    teacherId: number
    subject: number
    description: number
    pricePerHour: number
    locationType: number
    status: number
    createdAt: number
    updatedAt: number
    maxStudents: number
    prerequisites: number
    level: number
    tags: number
    featured: number
    _all: number
  }


  export type TutoringSessionAvgAggregateInputType = {
    pricePerHour?: true
    maxStudents?: true
  }

  export type TutoringSessionSumAggregateInputType = {
    pricePerHour?: true
    maxStudents?: true
  }

  export type TutoringSessionMinAggregateInputType = {
    id?: true
    teacherId?: true
    subject?: true
    description?: true
    pricePerHour?: true
    locationType?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    maxStudents?: true
    level?: true
    featured?: true
  }

  export type TutoringSessionMaxAggregateInputType = {
    id?: true
    teacherId?: true
    subject?: true
    description?: true
    pricePerHour?: true
    locationType?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    maxStudents?: true
    level?: true
    featured?: true
  }

  export type TutoringSessionCountAggregateInputType = {
    id?: true
    teacherId?: true
    subject?: true
    description?: true
    pricePerHour?: true
    locationType?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    maxStudents?: true
    prerequisites?: true
    level?: true
    tags?: true
    featured?: true
    _all?: true
  }

  export type TutoringSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TutoringSession to aggregate.
     */
    where?: TutoringSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TutoringSessions to fetch.
     */
    orderBy?: TutoringSessionOrderByWithRelationInput | TutoringSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TutoringSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TutoringSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TutoringSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TutoringSessions
    **/
    _count?: true | TutoringSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TutoringSessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TutoringSessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TutoringSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TutoringSessionMaxAggregateInputType
  }

  export type GetTutoringSessionAggregateType<T extends TutoringSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateTutoringSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTutoringSession[P]>
      : GetScalarType<T[P], AggregateTutoringSession[P]>
  }




  export type TutoringSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TutoringSessionWhereInput
    orderBy?: TutoringSessionOrderByWithAggregationInput | TutoringSessionOrderByWithAggregationInput[]
    by: TutoringSessionScalarFieldEnum[] | TutoringSessionScalarFieldEnum
    having?: TutoringSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TutoringSessionCountAggregateInputType | true
    _avg?: TutoringSessionAvgAggregateInputType
    _sum?: TutoringSessionSumAggregateInputType
    _min?: TutoringSessionMinAggregateInputType
    _max?: TutoringSessionMaxAggregateInputType
  }

  export type TutoringSessionGroupByOutputType = {
    id: string
    teacherId: string
    subject: string
    description: string | null
    pricePerHour: Decimal
    locationType: $Enums.TutoringLocationType
    status: $Enums.TutoringStatus
    createdAt: Date
    updatedAt: Date
    maxStudents: number
    prerequisites: string[]
    level: string | null
    tags: string[]
    featured: boolean
    _count: TutoringSessionCountAggregateOutputType | null
    _avg: TutoringSessionAvgAggregateOutputType | null
    _sum: TutoringSessionSumAggregateOutputType | null
    _min: TutoringSessionMinAggregateOutputType | null
    _max: TutoringSessionMaxAggregateOutputType | null
  }

  type GetTutoringSessionGroupByPayload<T extends TutoringSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TutoringSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TutoringSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TutoringSessionGroupByOutputType[P]>
            : GetScalarType<T[P], TutoringSessionGroupByOutputType[P]>
        }
      >
    >


  export type TutoringSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teacherId?: boolean
    subject?: boolean
    description?: boolean
    pricePerHour?: boolean
    locationType?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    maxStudents?: boolean
    prerequisites?: boolean
    level?: boolean
    tags?: boolean
    featured?: boolean
    teacher?: boolean | UserDefaultArgs<ExtArgs>
    availability?: boolean | TutoringSession$availabilityArgs<ExtArgs>
    requests?: boolean | TutoringSession$requestsArgs<ExtArgs>
    appointments?: boolean | TutoringSession$appointmentsArgs<ExtArgs>
    reviews?: boolean | TutoringSession$reviewsArgs<ExtArgs>
    certificates?: boolean | TutoringSession$certificatesArgs<ExtArgs>
    _count?: boolean | TutoringSessionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tutoringSession"]>

  export type TutoringSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teacherId?: boolean
    subject?: boolean
    description?: boolean
    pricePerHour?: boolean
    locationType?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    maxStudents?: boolean
    prerequisites?: boolean
    level?: boolean
    tags?: boolean
    featured?: boolean
    teacher?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tutoringSession"]>

  export type TutoringSessionSelectScalar = {
    id?: boolean
    teacherId?: boolean
    subject?: boolean
    description?: boolean
    pricePerHour?: boolean
    locationType?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    maxStudents?: boolean
    prerequisites?: boolean
    level?: boolean
    tags?: boolean
    featured?: boolean
  }

  export type TutoringSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teacher?: boolean | UserDefaultArgs<ExtArgs>
    availability?: boolean | TutoringSession$availabilityArgs<ExtArgs>
    requests?: boolean | TutoringSession$requestsArgs<ExtArgs>
    appointments?: boolean | TutoringSession$appointmentsArgs<ExtArgs>
    reviews?: boolean | TutoringSession$reviewsArgs<ExtArgs>
    certificates?: boolean | TutoringSession$certificatesArgs<ExtArgs>
    _count?: boolean | TutoringSessionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TutoringSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teacher?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TutoringSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TutoringSession"
    objects: {
      teacher: Prisma.$UserPayload<ExtArgs>
      availability: Prisma.$TutoringAvailabilityPayload<ExtArgs>[]
      requests: Prisma.$TutoringRequestPayload<ExtArgs>[]
      appointments: Prisma.$TutoringAppointmentPayload<ExtArgs>[]
      reviews: Prisma.$TutoringReviewPayload<ExtArgs>[]
      certificates: Prisma.$CertificatePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      teacherId: string
      subject: string
      description: string | null
      pricePerHour: Prisma.Decimal
      locationType: $Enums.TutoringLocationType
      status: $Enums.TutoringStatus
      createdAt: Date
      updatedAt: Date
      maxStudents: number
      prerequisites: string[]
      level: string | null
      tags: string[]
      featured: boolean
    }, ExtArgs["result"]["tutoringSession"]>
    composites: {}
  }

  type TutoringSessionGetPayload<S extends boolean | null | undefined | TutoringSessionDefaultArgs> = $Result.GetResult<Prisma.$TutoringSessionPayload, S>

  type TutoringSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TutoringSessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TutoringSessionCountAggregateInputType | true
    }

  export interface TutoringSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TutoringSession'], meta: { name: 'TutoringSession' } }
    /**
     * Find zero or one TutoringSession that matches the filter.
     * @param {TutoringSessionFindUniqueArgs} args - Arguments to find a TutoringSession
     * @example
     * // Get one TutoringSession
     * const tutoringSession = await prisma.tutoringSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TutoringSessionFindUniqueArgs>(args: SelectSubset<T, TutoringSessionFindUniqueArgs<ExtArgs>>): Prisma__TutoringSessionClient<$Result.GetResult<Prisma.$TutoringSessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TutoringSession that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TutoringSessionFindUniqueOrThrowArgs} args - Arguments to find a TutoringSession
     * @example
     * // Get one TutoringSession
     * const tutoringSession = await prisma.tutoringSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TutoringSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, TutoringSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TutoringSessionClient<$Result.GetResult<Prisma.$TutoringSessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TutoringSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TutoringSessionFindFirstArgs} args - Arguments to find a TutoringSession
     * @example
     * // Get one TutoringSession
     * const tutoringSession = await prisma.tutoringSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TutoringSessionFindFirstArgs>(args?: SelectSubset<T, TutoringSessionFindFirstArgs<ExtArgs>>): Prisma__TutoringSessionClient<$Result.GetResult<Prisma.$TutoringSessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TutoringSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TutoringSessionFindFirstOrThrowArgs} args - Arguments to find a TutoringSession
     * @example
     * // Get one TutoringSession
     * const tutoringSession = await prisma.tutoringSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TutoringSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, TutoringSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TutoringSessionClient<$Result.GetResult<Prisma.$TutoringSessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TutoringSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TutoringSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TutoringSessions
     * const tutoringSessions = await prisma.tutoringSession.findMany()
     * 
     * // Get first 10 TutoringSessions
     * const tutoringSessions = await prisma.tutoringSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tutoringSessionWithIdOnly = await prisma.tutoringSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TutoringSessionFindManyArgs>(args?: SelectSubset<T, TutoringSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TutoringSessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TutoringSession.
     * @param {TutoringSessionCreateArgs} args - Arguments to create a TutoringSession.
     * @example
     * // Create one TutoringSession
     * const TutoringSession = await prisma.tutoringSession.create({
     *   data: {
     *     // ... data to create a TutoringSession
     *   }
     * })
     * 
     */
    create<T extends TutoringSessionCreateArgs>(args: SelectSubset<T, TutoringSessionCreateArgs<ExtArgs>>): Prisma__TutoringSessionClient<$Result.GetResult<Prisma.$TutoringSessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TutoringSessions.
     * @param {TutoringSessionCreateManyArgs} args - Arguments to create many TutoringSessions.
     * @example
     * // Create many TutoringSessions
     * const tutoringSession = await prisma.tutoringSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TutoringSessionCreateManyArgs>(args?: SelectSubset<T, TutoringSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TutoringSessions and returns the data saved in the database.
     * @param {TutoringSessionCreateManyAndReturnArgs} args - Arguments to create many TutoringSessions.
     * @example
     * // Create many TutoringSessions
     * const tutoringSession = await prisma.tutoringSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TutoringSessions and only return the `id`
     * const tutoringSessionWithIdOnly = await prisma.tutoringSession.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TutoringSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, TutoringSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TutoringSessionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TutoringSession.
     * @param {TutoringSessionDeleteArgs} args - Arguments to delete one TutoringSession.
     * @example
     * // Delete one TutoringSession
     * const TutoringSession = await prisma.tutoringSession.delete({
     *   where: {
     *     // ... filter to delete one TutoringSession
     *   }
     * })
     * 
     */
    delete<T extends TutoringSessionDeleteArgs>(args: SelectSubset<T, TutoringSessionDeleteArgs<ExtArgs>>): Prisma__TutoringSessionClient<$Result.GetResult<Prisma.$TutoringSessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TutoringSession.
     * @param {TutoringSessionUpdateArgs} args - Arguments to update one TutoringSession.
     * @example
     * // Update one TutoringSession
     * const tutoringSession = await prisma.tutoringSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TutoringSessionUpdateArgs>(args: SelectSubset<T, TutoringSessionUpdateArgs<ExtArgs>>): Prisma__TutoringSessionClient<$Result.GetResult<Prisma.$TutoringSessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TutoringSessions.
     * @param {TutoringSessionDeleteManyArgs} args - Arguments to filter TutoringSessions to delete.
     * @example
     * // Delete a few TutoringSessions
     * const { count } = await prisma.tutoringSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TutoringSessionDeleteManyArgs>(args?: SelectSubset<T, TutoringSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TutoringSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TutoringSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TutoringSessions
     * const tutoringSession = await prisma.tutoringSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TutoringSessionUpdateManyArgs>(args: SelectSubset<T, TutoringSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TutoringSession.
     * @param {TutoringSessionUpsertArgs} args - Arguments to update or create a TutoringSession.
     * @example
     * // Update or create a TutoringSession
     * const tutoringSession = await prisma.tutoringSession.upsert({
     *   create: {
     *     // ... data to create a TutoringSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TutoringSession we want to update
     *   }
     * })
     */
    upsert<T extends TutoringSessionUpsertArgs>(args: SelectSubset<T, TutoringSessionUpsertArgs<ExtArgs>>): Prisma__TutoringSessionClient<$Result.GetResult<Prisma.$TutoringSessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TutoringSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TutoringSessionCountArgs} args - Arguments to filter TutoringSessions to count.
     * @example
     * // Count the number of TutoringSessions
     * const count = await prisma.tutoringSession.count({
     *   where: {
     *     // ... the filter for the TutoringSessions we want to count
     *   }
     * })
    **/
    count<T extends TutoringSessionCountArgs>(
      args?: Subset<T, TutoringSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TutoringSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TutoringSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TutoringSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TutoringSessionAggregateArgs>(args: Subset<T, TutoringSessionAggregateArgs>): Prisma.PrismaPromise<GetTutoringSessionAggregateType<T>>

    /**
     * Group by TutoringSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TutoringSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TutoringSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TutoringSessionGroupByArgs['orderBy'] }
        : { orderBy?: TutoringSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TutoringSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTutoringSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TutoringSession model
   */
  readonly fields: TutoringSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TutoringSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TutoringSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    teacher<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    availability<T extends TutoringSession$availabilityArgs<ExtArgs> = {}>(args?: Subset<T, TutoringSession$availabilityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TutoringAvailabilityPayload<ExtArgs>, T, "findMany"> | Null>
    requests<T extends TutoringSession$requestsArgs<ExtArgs> = {}>(args?: Subset<T, TutoringSession$requestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TutoringRequestPayload<ExtArgs>, T, "findMany"> | Null>
    appointments<T extends TutoringSession$appointmentsArgs<ExtArgs> = {}>(args?: Subset<T, TutoringSession$appointmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TutoringAppointmentPayload<ExtArgs>, T, "findMany"> | Null>
    reviews<T extends TutoringSession$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, TutoringSession$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TutoringReviewPayload<ExtArgs>, T, "findMany"> | Null>
    certificates<T extends TutoringSession$certificatesArgs<ExtArgs> = {}>(args?: Subset<T, TutoringSession$certificatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TutoringSession model
   */ 
  interface TutoringSessionFieldRefs {
    readonly id: FieldRef<"TutoringSession", 'String'>
    readonly teacherId: FieldRef<"TutoringSession", 'String'>
    readonly subject: FieldRef<"TutoringSession", 'String'>
    readonly description: FieldRef<"TutoringSession", 'String'>
    readonly pricePerHour: FieldRef<"TutoringSession", 'Decimal'>
    readonly locationType: FieldRef<"TutoringSession", 'TutoringLocationType'>
    readonly status: FieldRef<"TutoringSession", 'TutoringStatus'>
    readonly createdAt: FieldRef<"TutoringSession", 'DateTime'>
    readonly updatedAt: FieldRef<"TutoringSession", 'DateTime'>
    readonly maxStudents: FieldRef<"TutoringSession", 'Int'>
    readonly prerequisites: FieldRef<"TutoringSession", 'String[]'>
    readonly level: FieldRef<"TutoringSession", 'String'>
    readonly tags: FieldRef<"TutoringSession", 'String[]'>
    readonly featured: FieldRef<"TutoringSession", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * TutoringSession findUnique
   */
  export type TutoringSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutoringSession
     */
    select?: TutoringSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutoringSessionInclude<ExtArgs> | null
    /**
     * Filter, which TutoringSession to fetch.
     */
    where: TutoringSessionWhereUniqueInput
  }

  /**
   * TutoringSession findUniqueOrThrow
   */
  export type TutoringSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutoringSession
     */
    select?: TutoringSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutoringSessionInclude<ExtArgs> | null
    /**
     * Filter, which TutoringSession to fetch.
     */
    where: TutoringSessionWhereUniqueInput
  }

  /**
   * TutoringSession findFirst
   */
  export type TutoringSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutoringSession
     */
    select?: TutoringSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutoringSessionInclude<ExtArgs> | null
    /**
     * Filter, which TutoringSession to fetch.
     */
    where?: TutoringSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TutoringSessions to fetch.
     */
    orderBy?: TutoringSessionOrderByWithRelationInput | TutoringSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TutoringSessions.
     */
    cursor?: TutoringSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TutoringSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TutoringSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TutoringSessions.
     */
    distinct?: TutoringSessionScalarFieldEnum | TutoringSessionScalarFieldEnum[]
  }

  /**
   * TutoringSession findFirstOrThrow
   */
  export type TutoringSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutoringSession
     */
    select?: TutoringSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutoringSessionInclude<ExtArgs> | null
    /**
     * Filter, which TutoringSession to fetch.
     */
    where?: TutoringSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TutoringSessions to fetch.
     */
    orderBy?: TutoringSessionOrderByWithRelationInput | TutoringSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TutoringSessions.
     */
    cursor?: TutoringSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TutoringSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TutoringSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TutoringSessions.
     */
    distinct?: TutoringSessionScalarFieldEnum | TutoringSessionScalarFieldEnum[]
  }

  /**
   * TutoringSession findMany
   */
  export type TutoringSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutoringSession
     */
    select?: TutoringSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutoringSessionInclude<ExtArgs> | null
    /**
     * Filter, which TutoringSessions to fetch.
     */
    where?: TutoringSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TutoringSessions to fetch.
     */
    orderBy?: TutoringSessionOrderByWithRelationInput | TutoringSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TutoringSessions.
     */
    cursor?: TutoringSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TutoringSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TutoringSessions.
     */
    skip?: number
    distinct?: TutoringSessionScalarFieldEnum | TutoringSessionScalarFieldEnum[]
  }

  /**
   * TutoringSession create
   */
  export type TutoringSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutoringSession
     */
    select?: TutoringSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutoringSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a TutoringSession.
     */
    data: XOR<TutoringSessionCreateInput, TutoringSessionUncheckedCreateInput>
  }

  /**
   * TutoringSession createMany
   */
  export type TutoringSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TutoringSessions.
     */
    data: TutoringSessionCreateManyInput | TutoringSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TutoringSession createManyAndReturn
   */
  export type TutoringSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutoringSession
     */
    select?: TutoringSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TutoringSessions.
     */
    data: TutoringSessionCreateManyInput | TutoringSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutoringSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TutoringSession update
   */
  export type TutoringSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutoringSession
     */
    select?: TutoringSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutoringSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a TutoringSession.
     */
    data: XOR<TutoringSessionUpdateInput, TutoringSessionUncheckedUpdateInput>
    /**
     * Choose, which TutoringSession to update.
     */
    where: TutoringSessionWhereUniqueInput
  }

  /**
   * TutoringSession updateMany
   */
  export type TutoringSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TutoringSessions.
     */
    data: XOR<TutoringSessionUpdateManyMutationInput, TutoringSessionUncheckedUpdateManyInput>
    /**
     * Filter which TutoringSessions to update
     */
    where?: TutoringSessionWhereInput
  }

  /**
   * TutoringSession upsert
   */
  export type TutoringSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutoringSession
     */
    select?: TutoringSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutoringSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the TutoringSession to update in case it exists.
     */
    where: TutoringSessionWhereUniqueInput
    /**
     * In case the TutoringSession found by the `where` argument doesn't exist, create a new TutoringSession with this data.
     */
    create: XOR<TutoringSessionCreateInput, TutoringSessionUncheckedCreateInput>
    /**
     * In case the TutoringSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TutoringSessionUpdateInput, TutoringSessionUncheckedUpdateInput>
  }

  /**
   * TutoringSession delete
   */
  export type TutoringSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutoringSession
     */
    select?: TutoringSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutoringSessionInclude<ExtArgs> | null
    /**
     * Filter which TutoringSession to delete.
     */
    where: TutoringSessionWhereUniqueInput
  }

  /**
   * TutoringSession deleteMany
   */
  export type TutoringSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TutoringSessions to delete
     */
    where?: TutoringSessionWhereInput
  }

  /**
   * TutoringSession.availability
   */
  export type TutoringSession$availabilityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutoringAvailability
     */
    select?: TutoringAvailabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutoringAvailabilityInclude<ExtArgs> | null
    where?: TutoringAvailabilityWhereInput
    orderBy?: TutoringAvailabilityOrderByWithRelationInput | TutoringAvailabilityOrderByWithRelationInput[]
    cursor?: TutoringAvailabilityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TutoringAvailabilityScalarFieldEnum | TutoringAvailabilityScalarFieldEnum[]
  }

  /**
   * TutoringSession.requests
   */
  export type TutoringSession$requestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutoringRequest
     */
    select?: TutoringRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutoringRequestInclude<ExtArgs> | null
    where?: TutoringRequestWhereInput
    orderBy?: TutoringRequestOrderByWithRelationInput | TutoringRequestOrderByWithRelationInput[]
    cursor?: TutoringRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TutoringRequestScalarFieldEnum | TutoringRequestScalarFieldEnum[]
  }

  /**
   * TutoringSession.appointments
   */
  export type TutoringSession$appointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutoringAppointment
     */
    select?: TutoringAppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutoringAppointmentInclude<ExtArgs> | null
    where?: TutoringAppointmentWhereInput
    orderBy?: TutoringAppointmentOrderByWithRelationInput | TutoringAppointmentOrderByWithRelationInput[]
    cursor?: TutoringAppointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TutoringAppointmentScalarFieldEnum | TutoringAppointmentScalarFieldEnum[]
  }

  /**
   * TutoringSession.reviews
   */
  export type TutoringSession$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutoringReview
     */
    select?: TutoringReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutoringReviewInclude<ExtArgs> | null
    where?: TutoringReviewWhereInput
    orderBy?: TutoringReviewOrderByWithRelationInput | TutoringReviewOrderByWithRelationInput[]
    cursor?: TutoringReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TutoringReviewScalarFieldEnum | TutoringReviewScalarFieldEnum[]
  }

  /**
   * TutoringSession.certificates
   */
  export type TutoringSession$certificatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    where?: CertificateWhereInput
    orderBy?: CertificateOrderByWithRelationInput | CertificateOrderByWithRelationInput[]
    cursor?: CertificateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CertificateScalarFieldEnum | CertificateScalarFieldEnum[]
  }

  /**
   * TutoringSession without action
   */
  export type TutoringSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutoringSession
     */
    select?: TutoringSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutoringSessionInclude<ExtArgs> | null
  }


  /**
   * Model TutoringAvailability
   */

  export type AggregateTutoringAvailability = {
    _count: TutoringAvailabilityCountAggregateOutputType | null
    _avg: TutoringAvailabilityAvgAggregateOutputType | null
    _sum: TutoringAvailabilitySumAggregateOutputType | null
    _min: TutoringAvailabilityMinAggregateOutputType | null
    _max: TutoringAvailabilityMaxAggregateOutputType | null
  }

  export type TutoringAvailabilityAvgAggregateOutputType = {
    dayOfWeek: number | null
  }

  export type TutoringAvailabilitySumAggregateOutputType = {
    dayOfWeek: number | null
  }

  export type TutoringAvailabilityMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    dayOfWeek: number | null
    startTime: Date | null
    endTime: Date | null
  }

  export type TutoringAvailabilityMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    dayOfWeek: number | null
    startTime: Date | null
    endTime: Date | null
  }

  export type TutoringAvailabilityCountAggregateOutputType = {
    id: number
    sessionId: number
    dayOfWeek: number
    startTime: number
    endTime: number
    _all: number
  }


  export type TutoringAvailabilityAvgAggregateInputType = {
    dayOfWeek?: true
  }

  export type TutoringAvailabilitySumAggregateInputType = {
    dayOfWeek?: true
  }

  export type TutoringAvailabilityMinAggregateInputType = {
    id?: true
    sessionId?: true
    dayOfWeek?: true
    startTime?: true
    endTime?: true
  }

  export type TutoringAvailabilityMaxAggregateInputType = {
    id?: true
    sessionId?: true
    dayOfWeek?: true
    startTime?: true
    endTime?: true
  }

  export type TutoringAvailabilityCountAggregateInputType = {
    id?: true
    sessionId?: true
    dayOfWeek?: true
    startTime?: true
    endTime?: true
    _all?: true
  }

  export type TutoringAvailabilityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TutoringAvailability to aggregate.
     */
    where?: TutoringAvailabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TutoringAvailabilities to fetch.
     */
    orderBy?: TutoringAvailabilityOrderByWithRelationInput | TutoringAvailabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TutoringAvailabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TutoringAvailabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TutoringAvailabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TutoringAvailabilities
    **/
    _count?: true | TutoringAvailabilityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TutoringAvailabilityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TutoringAvailabilitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TutoringAvailabilityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TutoringAvailabilityMaxAggregateInputType
  }

  export type GetTutoringAvailabilityAggregateType<T extends TutoringAvailabilityAggregateArgs> = {
        [P in keyof T & keyof AggregateTutoringAvailability]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTutoringAvailability[P]>
      : GetScalarType<T[P], AggregateTutoringAvailability[P]>
  }




  export type TutoringAvailabilityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TutoringAvailabilityWhereInput
    orderBy?: TutoringAvailabilityOrderByWithAggregationInput | TutoringAvailabilityOrderByWithAggregationInput[]
    by: TutoringAvailabilityScalarFieldEnum[] | TutoringAvailabilityScalarFieldEnum
    having?: TutoringAvailabilityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TutoringAvailabilityCountAggregateInputType | true
    _avg?: TutoringAvailabilityAvgAggregateInputType
    _sum?: TutoringAvailabilitySumAggregateInputType
    _min?: TutoringAvailabilityMinAggregateInputType
    _max?: TutoringAvailabilityMaxAggregateInputType
  }

  export type TutoringAvailabilityGroupByOutputType = {
    id: string
    sessionId: string
    dayOfWeek: number
    startTime: Date
    endTime: Date
    _count: TutoringAvailabilityCountAggregateOutputType | null
    _avg: TutoringAvailabilityAvgAggregateOutputType | null
    _sum: TutoringAvailabilitySumAggregateOutputType | null
    _min: TutoringAvailabilityMinAggregateOutputType | null
    _max: TutoringAvailabilityMaxAggregateOutputType | null
  }

  type GetTutoringAvailabilityGroupByPayload<T extends TutoringAvailabilityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TutoringAvailabilityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TutoringAvailabilityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TutoringAvailabilityGroupByOutputType[P]>
            : GetScalarType<T[P], TutoringAvailabilityGroupByOutputType[P]>
        }
      >
    >


  export type TutoringAvailabilitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    dayOfWeek?: boolean
    startTime?: boolean
    endTime?: boolean
    session?: boolean | TutoringSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tutoringAvailability"]>

  export type TutoringAvailabilitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    dayOfWeek?: boolean
    startTime?: boolean
    endTime?: boolean
    session?: boolean | TutoringSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tutoringAvailability"]>

  export type TutoringAvailabilitySelectScalar = {
    id?: boolean
    sessionId?: boolean
    dayOfWeek?: boolean
    startTime?: boolean
    endTime?: boolean
  }

  export type TutoringAvailabilityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | TutoringSessionDefaultArgs<ExtArgs>
  }
  export type TutoringAvailabilityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | TutoringSessionDefaultArgs<ExtArgs>
  }

  export type $TutoringAvailabilityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TutoringAvailability"
    objects: {
      session: Prisma.$TutoringSessionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      dayOfWeek: number
      startTime: Date
      endTime: Date
    }, ExtArgs["result"]["tutoringAvailability"]>
    composites: {}
  }

  type TutoringAvailabilityGetPayload<S extends boolean | null | undefined | TutoringAvailabilityDefaultArgs> = $Result.GetResult<Prisma.$TutoringAvailabilityPayload, S>

  type TutoringAvailabilityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TutoringAvailabilityFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TutoringAvailabilityCountAggregateInputType | true
    }

  export interface TutoringAvailabilityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TutoringAvailability'], meta: { name: 'TutoringAvailability' } }
    /**
     * Find zero or one TutoringAvailability that matches the filter.
     * @param {TutoringAvailabilityFindUniqueArgs} args - Arguments to find a TutoringAvailability
     * @example
     * // Get one TutoringAvailability
     * const tutoringAvailability = await prisma.tutoringAvailability.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TutoringAvailabilityFindUniqueArgs>(args: SelectSubset<T, TutoringAvailabilityFindUniqueArgs<ExtArgs>>): Prisma__TutoringAvailabilityClient<$Result.GetResult<Prisma.$TutoringAvailabilityPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TutoringAvailability that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TutoringAvailabilityFindUniqueOrThrowArgs} args - Arguments to find a TutoringAvailability
     * @example
     * // Get one TutoringAvailability
     * const tutoringAvailability = await prisma.tutoringAvailability.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TutoringAvailabilityFindUniqueOrThrowArgs>(args: SelectSubset<T, TutoringAvailabilityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TutoringAvailabilityClient<$Result.GetResult<Prisma.$TutoringAvailabilityPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TutoringAvailability that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TutoringAvailabilityFindFirstArgs} args - Arguments to find a TutoringAvailability
     * @example
     * // Get one TutoringAvailability
     * const tutoringAvailability = await prisma.tutoringAvailability.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TutoringAvailabilityFindFirstArgs>(args?: SelectSubset<T, TutoringAvailabilityFindFirstArgs<ExtArgs>>): Prisma__TutoringAvailabilityClient<$Result.GetResult<Prisma.$TutoringAvailabilityPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TutoringAvailability that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TutoringAvailabilityFindFirstOrThrowArgs} args - Arguments to find a TutoringAvailability
     * @example
     * // Get one TutoringAvailability
     * const tutoringAvailability = await prisma.tutoringAvailability.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TutoringAvailabilityFindFirstOrThrowArgs>(args?: SelectSubset<T, TutoringAvailabilityFindFirstOrThrowArgs<ExtArgs>>): Prisma__TutoringAvailabilityClient<$Result.GetResult<Prisma.$TutoringAvailabilityPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TutoringAvailabilities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TutoringAvailabilityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TutoringAvailabilities
     * const tutoringAvailabilities = await prisma.tutoringAvailability.findMany()
     * 
     * // Get first 10 TutoringAvailabilities
     * const tutoringAvailabilities = await prisma.tutoringAvailability.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tutoringAvailabilityWithIdOnly = await prisma.tutoringAvailability.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TutoringAvailabilityFindManyArgs>(args?: SelectSubset<T, TutoringAvailabilityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TutoringAvailabilityPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TutoringAvailability.
     * @param {TutoringAvailabilityCreateArgs} args - Arguments to create a TutoringAvailability.
     * @example
     * // Create one TutoringAvailability
     * const TutoringAvailability = await prisma.tutoringAvailability.create({
     *   data: {
     *     // ... data to create a TutoringAvailability
     *   }
     * })
     * 
     */
    create<T extends TutoringAvailabilityCreateArgs>(args: SelectSubset<T, TutoringAvailabilityCreateArgs<ExtArgs>>): Prisma__TutoringAvailabilityClient<$Result.GetResult<Prisma.$TutoringAvailabilityPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TutoringAvailabilities.
     * @param {TutoringAvailabilityCreateManyArgs} args - Arguments to create many TutoringAvailabilities.
     * @example
     * // Create many TutoringAvailabilities
     * const tutoringAvailability = await prisma.tutoringAvailability.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TutoringAvailabilityCreateManyArgs>(args?: SelectSubset<T, TutoringAvailabilityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TutoringAvailabilities and returns the data saved in the database.
     * @param {TutoringAvailabilityCreateManyAndReturnArgs} args - Arguments to create many TutoringAvailabilities.
     * @example
     * // Create many TutoringAvailabilities
     * const tutoringAvailability = await prisma.tutoringAvailability.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TutoringAvailabilities and only return the `id`
     * const tutoringAvailabilityWithIdOnly = await prisma.tutoringAvailability.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TutoringAvailabilityCreateManyAndReturnArgs>(args?: SelectSubset<T, TutoringAvailabilityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TutoringAvailabilityPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TutoringAvailability.
     * @param {TutoringAvailabilityDeleteArgs} args - Arguments to delete one TutoringAvailability.
     * @example
     * // Delete one TutoringAvailability
     * const TutoringAvailability = await prisma.tutoringAvailability.delete({
     *   where: {
     *     // ... filter to delete one TutoringAvailability
     *   }
     * })
     * 
     */
    delete<T extends TutoringAvailabilityDeleteArgs>(args: SelectSubset<T, TutoringAvailabilityDeleteArgs<ExtArgs>>): Prisma__TutoringAvailabilityClient<$Result.GetResult<Prisma.$TutoringAvailabilityPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TutoringAvailability.
     * @param {TutoringAvailabilityUpdateArgs} args - Arguments to update one TutoringAvailability.
     * @example
     * // Update one TutoringAvailability
     * const tutoringAvailability = await prisma.tutoringAvailability.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TutoringAvailabilityUpdateArgs>(args: SelectSubset<T, TutoringAvailabilityUpdateArgs<ExtArgs>>): Prisma__TutoringAvailabilityClient<$Result.GetResult<Prisma.$TutoringAvailabilityPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TutoringAvailabilities.
     * @param {TutoringAvailabilityDeleteManyArgs} args - Arguments to filter TutoringAvailabilities to delete.
     * @example
     * // Delete a few TutoringAvailabilities
     * const { count } = await prisma.tutoringAvailability.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TutoringAvailabilityDeleteManyArgs>(args?: SelectSubset<T, TutoringAvailabilityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TutoringAvailabilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TutoringAvailabilityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TutoringAvailabilities
     * const tutoringAvailability = await prisma.tutoringAvailability.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TutoringAvailabilityUpdateManyArgs>(args: SelectSubset<T, TutoringAvailabilityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TutoringAvailability.
     * @param {TutoringAvailabilityUpsertArgs} args - Arguments to update or create a TutoringAvailability.
     * @example
     * // Update or create a TutoringAvailability
     * const tutoringAvailability = await prisma.tutoringAvailability.upsert({
     *   create: {
     *     // ... data to create a TutoringAvailability
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TutoringAvailability we want to update
     *   }
     * })
     */
    upsert<T extends TutoringAvailabilityUpsertArgs>(args: SelectSubset<T, TutoringAvailabilityUpsertArgs<ExtArgs>>): Prisma__TutoringAvailabilityClient<$Result.GetResult<Prisma.$TutoringAvailabilityPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TutoringAvailabilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TutoringAvailabilityCountArgs} args - Arguments to filter TutoringAvailabilities to count.
     * @example
     * // Count the number of TutoringAvailabilities
     * const count = await prisma.tutoringAvailability.count({
     *   where: {
     *     // ... the filter for the TutoringAvailabilities we want to count
     *   }
     * })
    **/
    count<T extends TutoringAvailabilityCountArgs>(
      args?: Subset<T, TutoringAvailabilityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TutoringAvailabilityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TutoringAvailability.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TutoringAvailabilityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TutoringAvailabilityAggregateArgs>(args: Subset<T, TutoringAvailabilityAggregateArgs>): Prisma.PrismaPromise<GetTutoringAvailabilityAggregateType<T>>

    /**
     * Group by TutoringAvailability.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TutoringAvailabilityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TutoringAvailabilityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TutoringAvailabilityGroupByArgs['orderBy'] }
        : { orderBy?: TutoringAvailabilityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TutoringAvailabilityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTutoringAvailabilityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TutoringAvailability model
   */
  readonly fields: TutoringAvailabilityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TutoringAvailability.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TutoringAvailabilityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends TutoringSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TutoringSessionDefaultArgs<ExtArgs>>): Prisma__TutoringSessionClient<$Result.GetResult<Prisma.$TutoringSessionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TutoringAvailability model
   */ 
  interface TutoringAvailabilityFieldRefs {
    readonly id: FieldRef<"TutoringAvailability", 'String'>
    readonly sessionId: FieldRef<"TutoringAvailability", 'String'>
    readonly dayOfWeek: FieldRef<"TutoringAvailability", 'Int'>
    readonly startTime: FieldRef<"TutoringAvailability", 'DateTime'>
    readonly endTime: FieldRef<"TutoringAvailability", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TutoringAvailability findUnique
   */
  export type TutoringAvailabilityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutoringAvailability
     */
    select?: TutoringAvailabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutoringAvailabilityInclude<ExtArgs> | null
    /**
     * Filter, which TutoringAvailability to fetch.
     */
    where: TutoringAvailabilityWhereUniqueInput
  }

  /**
   * TutoringAvailability findUniqueOrThrow
   */
  export type TutoringAvailabilityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutoringAvailability
     */
    select?: TutoringAvailabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutoringAvailabilityInclude<ExtArgs> | null
    /**
     * Filter, which TutoringAvailability to fetch.
     */
    where: TutoringAvailabilityWhereUniqueInput
  }

  /**
   * TutoringAvailability findFirst
   */
  export type TutoringAvailabilityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutoringAvailability
     */
    select?: TutoringAvailabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutoringAvailabilityInclude<ExtArgs> | null
    /**
     * Filter, which TutoringAvailability to fetch.
     */
    where?: TutoringAvailabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TutoringAvailabilities to fetch.
     */
    orderBy?: TutoringAvailabilityOrderByWithRelationInput | TutoringAvailabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TutoringAvailabilities.
     */
    cursor?: TutoringAvailabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TutoringAvailabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TutoringAvailabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TutoringAvailabilities.
     */
    distinct?: TutoringAvailabilityScalarFieldEnum | TutoringAvailabilityScalarFieldEnum[]
  }

  /**
   * TutoringAvailability findFirstOrThrow
   */
  export type TutoringAvailabilityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutoringAvailability
     */
    select?: TutoringAvailabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutoringAvailabilityInclude<ExtArgs> | null
    /**
     * Filter, which TutoringAvailability to fetch.
     */
    where?: TutoringAvailabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TutoringAvailabilities to fetch.
     */
    orderBy?: TutoringAvailabilityOrderByWithRelationInput | TutoringAvailabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TutoringAvailabilities.
     */
    cursor?: TutoringAvailabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TutoringAvailabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TutoringAvailabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TutoringAvailabilities.
     */
    distinct?: TutoringAvailabilityScalarFieldEnum | TutoringAvailabilityScalarFieldEnum[]
  }

  /**
   * TutoringAvailability findMany
   */
  export type TutoringAvailabilityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutoringAvailability
     */
    select?: TutoringAvailabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutoringAvailabilityInclude<ExtArgs> | null
    /**
     * Filter, which TutoringAvailabilities to fetch.
     */
    where?: TutoringAvailabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TutoringAvailabilities to fetch.
     */
    orderBy?: TutoringAvailabilityOrderByWithRelationInput | TutoringAvailabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TutoringAvailabilities.
     */
    cursor?: TutoringAvailabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TutoringAvailabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TutoringAvailabilities.
     */
    skip?: number
    distinct?: TutoringAvailabilityScalarFieldEnum | TutoringAvailabilityScalarFieldEnum[]
  }

  /**
   * TutoringAvailability create
   */
  export type TutoringAvailabilityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutoringAvailability
     */
    select?: TutoringAvailabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutoringAvailabilityInclude<ExtArgs> | null
    /**
     * The data needed to create a TutoringAvailability.
     */
    data: XOR<TutoringAvailabilityCreateInput, TutoringAvailabilityUncheckedCreateInput>
  }

  /**
   * TutoringAvailability createMany
   */
  export type TutoringAvailabilityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TutoringAvailabilities.
     */
    data: TutoringAvailabilityCreateManyInput | TutoringAvailabilityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TutoringAvailability createManyAndReturn
   */
  export type TutoringAvailabilityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutoringAvailability
     */
    select?: TutoringAvailabilitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TutoringAvailabilities.
     */
    data: TutoringAvailabilityCreateManyInput | TutoringAvailabilityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutoringAvailabilityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TutoringAvailability update
   */
  export type TutoringAvailabilityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutoringAvailability
     */
    select?: TutoringAvailabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutoringAvailabilityInclude<ExtArgs> | null
    /**
     * The data needed to update a TutoringAvailability.
     */
    data: XOR<TutoringAvailabilityUpdateInput, TutoringAvailabilityUncheckedUpdateInput>
    /**
     * Choose, which TutoringAvailability to update.
     */
    where: TutoringAvailabilityWhereUniqueInput
  }

  /**
   * TutoringAvailability updateMany
   */
  export type TutoringAvailabilityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TutoringAvailabilities.
     */
    data: XOR<TutoringAvailabilityUpdateManyMutationInput, TutoringAvailabilityUncheckedUpdateManyInput>
    /**
     * Filter which TutoringAvailabilities to update
     */
    where?: TutoringAvailabilityWhereInput
  }

  /**
   * TutoringAvailability upsert
   */
  export type TutoringAvailabilityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutoringAvailability
     */
    select?: TutoringAvailabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutoringAvailabilityInclude<ExtArgs> | null
    /**
     * The filter to search for the TutoringAvailability to update in case it exists.
     */
    where: TutoringAvailabilityWhereUniqueInput
    /**
     * In case the TutoringAvailability found by the `where` argument doesn't exist, create a new TutoringAvailability with this data.
     */
    create: XOR<TutoringAvailabilityCreateInput, TutoringAvailabilityUncheckedCreateInput>
    /**
     * In case the TutoringAvailability was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TutoringAvailabilityUpdateInput, TutoringAvailabilityUncheckedUpdateInput>
  }

  /**
   * TutoringAvailability delete
   */
  export type TutoringAvailabilityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutoringAvailability
     */
    select?: TutoringAvailabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutoringAvailabilityInclude<ExtArgs> | null
    /**
     * Filter which TutoringAvailability to delete.
     */
    where: TutoringAvailabilityWhereUniqueInput
  }

  /**
   * TutoringAvailability deleteMany
   */
  export type TutoringAvailabilityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TutoringAvailabilities to delete
     */
    where?: TutoringAvailabilityWhereInput
  }

  /**
   * TutoringAvailability without action
   */
  export type TutoringAvailabilityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutoringAvailability
     */
    select?: TutoringAvailabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutoringAvailabilityInclude<ExtArgs> | null
  }


  /**
   * Model TutoringRequest
   */

  export type AggregateTutoringRequest = {
    _count: TutoringRequestCountAggregateOutputType | null
    _min: TutoringRequestMinAggregateOutputType | null
    _max: TutoringRequestMaxAggregateOutputType | null
  }

  export type TutoringRequestMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    studentId: string | null
    message: string | null
    status: $Enums.TutoringRequestStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TutoringRequestMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    studentId: string | null
    message: string | null
    status: $Enums.TutoringRequestStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TutoringRequestCountAggregateOutputType = {
    id: number
    sessionId: number
    studentId: number
    message: number
    preferredDates: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TutoringRequestMinAggregateInputType = {
    id?: true
    sessionId?: true
    studentId?: true
    message?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TutoringRequestMaxAggregateInputType = {
    id?: true
    sessionId?: true
    studentId?: true
    message?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TutoringRequestCountAggregateInputType = {
    id?: true
    sessionId?: true
    studentId?: true
    message?: true
    preferredDates?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TutoringRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TutoringRequest to aggregate.
     */
    where?: TutoringRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TutoringRequests to fetch.
     */
    orderBy?: TutoringRequestOrderByWithRelationInput | TutoringRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TutoringRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TutoringRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TutoringRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TutoringRequests
    **/
    _count?: true | TutoringRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TutoringRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TutoringRequestMaxAggregateInputType
  }

  export type GetTutoringRequestAggregateType<T extends TutoringRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateTutoringRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTutoringRequest[P]>
      : GetScalarType<T[P], AggregateTutoringRequest[P]>
  }




  export type TutoringRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TutoringRequestWhereInput
    orderBy?: TutoringRequestOrderByWithAggregationInput | TutoringRequestOrderByWithAggregationInput[]
    by: TutoringRequestScalarFieldEnum[] | TutoringRequestScalarFieldEnum
    having?: TutoringRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TutoringRequestCountAggregateInputType | true
    _min?: TutoringRequestMinAggregateInputType
    _max?: TutoringRequestMaxAggregateInputType
  }

  export type TutoringRequestGroupByOutputType = {
    id: string
    sessionId: string
    studentId: string
    message: string | null
    preferredDates: Date[]
    status: $Enums.TutoringRequestStatus
    createdAt: Date
    updatedAt: Date
    _count: TutoringRequestCountAggregateOutputType | null
    _min: TutoringRequestMinAggregateOutputType | null
    _max: TutoringRequestMaxAggregateOutputType | null
  }

  type GetTutoringRequestGroupByPayload<T extends TutoringRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TutoringRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TutoringRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TutoringRequestGroupByOutputType[P]>
            : GetScalarType<T[P], TutoringRequestGroupByOutputType[P]>
        }
      >
    >


  export type TutoringRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    studentId?: boolean
    message?: boolean
    preferredDates?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    session?: boolean | TutoringSessionDefaultArgs<ExtArgs>
    student?: boolean | UserDefaultArgs<ExtArgs>
    appointment?: boolean | TutoringRequest$appointmentArgs<ExtArgs>
    messages?: boolean | TutoringRequest$messagesArgs<ExtArgs>
    _count?: boolean | TutoringRequestCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tutoringRequest"]>

  export type TutoringRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    studentId?: boolean
    message?: boolean
    preferredDates?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    session?: boolean | TutoringSessionDefaultArgs<ExtArgs>
    student?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tutoringRequest"]>

  export type TutoringRequestSelectScalar = {
    id?: boolean
    sessionId?: boolean
    studentId?: boolean
    message?: boolean
    preferredDates?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TutoringRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | TutoringSessionDefaultArgs<ExtArgs>
    student?: boolean | UserDefaultArgs<ExtArgs>
    appointment?: boolean | TutoringRequest$appointmentArgs<ExtArgs>
    messages?: boolean | TutoringRequest$messagesArgs<ExtArgs>
    _count?: boolean | TutoringRequestCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TutoringRequestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | TutoringSessionDefaultArgs<ExtArgs>
    student?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TutoringRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TutoringRequest"
    objects: {
      session: Prisma.$TutoringSessionPayload<ExtArgs>
      student: Prisma.$UserPayload<ExtArgs>
      appointment: Prisma.$TutoringAppointmentPayload<ExtArgs> | null
      messages: Prisma.$TutoringMessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      studentId: string
      message: string | null
      preferredDates: Date[]
      status: $Enums.TutoringRequestStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tutoringRequest"]>
    composites: {}
  }

  type TutoringRequestGetPayload<S extends boolean | null | undefined | TutoringRequestDefaultArgs> = $Result.GetResult<Prisma.$TutoringRequestPayload, S>

  type TutoringRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TutoringRequestFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TutoringRequestCountAggregateInputType | true
    }

  export interface TutoringRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TutoringRequest'], meta: { name: 'TutoringRequest' } }
    /**
     * Find zero or one TutoringRequest that matches the filter.
     * @param {TutoringRequestFindUniqueArgs} args - Arguments to find a TutoringRequest
     * @example
     * // Get one TutoringRequest
     * const tutoringRequest = await prisma.tutoringRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TutoringRequestFindUniqueArgs>(args: SelectSubset<T, TutoringRequestFindUniqueArgs<ExtArgs>>): Prisma__TutoringRequestClient<$Result.GetResult<Prisma.$TutoringRequestPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TutoringRequest that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TutoringRequestFindUniqueOrThrowArgs} args - Arguments to find a TutoringRequest
     * @example
     * // Get one TutoringRequest
     * const tutoringRequest = await prisma.tutoringRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TutoringRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, TutoringRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TutoringRequestClient<$Result.GetResult<Prisma.$TutoringRequestPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TutoringRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TutoringRequestFindFirstArgs} args - Arguments to find a TutoringRequest
     * @example
     * // Get one TutoringRequest
     * const tutoringRequest = await prisma.tutoringRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TutoringRequestFindFirstArgs>(args?: SelectSubset<T, TutoringRequestFindFirstArgs<ExtArgs>>): Prisma__TutoringRequestClient<$Result.GetResult<Prisma.$TutoringRequestPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TutoringRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TutoringRequestFindFirstOrThrowArgs} args - Arguments to find a TutoringRequest
     * @example
     * // Get one TutoringRequest
     * const tutoringRequest = await prisma.tutoringRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TutoringRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, TutoringRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__TutoringRequestClient<$Result.GetResult<Prisma.$TutoringRequestPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TutoringRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TutoringRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TutoringRequests
     * const tutoringRequests = await prisma.tutoringRequest.findMany()
     * 
     * // Get first 10 TutoringRequests
     * const tutoringRequests = await prisma.tutoringRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tutoringRequestWithIdOnly = await prisma.tutoringRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TutoringRequestFindManyArgs>(args?: SelectSubset<T, TutoringRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TutoringRequestPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TutoringRequest.
     * @param {TutoringRequestCreateArgs} args - Arguments to create a TutoringRequest.
     * @example
     * // Create one TutoringRequest
     * const TutoringRequest = await prisma.tutoringRequest.create({
     *   data: {
     *     // ... data to create a TutoringRequest
     *   }
     * })
     * 
     */
    create<T extends TutoringRequestCreateArgs>(args: SelectSubset<T, TutoringRequestCreateArgs<ExtArgs>>): Prisma__TutoringRequestClient<$Result.GetResult<Prisma.$TutoringRequestPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TutoringRequests.
     * @param {TutoringRequestCreateManyArgs} args - Arguments to create many TutoringRequests.
     * @example
     * // Create many TutoringRequests
     * const tutoringRequest = await prisma.tutoringRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TutoringRequestCreateManyArgs>(args?: SelectSubset<T, TutoringRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TutoringRequests and returns the data saved in the database.
     * @param {TutoringRequestCreateManyAndReturnArgs} args - Arguments to create many TutoringRequests.
     * @example
     * // Create many TutoringRequests
     * const tutoringRequest = await prisma.tutoringRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TutoringRequests and only return the `id`
     * const tutoringRequestWithIdOnly = await prisma.tutoringRequest.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TutoringRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, TutoringRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TutoringRequestPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TutoringRequest.
     * @param {TutoringRequestDeleteArgs} args - Arguments to delete one TutoringRequest.
     * @example
     * // Delete one TutoringRequest
     * const TutoringRequest = await prisma.tutoringRequest.delete({
     *   where: {
     *     // ... filter to delete one TutoringRequest
     *   }
     * })
     * 
     */
    delete<T extends TutoringRequestDeleteArgs>(args: SelectSubset<T, TutoringRequestDeleteArgs<ExtArgs>>): Prisma__TutoringRequestClient<$Result.GetResult<Prisma.$TutoringRequestPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TutoringRequest.
     * @param {TutoringRequestUpdateArgs} args - Arguments to update one TutoringRequest.
     * @example
     * // Update one TutoringRequest
     * const tutoringRequest = await prisma.tutoringRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TutoringRequestUpdateArgs>(args: SelectSubset<T, TutoringRequestUpdateArgs<ExtArgs>>): Prisma__TutoringRequestClient<$Result.GetResult<Prisma.$TutoringRequestPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TutoringRequests.
     * @param {TutoringRequestDeleteManyArgs} args - Arguments to filter TutoringRequests to delete.
     * @example
     * // Delete a few TutoringRequests
     * const { count } = await prisma.tutoringRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TutoringRequestDeleteManyArgs>(args?: SelectSubset<T, TutoringRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TutoringRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TutoringRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TutoringRequests
     * const tutoringRequest = await prisma.tutoringRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TutoringRequestUpdateManyArgs>(args: SelectSubset<T, TutoringRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TutoringRequest.
     * @param {TutoringRequestUpsertArgs} args - Arguments to update or create a TutoringRequest.
     * @example
     * // Update or create a TutoringRequest
     * const tutoringRequest = await prisma.tutoringRequest.upsert({
     *   create: {
     *     // ... data to create a TutoringRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TutoringRequest we want to update
     *   }
     * })
     */
    upsert<T extends TutoringRequestUpsertArgs>(args: SelectSubset<T, TutoringRequestUpsertArgs<ExtArgs>>): Prisma__TutoringRequestClient<$Result.GetResult<Prisma.$TutoringRequestPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TutoringRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TutoringRequestCountArgs} args - Arguments to filter TutoringRequests to count.
     * @example
     * // Count the number of TutoringRequests
     * const count = await prisma.tutoringRequest.count({
     *   where: {
     *     // ... the filter for the TutoringRequests we want to count
     *   }
     * })
    **/
    count<T extends TutoringRequestCountArgs>(
      args?: Subset<T, TutoringRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TutoringRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TutoringRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TutoringRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TutoringRequestAggregateArgs>(args: Subset<T, TutoringRequestAggregateArgs>): Prisma.PrismaPromise<GetTutoringRequestAggregateType<T>>

    /**
     * Group by TutoringRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TutoringRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TutoringRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TutoringRequestGroupByArgs['orderBy'] }
        : { orderBy?: TutoringRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TutoringRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTutoringRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TutoringRequest model
   */
  readonly fields: TutoringRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TutoringRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TutoringRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends TutoringSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TutoringSessionDefaultArgs<ExtArgs>>): Prisma__TutoringSessionClient<$Result.GetResult<Prisma.$TutoringSessionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    student<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    appointment<T extends TutoringRequest$appointmentArgs<ExtArgs> = {}>(args?: Subset<T, TutoringRequest$appointmentArgs<ExtArgs>>): Prisma__TutoringAppointmentClient<$Result.GetResult<Prisma.$TutoringAppointmentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    messages<T extends TutoringRequest$messagesArgs<ExtArgs> = {}>(args?: Subset<T, TutoringRequest$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TutoringMessagePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TutoringRequest model
   */ 
  interface TutoringRequestFieldRefs {
    readonly id: FieldRef<"TutoringRequest", 'String'>
    readonly sessionId: FieldRef<"TutoringRequest", 'String'>
    readonly studentId: FieldRef<"TutoringRequest", 'String'>
    readonly message: FieldRef<"TutoringRequest", 'String'>
    readonly preferredDates: FieldRef<"TutoringRequest", 'DateTime[]'>
    readonly status: FieldRef<"TutoringRequest", 'TutoringRequestStatus'>
    readonly createdAt: FieldRef<"TutoringRequest", 'DateTime'>
    readonly updatedAt: FieldRef<"TutoringRequest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TutoringRequest findUnique
   */
  export type TutoringRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutoringRequest
     */
    select?: TutoringRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutoringRequestInclude<ExtArgs> | null
    /**
     * Filter, which TutoringRequest to fetch.
     */
    where: TutoringRequestWhereUniqueInput
  }

  /**
   * TutoringRequest findUniqueOrThrow
   */
  export type TutoringRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutoringRequest
     */
    select?: TutoringRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutoringRequestInclude<ExtArgs> | null
    /**
     * Filter, which TutoringRequest to fetch.
     */
    where: TutoringRequestWhereUniqueInput
  }

  /**
   * TutoringRequest findFirst
   */
  export type TutoringRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutoringRequest
     */
    select?: TutoringRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutoringRequestInclude<ExtArgs> | null
    /**
     * Filter, which TutoringRequest to fetch.
     */
    where?: TutoringRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TutoringRequests to fetch.
     */
    orderBy?: TutoringRequestOrderByWithRelationInput | TutoringRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TutoringRequests.
     */
    cursor?: TutoringRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TutoringRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TutoringRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TutoringRequests.
     */
    distinct?: TutoringRequestScalarFieldEnum | TutoringRequestScalarFieldEnum[]
  }

  /**
   * TutoringRequest findFirstOrThrow
   */
  export type TutoringRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutoringRequest
     */
    select?: TutoringRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutoringRequestInclude<ExtArgs> | null
    /**
     * Filter, which TutoringRequest to fetch.
     */
    where?: TutoringRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TutoringRequests to fetch.
     */
    orderBy?: TutoringRequestOrderByWithRelationInput | TutoringRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TutoringRequests.
     */
    cursor?: TutoringRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TutoringRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TutoringRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TutoringRequests.
     */
    distinct?: TutoringRequestScalarFieldEnum | TutoringRequestScalarFieldEnum[]
  }

  /**
   * TutoringRequest findMany
   */
  export type TutoringRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutoringRequest
     */
    select?: TutoringRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutoringRequestInclude<ExtArgs> | null
    /**
     * Filter, which TutoringRequests to fetch.
     */
    where?: TutoringRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TutoringRequests to fetch.
     */
    orderBy?: TutoringRequestOrderByWithRelationInput | TutoringRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TutoringRequests.
     */
    cursor?: TutoringRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TutoringRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TutoringRequests.
     */
    skip?: number
    distinct?: TutoringRequestScalarFieldEnum | TutoringRequestScalarFieldEnum[]
  }

  /**
   * TutoringRequest create
   */
  export type TutoringRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutoringRequest
     */
    select?: TutoringRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutoringRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a TutoringRequest.
     */
    data: XOR<TutoringRequestCreateInput, TutoringRequestUncheckedCreateInput>
  }

  /**
   * TutoringRequest createMany
   */
  export type TutoringRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TutoringRequests.
     */
    data: TutoringRequestCreateManyInput | TutoringRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TutoringRequest createManyAndReturn
   */
  export type TutoringRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutoringRequest
     */
    select?: TutoringRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TutoringRequests.
     */
    data: TutoringRequestCreateManyInput | TutoringRequestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutoringRequestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TutoringRequest update
   */
  export type TutoringRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutoringRequest
     */
    select?: TutoringRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutoringRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a TutoringRequest.
     */
    data: XOR<TutoringRequestUpdateInput, TutoringRequestUncheckedUpdateInput>
    /**
     * Choose, which TutoringRequest to update.
     */
    where: TutoringRequestWhereUniqueInput
  }

  /**
   * TutoringRequest updateMany
   */
  export type TutoringRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TutoringRequests.
     */
    data: XOR<TutoringRequestUpdateManyMutationInput, TutoringRequestUncheckedUpdateManyInput>
    /**
     * Filter which TutoringRequests to update
     */
    where?: TutoringRequestWhereInput
  }

  /**
   * TutoringRequest upsert
   */
  export type TutoringRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutoringRequest
     */
    select?: TutoringRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutoringRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the TutoringRequest to update in case it exists.
     */
    where: TutoringRequestWhereUniqueInput
    /**
     * In case the TutoringRequest found by the `where` argument doesn't exist, create a new TutoringRequest with this data.
     */
    create: XOR<TutoringRequestCreateInput, TutoringRequestUncheckedCreateInput>
    /**
     * In case the TutoringRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TutoringRequestUpdateInput, TutoringRequestUncheckedUpdateInput>
  }

  /**
   * TutoringRequest delete
   */
  export type TutoringRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutoringRequest
     */
    select?: TutoringRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutoringRequestInclude<ExtArgs> | null
    /**
     * Filter which TutoringRequest to delete.
     */
    where: TutoringRequestWhereUniqueInput
  }

  /**
   * TutoringRequest deleteMany
   */
  export type TutoringRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TutoringRequests to delete
     */
    where?: TutoringRequestWhereInput
  }

  /**
   * TutoringRequest.appointment
   */
  export type TutoringRequest$appointmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutoringAppointment
     */
    select?: TutoringAppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutoringAppointmentInclude<ExtArgs> | null
    where?: TutoringAppointmentWhereInput
  }

  /**
   * TutoringRequest.messages
   */
  export type TutoringRequest$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutoringMessage
     */
    select?: TutoringMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutoringMessageInclude<ExtArgs> | null
    where?: TutoringMessageWhereInput
    orderBy?: TutoringMessageOrderByWithRelationInput | TutoringMessageOrderByWithRelationInput[]
    cursor?: TutoringMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TutoringMessageScalarFieldEnum | TutoringMessageScalarFieldEnum[]
  }

  /**
   * TutoringRequest without action
   */
  export type TutoringRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutoringRequest
     */
    select?: TutoringRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutoringRequestInclude<ExtArgs> | null
  }


  /**
   * Model TutoringAppointment
   */

  export type AggregateTutoringAppointment = {
    _count: TutoringAppointmentCountAggregateOutputType | null
    _avg: TutoringAppointmentAvgAggregateOutputType | null
    _sum: TutoringAppointmentSumAggregateOutputType | null
    _min: TutoringAppointmentMinAggregateOutputType | null
    _max: TutoringAppointmentMaxAggregateOutputType | null
  }

  export type TutoringAppointmentAvgAggregateOutputType = {
    duration: number | null
    price: Decimal | null
  }

  export type TutoringAppointmentSumAggregateOutputType = {
    duration: number | null
    price: Decimal | null
  }

  export type TutoringAppointmentMinAggregateOutputType = {
    id: string | null
    requestId: string | null
    sessionId: string | null
    scheduledAt: Date | null
    duration: number | null
    notes: string | null
    meetingLink: string | null
    status: $Enums.AppointmentStatus | null
    price: Decimal | null
    teacherId: string | null
    studentId: string | null
  }

  export type TutoringAppointmentMaxAggregateOutputType = {
    id: string | null
    requestId: string | null
    sessionId: string | null
    scheduledAt: Date | null
    duration: number | null
    notes: string | null
    meetingLink: string | null
    status: $Enums.AppointmentStatus | null
    price: Decimal | null
    teacherId: string | null
    studentId: string | null
  }

  export type TutoringAppointmentCountAggregateOutputType = {
    id: number
    requestId: number
    sessionId: number
    scheduledAt: number
    duration: number
    notes: number
    meetingLink: number
    status: number
    price: number
    teacherId: number
    studentId: number
    _all: number
  }


  export type TutoringAppointmentAvgAggregateInputType = {
    duration?: true
    price?: true
  }

  export type TutoringAppointmentSumAggregateInputType = {
    duration?: true
    price?: true
  }

  export type TutoringAppointmentMinAggregateInputType = {
    id?: true
    requestId?: true
    sessionId?: true
    scheduledAt?: true
    duration?: true
    notes?: true
    meetingLink?: true
    status?: true
    price?: true
    teacherId?: true
    studentId?: true
  }

  export type TutoringAppointmentMaxAggregateInputType = {
    id?: true
    requestId?: true
    sessionId?: true
    scheduledAt?: true
    duration?: true
    notes?: true
    meetingLink?: true
    status?: true
    price?: true
    teacherId?: true
    studentId?: true
  }

  export type TutoringAppointmentCountAggregateInputType = {
    id?: true
    requestId?: true
    sessionId?: true
    scheduledAt?: true
    duration?: true
    notes?: true
    meetingLink?: true
    status?: true
    price?: true
    teacherId?: true
    studentId?: true
    _all?: true
  }

  export type TutoringAppointmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TutoringAppointment to aggregate.
     */
    where?: TutoringAppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TutoringAppointments to fetch.
     */
    orderBy?: TutoringAppointmentOrderByWithRelationInput | TutoringAppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TutoringAppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TutoringAppointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TutoringAppointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TutoringAppointments
    **/
    _count?: true | TutoringAppointmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TutoringAppointmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TutoringAppointmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TutoringAppointmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TutoringAppointmentMaxAggregateInputType
  }

  export type GetTutoringAppointmentAggregateType<T extends TutoringAppointmentAggregateArgs> = {
        [P in keyof T & keyof AggregateTutoringAppointment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTutoringAppointment[P]>
      : GetScalarType<T[P], AggregateTutoringAppointment[P]>
  }




  export type TutoringAppointmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TutoringAppointmentWhereInput
    orderBy?: TutoringAppointmentOrderByWithAggregationInput | TutoringAppointmentOrderByWithAggregationInput[]
    by: TutoringAppointmentScalarFieldEnum[] | TutoringAppointmentScalarFieldEnum
    having?: TutoringAppointmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TutoringAppointmentCountAggregateInputType | true
    _avg?: TutoringAppointmentAvgAggregateInputType
    _sum?: TutoringAppointmentSumAggregateInputType
    _min?: TutoringAppointmentMinAggregateInputType
    _max?: TutoringAppointmentMaxAggregateInputType
  }

  export type TutoringAppointmentGroupByOutputType = {
    id: string
    requestId: string
    sessionId: string
    scheduledAt: Date
    duration: number
    notes: string | null
    meetingLink: string | null
    status: $Enums.AppointmentStatus
    price: Decimal
    teacherId: string
    studentId: string
    _count: TutoringAppointmentCountAggregateOutputType | null
    _avg: TutoringAppointmentAvgAggregateOutputType | null
    _sum: TutoringAppointmentSumAggregateOutputType | null
    _min: TutoringAppointmentMinAggregateOutputType | null
    _max: TutoringAppointmentMaxAggregateOutputType | null
  }

  type GetTutoringAppointmentGroupByPayload<T extends TutoringAppointmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TutoringAppointmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TutoringAppointmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TutoringAppointmentGroupByOutputType[P]>
            : GetScalarType<T[P], TutoringAppointmentGroupByOutputType[P]>
        }
      >
    >


  export type TutoringAppointmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    requestId?: boolean
    sessionId?: boolean
    scheduledAt?: boolean
    duration?: boolean
    notes?: boolean
    meetingLink?: boolean
    status?: boolean
    price?: boolean
    teacherId?: boolean
    studentId?: boolean
    request?: boolean | TutoringRequestDefaultArgs<ExtArgs>
    session?: boolean | TutoringSessionDefaultArgs<ExtArgs>
    teacher?: boolean | UserDefaultArgs<ExtArgs>
    student?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tutoringAppointment"]>

  export type TutoringAppointmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    requestId?: boolean
    sessionId?: boolean
    scheduledAt?: boolean
    duration?: boolean
    notes?: boolean
    meetingLink?: boolean
    status?: boolean
    price?: boolean
    teacherId?: boolean
    studentId?: boolean
    request?: boolean | TutoringRequestDefaultArgs<ExtArgs>
    session?: boolean | TutoringSessionDefaultArgs<ExtArgs>
    teacher?: boolean | UserDefaultArgs<ExtArgs>
    student?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tutoringAppointment"]>

  export type TutoringAppointmentSelectScalar = {
    id?: boolean
    requestId?: boolean
    sessionId?: boolean
    scheduledAt?: boolean
    duration?: boolean
    notes?: boolean
    meetingLink?: boolean
    status?: boolean
    price?: boolean
    teacherId?: boolean
    studentId?: boolean
  }

  export type TutoringAppointmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    request?: boolean | TutoringRequestDefaultArgs<ExtArgs>
    session?: boolean | TutoringSessionDefaultArgs<ExtArgs>
    teacher?: boolean | UserDefaultArgs<ExtArgs>
    student?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TutoringAppointmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    request?: boolean | TutoringRequestDefaultArgs<ExtArgs>
    session?: boolean | TutoringSessionDefaultArgs<ExtArgs>
    teacher?: boolean | UserDefaultArgs<ExtArgs>
    student?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TutoringAppointmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TutoringAppointment"
    objects: {
      request: Prisma.$TutoringRequestPayload<ExtArgs>
      session: Prisma.$TutoringSessionPayload<ExtArgs>
      teacher: Prisma.$UserPayload<ExtArgs>
      student: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      requestId: string
      sessionId: string
      scheduledAt: Date
      duration: number
      notes: string | null
      meetingLink: string | null
      status: $Enums.AppointmentStatus
      price: Prisma.Decimal
      teacherId: string
      studentId: string
    }, ExtArgs["result"]["tutoringAppointment"]>
    composites: {}
  }

  type TutoringAppointmentGetPayload<S extends boolean | null | undefined | TutoringAppointmentDefaultArgs> = $Result.GetResult<Prisma.$TutoringAppointmentPayload, S>

  type TutoringAppointmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TutoringAppointmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TutoringAppointmentCountAggregateInputType | true
    }

  export interface TutoringAppointmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TutoringAppointment'], meta: { name: 'TutoringAppointment' } }
    /**
     * Find zero or one TutoringAppointment that matches the filter.
     * @param {TutoringAppointmentFindUniqueArgs} args - Arguments to find a TutoringAppointment
     * @example
     * // Get one TutoringAppointment
     * const tutoringAppointment = await prisma.tutoringAppointment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TutoringAppointmentFindUniqueArgs>(args: SelectSubset<T, TutoringAppointmentFindUniqueArgs<ExtArgs>>): Prisma__TutoringAppointmentClient<$Result.GetResult<Prisma.$TutoringAppointmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TutoringAppointment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TutoringAppointmentFindUniqueOrThrowArgs} args - Arguments to find a TutoringAppointment
     * @example
     * // Get one TutoringAppointment
     * const tutoringAppointment = await prisma.tutoringAppointment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TutoringAppointmentFindUniqueOrThrowArgs>(args: SelectSubset<T, TutoringAppointmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TutoringAppointmentClient<$Result.GetResult<Prisma.$TutoringAppointmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TutoringAppointment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TutoringAppointmentFindFirstArgs} args - Arguments to find a TutoringAppointment
     * @example
     * // Get one TutoringAppointment
     * const tutoringAppointment = await prisma.tutoringAppointment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TutoringAppointmentFindFirstArgs>(args?: SelectSubset<T, TutoringAppointmentFindFirstArgs<ExtArgs>>): Prisma__TutoringAppointmentClient<$Result.GetResult<Prisma.$TutoringAppointmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TutoringAppointment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TutoringAppointmentFindFirstOrThrowArgs} args - Arguments to find a TutoringAppointment
     * @example
     * // Get one TutoringAppointment
     * const tutoringAppointment = await prisma.tutoringAppointment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TutoringAppointmentFindFirstOrThrowArgs>(args?: SelectSubset<T, TutoringAppointmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__TutoringAppointmentClient<$Result.GetResult<Prisma.$TutoringAppointmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TutoringAppointments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TutoringAppointmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TutoringAppointments
     * const tutoringAppointments = await prisma.tutoringAppointment.findMany()
     * 
     * // Get first 10 TutoringAppointments
     * const tutoringAppointments = await prisma.tutoringAppointment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tutoringAppointmentWithIdOnly = await prisma.tutoringAppointment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TutoringAppointmentFindManyArgs>(args?: SelectSubset<T, TutoringAppointmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TutoringAppointmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TutoringAppointment.
     * @param {TutoringAppointmentCreateArgs} args - Arguments to create a TutoringAppointment.
     * @example
     * // Create one TutoringAppointment
     * const TutoringAppointment = await prisma.tutoringAppointment.create({
     *   data: {
     *     // ... data to create a TutoringAppointment
     *   }
     * })
     * 
     */
    create<T extends TutoringAppointmentCreateArgs>(args: SelectSubset<T, TutoringAppointmentCreateArgs<ExtArgs>>): Prisma__TutoringAppointmentClient<$Result.GetResult<Prisma.$TutoringAppointmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TutoringAppointments.
     * @param {TutoringAppointmentCreateManyArgs} args - Arguments to create many TutoringAppointments.
     * @example
     * // Create many TutoringAppointments
     * const tutoringAppointment = await prisma.tutoringAppointment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TutoringAppointmentCreateManyArgs>(args?: SelectSubset<T, TutoringAppointmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TutoringAppointments and returns the data saved in the database.
     * @param {TutoringAppointmentCreateManyAndReturnArgs} args - Arguments to create many TutoringAppointments.
     * @example
     * // Create many TutoringAppointments
     * const tutoringAppointment = await prisma.tutoringAppointment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TutoringAppointments and only return the `id`
     * const tutoringAppointmentWithIdOnly = await prisma.tutoringAppointment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TutoringAppointmentCreateManyAndReturnArgs>(args?: SelectSubset<T, TutoringAppointmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TutoringAppointmentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TutoringAppointment.
     * @param {TutoringAppointmentDeleteArgs} args - Arguments to delete one TutoringAppointment.
     * @example
     * // Delete one TutoringAppointment
     * const TutoringAppointment = await prisma.tutoringAppointment.delete({
     *   where: {
     *     // ... filter to delete one TutoringAppointment
     *   }
     * })
     * 
     */
    delete<T extends TutoringAppointmentDeleteArgs>(args: SelectSubset<T, TutoringAppointmentDeleteArgs<ExtArgs>>): Prisma__TutoringAppointmentClient<$Result.GetResult<Prisma.$TutoringAppointmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TutoringAppointment.
     * @param {TutoringAppointmentUpdateArgs} args - Arguments to update one TutoringAppointment.
     * @example
     * // Update one TutoringAppointment
     * const tutoringAppointment = await prisma.tutoringAppointment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TutoringAppointmentUpdateArgs>(args: SelectSubset<T, TutoringAppointmentUpdateArgs<ExtArgs>>): Prisma__TutoringAppointmentClient<$Result.GetResult<Prisma.$TutoringAppointmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TutoringAppointments.
     * @param {TutoringAppointmentDeleteManyArgs} args - Arguments to filter TutoringAppointments to delete.
     * @example
     * // Delete a few TutoringAppointments
     * const { count } = await prisma.tutoringAppointment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TutoringAppointmentDeleteManyArgs>(args?: SelectSubset<T, TutoringAppointmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TutoringAppointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TutoringAppointmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TutoringAppointments
     * const tutoringAppointment = await prisma.tutoringAppointment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TutoringAppointmentUpdateManyArgs>(args: SelectSubset<T, TutoringAppointmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TutoringAppointment.
     * @param {TutoringAppointmentUpsertArgs} args - Arguments to update or create a TutoringAppointment.
     * @example
     * // Update or create a TutoringAppointment
     * const tutoringAppointment = await prisma.tutoringAppointment.upsert({
     *   create: {
     *     // ... data to create a TutoringAppointment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TutoringAppointment we want to update
     *   }
     * })
     */
    upsert<T extends TutoringAppointmentUpsertArgs>(args: SelectSubset<T, TutoringAppointmentUpsertArgs<ExtArgs>>): Prisma__TutoringAppointmentClient<$Result.GetResult<Prisma.$TutoringAppointmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TutoringAppointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TutoringAppointmentCountArgs} args - Arguments to filter TutoringAppointments to count.
     * @example
     * // Count the number of TutoringAppointments
     * const count = await prisma.tutoringAppointment.count({
     *   where: {
     *     // ... the filter for the TutoringAppointments we want to count
     *   }
     * })
    **/
    count<T extends TutoringAppointmentCountArgs>(
      args?: Subset<T, TutoringAppointmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TutoringAppointmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TutoringAppointment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TutoringAppointmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TutoringAppointmentAggregateArgs>(args: Subset<T, TutoringAppointmentAggregateArgs>): Prisma.PrismaPromise<GetTutoringAppointmentAggregateType<T>>

    /**
     * Group by TutoringAppointment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TutoringAppointmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TutoringAppointmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TutoringAppointmentGroupByArgs['orderBy'] }
        : { orderBy?: TutoringAppointmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TutoringAppointmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTutoringAppointmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TutoringAppointment model
   */
  readonly fields: TutoringAppointmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TutoringAppointment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TutoringAppointmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    request<T extends TutoringRequestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TutoringRequestDefaultArgs<ExtArgs>>): Prisma__TutoringRequestClient<$Result.GetResult<Prisma.$TutoringRequestPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    session<T extends TutoringSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TutoringSessionDefaultArgs<ExtArgs>>): Prisma__TutoringSessionClient<$Result.GetResult<Prisma.$TutoringSessionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    teacher<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    student<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TutoringAppointment model
   */ 
  interface TutoringAppointmentFieldRefs {
    readonly id: FieldRef<"TutoringAppointment", 'String'>
    readonly requestId: FieldRef<"TutoringAppointment", 'String'>
    readonly sessionId: FieldRef<"TutoringAppointment", 'String'>
    readonly scheduledAt: FieldRef<"TutoringAppointment", 'DateTime'>
    readonly duration: FieldRef<"TutoringAppointment", 'Int'>
    readonly notes: FieldRef<"TutoringAppointment", 'String'>
    readonly meetingLink: FieldRef<"TutoringAppointment", 'String'>
    readonly status: FieldRef<"TutoringAppointment", 'AppointmentStatus'>
    readonly price: FieldRef<"TutoringAppointment", 'Decimal'>
    readonly teacherId: FieldRef<"TutoringAppointment", 'String'>
    readonly studentId: FieldRef<"TutoringAppointment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TutoringAppointment findUnique
   */
  export type TutoringAppointmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutoringAppointment
     */
    select?: TutoringAppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutoringAppointmentInclude<ExtArgs> | null
    /**
     * Filter, which TutoringAppointment to fetch.
     */
    where: TutoringAppointmentWhereUniqueInput
  }

  /**
   * TutoringAppointment findUniqueOrThrow
   */
  export type TutoringAppointmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutoringAppointment
     */
    select?: TutoringAppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutoringAppointmentInclude<ExtArgs> | null
    /**
     * Filter, which TutoringAppointment to fetch.
     */
    where: TutoringAppointmentWhereUniqueInput
  }

  /**
   * TutoringAppointment findFirst
   */
  export type TutoringAppointmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutoringAppointment
     */
    select?: TutoringAppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutoringAppointmentInclude<ExtArgs> | null
    /**
     * Filter, which TutoringAppointment to fetch.
     */
    where?: TutoringAppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TutoringAppointments to fetch.
     */
    orderBy?: TutoringAppointmentOrderByWithRelationInput | TutoringAppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TutoringAppointments.
     */
    cursor?: TutoringAppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TutoringAppointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TutoringAppointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TutoringAppointments.
     */
    distinct?: TutoringAppointmentScalarFieldEnum | TutoringAppointmentScalarFieldEnum[]
  }

  /**
   * TutoringAppointment findFirstOrThrow
   */
  export type TutoringAppointmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutoringAppointment
     */
    select?: TutoringAppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutoringAppointmentInclude<ExtArgs> | null
    /**
     * Filter, which TutoringAppointment to fetch.
     */
    where?: TutoringAppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TutoringAppointments to fetch.
     */
    orderBy?: TutoringAppointmentOrderByWithRelationInput | TutoringAppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TutoringAppointments.
     */
    cursor?: TutoringAppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TutoringAppointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TutoringAppointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TutoringAppointments.
     */
    distinct?: TutoringAppointmentScalarFieldEnum | TutoringAppointmentScalarFieldEnum[]
  }

  /**
   * TutoringAppointment findMany
   */
  export type TutoringAppointmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutoringAppointment
     */
    select?: TutoringAppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutoringAppointmentInclude<ExtArgs> | null
    /**
     * Filter, which TutoringAppointments to fetch.
     */
    where?: TutoringAppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TutoringAppointments to fetch.
     */
    orderBy?: TutoringAppointmentOrderByWithRelationInput | TutoringAppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TutoringAppointments.
     */
    cursor?: TutoringAppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TutoringAppointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TutoringAppointments.
     */
    skip?: number
    distinct?: TutoringAppointmentScalarFieldEnum | TutoringAppointmentScalarFieldEnum[]
  }

  /**
   * TutoringAppointment create
   */
  export type TutoringAppointmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutoringAppointment
     */
    select?: TutoringAppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutoringAppointmentInclude<ExtArgs> | null
    /**
     * The data needed to create a TutoringAppointment.
     */
    data: XOR<TutoringAppointmentCreateInput, TutoringAppointmentUncheckedCreateInput>
  }

  /**
   * TutoringAppointment createMany
   */
  export type TutoringAppointmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TutoringAppointments.
     */
    data: TutoringAppointmentCreateManyInput | TutoringAppointmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TutoringAppointment createManyAndReturn
   */
  export type TutoringAppointmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutoringAppointment
     */
    select?: TutoringAppointmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TutoringAppointments.
     */
    data: TutoringAppointmentCreateManyInput | TutoringAppointmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutoringAppointmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TutoringAppointment update
   */
  export type TutoringAppointmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutoringAppointment
     */
    select?: TutoringAppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutoringAppointmentInclude<ExtArgs> | null
    /**
     * The data needed to update a TutoringAppointment.
     */
    data: XOR<TutoringAppointmentUpdateInput, TutoringAppointmentUncheckedUpdateInput>
    /**
     * Choose, which TutoringAppointment to update.
     */
    where: TutoringAppointmentWhereUniqueInput
  }

  /**
   * TutoringAppointment updateMany
   */
  export type TutoringAppointmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TutoringAppointments.
     */
    data: XOR<TutoringAppointmentUpdateManyMutationInput, TutoringAppointmentUncheckedUpdateManyInput>
    /**
     * Filter which TutoringAppointments to update
     */
    where?: TutoringAppointmentWhereInput
  }

  /**
   * TutoringAppointment upsert
   */
  export type TutoringAppointmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutoringAppointment
     */
    select?: TutoringAppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutoringAppointmentInclude<ExtArgs> | null
    /**
     * The filter to search for the TutoringAppointment to update in case it exists.
     */
    where: TutoringAppointmentWhereUniqueInput
    /**
     * In case the TutoringAppointment found by the `where` argument doesn't exist, create a new TutoringAppointment with this data.
     */
    create: XOR<TutoringAppointmentCreateInput, TutoringAppointmentUncheckedCreateInput>
    /**
     * In case the TutoringAppointment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TutoringAppointmentUpdateInput, TutoringAppointmentUncheckedUpdateInput>
  }

  /**
   * TutoringAppointment delete
   */
  export type TutoringAppointmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutoringAppointment
     */
    select?: TutoringAppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutoringAppointmentInclude<ExtArgs> | null
    /**
     * Filter which TutoringAppointment to delete.
     */
    where: TutoringAppointmentWhereUniqueInput
  }

  /**
   * TutoringAppointment deleteMany
   */
  export type TutoringAppointmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TutoringAppointments to delete
     */
    where?: TutoringAppointmentWhereInput
  }

  /**
   * TutoringAppointment without action
   */
  export type TutoringAppointmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutoringAppointment
     */
    select?: TutoringAppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutoringAppointmentInclude<ExtArgs> | null
  }


  /**
   * Model TutoringReview
   */

  export type AggregateTutoringReview = {
    _count: TutoringReviewCountAggregateOutputType | null
    _avg: TutoringReviewAvgAggregateOutputType | null
    _sum: TutoringReviewSumAggregateOutputType | null
    _min: TutoringReviewMinAggregateOutputType | null
    _max: TutoringReviewMaxAggregateOutputType | null
  }

  export type TutoringReviewAvgAggregateOutputType = {
    rating: number | null
  }

  export type TutoringReviewSumAggregateOutputType = {
    rating: number | null
  }

  export type TutoringReviewMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    studentId: string | null
    rating: number | null
    comment: string | null
    createdAt: Date | null
  }

  export type TutoringReviewMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    studentId: string | null
    rating: number | null
    comment: string | null
    createdAt: Date | null
  }

  export type TutoringReviewCountAggregateOutputType = {
    id: number
    sessionId: number
    studentId: number
    rating: number
    comment: number
    createdAt: number
    _all: number
  }


  export type TutoringReviewAvgAggregateInputType = {
    rating?: true
  }

  export type TutoringReviewSumAggregateInputType = {
    rating?: true
  }

  export type TutoringReviewMinAggregateInputType = {
    id?: true
    sessionId?: true
    studentId?: true
    rating?: true
    comment?: true
    createdAt?: true
  }

  export type TutoringReviewMaxAggregateInputType = {
    id?: true
    sessionId?: true
    studentId?: true
    rating?: true
    comment?: true
    createdAt?: true
  }

  export type TutoringReviewCountAggregateInputType = {
    id?: true
    sessionId?: true
    studentId?: true
    rating?: true
    comment?: true
    createdAt?: true
    _all?: true
  }

  export type TutoringReviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TutoringReview to aggregate.
     */
    where?: TutoringReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TutoringReviews to fetch.
     */
    orderBy?: TutoringReviewOrderByWithRelationInput | TutoringReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TutoringReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TutoringReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TutoringReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TutoringReviews
    **/
    _count?: true | TutoringReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TutoringReviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TutoringReviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TutoringReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TutoringReviewMaxAggregateInputType
  }

  export type GetTutoringReviewAggregateType<T extends TutoringReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateTutoringReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTutoringReview[P]>
      : GetScalarType<T[P], AggregateTutoringReview[P]>
  }




  export type TutoringReviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TutoringReviewWhereInput
    orderBy?: TutoringReviewOrderByWithAggregationInput | TutoringReviewOrderByWithAggregationInput[]
    by: TutoringReviewScalarFieldEnum[] | TutoringReviewScalarFieldEnum
    having?: TutoringReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TutoringReviewCountAggregateInputType | true
    _avg?: TutoringReviewAvgAggregateInputType
    _sum?: TutoringReviewSumAggregateInputType
    _min?: TutoringReviewMinAggregateInputType
    _max?: TutoringReviewMaxAggregateInputType
  }

  export type TutoringReviewGroupByOutputType = {
    id: string
    sessionId: string
    studentId: string
    rating: number
    comment: string | null
    createdAt: Date
    _count: TutoringReviewCountAggregateOutputType | null
    _avg: TutoringReviewAvgAggregateOutputType | null
    _sum: TutoringReviewSumAggregateOutputType | null
    _min: TutoringReviewMinAggregateOutputType | null
    _max: TutoringReviewMaxAggregateOutputType | null
  }

  type GetTutoringReviewGroupByPayload<T extends TutoringReviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TutoringReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TutoringReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TutoringReviewGroupByOutputType[P]>
            : GetScalarType<T[P], TutoringReviewGroupByOutputType[P]>
        }
      >
    >


  export type TutoringReviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    studentId?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
    session?: boolean | TutoringSessionDefaultArgs<ExtArgs>
    student?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tutoringReview"]>

  export type TutoringReviewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    studentId?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
    session?: boolean | TutoringSessionDefaultArgs<ExtArgs>
    student?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tutoringReview"]>

  export type TutoringReviewSelectScalar = {
    id?: boolean
    sessionId?: boolean
    studentId?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
  }

  export type TutoringReviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | TutoringSessionDefaultArgs<ExtArgs>
    student?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TutoringReviewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | TutoringSessionDefaultArgs<ExtArgs>
    student?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TutoringReviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TutoringReview"
    objects: {
      session: Prisma.$TutoringSessionPayload<ExtArgs>
      student: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      studentId: string
      rating: number
      comment: string | null
      createdAt: Date
    }, ExtArgs["result"]["tutoringReview"]>
    composites: {}
  }

  type TutoringReviewGetPayload<S extends boolean | null | undefined | TutoringReviewDefaultArgs> = $Result.GetResult<Prisma.$TutoringReviewPayload, S>

  type TutoringReviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TutoringReviewFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TutoringReviewCountAggregateInputType | true
    }

  export interface TutoringReviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TutoringReview'], meta: { name: 'TutoringReview' } }
    /**
     * Find zero or one TutoringReview that matches the filter.
     * @param {TutoringReviewFindUniqueArgs} args - Arguments to find a TutoringReview
     * @example
     * // Get one TutoringReview
     * const tutoringReview = await prisma.tutoringReview.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TutoringReviewFindUniqueArgs>(args: SelectSubset<T, TutoringReviewFindUniqueArgs<ExtArgs>>): Prisma__TutoringReviewClient<$Result.GetResult<Prisma.$TutoringReviewPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TutoringReview that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TutoringReviewFindUniqueOrThrowArgs} args - Arguments to find a TutoringReview
     * @example
     * // Get one TutoringReview
     * const tutoringReview = await prisma.tutoringReview.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TutoringReviewFindUniqueOrThrowArgs>(args: SelectSubset<T, TutoringReviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TutoringReviewClient<$Result.GetResult<Prisma.$TutoringReviewPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TutoringReview that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TutoringReviewFindFirstArgs} args - Arguments to find a TutoringReview
     * @example
     * // Get one TutoringReview
     * const tutoringReview = await prisma.tutoringReview.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TutoringReviewFindFirstArgs>(args?: SelectSubset<T, TutoringReviewFindFirstArgs<ExtArgs>>): Prisma__TutoringReviewClient<$Result.GetResult<Prisma.$TutoringReviewPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TutoringReview that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TutoringReviewFindFirstOrThrowArgs} args - Arguments to find a TutoringReview
     * @example
     * // Get one TutoringReview
     * const tutoringReview = await prisma.tutoringReview.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TutoringReviewFindFirstOrThrowArgs>(args?: SelectSubset<T, TutoringReviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__TutoringReviewClient<$Result.GetResult<Prisma.$TutoringReviewPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TutoringReviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TutoringReviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TutoringReviews
     * const tutoringReviews = await prisma.tutoringReview.findMany()
     * 
     * // Get first 10 TutoringReviews
     * const tutoringReviews = await prisma.tutoringReview.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tutoringReviewWithIdOnly = await prisma.tutoringReview.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TutoringReviewFindManyArgs>(args?: SelectSubset<T, TutoringReviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TutoringReviewPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TutoringReview.
     * @param {TutoringReviewCreateArgs} args - Arguments to create a TutoringReview.
     * @example
     * // Create one TutoringReview
     * const TutoringReview = await prisma.tutoringReview.create({
     *   data: {
     *     // ... data to create a TutoringReview
     *   }
     * })
     * 
     */
    create<T extends TutoringReviewCreateArgs>(args: SelectSubset<T, TutoringReviewCreateArgs<ExtArgs>>): Prisma__TutoringReviewClient<$Result.GetResult<Prisma.$TutoringReviewPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TutoringReviews.
     * @param {TutoringReviewCreateManyArgs} args - Arguments to create many TutoringReviews.
     * @example
     * // Create many TutoringReviews
     * const tutoringReview = await prisma.tutoringReview.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TutoringReviewCreateManyArgs>(args?: SelectSubset<T, TutoringReviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TutoringReviews and returns the data saved in the database.
     * @param {TutoringReviewCreateManyAndReturnArgs} args - Arguments to create many TutoringReviews.
     * @example
     * // Create many TutoringReviews
     * const tutoringReview = await prisma.tutoringReview.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TutoringReviews and only return the `id`
     * const tutoringReviewWithIdOnly = await prisma.tutoringReview.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TutoringReviewCreateManyAndReturnArgs>(args?: SelectSubset<T, TutoringReviewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TutoringReviewPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TutoringReview.
     * @param {TutoringReviewDeleteArgs} args - Arguments to delete one TutoringReview.
     * @example
     * // Delete one TutoringReview
     * const TutoringReview = await prisma.tutoringReview.delete({
     *   where: {
     *     // ... filter to delete one TutoringReview
     *   }
     * })
     * 
     */
    delete<T extends TutoringReviewDeleteArgs>(args: SelectSubset<T, TutoringReviewDeleteArgs<ExtArgs>>): Prisma__TutoringReviewClient<$Result.GetResult<Prisma.$TutoringReviewPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TutoringReview.
     * @param {TutoringReviewUpdateArgs} args - Arguments to update one TutoringReview.
     * @example
     * // Update one TutoringReview
     * const tutoringReview = await prisma.tutoringReview.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TutoringReviewUpdateArgs>(args: SelectSubset<T, TutoringReviewUpdateArgs<ExtArgs>>): Prisma__TutoringReviewClient<$Result.GetResult<Prisma.$TutoringReviewPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TutoringReviews.
     * @param {TutoringReviewDeleteManyArgs} args - Arguments to filter TutoringReviews to delete.
     * @example
     * // Delete a few TutoringReviews
     * const { count } = await prisma.tutoringReview.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TutoringReviewDeleteManyArgs>(args?: SelectSubset<T, TutoringReviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TutoringReviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TutoringReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TutoringReviews
     * const tutoringReview = await prisma.tutoringReview.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TutoringReviewUpdateManyArgs>(args: SelectSubset<T, TutoringReviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TutoringReview.
     * @param {TutoringReviewUpsertArgs} args - Arguments to update or create a TutoringReview.
     * @example
     * // Update or create a TutoringReview
     * const tutoringReview = await prisma.tutoringReview.upsert({
     *   create: {
     *     // ... data to create a TutoringReview
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TutoringReview we want to update
     *   }
     * })
     */
    upsert<T extends TutoringReviewUpsertArgs>(args: SelectSubset<T, TutoringReviewUpsertArgs<ExtArgs>>): Prisma__TutoringReviewClient<$Result.GetResult<Prisma.$TutoringReviewPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TutoringReviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TutoringReviewCountArgs} args - Arguments to filter TutoringReviews to count.
     * @example
     * // Count the number of TutoringReviews
     * const count = await prisma.tutoringReview.count({
     *   where: {
     *     // ... the filter for the TutoringReviews we want to count
     *   }
     * })
    **/
    count<T extends TutoringReviewCountArgs>(
      args?: Subset<T, TutoringReviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TutoringReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TutoringReview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TutoringReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TutoringReviewAggregateArgs>(args: Subset<T, TutoringReviewAggregateArgs>): Prisma.PrismaPromise<GetTutoringReviewAggregateType<T>>

    /**
     * Group by TutoringReview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TutoringReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TutoringReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TutoringReviewGroupByArgs['orderBy'] }
        : { orderBy?: TutoringReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TutoringReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTutoringReviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TutoringReview model
   */
  readonly fields: TutoringReviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TutoringReview.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TutoringReviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends TutoringSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TutoringSessionDefaultArgs<ExtArgs>>): Prisma__TutoringSessionClient<$Result.GetResult<Prisma.$TutoringSessionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    student<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TutoringReview model
   */ 
  interface TutoringReviewFieldRefs {
    readonly id: FieldRef<"TutoringReview", 'String'>
    readonly sessionId: FieldRef<"TutoringReview", 'String'>
    readonly studentId: FieldRef<"TutoringReview", 'String'>
    readonly rating: FieldRef<"TutoringReview", 'Int'>
    readonly comment: FieldRef<"TutoringReview", 'String'>
    readonly createdAt: FieldRef<"TutoringReview", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TutoringReview findUnique
   */
  export type TutoringReviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutoringReview
     */
    select?: TutoringReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutoringReviewInclude<ExtArgs> | null
    /**
     * Filter, which TutoringReview to fetch.
     */
    where: TutoringReviewWhereUniqueInput
  }

  /**
   * TutoringReview findUniqueOrThrow
   */
  export type TutoringReviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutoringReview
     */
    select?: TutoringReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutoringReviewInclude<ExtArgs> | null
    /**
     * Filter, which TutoringReview to fetch.
     */
    where: TutoringReviewWhereUniqueInput
  }

  /**
   * TutoringReview findFirst
   */
  export type TutoringReviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutoringReview
     */
    select?: TutoringReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutoringReviewInclude<ExtArgs> | null
    /**
     * Filter, which TutoringReview to fetch.
     */
    where?: TutoringReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TutoringReviews to fetch.
     */
    orderBy?: TutoringReviewOrderByWithRelationInput | TutoringReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TutoringReviews.
     */
    cursor?: TutoringReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TutoringReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TutoringReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TutoringReviews.
     */
    distinct?: TutoringReviewScalarFieldEnum | TutoringReviewScalarFieldEnum[]
  }

  /**
   * TutoringReview findFirstOrThrow
   */
  export type TutoringReviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutoringReview
     */
    select?: TutoringReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutoringReviewInclude<ExtArgs> | null
    /**
     * Filter, which TutoringReview to fetch.
     */
    where?: TutoringReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TutoringReviews to fetch.
     */
    orderBy?: TutoringReviewOrderByWithRelationInput | TutoringReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TutoringReviews.
     */
    cursor?: TutoringReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TutoringReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TutoringReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TutoringReviews.
     */
    distinct?: TutoringReviewScalarFieldEnum | TutoringReviewScalarFieldEnum[]
  }

  /**
   * TutoringReview findMany
   */
  export type TutoringReviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutoringReview
     */
    select?: TutoringReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutoringReviewInclude<ExtArgs> | null
    /**
     * Filter, which TutoringReviews to fetch.
     */
    where?: TutoringReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TutoringReviews to fetch.
     */
    orderBy?: TutoringReviewOrderByWithRelationInput | TutoringReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TutoringReviews.
     */
    cursor?: TutoringReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TutoringReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TutoringReviews.
     */
    skip?: number
    distinct?: TutoringReviewScalarFieldEnum | TutoringReviewScalarFieldEnum[]
  }

  /**
   * TutoringReview create
   */
  export type TutoringReviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutoringReview
     */
    select?: TutoringReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutoringReviewInclude<ExtArgs> | null
    /**
     * The data needed to create a TutoringReview.
     */
    data: XOR<TutoringReviewCreateInput, TutoringReviewUncheckedCreateInput>
  }

  /**
   * TutoringReview createMany
   */
  export type TutoringReviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TutoringReviews.
     */
    data: TutoringReviewCreateManyInput | TutoringReviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TutoringReview createManyAndReturn
   */
  export type TutoringReviewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutoringReview
     */
    select?: TutoringReviewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TutoringReviews.
     */
    data: TutoringReviewCreateManyInput | TutoringReviewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutoringReviewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TutoringReview update
   */
  export type TutoringReviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutoringReview
     */
    select?: TutoringReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutoringReviewInclude<ExtArgs> | null
    /**
     * The data needed to update a TutoringReview.
     */
    data: XOR<TutoringReviewUpdateInput, TutoringReviewUncheckedUpdateInput>
    /**
     * Choose, which TutoringReview to update.
     */
    where: TutoringReviewWhereUniqueInput
  }

  /**
   * TutoringReview updateMany
   */
  export type TutoringReviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TutoringReviews.
     */
    data: XOR<TutoringReviewUpdateManyMutationInput, TutoringReviewUncheckedUpdateManyInput>
    /**
     * Filter which TutoringReviews to update
     */
    where?: TutoringReviewWhereInput
  }

  /**
   * TutoringReview upsert
   */
  export type TutoringReviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutoringReview
     */
    select?: TutoringReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutoringReviewInclude<ExtArgs> | null
    /**
     * The filter to search for the TutoringReview to update in case it exists.
     */
    where: TutoringReviewWhereUniqueInput
    /**
     * In case the TutoringReview found by the `where` argument doesn't exist, create a new TutoringReview with this data.
     */
    create: XOR<TutoringReviewCreateInput, TutoringReviewUncheckedCreateInput>
    /**
     * In case the TutoringReview was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TutoringReviewUpdateInput, TutoringReviewUncheckedUpdateInput>
  }

  /**
   * TutoringReview delete
   */
  export type TutoringReviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutoringReview
     */
    select?: TutoringReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutoringReviewInclude<ExtArgs> | null
    /**
     * Filter which TutoringReview to delete.
     */
    where: TutoringReviewWhereUniqueInput
  }

  /**
   * TutoringReview deleteMany
   */
  export type TutoringReviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TutoringReviews to delete
     */
    where?: TutoringReviewWhereInput
  }

  /**
   * TutoringReview without action
   */
  export type TutoringReviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutoringReview
     */
    select?: TutoringReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutoringReviewInclude<ExtArgs> | null
  }


  /**
   * Model TutoringMessage
   */

  export type AggregateTutoringMessage = {
    _count: TutoringMessageCountAggregateOutputType | null
    _min: TutoringMessageMinAggregateOutputType | null
    _max: TutoringMessageMaxAggregateOutputType | null
  }

  export type TutoringMessageMinAggregateOutputType = {
    id: string | null
    requestId: string | null
    senderId: string | null
    message: string | null
    read: boolean | null
    createdAt: Date | null
  }

  export type TutoringMessageMaxAggregateOutputType = {
    id: string | null
    requestId: string | null
    senderId: string | null
    message: string | null
    read: boolean | null
    createdAt: Date | null
  }

  export type TutoringMessageCountAggregateOutputType = {
    id: number
    requestId: number
    senderId: number
    message: number
    read: number
    createdAt: number
    _all: number
  }


  export type TutoringMessageMinAggregateInputType = {
    id?: true
    requestId?: true
    senderId?: true
    message?: true
    read?: true
    createdAt?: true
  }

  export type TutoringMessageMaxAggregateInputType = {
    id?: true
    requestId?: true
    senderId?: true
    message?: true
    read?: true
    createdAt?: true
  }

  export type TutoringMessageCountAggregateInputType = {
    id?: true
    requestId?: true
    senderId?: true
    message?: true
    read?: true
    createdAt?: true
    _all?: true
  }

  export type TutoringMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TutoringMessage to aggregate.
     */
    where?: TutoringMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TutoringMessages to fetch.
     */
    orderBy?: TutoringMessageOrderByWithRelationInput | TutoringMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TutoringMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TutoringMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TutoringMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TutoringMessages
    **/
    _count?: true | TutoringMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TutoringMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TutoringMessageMaxAggregateInputType
  }

  export type GetTutoringMessageAggregateType<T extends TutoringMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateTutoringMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTutoringMessage[P]>
      : GetScalarType<T[P], AggregateTutoringMessage[P]>
  }




  export type TutoringMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TutoringMessageWhereInput
    orderBy?: TutoringMessageOrderByWithAggregationInput | TutoringMessageOrderByWithAggregationInput[]
    by: TutoringMessageScalarFieldEnum[] | TutoringMessageScalarFieldEnum
    having?: TutoringMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TutoringMessageCountAggregateInputType | true
    _min?: TutoringMessageMinAggregateInputType
    _max?: TutoringMessageMaxAggregateInputType
  }

  export type TutoringMessageGroupByOutputType = {
    id: string
    requestId: string
    senderId: string
    message: string
    read: boolean
    createdAt: Date
    _count: TutoringMessageCountAggregateOutputType | null
    _min: TutoringMessageMinAggregateOutputType | null
    _max: TutoringMessageMaxAggregateOutputType | null
  }

  type GetTutoringMessageGroupByPayload<T extends TutoringMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TutoringMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TutoringMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TutoringMessageGroupByOutputType[P]>
            : GetScalarType<T[P], TutoringMessageGroupByOutputType[P]>
        }
      >
    >


  export type TutoringMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    requestId?: boolean
    senderId?: boolean
    message?: boolean
    read?: boolean
    createdAt?: boolean
    request?: boolean | TutoringRequestDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tutoringMessage"]>

  export type TutoringMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    requestId?: boolean
    senderId?: boolean
    message?: boolean
    read?: boolean
    createdAt?: boolean
    request?: boolean | TutoringRequestDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tutoringMessage"]>

  export type TutoringMessageSelectScalar = {
    id?: boolean
    requestId?: boolean
    senderId?: boolean
    message?: boolean
    read?: boolean
    createdAt?: boolean
  }

  export type TutoringMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    request?: boolean | TutoringRequestDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TutoringMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    request?: boolean | TutoringRequestDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TutoringMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TutoringMessage"
    objects: {
      request: Prisma.$TutoringRequestPayload<ExtArgs>
      sender: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      requestId: string
      senderId: string
      message: string
      read: boolean
      createdAt: Date
    }, ExtArgs["result"]["tutoringMessage"]>
    composites: {}
  }

  type TutoringMessageGetPayload<S extends boolean | null | undefined | TutoringMessageDefaultArgs> = $Result.GetResult<Prisma.$TutoringMessagePayload, S>

  type TutoringMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TutoringMessageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TutoringMessageCountAggregateInputType | true
    }

  export interface TutoringMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TutoringMessage'], meta: { name: 'TutoringMessage' } }
    /**
     * Find zero or one TutoringMessage that matches the filter.
     * @param {TutoringMessageFindUniqueArgs} args - Arguments to find a TutoringMessage
     * @example
     * // Get one TutoringMessage
     * const tutoringMessage = await prisma.tutoringMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TutoringMessageFindUniqueArgs>(args: SelectSubset<T, TutoringMessageFindUniqueArgs<ExtArgs>>): Prisma__TutoringMessageClient<$Result.GetResult<Prisma.$TutoringMessagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TutoringMessage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TutoringMessageFindUniqueOrThrowArgs} args - Arguments to find a TutoringMessage
     * @example
     * // Get one TutoringMessage
     * const tutoringMessage = await prisma.tutoringMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TutoringMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, TutoringMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TutoringMessageClient<$Result.GetResult<Prisma.$TutoringMessagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TutoringMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TutoringMessageFindFirstArgs} args - Arguments to find a TutoringMessage
     * @example
     * // Get one TutoringMessage
     * const tutoringMessage = await prisma.tutoringMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TutoringMessageFindFirstArgs>(args?: SelectSubset<T, TutoringMessageFindFirstArgs<ExtArgs>>): Prisma__TutoringMessageClient<$Result.GetResult<Prisma.$TutoringMessagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TutoringMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TutoringMessageFindFirstOrThrowArgs} args - Arguments to find a TutoringMessage
     * @example
     * // Get one TutoringMessage
     * const tutoringMessage = await prisma.tutoringMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TutoringMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, TutoringMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__TutoringMessageClient<$Result.GetResult<Prisma.$TutoringMessagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TutoringMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TutoringMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TutoringMessages
     * const tutoringMessages = await prisma.tutoringMessage.findMany()
     * 
     * // Get first 10 TutoringMessages
     * const tutoringMessages = await prisma.tutoringMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tutoringMessageWithIdOnly = await prisma.tutoringMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TutoringMessageFindManyArgs>(args?: SelectSubset<T, TutoringMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TutoringMessagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TutoringMessage.
     * @param {TutoringMessageCreateArgs} args - Arguments to create a TutoringMessage.
     * @example
     * // Create one TutoringMessage
     * const TutoringMessage = await prisma.tutoringMessage.create({
     *   data: {
     *     // ... data to create a TutoringMessage
     *   }
     * })
     * 
     */
    create<T extends TutoringMessageCreateArgs>(args: SelectSubset<T, TutoringMessageCreateArgs<ExtArgs>>): Prisma__TutoringMessageClient<$Result.GetResult<Prisma.$TutoringMessagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TutoringMessages.
     * @param {TutoringMessageCreateManyArgs} args - Arguments to create many TutoringMessages.
     * @example
     * // Create many TutoringMessages
     * const tutoringMessage = await prisma.tutoringMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TutoringMessageCreateManyArgs>(args?: SelectSubset<T, TutoringMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TutoringMessages and returns the data saved in the database.
     * @param {TutoringMessageCreateManyAndReturnArgs} args - Arguments to create many TutoringMessages.
     * @example
     * // Create many TutoringMessages
     * const tutoringMessage = await prisma.tutoringMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TutoringMessages and only return the `id`
     * const tutoringMessageWithIdOnly = await prisma.tutoringMessage.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TutoringMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, TutoringMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TutoringMessagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TutoringMessage.
     * @param {TutoringMessageDeleteArgs} args - Arguments to delete one TutoringMessage.
     * @example
     * // Delete one TutoringMessage
     * const TutoringMessage = await prisma.tutoringMessage.delete({
     *   where: {
     *     // ... filter to delete one TutoringMessage
     *   }
     * })
     * 
     */
    delete<T extends TutoringMessageDeleteArgs>(args: SelectSubset<T, TutoringMessageDeleteArgs<ExtArgs>>): Prisma__TutoringMessageClient<$Result.GetResult<Prisma.$TutoringMessagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TutoringMessage.
     * @param {TutoringMessageUpdateArgs} args - Arguments to update one TutoringMessage.
     * @example
     * // Update one TutoringMessage
     * const tutoringMessage = await prisma.tutoringMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TutoringMessageUpdateArgs>(args: SelectSubset<T, TutoringMessageUpdateArgs<ExtArgs>>): Prisma__TutoringMessageClient<$Result.GetResult<Prisma.$TutoringMessagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TutoringMessages.
     * @param {TutoringMessageDeleteManyArgs} args - Arguments to filter TutoringMessages to delete.
     * @example
     * // Delete a few TutoringMessages
     * const { count } = await prisma.tutoringMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TutoringMessageDeleteManyArgs>(args?: SelectSubset<T, TutoringMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TutoringMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TutoringMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TutoringMessages
     * const tutoringMessage = await prisma.tutoringMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TutoringMessageUpdateManyArgs>(args: SelectSubset<T, TutoringMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TutoringMessage.
     * @param {TutoringMessageUpsertArgs} args - Arguments to update or create a TutoringMessage.
     * @example
     * // Update or create a TutoringMessage
     * const tutoringMessage = await prisma.tutoringMessage.upsert({
     *   create: {
     *     // ... data to create a TutoringMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TutoringMessage we want to update
     *   }
     * })
     */
    upsert<T extends TutoringMessageUpsertArgs>(args: SelectSubset<T, TutoringMessageUpsertArgs<ExtArgs>>): Prisma__TutoringMessageClient<$Result.GetResult<Prisma.$TutoringMessagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TutoringMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TutoringMessageCountArgs} args - Arguments to filter TutoringMessages to count.
     * @example
     * // Count the number of TutoringMessages
     * const count = await prisma.tutoringMessage.count({
     *   where: {
     *     // ... the filter for the TutoringMessages we want to count
     *   }
     * })
    **/
    count<T extends TutoringMessageCountArgs>(
      args?: Subset<T, TutoringMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TutoringMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TutoringMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TutoringMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TutoringMessageAggregateArgs>(args: Subset<T, TutoringMessageAggregateArgs>): Prisma.PrismaPromise<GetTutoringMessageAggregateType<T>>

    /**
     * Group by TutoringMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TutoringMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TutoringMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TutoringMessageGroupByArgs['orderBy'] }
        : { orderBy?: TutoringMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TutoringMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTutoringMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TutoringMessage model
   */
  readonly fields: TutoringMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TutoringMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TutoringMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    request<T extends TutoringRequestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TutoringRequestDefaultArgs<ExtArgs>>): Prisma__TutoringRequestClient<$Result.GetResult<Prisma.$TutoringRequestPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    sender<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TutoringMessage model
   */ 
  interface TutoringMessageFieldRefs {
    readonly id: FieldRef<"TutoringMessage", 'String'>
    readonly requestId: FieldRef<"TutoringMessage", 'String'>
    readonly senderId: FieldRef<"TutoringMessage", 'String'>
    readonly message: FieldRef<"TutoringMessage", 'String'>
    readonly read: FieldRef<"TutoringMessage", 'Boolean'>
    readonly createdAt: FieldRef<"TutoringMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TutoringMessage findUnique
   */
  export type TutoringMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutoringMessage
     */
    select?: TutoringMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutoringMessageInclude<ExtArgs> | null
    /**
     * Filter, which TutoringMessage to fetch.
     */
    where: TutoringMessageWhereUniqueInput
  }

  /**
   * TutoringMessage findUniqueOrThrow
   */
  export type TutoringMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutoringMessage
     */
    select?: TutoringMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutoringMessageInclude<ExtArgs> | null
    /**
     * Filter, which TutoringMessage to fetch.
     */
    where: TutoringMessageWhereUniqueInput
  }

  /**
   * TutoringMessage findFirst
   */
  export type TutoringMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutoringMessage
     */
    select?: TutoringMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutoringMessageInclude<ExtArgs> | null
    /**
     * Filter, which TutoringMessage to fetch.
     */
    where?: TutoringMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TutoringMessages to fetch.
     */
    orderBy?: TutoringMessageOrderByWithRelationInput | TutoringMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TutoringMessages.
     */
    cursor?: TutoringMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TutoringMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TutoringMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TutoringMessages.
     */
    distinct?: TutoringMessageScalarFieldEnum | TutoringMessageScalarFieldEnum[]
  }

  /**
   * TutoringMessage findFirstOrThrow
   */
  export type TutoringMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutoringMessage
     */
    select?: TutoringMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutoringMessageInclude<ExtArgs> | null
    /**
     * Filter, which TutoringMessage to fetch.
     */
    where?: TutoringMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TutoringMessages to fetch.
     */
    orderBy?: TutoringMessageOrderByWithRelationInput | TutoringMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TutoringMessages.
     */
    cursor?: TutoringMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TutoringMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TutoringMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TutoringMessages.
     */
    distinct?: TutoringMessageScalarFieldEnum | TutoringMessageScalarFieldEnum[]
  }

  /**
   * TutoringMessage findMany
   */
  export type TutoringMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutoringMessage
     */
    select?: TutoringMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutoringMessageInclude<ExtArgs> | null
    /**
     * Filter, which TutoringMessages to fetch.
     */
    where?: TutoringMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TutoringMessages to fetch.
     */
    orderBy?: TutoringMessageOrderByWithRelationInput | TutoringMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TutoringMessages.
     */
    cursor?: TutoringMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TutoringMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TutoringMessages.
     */
    skip?: number
    distinct?: TutoringMessageScalarFieldEnum | TutoringMessageScalarFieldEnum[]
  }

  /**
   * TutoringMessage create
   */
  export type TutoringMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutoringMessage
     */
    select?: TutoringMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutoringMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a TutoringMessage.
     */
    data: XOR<TutoringMessageCreateInput, TutoringMessageUncheckedCreateInput>
  }

  /**
   * TutoringMessage createMany
   */
  export type TutoringMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TutoringMessages.
     */
    data: TutoringMessageCreateManyInput | TutoringMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TutoringMessage createManyAndReturn
   */
  export type TutoringMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutoringMessage
     */
    select?: TutoringMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TutoringMessages.
     */
    data: TutoringMessageCreateManyInput | TutoringMessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutoringMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TutoringMessage update
   */
  export type TutoringMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutoringMessage
     */
    select?: TutoringMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutoringMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a TutoringMessage.
     */
    data: XOR<TutoringMessageUpdateInput, TutoringMessageUncheckedUpdateInput>
    /**
     * Choose, which TutoringMessage to update.
     */
    where: TutoringMessageWhereUniqueInput
  }

  /**
   * TutoringMessage updateMany
   */
  export type TutoringMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TutoringMessages.
     */
    data: XOR<TutoringMessageUpdateManyMutationInput, TutoringMessageUncheckedUpdateManyInput>
    /**
     * Filter which TutoringMessages to update
     */
    where?: TutoringMessageWhereInput
  }

  /**
   * TutoringMessage upsert
   */
  export type TutoringMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutoringMessage
     */
    select?: TutoringMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutoringMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the TutoringMessage to update in case it exists.
     */
    where: TutoringMessageWhereUniqueInput
    /**
     * In case the TutoringMessage found by the `where` argument doesn't exist, create a new TutoringMessage with this data.
     */
    create: XOR<TutoringMessageCreateInput, TutoringMessageUncheckedCreateInput>
    /**
     * In case the TutoringMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TutoringMessageUpdateInput, TutoringMessageUncheckedUpdateInput>
  }

  /**
   * TutoringMessage delete
   */
  export type TutoringMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutoringMessage
     */
    select?: TutoringMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutoringMessageInclude<ExtArgs> | null
    /**
     * Filter which TutoringMessage to delete.
     */
    where: TutoringMessageWhereUniqueInput
  }

  /**
   * TutoringMessage deleteMany
   */
  export type TutoringMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TutoringMessages to delete
     */
    where?: TutoringMessageWhereInput
  }

  /**
   * TutoringMessage without action
   */
  export type TutoringMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutoringMessage
     */
    select?: TutoringMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutoringMessageInclude<ExtArgs> | null
  }


  /**
   * Model Achievement
   */

  export type AggregateAchievement = {
    _count: AchievementCountAggregateOutputType | null
    _avg: AchievementAvgAggregateOutputType | null
    _sum: AchievementSumAggregateOutputType | null
    _min: AchievementMinAggregateOutputType | null
    _max: AchievementMaxAggregateOutputType | null
  }

  export type AchievementAvgAggregateOutputType = {
    pointsRewarded: number | null
  }

  export type AchievementSumAggregateOutputType = {
    pointsRewarded: number | null
  }

  export type AchievementMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    pointsRewarded: number | null
    icon: string | null
    category: $Enums.AchievementCategory | null
  }

  export type AchievementMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    pointsRewarded: number | null
    icon: string | null
    category: $Enums.AchievementCategory | null
  }

  export type AchievementCountAggregateOutputType = {
    id: number
    name: number
    description: number
    pointsRewarded: number
    icon: number
    category: number
    _all: number
  }


  export type AchievementAvgAggregateInputType = {
    pointsRewarded?: true
  }

  export type AchievementSumAggregateInputType = {
    pointsRewarded?: true
  }

  export type AchievementMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    pointsRewarded?: true
    icon?: true
    category?: true
  }

  export type AchievementMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    pointsRewarded?: true
    icon?: true
    category?: true
  }

  export type AchievementCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    pointsRewarded?: true
    icon?: true
    category?: true
    _all?: true
  }

  export type AchievementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Achievement to aggregate.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Achievements
    **/
    _count?: true | AchievementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AchievementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AchievementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AchievementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AchievementMaxAggregateInputType
  }

  export type GetAchievementAggregateType<T extends AchievementAggregateArgs> = {
        [P in keyof T & keyof AggregateAchievement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAchievement[P]>
      : GetScalarType<T[P], AggregateAchievement[P]>
  }




  export type AchievementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AchievementWhereInput
    orderBy?: AchievementOrderByWithAggregationInput | AchievementOrderByWithAggregationInput[]
    by: AchievementScalarFieldEnum[] | AchievementScalarFieldEnum
    having?: AchievementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AchievementCountAggregateInputType | true
    _avg?: AchievementAvgAggregateInputType
    _sum?: AchievementSumAggregateInputType
    _min?: AchievementMinAggregateInputType
    _max?: AchievementMaxAggregateInputType
  }

  export type AchievementGroupByOutputType = {
    id: string
    name: string
    description: string | null
    pointsRewarded: number
    icon: string | null
    category: $Enums.AchievementCategory
    _count: AchievementCountAggregateOutputType | null
    _avg: AchievementAvgAggregateOutputType | null
    _sum: AchievementSumAggregateOutputType | null
    _min: AchievementMinAggregateOutputType | null
    _max: AchievementMaxAggregateOutputType | null
  }

  type GetAchievementGroupByPayload<T extends AchievementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AchievementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AchievementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AchievementGroupByOutputType[P]>
            : GetScalarType<T[P], AchievementGroupByOutputType[P]>
        }
      >
    >


  export type AchievementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    pointsRewarded?: boolean
    icon?: boolean
    category?: boolean
    users?: boolean | Achievement$usersArgs<ExtArgs>
    _count?: boolean | AchievementCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["achievement"]>

  export type AchievementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    pointsRewarded?: boolean
    icon?: boolean
    category?: boolean
  }, ExtArgs["result"]["achievement"]>

  export type AchievementSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    pointsRewarded?: boolean
    icon?: boolean
    category?: boolean
  }

  export type AchievementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Achievement$usersArgs<ExtArgs>
    _count?: boolean | AchievementCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AchievementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AchievementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Achievement"
    objects: {
      users: Prisma.$UserAchievementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      pointsRewarded: number
      icon: string | null
      category: $Enums.AchievementCategory
    }, ExtArgs["result"]["achievement"]>
    composites: {}
  }

  type AchievementGetPayload<S extends boolean | null | undefined | AchievementDefaultArgs> = $Result.GetResult<Prisma.$AchievementPayload, S>

  type AchievementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AchievementFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AchievementCountAggregateInputType | true
    }

  export interface AchievementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Achievement'], meta: { name: 'Achievement' } }
    /**
     * Find zero or one Achievement that matches the filter.
     * @param {AchievementFindUniqueArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AchievementFindUniqueArgs>(args: SelectSubset<T, AchievementFindUniqueArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Achievement that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AchievementFindUniqueOrThrowArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AchievementFindUniqueOrThrowArgs>(args: SelectSubset<T, AchievementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Achievement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementFindFirstArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AchievementFindFirstArgs>(args?: SelectSubset<T, AchievementFindFirstArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Achievement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementFindFirstOrThrowArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AchievementFindFirstOrThrowArgs>(args?: SelectSubset<T, AchievementFindFirstOrThrowArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Achievements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Achievements
     * const achievements = await prisma.achievement.findMany()
     * 
     * // Get first 10 Achievements
     * const achievements = await prisma.achievement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const achievementWithIdOnly = await prisma.achievement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AchievementFindManyArgs>(args?: SelectSubset<T, AchievementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Achievement.
     * @param {AchievementCreateArgs} args - Arguments to create a Achievement.
     * @example
     * // Create one Achievement
     * const Achievement = await prisma.achievement.create({
     *   data: {
     *     // ... data to create a Achievement
     *   }
     * })
     * 
     */
    create<T extends AchievementCreateArgs>(args: SelectSubset<T, AchievementCreateArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Achievements.
     * @param {AchievementCreateManyArgs} args - Arguments to create many Achievements.
     * @example
     * // Create many Achievements
     * const achievement = await prisma.achievement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AchievementCreateManyArgs>(args?: SelectSubset<T, AchievementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Achievements and returns the data saved in the database.
     * @param {AchievementCreateManyAndReturnArgs} args - Arguments to create many Achievements.
     * @example
     * // Create many Achievements
     * const achievement = await prisma.achievement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Achievements and only return the `id`
     * const achievementWithIdOnly = await prisma.achievement.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AchievementCreateManyAndReturnArgs>(args?: SelectSubset<T, AchievementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Achievement.
     * @param {AchievementDeleteArgs} args - Arguments to delete one Achievement.
     * @example
     * // Delete one Achievement
     * const Achievement = await prisma.achievement.delete({
     *   where: {
     *     // ... filter to delete one Achievement
     *   }
     * })
     * 
     */
    delete<T extends AchievementDeleteArgs>(args: SelectSubset<T, AchievementDeleteArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Achievement.
     * @param {AchievementUpdateArgs} args - Arguments to update one Achievement.
     * @example
     * // Update one Achievement
     * const achievement = await prisma.achievement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AchievementUpdateArgs>(args: SelectSubset<T, AchievementUpdateArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Achievements.
     * @param {AchievementDeleteManyArgs} args - Arguments to filter Achievements to delete.
     * @example
     * // Delete a few Achievements
     * const { count } = await prisma.achievement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AchievementDeleteManyArgs>(args?: SelectSubset<T, AchievementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Achievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Achievements
     * const achievement = await prisma.achievement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AchievementUpdateManyArgs>(args: SelectSubset<T, AchievementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Achievement.
     * @param {AchievementUpsertArgs} args - Arguments to update or create a Achievement.
     * @example
     * // Update or create a Achievement
     * const achievement = await prisma.achievement.upsert({
     *   create: {
     *     // ... data to create a Achievement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Achievement we want to update
     *   }
     * })
     */
    upsert<T extends AchievementUpsertArgs>(args: SelectSubset<T, AchievementUpsertArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Achievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementCountArgs} args - Arguments to filter Achievements to count.
     * @example
     * // Count the number of Achievements
     * const count = await prisma.achievement.count({
     *   where: {
     *     // ... the filter for the Achievements we want to count
     *   }
     * })
    **/
    count<T extends AchievementCountArgs>(
      args?: Subset<T, AchievementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AchievementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Achievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AchievementAggregateArgs>(args: Subset<T, AchievementAggregateArgs>): Prisma.PrismaPromise<GetAchievementAggregateType<T>>

    /**
     * Group by Achievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AchievementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AchievementGroupByArgs['orderBy'] }
        : { orderBy?: AchievementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AchievementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAchievementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Achievement model
   */
  readonly fields: AchievementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Achievement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AchievementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Achievement$usersArgs<ExtArgs> = {}>(args?: Subset<T, Achievement$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Achievement model
   */ 
  interface AchievementFieldRefs {
    readonly id: FieldRef<"Achievement", 'String'>
    readonly name: FieldRef<"Achievement", 'String'>
    readonly description: FieldRef<"Achievement", 'String'>
    readonly pointsRewarded: FieldRef<"Achievement", 'Int'>
    readonly icon: FieldRef<"Achievement", 'String'>
    readonly category: FieldRef<"Achievement", 'AchievementCategory'>
  }
    

  // Custom InputTypes
  /**
   * Achievement findUnique
   */
  export type AchievementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement findUniqueOrThrow
   */
  export type AchievementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement findFirst
   */
  export type AchievementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Achievements.
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Achievements.
     */
    distinct?: AchievementScalarFieldEnum | AchievementScalarFieldEnum[]
  }

  /**
   * Achievement findFirstOrThrow
   */
  export type AchievementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Achievements.
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Achievements.
     */
    distinct?: AchievementScalarFieldEnum | AchievementScalarFieldEnum[]
  }

  /**
   * Achievement findMany
   */
  export type AchievementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievements to fetch.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Achievements.
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    distinct?: AchievementScalarFieldEnum | AchievementScalarFieldEnum[]
  }

  /**
   * Achievement create
   */
  export type AchievementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * The data needed to create a Achievement.
     */
    data: XOR<AchievementCreateInput, AchievementUncheckedCreateInput>
  }

  /**
   * Achievement createMany
   */
  export type AchievementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Achievements.
     */
    data: AchievementCreateManyInput | AchievementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Achievement createManyAndReturn
   */
  export type AchievementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Achievements.
     */
    data: AchievementCreateManyInput | AchievementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Achievement update
   */
  export type AchievementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * The data needed to update a Achievement.
     */
    data: XOR<AchievementUpdateInput, AchievementUncheckedUpdateInput>
    /**
     * Choose, which Achievement to update.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement updateMany
   */
  export type AchievementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Achievements.
     */
    data: XOR<AchievementUpdateManyMutationInput, AchievementUncheckedUpdateManyInput>
    /**
     * Filter which Achievements to update
     */
    where?: AchievementWhereInput
  }

  /**
   * Achievement upsert
   */
  export type AchievementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * The filter to search for the Achievement to update in case it exists.
     */
    where: AchievementWhereUniqueInput
    /**
     * In case the Achievement found by the `where` argument doesn't exist, create a new Achievement with this data.
     */
    create: XOR<AchievementCreateInput, AchievementUncheckedCreateInput>
    /**
     * In case the Achievement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AchievementUpdateInput, AchievementUncheckedUpdateInput>
  }

  /**
   * Achievement delete
   */
  export type AchievementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter which Achievement to delete.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement deleteMany
   */
  export type AchievementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Achievements to delete
     */
    where?: AchievementWhereInput
  }

  /**
   * Achievement.users
   */
  export type Achievement$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    where?: UserAchievementWhereInput
    orderBy?: UserAchievementOrderByWithRelationInput | UserAchievementOrderByWithRelationInput[]
    cursor?: UserAchievementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserAchievementScalarFieldEnum | UserAchievementScalarFieldEnum[]
  }

  /**
   * Achievement without action
   */
  export type AchievementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
  }


  /**
   * Model UserAchievement
   */

  export type AggregateUserAchievement = {
    _count: UserAchievementCountAggregateOutputType | null
    _avg: UserAchievementAvgAggregateOutputType | null
    _sum: UserAchievementSumAggregateOutputType | null
    _min: UserAchievementMinAggregateOutputType | null
    _max: UserAchievementMaxAggregateOutputType | null
  }

  export type UserAchievementAvgAggregateOutputType = {
    progress: number | null
  }

  export type UserAchievementSumAggregateOutputType = {
    progress: number | null
  }

  export type UserAchievementMinAggregateOutputType = {
    id: string | null
    userId: string | null
    achievementId: string | null
    completed: boolean | null
    completedAt: Date | null
    progress: number | null
  }

  export type UserAchievementMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    achievementId: string | null
    completed: boolean | null
    completedAt: Date | null
    progress: number | null
  }

  export type UserAchievementCountAggregateOutputType = {
    id: number
    userId: number
    achievementId: number
    completed: number
    completedAt: number
    progress: number
    _all: number
  }


  export type UserAchievementAvgAggregateInputType = {
    progress?: true
  }

  export type UserAchievementSumAggregateInputType = {
    progress?: true
  }

  export type UserAchievementMinAggregateInputType = {
    id?: true
    userId?: true
    achievementId?: true
    completed?: true
    completedAt?: true
    progress?: true
  }

  export type UserAchievementMaxAggregateInputType = {
    id?: true
    userId?: true
    achievementId?: true
    completed?: true
    completedAt?: true
    progress?: true
  }

  export type UserAchievementCountAggregateInputType = {
    id?: true
    userId?: true
    achievementId?: true
    completed?: true
    completedAt?: true
    progress?: true
    _all?: true
  }

  export type UserAchievementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAchievement to aggregate.
     */
    where?: UserAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAchievements to fetch.
     */
    orderBy?: UserAchievementOrderByWithRelationInput | UserAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAchievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserAchievements
    **/
    _count?: true | UserAchievementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAchievementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserAchievementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserAchievementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserAchievementMaxAggregateInputType
  }

  export type GetUserAchievementAggregateType<T extends UserAchievementAggregateArgs> = {
        [P in keyof T & keyof AggregateUserAchievement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserAchievement[P]>
      : GetScalarType<T[P], AggregateUserAchievement[P]>
  }




  export type UserAchievementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAchievementWhereInput
    orderBy?: UserAchievementOrderByWithAggregationInput | UserAchievementOrderByWithAggregationInput[]
    by: UserAchievementScalarFieldEnum[] | UserAchievementScalarFieldEnum
    having?: UserAchievementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserAchievementCountAggregateInputType | true
    _avg?: UserAchievementAvgAggregateInputType
    _sum?: UserAchievementSumAggregateInputType
    _min?: UserAchievementMinAggregateInputType
    _max?: UserAchievementMaxAggregateInputType
  }

  export type UserAchievementGroupByOutputType = {
    id: string
    userId: string
    achievementId: string
    completed: boolean
    completedAt: Date | null
    progress: number
    _count: UserAchievementCountAggregateOutputType | null
    _avg: UserAchievementAvgAggregateOutputType | null
    _sum: UserAchievementSumAggregateOutputType | null
    _min: UserAchievementMinAggregateOutputType | null
    _max: UserAchievementMaxAggregateOutputType | null
  }

  type GetUserAchievementGroupByPayload<T extends UserAchievementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserAchievementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserAchievementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserAchievementGroupByOutputType[P]>
            : GetScalarType<T[P], UserAchievementGroupByOutputType[P]>
        }
      >
    >


  export type UserAchievementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    achievementId?: boolean
    completed?: boolean
    completedAt?: boolean
    progress?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    achievement?: boolean | AchievementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAchievement"]>

  export type UserAchievementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    achievementId?: boolean
    completed?: boolean
    completedAt?: boolean
    progress?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    achievement?: boolean | AchievementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAchievement"]>

  export type UserAchievementSelectScalar = {
    id?: boolean
    userId?: boolean
    achievementId?: boolean
    completed?: boolean
    completedAt?: boolean
    progress?: boolean
  }

  export type UserAchievementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    achievement?: boolean | AchievementDefaultArgs<ExtArgs>
  }
  export type UserAchievementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    achievement?: boolean | AchievementDefaultArgs<ExtArgs>
  }

  export type $UserAchievementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserAchievement"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      achievement: Prisma.$AchievementPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      achievementId: string
      completed: boolean
      completedAt: Date | null
      progress: number
    }, ExtArgs["result"]["userAchievement"]>
    composites: {}
  }

  type UserAchievementGetPayload<S extends boolean | null | undefined | UserAchievementDefaultArgs> = $Result.GetResult<Prisma.$UserAchievementPayload, S>

  type UserAchievementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserAchievementFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserAchievementCountAggregateInputType | true
    }

  export interface UserAchievementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserAchievement'], meta: { name: 'UserAchievement' } }
    /**
     * Find zero or one UserAchievement that matches the filter.
     * @param {UserAchievementFindUniqueArgs} args - Arguments to find a UserAchievement
     * @example
     * // Get one UserAchievement
     * const userAchievement = await prisma.userAchievement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserAchievementFindUniqueArgs>(args: SelectSubset<T, UserAchievementFindUniqueArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserAchievement that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserAchievementFindUniqueOrThrowArgs} args - Arguments to find a UserAchievement
     * @example
     * // Get one UserAchievement
     * const userAchievement = await prisma.userAchievement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserAchievementFindUniqueOrThrowArgs>(args: SelectSubset<T, UserAchievementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserAchievement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementFindFirstArgs} args - Arguments to find a UserAchievement
     * @example
     * // Get one UserAchievement
     * const userAchievement = await prisma.userAchievement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserAchievementFindFirstArgs>(args?: SelectSubset<T, UserAchievementFindFirstArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserAchievement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementFindFirstOrThrowArgs} args - Arguments to find a UserAchievement
     * @example
     * // Get one UserAchievement
     * const userAchievement = await prisma.userAchievement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserAchievementFindFirstOrThrowArgs>(args?: SelectSubset<T, UserAchievementFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserAchievements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserAchievements
     * const userAchievements = await prisma.userAchievement.findMany()
     * 
     * // Get first 10 UserAchievements
     * const userAchievements = await prisma.userAchievement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userAchievementWithIdOnly = await prisma.userAchievement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserAchievementFindManyArgs>(args?: SelectSubset<T, UserAchievementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserAchievement.
     * @param {UserAchievementCreateArgs} args - Arguments to create a UserAchievement.
     * @example
     * // Create one UserAchievement
     * const UserAchievement = await prisma.userAchievement.create({
     *   data: {
     *     // ... data to create a UserAchievement
     *   }
     * })
     * 
     */
    create<T extends UserAchievementCreateArgs>(args: SelectSubset<T, UserAchievementCreateArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserAchievements.
     * @param {UserAchievementCreateManyArgs} args - Arguments to create many UserAchievements.
     * @example
     * // Create many UserAchievements
     * const userAchievement = await prisma.userAchievement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserAchievementCreateManyArgs>(args?: SelectSubset<T, UserAchievementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserAchievements and returns the data saved in the database.
     * @param {UserAchievementCreateManyAndReturnArgs} args - Arguments to create many UserAchievements.
     * @example
     * // Create many UserAchievements
     * const userAchievement = await prisma.userAchievement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserAchievements and only return the `id`
     * const userAchievementWithIdOnly = await prisma.userAchievement.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserAchievementCreateManyAndReturnArgs>(args?: SelectSubset<T, UserAchievementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserAchievement.
     * @param {UserAchievementDeleteArgs} args - Arguments to delete one UserAchievement.
     * @example
     * // Delete one UserAchievement
     * const UserAchievement = await prisma.userAchievement.delete({
     *   where: {
     *     // ... filter to delete one UserAchievement
     *   }
     * })
     * 
     */
    delete<T extends UserAchievementDeleteArgs>(args: SelectSubset<T, UserAchievementDeleteArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserAchievement.
     * @param {UserAchievementUpdateArgs} args - Arguments to update one UserAchievement.
     * @example
     * // Update one UserAchievement
     * const userAchievement = await prisma.userAchievement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserAchievementUpdateArgs>(args: SelectSubset<T, UserAchievementUpdateArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserAchievements.
     * @param {UserAchievementDeleteManyArgs} args - Arguments to filter UserAchievements to delete.
     * @example
     * // Delete a few UserAchievements
     * const { count } = await prisma.userAchievement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserAchievementDeleteManyArgs>(args?: SelectSubset<T, UserAchievementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserAchievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserAchievements
     * const userAchievement = await prisma.userAchievement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserAchievementUpdateManyArgs>(args: SelectSubset<T, UserAchievementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserAchievement.
     * @param {UserAchievementUpsertArgs} args - Arguments to update or create a UserAchievement.
     * @example
     * // Update or create a UserAchievement
     * const userAchievement = await prisma.userAchievement.upsert({
     *   create: {
     *     // ... data to create a UserAchievement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserAchievement we want to update
     *   }
     * })
     */
    upsert<T extends UserAchievementUpsertArgs>(args: SelectSubset<T, UserAchievementUpsertArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserAchievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementCountArgs} args - Arguments to filter UserAchievements to count.
     * @example
     * // Count the number of UserAchievements
     * const count = await prisma.userAchievement.count({
     *   where: {
     *     // ... the filter for the UserAchievements we want to count
     *   }
     * })
    **/
    count<T extends UserAchievementCountArgs>(
      args?: Subset<T, UserAchievementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserAchievementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserAchievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAchievementAggregateArgs>(args: Subset<T, UserAchievementAggregateArgs>): Prisma.PrismaPromise<GetUserAchievementAggregateType<T>>

    /**
     * Group by UserAchievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserAchievementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserAchievementGroupByArgs['orderBy'] }
        : { orderBy?: UserAchievementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserAchievementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserAchievementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserAchievement model
   */
  readonly fields: UserAchievementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserAchievement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserAchievementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    achievement<T extends AchievementDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AchievementDefaultArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserAchievement model
   */ 
  interface UserAchievementFieldRefs {
    readonly id: FieldRef<"UserAchievement", 'String'>
    readonly userId: FieldRef<"UserAchievement", 'String'>
    readonly achievementId: FieldRef<"UserAchievement", 'String'>
    readonly completed: FieldRef<"UserAchievement", 'Boolean'>
    readonly completedAt: FieldRef<"UserAchievement", 'DateTime'>
    readonly progress: FieldRef<"UserAchievement", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * UserAchievement findUnique
   */
  export type UserAchievementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * Filter, which UserAchievement to fetch.
     */
    where: UserAchievementWhereUniqueInput
  }

  /**
   * UserAchievement findUniqueOrThrow
   */
  export type UserAchievementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * Filter, which UserAchievement to fetch.
     */
    where: UserAchievementWhereUniqueInput
  }

  /**
   * UserAchievement findFirst
   */
  export type UserAchievementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * Filter, which UserAchievement to fetch.
     */
    where?: UserAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAchievements to fetch.
     */
    orderBy?: UserAchievementOrderByWithRelationInput | UserAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAchievements.
     */
    cursor?: UserAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAchievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAchievements.
     */
    distinct?: UserAchievementScalarFieldEnum | UserAchievementScalarFieldEnum[]
  }

  /**
   * UserAchievement findFirstOrThrow
   */
  export type UserAchievementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * Filter, which UserAchievement to fetch.
     */
    where?: UserAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAchievements to fetch.
     */
    orderBy?: UserAchievementOrderByWithRelationInput | UserAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAchievements.
     */
    cursor?: UserAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAchievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAchievements.
     */
    distinct?: UserAchievementScalarFieldEnum | UserAchievementScalarFieldEnum[]
  }

  /**
   * UserAchievement findMany
   */
  export type UserAchievementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * Filter, which UserAchievements to fetch.
     */
    where?: UserAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAchievements to fetch.
     */
    orderBy?: UserAchievementOrderByWithRelationInput | UserAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserAchievements.
     */
    cursor?: UserAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAchievements.
     */
    skip?: number
    distinct?: UserAchievementScalarFieldEnum | UserAchievementScalarFieldEnum[]
  }

  /**
   * UserAchievement create
   */
  export type UserAchievementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * The data needed to create a UserAchievement.
     */
    data: XOR<UserAchievementCreateInput, UserAchievementUncheckedCreateInput>
  }

  /**
   * UserAchievement createMany
   */
  export type UserAchievementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserAchievements.
     */
    data: UserAchievementCreateManyInput | UserAchievementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserAchievement createManyAndReturn
   */
  export type UserAchievementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserAchievements.
     */
    data: UserAchievementCreateManyInput | UserAchievementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserAchievement update
   */
  export type UserAchievementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * The data needed to update a UserAchievement.
     */
    data: XOR<UserAchievementUpdateInput, UserAchievementUncheckedUpdateInput>
    /**
     * Choose, which UserAchievement to update.
     */
    where: UserAchievementWhereUniqueInput
  }

  /**
   * UserAchievement updateMany
   */
  export type UserAchievementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserAchievements.
     */
    data: XOR<UserAchievementUpdateManyMutationInput, UserAchievementUncheckedUpdateManyInput>
    /**
     * Filter which UserAchievements to update
     */
    where?: UserAchievementWhereInput
  }

  /**
   * UserAchievement upsert
   */
  export type UserAchievementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * The filter to search for the UserAchievement to update in case it exists.
     */
    where: UserAchievementWhereUniqueInput
    /**
     * In case the UserAchievement found by the `where` argument doesn't exist, create a new UserAchievement with this data.
     */
    create: XOR<UserAchievementCreateInput, UserAchievementUncheckedCreateInput>
    /**
     * In case the UserAchievement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserAchievementUpdateInput, UserAchievementUncheckedUpdateInput>
  }

  /**
   * UserAchievement delete
   */
  export type UserAchievementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * Filter which UserAchievement to delete.
     */
    where: UserAchievementWhereUniqueInput
  }

  /**
   * UserAchievement deleteMany
   */
  export type UserAchievementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAchievements to delete
     */
    where?: UserAchievementWhereInput
  }

  /**
   * UserAchievement without action
   */
  export type UserAchievementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
  }


  /**
   * Model Badge
   */

  export type AggregateBadge = {
    _count: BadgeCountAggregateOutputType | null
    _min: BadgeMinAggregateOutputType | null
    _max: BadgeMaxAggregateOutputType | null
  }

  export type BadgeMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    imageUrl: string | null
    type: $Enums.BadgeType | null
    category: string | null
  }

  export type BadgeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    imageUrl: string | null
    type: $Enums.BadgeType | null
    category: string | null
  }

  export type BadgeCountAggregateOutputType = {
    id: number
    name: number
    description: number
    imageUrl: number
    type: number
    category: number
    _all: number
  }


  export type BadgeMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    imageUrl?: true
    type?: true
    category?: true
  }

  export type BadgeMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    imageUrl?: true
    type?: true
    category?: true
  }

  export type BadgeCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    imageUrl?: true
    type?: true
    category?: true
    _all?: true
  }

  export type BadgeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Badge to aggregate.
     */
    where?: BadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Badges to fetch.
     */
    orderBy?: BadgeOrderByWithRelationInput | BadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Badges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Badges
    **/
    _count?: true | BadgeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BadgeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BadgeMaxAggregateInputType
  }

  export type GetBadgeAggregateType<T extends BadgeAggregateArgs> = {
        [P in keyof T & keyof AggregateBadge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBadge[P]>
      : GetScalarType<T[P], AggregateBadge[P]>
  }




  export type BadgeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BadgeWhereInput
    orderBy?: BadgeOrderByWithAggregationInput | BadgeOrderByWithAggregationInput[]
    by: BadgeScalarFieldEnum[] | BadgeScalarFieldEnum
    having?: BadgeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BadgeCountAggregateInputType | true
    _min?: BadgeMinAggregateInputType
    _max?: BadgeMaxAggregateInputType
  }

  export type BadgeGroupByOutputType = {
    id: string
    name: string
    description: string | null
    imageUrl: string | null
    type: $Enums.BadgeType
    category: string | null
    _count: BadgeCountAggregateOutputType | null
    _min: BadgeMinAggregateOutputType | null
    _max: BadgeMaxAggregateOutputType | null
  }

  type GetBadgeGroupByPayload<T extends BadgeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BadgeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BadgeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BadgeGroupByOutputType[P]>
            : GetScalarType<T[P], BadgeGroupByOutputType[P]>
        }
      >
    >


  export type BadgeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    imageUrl?: boolean
    type?: boolean
    category?: boolean
    certificates?: boolean | Badge$certificatesArgs<ExtArgs>
    _count?: boolean | BadgeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["badge"]>

  export type BadgeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    imageUrl?: boolean
    type?: boolean
    category?: boolean
  }, ExtArgs["result"]["badge"]>

  export type BadgeSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    imageUrl?: boolean
    type?: boolean
    category?: boolean
  }

  export type BadgeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    certificates?: boolean | Badge$certificatesArgs<ExtArgs>
    _count?: boolean | BadgeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BadgeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BadgePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Badge"
    objects: {
      certificates: Prisma.$CertificatePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      imageUrl: string | null
      type: $Enums.BadgeType
      category: string | null
    }, ExtArgs["result"]["badge"]>
    composites: {}
  }

  type BadgeGetPayload<S extends boolean | null | undefined | BadgeDefaultArgs> = $Result.GetResult<Prisma.$BadgePayload, S>

  type BadgeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BadgeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BadgeCountAggregateInputType | true
    }

  export interface BadgeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Badge'], meta: { name: 'Badge' } }
    /**
     * Find zero or one Badge that matches the filter.
     * @param {BadgeFindUniqueArgs} args - Arguments to find a Badge
     * @example
     * // Get one Badge
     * const badge = await prisma.badge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BadgeFindUniqueArgs>(args: SelectSubset<T, BadgeFindUniqueArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Badge that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BadgeFindUniqueOrThrowArgs} args - Arguments to find a Badge
     * @example
     * // Get one Badge
     * const badge = await prisma.badge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BadgeFindUniqueOrThrowArgs>(args: SelectSubset<T, BadgeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Badge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeFindFirstArgs} args - Arguments to find a Badge
     * @example
     * // Get one Badge
     * const badge = await prisma.badge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BadgeFindFirstArgs>(args?: SelectSubset<T, BadgeFindFirstArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Badge that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeFindFirstOrThrowArgs} args - Arguments to find a Badge
     * @example
     * // Get one Badge
     * const badge = await prisma.badge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BadgeFindFirstOrThrowArgs>(args?: SelectSubset<T, BadgeFindFirstOrThrowArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Badges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Badges
     * const badges = await prisma.badge.findMany()
     * 
     * // Get first 10 Badges
     * const badges = await prisma.badge.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const badgeWithIdOnly = await prisma.badge.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BadgeFindManyArgs>(args?: SelectSubset<T, BadgeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Badge.
     * @param {BadgeCreateArgs} args - Arguments to create a Badge.
     * @example
     * // Create one Badge
     * const Badge = await prisma.badge.create({
     *   data: {
     *     // ... data to create a Badge
     *   }
     * })
     * 
     */
    create<T extends BadgeCreateArgs>(args: SelectSubset<T, BadgeCreateArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Badges.
     * @param {BadgeCreateManyArgs} args - Arguments to create many Badges.
     * @example
     * // Create many Badges
     * const badge = await prisma.badge.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BadgeCreateManyArgs>(args?: SelectSubset<T, BadgeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Badges and returns the data saved in the database.
     * @param {BadgeCreateManyAndReturnArgs} args - Arguments to create many Badges.
     * @example
     * // Create many Badges
     * const badge = await prisma.badge.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Badges and only return the `id`
     * const badgeWithIdOnly = await prisma.badge.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BadgeCreateManyAndReturnArgs>(args?: SelectSubset<T, BadgeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Badge.
     * @param {BadgeDeleteArgs} args - Arguments to delete one Badge.
     * @example
     * // Delete one Badge
     * const Badge = await prisma.badge.delete({
     *   where: {
     *     // ... filter to delete one Badge
     *   }
     * })
     * 
     */
    delete<T extends BadgeDeleteArgs>(args: SelectSubset<T, BadgeDeleteArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Badge.
     * @param {BadgeUpdateArgs} args - Arguments to update one Badge.
     * @example
     * // Update one Badge
     * const badge = await prisma.badge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BadgeUpdateArgs>(args: SelectSubset<T, BadgeUpdateArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Badges.
     * @param {BadgeDeleteManyArgs} args - Arguments to filter Badges to delete.
     * @example
     * // Delete a few Badges
     * const { count } = await prisma.badge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BadgeDeleteManyArgs>(args?: SelectSubset<T, BadgeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Badges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Badges
     * const badge = await prisma.badge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BadgeUpdateManyArgs>(args: SelectSubset<T, BadgeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Badge.
     * @param {BadgeUpsertArgs} args - Arguments to update or create a Badge.
     * @example
     * // Update or create a Badge
     * const badge = await prisma.badge.upsert({
     *   create: {
     *     // ... data to create a Badge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Badge we want to update
     *   }
     * })
     */
    upsert<T extends BadgeUpsertArgs>(args: SelectSubset<T, BadgeUpsertArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Badges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeCountArgs} args - Arguments to filter Badges to count.
     * @example
     * // Count the number of Badges
     * const count = await prisma.badge.count({
     *   where: {
     *     // ... the filter for the Badges we want to count
     *   }
     * })
    **/
    count<T extends BadgeCountArgs>(
      args?: Subset<T, BadgeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BadgeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Badge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BadgeAggregateArgs>(args: Subset<T, BadgeAggregateArgs>): Prisma.PrismaPromise<GetBadgeAggregateType<T>>

    /**
     * Group by Badge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BadgeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BadgeGroupByArgs['orderBy'] }
        : { orderBy?: BadgeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BadgeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBadgeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Badge model
   */
  readonly fields: BadgeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Badge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BadgeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    certificates<T extends Badge$certificatesArgs<ExtArgs> = {}>(args?: Subset<T, Badge$certificatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Badge model
   */ 
  interface BadgeFieldRefs {
    readonly id: FieldRef<"Badge", 'String'>
    readonly name: FieldRef<"Badge", 'String'>
    readonly description: FieldRef<"Badge", 'String'>
    readonly imageUrl: FieldRef<"Badge", 'String'>
    readonly type: FieldRef<"Badge", 'BadgeType'>
    readonly category: FieldRef<"Badge", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Badge findUnique
   */
  export type BadgeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter, which Badge to fetch.
     */
    where: BadgeWhereUniqueInput
  }

  /**
   * Badge findUniqueOrThrow
   */
  export type BadgeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter, which Badge to fetch.
     */
    where: BadgeWhereUniqueInput
  }

  /**
   * Badge findFirst
   */
  export type BadgeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter, which Badge to fetch.
     */
    where?: BadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Badges to fetch.
     */
    orderBy?: BadgeOrderByWithRelationInput | BadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Badges.
     */
    cursor?: BadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Badges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Badges.
     */
    distinct?: BadgeScalarFieldEnum | BadgeScalarFieldEnum[]
  }

  /**
   * Badge findFirstOrThrow
   */
  export type BadgeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter, which Badge to fetch.
     */
    where?: BadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Badges to fetch.
     */
    orderBy?: BadgeOrderByWithRelationInput | BadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Badges.
     */
    cursor?: BadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Badges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Badges.
     */
    distinct?: BadgeScalarFieldEnum | BadgeScalarFieldEnum[]
  }

  /**
   * Badge findMany
   */
  export type BadgeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter, which Badges to fetch.
     */
    where?: BadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Badges to fetch.
     */
    orderBy?: BadgeOrderByWithRelationInput | BadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Badges.
     */
    cursor?: BadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Badges.
     */
    skip?: number
    distinct?: BadgeScalarFieldEnum | BadgeScalarFieldEnum[]
  }

  /**
   * Badge create
   */
  export type BadgeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * The data needed to create a Badge.
     */
    data: XOR<BadgeCreateInput, BadgeUncheckedCreateInput>
  }

  /**
   * Badge createMany
   */
  export type BadgeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Badges.
     */
    data: BadgeCreateManyInput | BadgeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Badge createManyAndReturn
   */
  export type BadgeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Badges.
     */
    data: BadgeCreateManyInput | BadgeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Badge update
   */
  export type BadgeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * The data needed to update a Badge.
     */
    data: XOR<BadgeUpdateInput, BadgeUncheckedUpdateInput>
    /**
     * Choose, which Badge to update.
     */
    where: BadgeWhereUniqueInput
  }

  /**
   * Badge updateMany
   */
  export type BadgeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Badges.
     */
    data: XOR<BadgeUpdateManyMutationInput, BadgeUncheckedUpdateManyInput>
    /**
     * Filter which Badges to update
     */
    where?: BadgeWhereInput
  }

  /**
   * Badge upsert
   */
  export type BadgeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * The filter to search for the Badge to update in case it exists.
     */
    where: BadgeWhereUniqueInput
    /**
     * In case the Badge found by the `where` argument doesn't exist, create a new Badge with this data.
     */
    create: XOR<BadgeCreateInput, BadgeUncheckedCreateInput>
    /**
     * In case the Badge was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BadgeUpdateInput, BadgeUncheckedUpdateInput>
  }

  /**
   * Badge delete
   */
  export type BadgeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter which Badge to delete.
     */
    where: BadgeWhereUniqueInput
  }

  /**
   * Badge deleteMany
   */
  export type BadgeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Badges to delete
     */
    where?: BadgeWhereInput
  }

  /**
   * Badge.certificates
   */
  export type Badge$certificatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    where?: CertificateWhereInput
    orderBy?: CertificateOrderByWithRelationInput | CertificateOrderByWithRelationInput[]
    cursor?: CertificateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CertificateScalarFieldEnum | CertificateScalarFieldEnum[]
  }

  /**
   * Badge without action
   */
  export type BadgeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
  }


  /**
   * Model Certificate
   */

  export type AggregateCertificate = {
    _count: CertificateCountAggregateOutputType | null
    _min: CertificateMinAggregateOutputType | null
    _max: CertificateMaxAggregateOutputType | null
  }

  export type CertificateMinAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    issueDate: Date | null
    type: string | null
    courseId: string | null
    courseName: string | null
    tutoringId: string | null
    tutoringSubject: string | null
    teacherId: string | null
    teacherName: string | null
    customMessage: string | null
    imageUrl: string | null
    badgeId: string | null
  }

  export type CertificateMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    issueDate: Date | null
    type: string | null
    courseId: string | null
    courseName: string | null
    tutoringId: string | null
    tutoringSubject: string | null
    teacherId: string | null
    teacherName: string | null
    customMessage: string | null
    imageUrl: string | null
    badgeId: string | null
  }

  export type CertificateCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    issueDate: number
    type: number
    courseId: number
    courseName: number
    tutoringId: number
    tutoringSubject: number
    teacherId: number
    teacherName: number
    customMessage: number
    imageUrl: number
    badgeId: number
    _all: number
  }


  export type CertificateMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    issueDate?: true
    type?: true
    courseId?: true
    courseName?: true
    tutoringId?: true
    tutoringSubject?: true
    teacherId?: true
    teacherName?: true
    customMessage?: true
    imageUrl?: true
    badgeId?: true
  }

  export type CertificateMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    issueDate?: true
    type?: true
    courseId?: true
    courseName?: true
    tutoringId?: true
    tutoringSubject?: true
    teacherId?: true
    teacherName?: true
    customMessage?: true
    imageUrl?: true
    badgeId?: true
  }

  export type CertificateCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    issueDate?: true
    type?: true
    courseId?: true
    courseName?: true
    tutoringId?: true
    tutoringSubject?: true
    teacherId?: true
    teacherName?: true
    customMessage?: true
    imageUrl?: true
    badgeId?: true
    _all?: true
  }

  export type CertificateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Certificate to aggregate.
     */
    where?: CertificateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certificates to fetch.
     */
    orderBy?: CertificateOrderByWithRelationInput | CertificateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CertificateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certificates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certificates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Certificates
    **/
    _count?: true | CertificateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CertificateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CertificateMaxAggregateInputType
  }

  export type GetCertificateAggregateType<T extends CertificateAggregateArgs> = {
        [P in keyof T & keyof AggregateCertificate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCertificate[P]>
      : GetScalarType<T[P], AggregateCertificate[P]>
  }




  export type CertificateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CertificateWhereInput
    orderBy?: CertificateOrderByWithAggregationInput | CertificateOrderByWithAggregationInput[]
    by: CertificateScalarFieldEnum[] | CertificateScalarFieldEnum
    having?: CertificateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CertificateCountAggregateInputType | true
    _min?: CertificateMinAggregateInputType
    _max?: CertificateMaxAggregateInputType
  }

  export type CertificateGroupByOutputType = {
    id: string
    userId: string
    title: string
    issueDate: Date
    type: string
    courseId: string | null
    courseName: string | null
    tutoringId: string | null
    tutoringSubject: string | null
    teacherId: string | null
    teacherName: string | null
    customMessage: string | null
    imageUrl: string | null
    badgeId: string | null
    _count: CertificateCountAggregateOutputType | null
    _min: CertificateMinAggregateOutputType | null
    _max: CertificateMaxAggregateOutputType | null
  }

  type GetCertificateGroupByPayload<T extends CertificateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CertificateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CertificateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CertificateGroupByOutputType[P]>
            : GetScalarType<T[P], CertificateGroupByOutputType[P]>
        }
      >
    >


  export type CertificateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    issueDate?: boolean
    type?: boolean
    courseId?: boolean
    courseName?: boolean
    tutoringId?: boolean
    tutoringSubject?: boolean
    teacherId?: boolean
    teacherName?: boolean
    customMessage?: boolean
    imageUrl?: boolean
    badgeId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | Certificate$courseArgs<ExtArgs>
    tutoring?: boolean | Certificate$tutoringArgs<ExtArgs>
    badge?: boolean | Certificate$badgeArgs<ExtArgs>
  }, ExtArgs["result"]["certificate"]>

  export type CertificateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    issueDate?: boolean
    type?: boolean
    courseId?: boolean
    courseName?: boolean
    tutoringId?: boolean
    tutoringSubject?: boolean
    teacherId?: boolean
    teacherName?: boolean
    customMessage?: boolean
    imageUrl?: boolean
    badgeId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | Certificate$courseArgs<ExtArgs>
    tutoring?: boolean | Certificate$tutoringArgs<ExtArgs>
    badge?: boolean | Certificate$badgeArgs<ExtArgs>
  }, ExtArgs["result"]["certificate"]>

  export type CertificateSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    issueDate?: boolean
    type?: boolean
    courseId?: boolean
    courseName?: boolean
    tutoringId?: boolean
    tutoringSubject?: boolean
    teacherId?: boolean
    teacherName?: boolean
    customMessage?: boolean
    imageUrl?: boolean
    badgeId?: boolean
  }

  export type CertificateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | Certificate$courseArgs<ExtArgs>
    tutoring?: boolean | Certificate$tutoringArgs<ExtArgs>
    badge?: boolean | Certificate$badgeArgs<ExtArgs>
  }
  export type CertificateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | Certificate$courseArgs<ExtArgs>
    tutoring?: boolean | Certificate$tutoringArgs<ExtArgs>
    badge?: boolean | Certificate$badgeArgs<ExtArgs>
  }

  export type $CertificatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Certificate"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      course: Prisma.$CoursePayload<ExtArgs> | null
      tutoring: Prisma.$TutoringSessionPayload<ExtArgs> | null
      badge: Prisma.$BadgePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      title: string
      issueDate: Date
      type: string
      courseId: string | null
      courseName: string | null
      tutoringId: string | null
      tutoringSubject: string | null
      teacherId: string | null
      teacherName: string | null
      customMessage: string | null
      imageUrl: string | null
      badgeId: string | null
    }, ExtArgs["result"]["certificate"]>
    composites: {}
  }

  type CertificateGetPayload<S extends boolean | null | undefined | CertificateDefaultArgs> = $Result.GetResult<Prisma.$CertificatePayload, S>

  type CertificateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CertificateFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CertificateCountAggregateInputType | true
    }

  export interface CertificateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Certificate'], meta: { name: 'Certificate' } }
    /**
     * Find zero or one Certificate that matches the filter.
     * @param {CertificateFindUniqueArgs} args - Arguments to find a Certificate
     * @example
     * // Get one Certificate
     * const certificate = await prisma.certificate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CertificateFindUniqueArgs>(args: SelectSubset<T, CertificateFindUniqueArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Certificate that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CertificateFindUniqueOrThrowArgs} args - Arguments to find a Certificate
     * @example
     * // Get one Certificate
     * const certificate = await prisma.certificate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CertificateFindUniqueOrThrowArgs>(args: SelectSubset<T, CertificateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Certificate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateFindFirstArgs} args - Arguments to find a Certificate
     * @example
     * // Get one Certificate
     * const certificate = await prisma.certificate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CertificateFindFirstArgs>(args?: SelectSubset<T, CertificateFindFirstArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Certificate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateFindFirstOrThrowArgs} args - Arguments to find a Certificate
     * @example
     * // Get one Certificate
     * const certificate = await prisma.certificate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CertificateFindFirstOrThrowArgs>(args?: SelectSubset<T, CertificateFindFirstOrThrowArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Certificates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Certificates
     * const certificates = await prisma.certificate.findMany()
     * 
     * // Get first 10 Certificates
     * const certificates = await prisma.certificate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const certificateWithIdOnly = await prisma.certificate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CertificateFindManyArgs>(args?: SelectSubset<T, CertificateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Certificate.
     * @param {CertificateCreateArgs} args - Arguments to create a Certificate.
     * @example
     * // Create one Certificate
     * const Certificate = await prisma.certificate.create({
     *   data: {
     *     // ... data to create a Certificate
     *   }
     * })
     * 
     */
    create<T extends CertificateCreateArgs>(args: SelectSubset<T, CertificateCreateArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Certificates.
     * @param {CertificateCreateManyArgs} args - Arguments to create many Certificates.
     * @example
     * // Create many Certificates
     * const certificate = await prisma.certificate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CertificateCreateManyArgs>(args?: SelectSubset<T, CertificateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Certificates and returns the data saved in the database.
     * @param {CertificateCreateManyAndReturnArgs} args - Arguments to create many Certificates.
     * @example
     * // Create many Certificates
     * const certificate = await prisma.certificate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Certificates and only return the `id`
     * const certificateWithIdOnly = await prisma.certificate.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CertificateCreateManyAndReturnArgs>(args?: SelectSubset<T, CertificateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Certificate.
     * @param {CertificateDeleteArgs} args - Arguments to delete one Certificate.
     * @example
     * // Delete one Certificate
     * const Certificate = await prisma.certificate.delete({
     *   where: {
     *     // ... filter to delete one Certificate
     *   }
     * })
     * 
     */
    delete<T extends CertificateDeleteArgs>(args: SelectSubset<T, CertificateDeleteArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Certificate.
     * @param {CertificateUpdateArgs} args - Arguments to update one Certificate.
     * @example
     * // Update one Certificate
     * const certificate = await prisma.certificate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CertificateUpdateArgs>(args: SelectSubset<T, CertificateUpdateArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Certificates.
     * @param {CertificateDeleteManyArgs} args - Arguments to filter Certificates to delete.
     * @example
     * // Delete a few Certificates
     * const { count } = await prisma.certificate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CertificateDeleteManyArgs>(args?: SelectSubset<T, CertificateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Certificates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Certificates
     * const certificate = await prisma.certificate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CertificateUpdateManyArgs>(args: SelectSubset<T, CertificateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Certificate.
     * @param {CertificateUpsertArgs} args - Arguments to update or create a Certificate.
     * @example
     * // Update or create a Certificate
     * const certificate = await prisma.certificate.upsert({
     *   create: {
     *     // ... data to create a Certificate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Certificate we want to update
     *   }
     * })
     */
    upsert<T extends CertificateUpsertArgs>(args: SelectSubset<T, CertificateUpsertArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Certificates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateCountArgs} args - Arguments to filter Certificates to count.
     * @example
     * // Count the number of Certificates
     * const count = await prisma.certificate.count({
     *   where: {
     *     // ... the filter for the Certificates we want to count
     *   }
     * })
    **/
    count<T extends CertificateCountArgs>(
      args?: Subset<T, CertificateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CertificateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Certificate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CertificateAggregateArgs>(args: Subset<T, CertificateAggregateArgs>): Prisma.PrismaPromise<GetCertificateAggregateType<T>>

    /**
     * Group by Certificate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CertificateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CertificateGroupByArgs['orderBy'] }
        : { orderBy?: CertificateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CertificateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCertificateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Certificate model
   */
  readonly fields: CertificateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Certificate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CertificateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    course<T extends Certificate$courseArgs<ExtArgs> = {}>(args?: Subset<T, Certificate$courseArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    tutoring<T extends Certificate$tutoringArgs<ExtArgs> = {}>(args?: Subset<T, Certificate$tutoringArgs<ExtArgs>>): Prisma__TutoringSessionClient<$Result.GetResult<Prisma.$TutoringSessionPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    badge<T extends Certificate$badgeArgs<ExtArgs> = {}>(args?: Subset<T, Certificate$badgeArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Certificate model
   */ 
  interface CertificateFieldRefs {
    readonly id: FieldRef<"Certificate", 'String'>
    readonly userId: FieldRef<"Certificate", 'String'>
    readonly title: FieldRef<"Certificate", 'String'>
    readonly issueDate: FieldRef<"Certificate", 'DateTime'>
    readonly type: FieldRef<"Certificate", 'String'>
    readonly courseId: FieldRef<"Certificate", 'String'>
    readonly courseName: FieldRef<"Certificate", 'String'>
    readonly tutoringId: FieldRef<"Certificate", 'String'>
    readonly tutoringSubject: FieldRef<"Certificate", 'String'>
    readonly teacherId: FieldRef<"Certificate", 'String'>
    readonly teacherName: FieldRef<"Certificate", 'String'>
    readonly customMessage: FieldRef<"Certificate", 'String'>
    readonly imageUrl: FieldRef<"Certificate", 'String'>
    readonly badgeId: FieldRef<"Certificate", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Certificate findUnique
   */
  export type CertificateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * Filter, which Certificate to fetch.
     */
    where: CertificateWhereUniqueInput
  }

  /**
   * Certificate findUniqueOrThrow
   */
  export type CertificateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * Filter, which Certificate to fetch.
     */
    where: CertificateWhereUniqueInput
  }

  /**
   * Certificate findFirst
   */
  export type CertificateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * Filter, which Certificate to fetch.
     */
    where?: CertificateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certificates to fetch.
     */
    orderBy?: CertificateOrderByWithRelationInput | CertificateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Certificates.
     */
    cursor?: CertificateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certificates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certificates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Certificates.
     */
    distinct?: CertificateScalarFieldEnum | CertificateScalarFieldEnum[]
  }

  /**
   * Certificate findFirstOrThrow
   */
  export type CertificateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * Filter, which Certificate to fetch.
     */
    where?: CertificateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certificates to fetch.
     */
    orderBy?: CertificateOrderByWithRelationInput | CertificateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Certificates.
     */
    cursor?: CertificateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certificates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certificates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Certificates.
     */
    distinct?: CertificateScalarFieldEnum | CertificateScalarFieldEnum[]
  }

  /**
   * Certificate findMany
   */
  export type CertificateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * Filter, which Certificates to fetch.
     */
    where?: CertificateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certificates to fetch.
     */
    orderBy?: CertificateOrderByWithRelationInput | CertificateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Certificates.
     */
    cursor?: CertificateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certificates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certificates.
     */
    skip?: number
    distinct?: CertificateScalarFieldEnum | CertificateScalarFieldEnum[]
  }

  /**
   * Certificate create
   */
  export type CertificateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * The data needed to create a Certificate.
     */
    data: XOR<CertificateCreateInput, CertificateUncheckedCreateInput>
  }

  /**
   * Certificate createMany
   */
  export type CertificateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Certificates.
     */
    data: CertificateCreateManyInput | CertificateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Certificate createManyAndReturn
   */
  export type CertificateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Certificates.
     */
    data: CertificateCreateManyInput | CertificateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Certificate update
   */
  export type CertificateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * The data needed to update a Certificate.
     */
    data: XOR<CertificateUpdateInput, CertificateUncheckedUpdateInput>
    /**
     * Choose, which Certificate to update.
     */
    where: CertificateWhereUniqueInput
  }

  /**
   * Certificate updateMany
   */
  export type CertificateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Certificates.
     */
    data: XOR<CertificateUpdateManyMutationInput, CertificateUncheckedUpdateManyInput>
    /**
     * Filter which Certificates to update
     */
    where?: CertificateWhereInput
  }

  /**
   * Certificate upsert
   */
  export type CertificateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * The filter to search for the Certificate to update in case it exists.
     */
    where: CertificateWhereUniqueInput
    /**
     * In case the Certificate found by the `where` argument doesn't exist, create a new Certificate with this data.
     */
    create: XOR<CertificateCreateInput, CertificateUncheckedCreateInput>
    /**
     * In case the Certificate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CertificateUpdateInput, CertificateUncheckedUpdateInput>
  }

  /**
   * Certificate delete
   */
  export type CertificateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * Filter which Certificate to delete.
     */
    where: CertificateWhereUniqueInput
  }

  /**
   * Certificate deleteMany
   */
  export type CertificateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Certificates to delete
     */
    where?: CertificateWhereInput
  }

  /**
   * Certificate.course
   */
  export type Certificate$courseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    where?: CourseWhereInput
  }

  /**
   * Certificate.tutoring
   */
  export type Certificate$tutoringArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutoringSession
     */
    select?: TutoringSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutoringSessionInclude<ExtArgs> | null
    where?: TutoringSessionWhereInput
  }

  /**
   * Certificate.badge
   */
  export type Certificate$badgeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    where?: BadgeWhereInput
  }

  /**
   * Certificate without action
   */
  export type CertificateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
  }


  /**
   * Model Conversation
   */

  export type AggregateConversation = {
    _count: ConversationCountAggregateOutputType | null
    _min: ConversationMinAggregateOutputType | null
    _max: ConversationMaxAggregateOutputType | null
  }

  export type ConversationMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConversationMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConversationCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ConversationMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConversationMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConversationCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ConversationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conversation to aggregate.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Conversations
    **/
    _count?: true | ConversationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConversationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConversationMaxAggregateInputType
  }

  export type GetConversationAggregateType<T extends ConversationAggregateArgs> = {
        [P in keyof T & keyof AggregateConversation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConversation[P]>
      : GetScalarType<T[P], AggregateConversation[P]>
  }




  export type ConversationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationWhereInput
    orderBy?: ConversationOrderByWithAggregationInput | ConversationOrderByWithAggregationInput[]
    by: ConversationScalarFieldEnum[] | ConversationScalarFieldEnum
    having?: ConversationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConversationCountAggregateInputType | true
    _min?: ConversationMinAggregateInputType
    _max?: ConversationMaxAggregateInputType
  }

  export type ConversationGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    _count: ConversationCountAggregateOutputType | null
    _min: ConversationMinAggregateOutputType | null
    _max: ConversationMaxAggregateOutputType | null
  }

  type GetConversationGroupByPayload<T extends ConversationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConversationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConversationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConversationGroupByOutputType[P]>
            : GetScalarType<T[P], ConversationGroupByOutputType[P]>
        }
      >
    >


  export type ConversationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    participants?: boolean | Conversation$participantsArgs<ExtArgs>
    messages?: boolean | Conversation$messagesArgs<ExtArgs>
    _count?: boolean | ConversationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversation"]>

  export type ConversationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["conversation"]>

  export type ConversationSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ConversationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    participants?: boolean | Conversation$participantsArgs<ExtArgs>
    messages?: boolean | Conversation$messagesArgs<ExtArgs>
    _count?: boolean | ConversationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ConversationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ConversationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Conversation"
    objects: {
      participants: Prisma.$ConversationParticipantPayload<ExtArgs>[]
      messages: Prisma.$MessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["conversation"]>
    composites: {}
  }

  type ConversationGetPayload<S extends boolean | null | undefined | ConversationDefaultArgs> = $Result.GetResult<Prisma.$ConversationPayload, S>

  type ConversationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ConversationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ConversationCountAggregateInputType | true
    }

  export interface ConversationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Conversation'], meta: { name: 'Conversation' } }
    /**
     * Find zero or one Conversation that matches the filter.
     * @param {ConversationFindUniqueArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConversationFindUniqueArgs>(args: SelectSubset<T, ConversationFindUniqueArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Conversation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ConversationFindUniqueOrThrowArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConversationFindUniqueOrThrowArgs>(args: SelectSubset<T, ConversationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Conversation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindFirstArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConversationFindFirstArgs>(args?: SelectSubset<T, ConversationFindFirstArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Conversation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindFirstOrThrowArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConversationFindFirstOrThrowArgs>(args?: SelectSubset<T, ConversationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Conversations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Conversations
     * const conversations = await prisma.conversation.findMany()
     * 
     * // Get first 10 Conversations
     * const conversations = await prisma.conversation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conversationWithIdOnly = await prisma.conversation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConversationFindManyArgs>(args?: SelectSubset<T, ConversationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Conversation.
     * @param {ConversationCreateArgs} args - Arguments to create a Conversation.
     * @example
     * // Create one Conversation
     * const Conversation = await prisma.conversation.create({
     *   data: {
     *     // ... data to create a Conversation
     *   }
     * })
     * 
     */
    create<T extends ConversationCreateArgs>(args: SelectSubset<T, ConversationCreateArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Conversations.
     * @param {ConversationCreateManyArgs} args - Arguments to create many Conversations.
     * @example
     * // Create many Conversations
     * const conversation = await prisma.conversation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConversationCreateManyArgs>(args?: SelectSubset<T, ConversationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Conversations and returns the data saved in the database.
     * @param {ConversationCreateManyAndReturnArgs} args - Arguments to create many Conversations.
     * @example
     * // Create many Conversations
     * const conversation = await prisma.conversation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Conversations and only return the `id`
     * const conversationWithIdOnly = await prisma.conversation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConversationCreateManyAndReturnArgs>(args?: SelectSubset<T, ConversationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Conversation.
     * @param {ConversationDeleteArgs} args - Arguments to delete one Conversation.
     * @example
     * // Delete one Conversation
     * const Conversation = await prisma.conversation.delete({
     *   where: {
     *     // ... filter to delete one Conversation
     *   }
     * })
     * 
     */
    delete<T extends ConversationDeleteArgs>(args: SelectSubset<T, ConversationDeleteArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Conversation.
     * @param {ConversationUpdateArgs} args - Arguments to update one Conversation.
     * @example
     * // Update one Conversation
     * const conversation = await prisma.conversation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConversationUpdateArgs>(args: SelectSubset<T, ConversationUpdateArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Conversations.
     * @param {ConversationDeleteManyArgs} args - Arguments to filter Conversations to delete.
     * @example
     * // Delete a few Conversations
     * const { count } = await prisma.conversation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConversationDeleteManyArgs>(args?: SelectSubset<T, ConversationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Conversations
     * const conversation = await prisma.conversation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConversationUpdateManyArgs>(args: SelectSubset<T, ConversationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Conversation.
     * @param {ConversationUpsertArgs} args - Arguments to update or create a Conversation.
     * @example
     * // Update or create a Conversation
     * const conversation = await prisma.conversation.upsert({
     *   create: {
     *     // ... data to create a Conversation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Conversation we want to update
     *   }
     * })
     */
    upsert<T extends ConversationUpsertArgs>(args: SelectSubset<T, ConversationUpsertArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationCountArgs} args - Arguments to filter Conversations to count.
     * @example
     * // Count the number of Conversations
     * const count = await prisma.conversation.count({
     *   where: {
     *     // ... the filter for the Conversations we want to count
     *   }
     * })
    **/
    count<T extends ConversationCountArgs>(
      args?: Subset<T, ConversationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConversationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Conversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConversationAggregateArgs>(args: Subset<T, ConversationAggregateArgs>): Prisma.PrismaPromise<GetConversationAggregateType<T>>

    /**
     * Group by Conversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConversationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConversationGroupByArgs['orderBy'] }
        : { orderBy?: ConversationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConversationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConversationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Conversation model
   */
  readonly fields: ConversationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Conversation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConversationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    participants<T extends Conversation$participantsArgs<ExtArgs> = {}>(args?: Subset<T, Conversation$participantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "findMany"> | Null>
    messages<T extends Conversation$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Conversation$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Conversation model
   */ 
  interface ConversationFieldRefs {
    readonly id: FieldRef<"Conversation", 'String'>
    readonly createdAt: FieldRef<"Conversation", 'DateTime'>
    readonly updatedAt: FieldRef<"Conversation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Conversation findUnique
   */
  export type ConversationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation findUniqueOrThrow
   */
  export type ConversationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation findFirst
   */
  export type ConversationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conversations.
     */
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Conversation findFirstOrThrow
   */
  export type ConversationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conversations.
     */
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Conversation findMany
   */
  export type ConversationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversations to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Conversation create
   */
  export type ConversationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The data needed to create a Conversation.
     */
    data: XOR<ConversationCreateInput, ConversationUncheckedCreateInput>
  }

  /**
   * Conversation createMany
   */
  export type ConversationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Conversations.
     */
    data: ConversationCreateManyInput | ConversationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Conversation createManyAndReturn
   */
  export type ConversationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Conversations.
     */
    data: ConversationCreateManyInput | ConversationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Conversation update
   */
  export type ConversationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The data needed to update a Conversation.
     */
    data: XOR<ConversationUpdateInput, ConversationUncheckedUpdateInput>
    /**
     * Choose, which Conversation to update.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation updateMany
   */
  export type ConversationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Conversations.
     */
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyInput>
    /**
     * Filter which Conversations to update
     */
    where?: ConversationWhereInput
  }

  /**
   * Conversation upsert
   */
  export type ConversationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The filter to search for the Conversation to update in case it exists.
     */
    where: ConversationWhereUniqueInput
    /**
     * In case the Conversation found by the `where` argument doesn't exist, create a new Conversation with this data.
     */
    create: XOR<ConversationCreateInput, ConversationUncheckedCreateInput>
    /**
     * In case the Conversation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConversationUpdateInput, ConversationUncheckedUpdateInput>
  }

  /**
   * Conversation delete
   */
  export type ConversationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter which Conversation to delete.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation deleteMany
   */
  export type ConversationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conversations to delete
     */
    where?: ConversationWhereInput
  }

  /**
   * Conversation.participants
   */
  export type Conversation$participantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    where?: ConversationParticipantWhereInput
    orderBy?: ConversationParticipantOrderByWithRelationInput | ConversationParticipantOrderByWithRelationInput[]
    cursor?: ConversationParticipantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationParticipantScalarFieldEnum | ConversationParticipantScalarFieldEnum[]
  }

  /**
   * Conversation.messages
   */
  export type Conversation$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Conversation without action
   */
  export type ConversationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
  }


  /**
   * Model ConversationParticipant
   */

  export type AggregateConversationParticipant = {
    _count: ConversationParticipantCountAggregateOutputType | null
    _min: ConversationParticipantMinAggregateOutputType | null
    _max: ConversationParticipantMaxAggregateOutputType | null
  }

  export type ConversationParticipantMinAggregateOutputType = {
    conversationId: string | null
    userId: string | null
  }

  export type ConversationParticipantMaxAggregateOutputType = {
    conversationId: string | null
    userId: string | null
  }

  export type ConversationParticipantCountAggregateOutputType = {
    conversationId: number
    userId: number
    _all: number
  }


  export type ConversationParticipantMinAggregateInputType = {
    conversationId?: true
    userId?: true
  }

  export type ConversationParticipantMaxAggregateInputType = {
    conversationId?: true
    userId?: true
  }

  export type ConversationParticipantCountAggregateInputType = {
    conversationId?: true
    userId?: true
    _all?: true
  }

  export type ConversationParticipantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConversationParticipant to aggregate.
     */
    where?: ConversationParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationParticipants to fetch.
     */
    orderBy?: ConversationParticipantOrderByWithRelationInput | ConversationParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConversationParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConversationParticipants
    **/
    _count?: true | ConversationParticipantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConversationParticipantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConversationParticipantMaxAggregateInputType
  }

  export type GetConversationParticipantAggregateType<T extends ConversationParticipantAggregateArgs> = {
        [P in keyof T & keyof AggregateConversationParticipant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConversationParticipant[P]>
      : GetScalarType<T[P], AggregateConversationParticipant[P]>
  }




  export type ConversationParticipantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationParticipantWhereInput
    orderBy?: ConversationParticipantOrderByWithAggregationInput | ConversationParticipantOrderByWithAggregationInput[]
    by: ConversationParticipantScalarFieldEnum[] | ConversationParticipantScalarFieldEnum
    having?: ConversationParticipantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConversationParticipantCountAggregateInputType | true
    _min?: ConversationParticipantMinAggregateInputType
    _max?: ConversationParticipantMaxAggregateInputType
  }

  export type ConversationParticipantGroupByOutputType = {
    conversationId: string
    userId: string
    _count: ConversationParticipantCountAggregateOutputType | null
    _min: ConversationParticipantMinAggregateOutputType | null
    _max: ConversationParticipantMaxAggregateOutputType | null
  }

  type GetConversationParticipantGroupByPayload<T extends ConversationParticipantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConversationParticipantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConversationParticipantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConversationParticipantGroupByOutputType[P]>
            : GetScalarType<T[P], ConversationParticipantGroupByOutputType[P]>
        }
      >
    >


  export type ConversationParticipantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    conversationId?: boolean
    userId?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversationParticipant"]>

  export type ConversationParticipantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    conversationId?: boolean
    userId?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversationParticipant"]>

  export type ConversationParticipantSelectScalar = {
    conversationId?: boolean
    userId?: boolean
  }

  export type ConversationParticipantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ConversationParticipantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ConversationParticipantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConversationParticipant"
    objects: {
      conversation: Prisma.$ConversationPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      conversationId: string
      userId: string
    }, ExtArgs["result"]["conversationParticipant"]>
    composites: {}
  }

  type ConversationParticipantGetPayload<S extends boolean | null | undefined | ConversationParticipantDefaultArgs> = $Result.GetResult<Prisma.$ConversationParticipantPayload, S>

  type ConversationParticipantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ConversationParticipantFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ConversationParticipantCountAggregateInputType | true
    }

  export interface ConversationParticipantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConversationParticipant'], meta: { name: 'ConversationParticipant' } }
    /**
     * Find zero or one ConversationParticipant that matches the filter.
     * @param {ConversationParticipantFindUniqueArgs} args - Arguments to find a ConversationParticipant
     * @example
     * // Get one ConversationParticipant
     * const conversationParticipant = await prisma.conversationParticipant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConversationParticipantFindUniqueArgs>(args: SelectSubset<T, ConversationParticipantFindUniqueArgs<ExtArgs>>): Prisma__ConversationParticipantClient<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ConversationParticipant that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ConversationParticipantFindUniqueOrThrowArgs} args - Arguments to find a ConversationParticipant
     * @example
     * // Get one ConversationParticipant
     * const conversationParticipant = await prisma.conversationParticipant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConversationParticipantFindUniqueOrThrowArgs>(args: SelectSubset<T, ConversationParticipantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConversationParticipantClient<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ConversationParticipant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationParticipantFindFirstArgs} args - Arguments to find a ConversationParticipant
     * @example
     * // Get one ConversationParticipant
     * const conversationParticipant = await prisma.conversationParticipant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConversationParticipantFindFirstArgs>(args?: SelectSubset<T, ConversationParticipantFindFirstArgs<ExtArgs>>): Prisma__ConversationParticipantClient<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ConversationParticipant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationParticipantFindFirstOrThrowArgs} args - Arguments to find a ConversationParticipant
     * @example
     * // Get one ConversationParticipant
     * const conversationParticipant = await prisma.conversationParticipant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConversationParticipantFindFirstOrThrowArgs>(args?: SelectSubset<T, ConversationParticipantFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConversationParticipantClient<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ConversationParticipants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationParticipantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConversationParticipants
     * const conversationParticipants = await prisma.conversationParticipant.findMany()
     * 
     * // Get first 10 ConversationParticipants
     * const conversationParticipants = await prisma.conversationParticipant.findMany({ take: 10 })
     * 
     * // Only select the `conversationId`
     * const conversationParticipantWithConversationIdOnly = await prisma.conversationParticipant.findMany({ select: { conversationId: true } })
     * 
     */
    findMany<T extends ConversationParticipantFindManyArgs>(args?: SelectSubset<T, ConversationParticipantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ConversationParticipant.
     * @param {ConversationParticipantCreateArgs} args - Arguments to create a ConversationParticipant.
     * @example
     * // Create one ConversationParticipant
     * const ConversationParticipant = await prisma.conversationParticipant.create({
     *   data: {
     *     // ... data to create a ConversationParticipant
     *   }
     * })
     * 
     */
    create<T extends ConversationParticipantCreateArgs>(args: SelectSubset<T, ConversationParticipantCreateArgs<ExtArgs>>): Prisma__ConversationParticipantClient<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ConversationParticipants.
     * @param {ConversationParticipantCreateManyArgs} args - Arguments to create many ConversationParticipants.
     * @example
     * // Create many ConversationParticipants
     * const conversationParticipant = await prisma.conversationParticipant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConversationParticipantCreateManyArgs>(args?: SelectSubset<T, ConversationParticipantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ConversationParticipants and returns the data saved in the database.
     * @param {ConversationParticipantCreateManyAndReturnArgs} args - Arguments to create many ConversationParticipants.
     * @example
     * // Create many ConversationParticipants
     * const conversationParticipant = await prisma.conversationParticipant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ConversationParticipants and only return the `conversationId`
     * const conversationParticipantWithConversationIdOnly = await prisma.conversationParticipant.createManyAndReturn({ 
     *   select: { conversationId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConversationParticipantCreateManyAndReturnArgs>(args?: SelectSubset<T, ConversationParticipantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ConversationParticipant.
     * @param {ConversationParticipantDeleteArgs} args - Arguments to delete one ConversationParticipant.
     * @example
     * // Delete one ConversationParticipant
     * const ConversationParticipant = await prisma.conversationParticipant.delete({
     *   where: {
     *     // ... filter to delete one ConversationParticipant
     *   }
     * })
     * 
     */
    delete<T extends ConversationParticipantDeleteArgs>(args: SelectSubset<T, ConversationParticipantDeleteArgs<ExtArgs>>): Prisma__ConversationParticipantClient<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ConversationParticipant.
     * @param {ConversationParticipantUpdateArgs} args - Arguments to update one ConversationParticipant.
     * @example
     * // Update one ConversationParticipant
     * const conversationParticipant = await prisma.conversationParticipant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConversationParticipantUpdateArgs>(args: SelectSubset<T, ConversationParticipantUpdateArgs<ExtArgs>>): Prisma__ConversationParticipantClient<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ConversationParticipants.
     * @param {ConversationParticipantDeleteManyArgs} args - Arguments to filter ConversationParticipants to delete.
     * @example
     * // Delete a few ConversationParticipants
     * const { count } = await prisma.conversationParticipant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConversationParticipantDeleteManyArgs>(args?: SelectSubset<T, ConversationParticipantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConversationParticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationParticipantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConversationParticipants
     * const conversationParticipant = await prisma.conversationParticipant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConversationParticipantUpdateManyArgs>(args: SelectSubset<T, ConversationParticipantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ConversationParticipant.
     * @param {ConversationParticipantUpsertArgs} args - Arguments to update or create a ConversationParticipant.
     * @example
     * // Update or create a ConversationParticipant
     * const conversationParticipant = await prisma.conversationParticipant.upsert({
     *   create: {
     *     // ... data to create a ConversationParticipant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConversationParticipant we want to update
     *   }
     * })
     */
    upsert<T extends ConversationParticipantUpsertArgs>(args: SelectSubset<T, ConversationParticipantUpsertArgs<ExtArgs>>): Prisma__ConversationParticipantClient<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ConversationParticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationParticipantCountArgs} args - Arguments to filter ConversationParticipants to count.
     * @example
     * // Count the number of ConversationParticipants
     * const count = await prisma.conversationParticipant.count({
     *   where: {
     *     // ... the filter for the ConversationParticipants we want to count
     *   }
     * })
    **/
    count<T extends ConversationParticipantCountArgs>(
      args?: Subset<T, ConversationParticipantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConversationParticipantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConversationParticipant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationParticipantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConversationParticipantAggregateArgs>(args: Subset<T, ConversationParticipantAggregateArgs>): Prisma.PrismaPromise<GetConversationParticipantAggregateType<T>>

    /**
     * Group by ConversationParticipant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationParticipantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConversationParticipantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConversationParticipantGroupByArgs['orderBy'] }
        : { orderBy?: ConversationParticipantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConversationParticipantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConversationParticipantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConversationParticipant model
   */
  readonly fields: ConversationParticipantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConversationParticipant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConversationParticipantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    conversation<T extends ConversationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConversationDefaultArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ConversationParticipant model
   */ 
  interface ConversationParticipantFieldRefs {
    readonly conversationId: FieldRef<"ConversationParticipant", 'String'>
    readonly userId: FieldRef<"ConversationParticipant", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ConversationParticipant findUnique
   */
  export type ConversationParticipantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    /**
     * Filter, which ConversationParticipant to fetch.
     */
    where: ConversationParticipantWhereUniqueInput
  }

  /**
   * ConversationParticipant findUniqueOrThrow
   */
  export type ConversationParticipantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    /**
     * Filter, which ConversationParticipant to fetch.
     */
    where: ConversationParticipantWhereUniqueInput
  }

  /**
   * ConversationParticipant findFirst
   */
  export type ConversationParticipantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    /**
     * Filter, which ConversationParticipant to fetch.
     */
    where?: ConversationParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationParticipants to fetch.
     */
    orderBy?: ConversationParticipantOrderByWithRelationInput | ConversationParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConversationParticipants.
     */
    cursor?: ConversationParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConversationParticipants.
     */
    distinct?: ConversationParticipantScalarFieldEnum | ConversationParticipantScalarFieldEnum[]
  }

  /**
   * ConversationParticipant findFirstOrThrow
   */
  export type ConversationParticipantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    /**
     * Filter, which ConversationParticipant to fetch.
     */
    where?: ConversationParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationParticipants to fetch.
     */
    orderBy?: ConversationParticipantOrderByWithRelationInput | ConversationParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConversationParticipants.
     */
    cursor?: ConversationParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConversationParticipants.
     */
    distinct?: ConversationParticipantScalarFieldEnum | ConversationParticipantScalarFieldEnum[]
  }

  /**
   * ConversationParticipant findMany
   */
  export type ConversationParticipantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    /**
     * Filter, which ConversationParticipants to fetch.
     */
    where?: ConversationParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationParticipants to fetch.
     */
    orderBy?: ConversationParticipantOrderByWithRelationInput | ConversationParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConversationParticipants.
     */
    cursor?: ConversationParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationParticipants.
     */
    skip?: number
    distinct?: ConversationParticipantScalarFieldEnum | ConversationParticipantScalarFieldEnum[]
  }

  /**
   * ConversationParticipant create
   */
  export type ConversationParticipantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    /**
     * The data needed to create a ConversationParticipant.
     */
    data: XOR<ConversationParticipantCreateInput, ConversationParticipantUncheckedCreateInput>
  }

  /**
   * ConversationParticipant createMany
   */
  export type ConversationParticipantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConversationParticipants.
     */
    data: ConversationParticipantCreateManyInput | ConversationParticipantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConversationParticipant createManyAndReturn
   */
  export type ConversationParticipantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ConversationParticipants.
     */
    data: ConversationParticipantCreateManyInput | ConversationParticipantCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConversationParticipant update
   */
  export type ConversationParticipantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    /**
     * The data needed to update a ConversationParticipant.
     */
    data: XOR<ConversationParticipantUpdateInput, ConversationParticipantUncheckedUpdateInput>
    /**
     * Choose, which ConversationParticipant to update.
     */
    where: ConversationParticipantWhereUniqueInput
  }

  /**
   * ConversationParticipant updateMany
   */
  export type ConversationParticipantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConversationParticipants.
     */
    data: XOR<ConversationParticipantUpdateManyMutationInput, ConversationParticipantUncheckedUpdateManyInput>
    /**
     * Filter which ConversationParticipants to update
     */
    where?: ConversationParticipantWhereInput
  }

  /**
   * ConversationParticipant upsert
   */
  export type ConversationParticipantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    /**
     * The filter to search for the ConversationParticipant to update in case it exists.
     */
    where: ConversationParticipantWhereUniqueInput
    /**
     * In case the ConversationParticipant found by the `where` argument doesn't exist, create a new ConversationParticipant with this data.
     */
    create: XOR<ConversationParticipantCreateInput, ConversationParticipantUncheckedCreateInput>
    /**
     * In case the ConversationParticipant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConversationParticipantUpdateInput, ConversationParticipantUncheckedUpdateInput>
  }

  /**
   * ConversationParticipant delete
   */
  export type ConversationParticipantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    /**
     * Filter which ConversationParticipant to delete.
     */
    where: ConversationParticipantWhereUniqueInput
  }

  /**
   * ConversationParticipant deleteMany
   */
  export type ConversationParticipantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConversationParticipants to delete
     */
    where?: ConversationParticipantWhereInput
  }

  /**
   * ConversationParticipant without action
   */
  export type ConversationParticipantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
  }


  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageMinAggregateOutputType = {
    id: string | null
    conversationId: string | null
    senderId: string | null
    content: string | null
    timestamp: Date | null
    read: boolean | null
  }

  export type MessageMaxAggregateOutputType = {
    id: string | null
    conversationId: string | null
    senderId: string | null
    content: string | null
    timestamp: Date | null
    read: boolean | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    conversationId: number
    senderId: number
    content: number
    timestamp: number
    read: number
    _all: number
  }


  export type MessageMinAggregateInputType = {
    id?: true
    conversationId?: true
    senderId?: true
    content?: true
    timestamp?: true
    read?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    conversationId?: true
    senderId?: true
    content?: true
    timestamp?: true
    read?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    conversationId?: true
    senderId?: true
    content?: true
    timestamp?: true
    read?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithAggregationInput | MessageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: string
    conversationId: string
    senderId: string
    content: string
    timestamp: Date
    read: boolean
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    senderId?: boolean
    content?: boolean
    timestamp?: boolean
    read?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
    attachments?: boolean | Message$attachmentsArgs<ExtArgs>
    _count?: boolean | MessageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    senderId?: boolean
    content?: boolean
    timestamp?: boolean
    read?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectScalar = {
    id?: boolean
    conversationId?: boolean
    senderId?: boolean
    content?: boolean
    timestamp?: boolean
    read?: boolean
  }

  export type MessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
    attachments?: boolean | Message$attachmentsArgs<ExtArgs>
    _count?: boolean | MessageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Message"
    objects: {
      conversation: Prisma.$ConversationPayload<ExtArgs>
      sender: Prisma.$UserPayload<ExtArgs>
      attachments: Prisma.$AttachmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      conversationId: string
      senderId: string
      content: string
      timestamp: Date
      read: boolean
    }, ExtArgs["result"]["message"]>
    composites: {}
  }

  type MessageGetPayload<S extends boolean | null | undefined | MessageDefaultArgs> = $Result.GetResult<Prisma.$MessagePayload, S>

  type MessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MessageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message'], meta: { name: 'Message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageFindUniqueArgs>(args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageFindFirstArgs>(args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageFindManyArgs>(args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
     */
    create<T extends MessageCreateArgs>(args: SelectSubset<T, MessageCreateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Messages.
     * @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageCreateManyArgs>(args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Messages and returns the data saved in the database.
     * @param {MessageCreateManyAndReturnArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
     */
    delete<T extends MessageDeleteArgs>(args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageUpdateArgs>(args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageDeleteManyArgs>(args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageUpdateManyArgs>(args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
     */
    upsert<T extends MessageUpsertArgs>(args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Message model
   */
  readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    conversation<T extends ConversationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConversationDefaultArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    sender<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    attachments<T extends Message$attachmentsArgs<ExtArgs> = {}>(args?: Subset<T, Message$attachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Message model
   */ 
  interface MessageFieldRefs {
    readonly id: FieldRef<"Message", 'String'>
    readonly conversationId: FieldRef<"Message", 'String'>
    readonly senderId: FieldRef<"Message", 'String'>
    readonly content: FieldRef<"Message", 'String'>
    readonly timestamp: FieldRef<"Message", 'DateTime'>
    readonly read: FieldRef<"Message", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findMany
   */
  export type MessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message create
   */
  export type MessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }

  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Message createManyAndReturn
   */
  export type MessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message update
   */
  export type MessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
  }

  /**
   * Message upsert
   */
  export type MessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }

  /**
   * Message delete
   */
  export type MessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
  }

  /**
   * Message.attachments
   */
  export type Message$attachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    where?: AttachmentWhereInput
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    cursor?: AttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttachmentScalarFieldEnum | AttachmentScalarFieldEnum[]
  }

  /**
   * Message without action
   */
  export type MessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
  }


  /**
   * Model Attachment
   */

  export type AggregateAttachment = {
    _count: AttachmentCountAggregateOutputType | null
    _avg: AttachmentAvgAggregateOutputType | null
    _sum: AttachmentSumAggregateOutputType | null
    _min: AttachmentMinAggregateOutputType | null
    _max: AttachmentMaxAggregateOutputType | null
  }

  export type AttachmentAvgAggregateOutputType = {
    fileSize: number | null
  }

  export type AttachmentSumAggregateOutputType = {
    fileSize: number | null
  }

  export type AttachmentMinAggregateOutputType = {
    id: string | null
    messageId: string | null
    userId: string | null
    fileName: string | null
    fileUrl: string | null
    fileType: string | null
    fileSize: number | null
  }

  export type AttachmentMaxAggregateOutputType = {
    id: string | null
    messageId: string | null
    userId: string | null
    fileName: string | null
    fileUrl: string | null
    fileType: string | null
    fileSize: number | null
  }

  export type AttachmentCountAggregateOutputType = {
    id: number
    messageId: number
    userId: number
    fileName: number
    fileUrl: number
    fileType: number
    fileSize: number
    _all: number
  }


  export type AttachmentAvgAggregateInputType = {
    fileSize?: true
  }

  export type AttachmentSumAggregateInputType = {
    fileSize?: true
  }

  export type AttachmentMinAggregateInputType = {
    id?: true
    messageId?: true
    userId?: true
    fileName?: true
    fileUrl?: true
    fileType?: true
    fileSize?: true
  }

  export type AttachmentMaxAggregateInputType = {
    id?: true
    messageId?: true
    userId?: true
    fileName?: true
    fileUrl?: true
    fileType?: true
    fileSize?: true
  }

  export type AttachmentCountAggregateInputType = {
    id?: true
    messageId?: true
    userId?: true
    fileName?: true
    fileUrl?: true
    fileType?: true
    fileSize?: true
    _all?: true
  }

  export type AttachmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attachment to aggregate.
     */
    where?: AttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attachments to fetch.
     */
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Attachments
    **/
    _count?: true | AttachmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AttachmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AttachmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttachmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttachmentMaxAggregateInputType
  }

  export type GetAttachmentAggregateType<T extends AttachmentAggregateArgs> = {
        [P in keyof T & keyof AggregateAttachment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttachment[P]>
      : GetScalarType<T[P], AggregateAttachment[P]>
  }




  export type AttachmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttachmentWhereInput
    orderBy?: AttachmentOrderByWithAggregationInput | AttachmentOrderByWithAggregationInput[]
    by: AttachmentScalarFieldEnum[] | AttachmentScalarFieldEnum
    having?: AttachmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttachmentCountAggregateInputType | true
    _avg?: AttachmentAvgAggregateInputType
    _sum?: AttachmentSumAggregateInputType
    _min?: AttachmentMinAggregateInputType
    _max?: AttachmentMaxAggregateInputType
  }

  export type AttachmentGroupByOutputType = {
    id: string
    messageId: string
    userId: string | null
    fileName: string
    fileUrl: string
    fileType: string
    fileSize: number
    _count: AttachmentCountAggregateOutputType | null
    _avg: AttachmentAvgAggregateOutputType | null
    _sum: AttachmentSumAggregateOutputType | null
    _min: AttachmentMinAggregateOutputType | null
    _max: AttachmentMaxAggregateOutputType | null
  }

  type GetAttachmentGroupByPayload<T extends AttachmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttachmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttachmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttachmentGroupByOutputType[P]>
            : GetScalarType<T[P], AttachmentGroupByOutputType[P]>
        }
      >
    >


  export type AttachmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    messageId?: boolean
    userId?: boolean
    fileName?: boolean
    fileUrl?: boolean
    fileType?: boolean
    fileSize?: boolean
    message?: boolean | MessageDefaultArgs<ExtArgs>
    user?: boolean | Attachment$userArgs<ExtArgs>
  }, ExtArgs["result"]["attachment"]>

  export type AttachmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    messageId?: boolean
    userId?: boolean
    fileName?: boolean
    fileUrl?: boolean
    fileType?: boolean
    fileSize?: boolean
    message?: boolean | MessageDefaultArgs<ExtArgs>
    user?: boolean | Attachment$userArgs<ExtArgs>
  }, ExtArgs["result"]["attachment"]>

  export type AttachmentSelectScalar = {
    id?: boolean
    messageId?: boolean
    userId?: boolean
    fileName?: boolean
    fileUrl?: boolean
    fileType?: boolean
    fileSize?: boolean
  }

  export type AttachmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | MessageDefaultArgs<ExtArgs>
    user?: boolean | Attachment$userArgs<ExtArgs>
  }
  export type AttachmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | MessageDefaultArgs<ExtArgs>
    user?: boolean | Attachment$userArgs<ExtArgs>
  }

  export type $AttachmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Attachment"
    objects: {
      message: Prisma.$MessagePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      messageId: string
      userId: string | null
      fileName: string
      fileUrl: string
      fileType: string
      fileSize: number
    }, ExtArgs["result"]["attachment"]>
    composites: {}
  }

  type AttachmentGetPayload<S extends boolean | null | undefined | AttachmentDefaultArgs> = $Result.GetResult<Prisma.$AttachmentPayload, S>

  type AttachmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AttachmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AttachmentCountAggregateInputType | true
    }

  export interface AttachmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Attachment'], meta: { name: 'Attachment' } }
    /**
     * Find zero or one Attachment that matches the filter.
     * @param {AttachmentFindUniqueArgs} args - Arguments to find a Attachment
     * @example
     * // Get one Attachment
     * const attachment = await prisma.attachment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AttachmentFindUniqueArgs>(args: SelectSubset<T, AttachmentFindUniqueArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Attachment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AttachmentFindUniqueOrThrowArgs} args - Arguments to find a Attachment
     * @example
     * // Get one Attachment
     * const attachment = await prisma.attachment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AttachmentFindUniqueOrThrowArgs>(args: SelectSubset<T, AttachmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Attachment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentFindFirstArgs} args - Arguments to find a Attachment
     * @example
     * // Get one Attachment
     * const attachment = await prisma.attachment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AttachmentFindFirstArgs>(args?: SelectSubset<T, AttachmentFindFirstArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Attachment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentFindFirstOrThrowArgs} args - Arguments to find a Attachment
     * @example
     * // Get one Attachment
     * const attachment = await prisma.attachment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AttachmentFindFirstOrThrowArgs>(args?: SelectSubset<T, AttachmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Attachments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Attachments
     * const attachments = await prisma.attachment.findMany()
     * 
     * // Get first 10 Attachments
     * const attachments = await prisma.attachment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attachmentWithIdOnly = await prisma.attachment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AttachmentFindManyArgs>(args?: SelectSubset<T, AttachmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Attachment.
     * @param {AttachmentCreateArgs} args - Arguments to create a Attachment.
     * @example
     * // Create one Attachment
     * const Attachment = await prisma.attachment.create({
     *   data: {
     *     // ... data to create a Attachment
     *   }
     * })
     * 
     */
    create<T extends AttachmentCreateArgs>(args: SelectSubset<T, AttachmentCreateArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Attachments.
     * @param {AttachmentCreateManyArgs} args - Arguments to create many Attachments.
     * @example
     * // Create many Attachments
     * const attachment = await prisma.attachment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AttachmentCreateManyArgs>(args?: SelectSubset<T, AttachmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Attachments and returns the data saved in the database.
     * @param {AttachmentCreateManyAndReturnArgs} args - Arguments to create many Attachments.
     * @example
     * // Create many Attachments
     * const attachment = await prisma.attachment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Attachments and only return the `id`
     * const attachmentWithIdOnly = await prisma.attachment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AttachmentCreateManyAndReturnArgs>(args?: SelectSubset<T, AttachmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Attachment.
     * @param {AttachmentDeleteArgs} args - Arguments to delete one Attachment.
     * @example
     * // Delete one Attachment
     * const Attachment = await prisma.attachment.delete({
     *   where: {
     *     // ... filter to delete one Attachment
     *   }
     * })
     * 
     */
    delete<T extends AttachmentDeleteArgs>(args: SelectSubset<T, AttachmentDeleteArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Attachment.
     * @param {AttachmentUpdateArgs} args - Arguments to update one Attachment.
     * @example
     * // Update one Attachment
     * const attachment = await prisma.attachment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AttachmentUpdateArgs>(args: SelectSubset<T, AttachmentUpdateArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Attachments.
     * @param {AttachmentDeleteManyArgs} args - Arguments to filter Attachments to delete.
     * @example
     * // Delete a few Attachments
     * const { count } = await prisma.attachment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AttachmentDeleteManyArgs>(args?: SelectSubset<T, AttachmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Attachments
     * const attachment = await prisma.attachment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AttachmentUpdateManyArgs>(args: SelectSubset<T, AttachmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Attachment.
     * @param {AttachmentUpsertArgs} args - Arguments to update or create a Attachment.
     * @example
     * // Update or create a Attachment
     * const attachment = await prisma.attachment.upsert({
     *   create: {
     *     // ... data to create a Attachment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Attachment we want to update
     *   }
     * })
     */
    upsert<T extends AttachmentUpsertArgs>(args: SelectSubset<T, AttachmentUpsertArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Attachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentCountArgs} args - Arguments to filter Attachments to count.
     * @example
     * // Count the number of Attachments
     * const count = await prisma.attachment.count({
     *   where: {
     *     // ... the filter for the Attachments we want to count
     *   }
     * })
    **/
    count<T extends AttachmentCountArgs>(
      args?: Subset<T, AttachmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttachmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Attachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttachmentAggregateArgs>(args: Subset<T, AttachmentAggregateArgs>): Prisma.PrismaPromise<GetAttachmentAggregateType<T>>

    /**
     * Group by Attachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttachmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttachmentGroupByArgs['orderBy'] }
        : { orderBy?: AttachmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttachmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttachmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Attachment model
   */
  readonly fields: AttachmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Attachment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AttachmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    message<T extends MessageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MessageDefaultArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends Attachment$userArgs<ExtArgs> = {}>(args?: Subset<T, Attachment$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Attachment model
   */ 
  interface AttachmentFieldRefs {
    readonly id: FieldRef<"Attachment", 'String'>
    readonly messageId: FieldRef<"Attachment", 'String'>
    readonly userId: FieldRef<"Attachment", 'String'>
    readonly fileName: FieldRef<"Attachment", 'String'>
    readonly fileUrl: FieldRef<"Attachment", 'String'>
    readonly fileType: FieldRef<"Attachment", 'String'>
    readonly fileSize: FieldRef<"Attachment", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Attachment findUnique
   */
  export type AttachmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter, which Attachment to fetch.
     */
    where: AttachmentWhereUniqueInput
  }

  /**
   * Attachment findUniqueOrThrow
   */
  export type AttachmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter, which Attachment to fetch.
     */
    where: AttachmentWhereUniqueInput
  }

  /**
   * Attachment findFirst
   */
  export type AttachmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter, which Attachment to fetch.
     */
    where?: AttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attachments to fetch.
     */
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attachments.
     */
    cursor?: AttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attachments.
     */
    distinct?: AttachmentScalarFieldEnum | AttachmentScalarFieldEnum[]
  }

  /**
   * Attachment findFirstOrThrow
   */
  export type AttachmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter, which Attachment to fetch.
     */
    where?: AttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attachments to fetch.
     */
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attachments.
     */
    cursor?: AttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attachments.
     */
    distinct?: AttachmentScalarFieldEnum | AttachmentScalarFieldEnum[]
  }

  /**
   * Attachment findMany
   */
  export type AttachmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter, which Attachments to fetch.
     */
    where?: AttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attachments to fetch.
     */
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Attachments.
     */
    cursor?: AttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attachments.
     */
    skip?: number
    distinct?: AttachmentScalarFieldEnum | AttachmentScalarFieldEnum[]
  }

  /**
   * Attachment create
   */
  export type AttachmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Attachment.
     */
    data: XOR<AttachmentCreateInput, AttachmentUncheckedCreateInput>
  }

  /**
   * Attachment createMany
   */
  export type AttachmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Attachments.
     */
    data: AttachmentCreateManyInput | AttachmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Attachment createManyAndReturn
   */
  export type AttachmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Attachments.
     */
    data: AttachmentCreateManyInput | AttachmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Attachment update
   */
  export type AttachmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Attachment.
     */
    data: XOR<AttachmentUpdateInput, AttachmentUncheckedUpdateInput>
    /**
     * Choose, which Attachment to update.
     */
    where: AttachmentWhereUniqueInput
  }

  /**
   * Attachment updateMany
   */
  export type AttachmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Attachments.
     */
    data: XOR<AttachmentUpdateManyMutationInput, AttachmentUncheckedUpdateManyInput>
    /**
     * Filter which Attachments to update
     */
    where?: AttachmentWhereInput
  }

  /**
   * Attachment upsert
   */
  export type AttachmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Attachment to update in case it exists.
     */
    where: AttachmentWhereUniqueInput
    /**
     * In case the Attachment found by the `where` argument doesn't exist, create a new Attachment with this data.
     */
    create: XOR<AttachmentCreateInput, AttachmentUncheckedCreateInput>
    /**
     * In case the Attachment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttachmentUpdateInput, AttachmentUncheckedUpdateInput>
  }

  /**
   * Attachment delete
   */
  export type AttachmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter which Attachment to delete.
     */
    where: AttachmentWhereUniqueInput
  }

  /**
   * Attachment deleteMany
   */
  export type AttachmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attachments to delete
     */
    where?: AttachmentWhereInput
  }

  /**
   * Attachment.user
   */
  export type Attachment$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Attachment without action
   */
  export type AttachmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    message: string | null
    read: boolean | null
    type: $Enums.NotificationType | null
    link: string | null
    createdAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    message: string | null
    read: boolean | null
    type: $Enums.NotificationType | null
    link: string | null
    createdAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    message: number
    read: number
    type: number
    link: number
    createdAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    message?: true
    read?: true
    type?: true
    link?: true
    createdAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    message?: true
    read?: true
    type?: true
    link?: true
    createdAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    message?: true
    read?: true
    type?: true
    link?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    userId: string
    title: string
    message: string
    read: boolean
    type: $Enums.NotificationType
    link: string | null
    createdAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    read?: boolean
    type?: boolean
    link?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    read?: boolean
    type?: boolean
    link?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    read?: boolean
    type?: boolean
    link?: boolean
    createdAt?: boolean
  }

  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      title: string
      message: string
      read: boolean
      type: $Enums.NotificationType
      link: string | null
      createdAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */ 
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly read: FieldRef<"Notification", 'Boolean'>
    readonly type: FieldRef<"Notification", 'NotificationType'>
    readonly link: FieldRef<"Notification", 'String'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model SubscriptionPlan
   */

  export type AggregateSubscriptionPlan = {
    _count: SubscriptionPlanCountAggregateOutputType | null
    _avg: SubscriptionPlanAvgAggregateOutputType | null
    _sum: SubscriptionPlanSumAggregateOutputType | null
    _min: SubscriptionPlanMinAggregateOutputType | null
    _max: SubscriptionPlanMaxAggregateOutputType | null
  }

  export type SubscriptionPlanAvgAggregateOutputType = {
    price: Decimal | null
  }

  export type SubscriptionPlanSumAggregateOutputType = {
    price: Decimal | null
  }

  export type SubscriptionPlanMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    price: Decimal | null
    period: $Enums.SubscriptionPeriod | null
    featuredBenefit: string | null
    isPopular: boolean | null
  }

  export type SubscriptionPlanMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    price: Decimal | null
    period: $Enums.SubscriptionPeriod | null
    featuredBenefit: string | null
    isPopular: boolean | null
  }

  export type SubscriptionPlanCountAggregateOutputType = {
    id: number
    name: number
    description: number
    price: number
    period: number
    featuredBenefit: number
    benefits: number
    isPopular: number
    _all: number
  }


  export type SubscriptionPlanAvgAggregateInputType = {
    price?: true
  }

  export type SubscriptionPlanSumAggregateInputType = {
    price?: true
  }

  export type SubscriptionPlanMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    price?: true
    period?: true
    featuredBenefit?: true
    isPopular?: true
  }

  export type SubscriptionPlanMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    price?: true
    period?: true
    featuredBenefit?: true
    isPopular?: true
  }

  export type SubscriptionPlanCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    price?: true
    period?: true
    featuredBenefit?: true
    benefits?: true
    isPopular?: true
    _all?: true
  }

  export type SubscriptionPlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubscriptionPlan to aggregate.
     */
    where?: SubscriptionPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionPlans to fetch.
     */
    orderBy?: SubscriptionPlanOrderByWithRelationInput | SubscriptionPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriptionPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubscriptionPlans
    **/
    _count?: true | SubscriptionPlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubscriptionPlanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubscriptionPlanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionPlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionPlanMaxAggregateInputType
  }

  export type GetSubscriptionPlanAggregateType<T extends SubscriptionPlanAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscriptionPlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscriptionPlan[P]>
      : GetScalarType<T[P], AggregateSubscriptionPlan[P]>
  }




  export type SubscriptionPlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionPlanWhereInput
    orderBy?: SubscriptionPlanOrderByWithAggregationInput | SubscriptionPlanOrderByWithAggregationInput[]
    by: SubscriptionPlanScalarFieldEnum[] | SubscriptionPlanScalarFieldEnum
    having?: SubscriptionPlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionPlanCountAggregateInputType | true
    _avg?: SubscriptionPlanAvgAggregateInputType
    _sum?: SubscriptionPlanSumAggregateInputType
    _min?: SubscriptionPlanMinAggregateInputType
    _max?: SubscriptionPlanMaxAggregateInputType
  }

  export type SubscriptionPlanGroupByOutputType = {
    id: string
    name: string
    description: string | null
    price: Decimal
    period: $Enums.SubscriptionPeriod
    featuredBenefit: string | null
    benefits: string[]
    isPopular: boolean
    _count: SubscriptionPlanCountAggregateOutputType | null
    _avg: SubscriptionPlanAvgAggregateOutputType | null
    _sum: SubscriptionPlanSumAggregateOutputType | null
    _min: SubscriptionPlanMinAggregateOutputType | null
    _max: SubscriptionPlanMaxAggregateOutputType | null
  }

  type GetSubscriptionPlanGroupByPayload<T extends SubscriptionPlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionPlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionPlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionPlanGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionPlanGroupByOutputType[P]>
        }
      >
    >


  export type SubscriptionPlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    period?: boolean
    featuredBenefit?: boolean
    benefits?: boolean
    isPopular?: boolean
    users?: boolean | SubscriptionPlan$usersArgs<ExtArgs>
    _count?: boolean | SubscriptionPlanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscriptionPlan"]>

  export type SubscriptionPlanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    period?: boolean
    featuredBenefit?: boolean
    benefits?: boolean
    isPopular?: boolean
  }, ExtArgs["result"]["subscriptionPlan"]>

  export type SubscriptionPlanSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    period?: boolean
    featuredBenefit?: boolean
    benefits?: boolean
    isPopular?: boolean
  }

  export type SubscriptionPlanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | SubscriptionPlan$usersArgs<ExtArgs>
    _count?: boolean | SubscriptionPlanCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SubscriptionPlanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SubscriptionPlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SubscriptionPlan"
    objects: {
      users: Prisma.$UserSubscriptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      price: Prisma.Decimal
      period: $Enums.SubscriptionPeriod
      featuredBenefit: string | null
      benefits: string[]
      isPopular: boolean
    }, ExtArgs["result"]["subscriptionPlan"]>
    composites: {}
  }

  type SubscriptionPlanGetPayload<S extends boolean | null | undefined | SubscriptionPlanDefaultArgs> = $Result.GetResult<Prisma.$SubscriptionPlanPayload, S>

  type SubscriptionPlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SubscriptionPlanFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SubscriptionPlanCountAggregateInputType | true
    }

  export interface SubscriptionPlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SubscriptionPlan'], meta: { name: 'SubscriptionPlan' } }
    /**
     * Find zero or one SubscriptionPlan that matches the filter.
     * @param {SubscriptionPlanFindUniqueArgs} args - Arguments to find a SubscriptionPlan
     * @example
     * // Get one SubscriptionPlan
     * const subscriptionPlan = await prisma.subscriptionPlan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubscriptionPlanFindUniqueArgs>(args: SelectSubset<T, SubscriptionPlanFindUniqueArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SubscriptionPlan that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SubscriptionPlanFindUniqueOrThrowArgs} args - Arguments to find a SubscriptionPlan
     * @example
     * // Get one SubscriptionPlan
     * const subscriptionPlan = await prisma.subscriptionPlan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubscriptionPlanFindUniqueOrThrowArgs>(args: SelectSubset<T, SubscriptionPlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SubscriptionPlan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlanFindFirstArgs} args - Arguments to find a SubscriptionPlan
     * @example
     * // Get one SubscriptionPlan
     * const subscriptionPlan = await prisma.subscriptionPlan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubscriptionPlanFindFirstArgs>(args?: SelectSubset<T, SubscriptionPlanFindFirstArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SubscriptionPlan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlanFindFirstOrThrowArgs} args - Arguments to find a SubscriptionPlan
     * @example
     * // Get one SubscriptionPlan
     * const subscriptionPlan = await prisma.subscriptionPlan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubscriptionPlanFindFirstOrThrowArgs>(args?: SelectSubset<T, SubscriptionPlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SubscriptionPlans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubscriptionPlans
     * const subscriptionPlans = await prisma.subscriptionPlan.findMany()
     * 
     * // Get first 10 SubscriptionPlans
     * const subscriptionPlans = await prisma.subscriptionPlan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionPlanWithIdOnly = await prisma.subscriptionPlan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubscriptionPlanFindManyArgs>(args?: SelectSubset<T, SubscriptionPlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SubscriptionPlan.
     * @param {SubscriptionPlanCreateArgs} args - Arguments to create a SubscriptionPlan.
     * @example
     * // Create one SubscriptionPlan
     * const SubscriptionPlan = await prisma.subscriptionPlan.create({
     *   data: {
     *     // ... data to create a SubscriptionPlan
     *   }
     * })
     * 
     */
    create<T extends SubscriptionPlanCreateArgs>(args: SelectSubset<T, SubscriptionPlanCreateArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SubscriptionPlans.
     * @param {SubscriptionPlanCreateManyArgs} args - Arguments to create many SubscriptionPlans.
     * @example
     * // Create many SubscriptionPlans
     * const subscriptionPlan = await prisma.subscriptionPlan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubscriptionPlanCreateManyArgs>(args?: SelectSubset<T, SubscriptionPlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SubscriptionPlans and returns the data saved in the database.
     * @param {SubscriptionPlanCreateManyAndReturnArgs} args - Arguments to create many SubscriptionPlans.
     * @example
     * // Create many SubscriptionPlans
     * const subscriptionPlan = await prisma.subscriptionPlan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SubscriptionPlans and only return the `id`
     * const subscriptionPlanWithIdOnly = await prisma.subscriptionPlan.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubscriptionPlanCreateManyAndReturnArgs>(args?: SelectSubset<T, SubscriptionPlanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SubscriptionPlan.
     * @param {SubscriptionPlanDeleteArgs} args - Arguments to delete one SubscriptionPlan.
     * @example
     * // Delete one SubscriptionPlan
     * const SubscriptionPlan = await prisma.subscriptionPlan.delete({
     *   where: {
     *     // ... filter to delete one SubscriptionPlan
     *   }
     * })
     * 
     */
    delete<T extends SubscriptionPlanDeleteArgs>(args: SelectSubset<T, SubscriptionPlanDeleteArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SubscriptionPlan.
     * @param {SubscriptionPlanUpdateArgs} args - Arguments to update one SubscriptionPlan.
     * @example
     * // Update one SubscriptionPlan
     * const subscriptionPlan = await prisma.subscriptionPlan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubscriptionPlanUpdateArgs>(args: SelectSubset<T, SubscriptionPlanUpdateArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SubscriptionPlans.
     * @param {SubscriptionPlanDeleteManyArgs} args - Arguments to filter SubscriptionPlans to delete.
     * @example
     * // Delete a few SubscriptionPlans
     * const { count } = await prisma.subscriptionPlan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubscriptionPlanDeleteManyArgs>(args?: SelectSubset<T, SubscriptionPlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubscriptionPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubscriptionPlans
     * const subscriptionPlan = await prisma.subscriptionPlan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubscriptionPlanUpdateManyArgs>(args: SelectSubset<T, SubscriptionPlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SubscriptionPlan.
     * @param {SubscriptionPlanUpsertArgs} args - Arguments to update or create a SubscriptionPlan.
     * @example
     * // Update or create a SubscriptionPlan
     * const subscriptionPlan = await prisma.subscriptionPlan.upsert({
     *   create: {
     *     // ... data to create a SubscriptionPlan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubscriptionPlan we want to update
     *   }
     * })
     */
    upsert<T extends SubscriptionPlanUpsertArgs>(args: SelectSubset<T, SubscriptionPlanUpsertArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SubscriptionPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlanCountArgs} args - Arguments to filter SubscriptionPlans to count.
     * @example
     * // Count the number of SubscriptionPlans
     * const count = await prisma.subscriptionPlan.count({
     *   where: {
     *     // ... the filter for the SubscriptionPlans we want to count
     *   }
     * })
    **/
    count<T extends SubscriptionPlanCountArgs>(
      args?: Subset<T, SubscriptionPlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionPlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubscriptionPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionPlanAggregateArgs>(args: Subset<T, SubscriptionPlanAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionPlanAggregateType<T>>

    /**
     * Group by SubscriptionPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionPlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionPlanGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionPlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionPlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SubscriptionPlan model
   */
  readonly fields: SubscriptionPlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SubscriptionPlan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscriptionPlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends SubscriptionPlan$usersArgs<ExtArgs> = {}>(args?: Subset<T, SubscriptionPlan$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SubscriptionPlan model
   */ 
  interface SubscriptionPlanFieldRefs {
    readonly id: FieldRef<"SubscriptionPlan", 'String'>
    readonly name: FieldRef<"SubscriptionPlan", 'String'>
    readonly description: FieldRef<"SubscriptionPlan", 'String'>
    readonly price: FieldRef<"SubscriptionPlan", 'Decimal'>
    readonly period: FieldRef<"SubscriptionPlan", 'SubscriptionPeriod'>
    readonly featuredBenefit: FieldRef<"SubscriptionPlan", 'String'>
    readonly benefits: FieldRef<"SubscriptionPlan", 'String[]'>
    readonly isPopular: FieldRef<"SubscriptionPlan", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * SubscriptionPlan findUnique
   */
  export type SubscriptionPlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionPlan to fetch.
     */
    where: SubscriptionPlanWhereUniqueInput
  }

  /**
   * SubscriptionPlan findUniqueOrThrow
   */
  export type SubscriptionPlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionPlan to fetch.
     */
    where: SubscriptionPlanWhereUniqueInput
  }

  /**
   * SubscriptionPlan findFirst
   */
  export type SubscriptionPlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionPlan to fetch.
     */
    where?: SubscriptionPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionPlans to fetch.
     */
    orderBy?: SubscriptionPlanOrderByWithRelationInput | SubscriptionPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubscriptionPlans.
     */
    cursor?: SubscriptionPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubscriptionPlans.
     */
    distinct?: SubscriptionPlanScalarFieldEnum | SubscriptionPlanScalarFieldEnum[]
  }

  /**
   * SubscriptionPlan findFirstOrThrow
   */
  export type SubscriptionPlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionPlan to fetch.
     */
    where?: SubscriptionPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionPlans to fetch.
     */
    orderBy?: SubscriptionPlanOrderByWithRelationInput | SubscriptionPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubscriptionPlans.
     */
    cursor?: SubscriptionPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubscriptionPlans.
     */
    distinct?: SubscriptionPlanScalarFieldEnum | SubscriptionPlanScalarFieldEnum[]
  }

  /**
   * SubscriptionPlan findMany
   */
  export type SubscriptionPlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionPlans to fetch.
     */
    where?: SubscriptionPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionPlans to fetch.
     */
    orderBy?: SubscriptionPlanOrderByWithRelationInput | SubscriptionPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubscriptionPlans.
     */
    cursor?: SubscriptionPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionPlans.
     */
    skip?: number
    distinct?: SubscriptionPlanScalarFieldEnum | SubscriptionPlanScalarFieldEnum[]
  }

  /**
   * SubscriptionPlan create
   */
  export type SubscriptionPlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * The data needed to create a SubscriptionPlan.
     */
    data: XOR<SubscriptionPlanCreateInput, SubscriptionPlanUncheckedCreateInput>
  }

  /**
   * SubscriptionPlan createMany
   */
  export type SubscriptionPlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SubscriptionPlans.
     */
    data: SubscriptionPlanCreateManyInput | SubscriptionPlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubscriptionPlan createManyAndReturn
   */
  export type SubscriptionPlanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SubscriptionPlans.
     */
    data: SubscriptionPlanCreateManyInput | SubscriptionPlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubscriptionPlan update
   */
  export type SubscriptionPlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * The data needed to update a SubscriptionPlan.
     */
    data: XOR<SubscriptionPlanUpdateInput, SubscriptionPlanUncheckedUpdateInput>
    /**
     * Choose, which SubscriptionPlan to update.
     */
    where: SubscriptionPlanWhereUniqueInput
  }

  /**
   * SubscriptionPlan updateMany
   */
  export type SubscriptionPlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SubscriptionPlans.
     */
    data: XOR<SubscriptionPlanUpdateManyMutationInput, SubscriptionPlanUncheckedUpdateManyInput>
    /**
     * Filter which SubscriptionPlans to update
     */
    where?: SubscriptionPlanWhereInput
  }

  /**
   * SubscriptionPlan upsert
   */
  export type SubscriptionPlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * The filter to search for the SubscriptionPlan to update in case it exists.
     */
    where: SubscriptionPlanWhereUniqueInput
    /**
     * In case the SubscriptionPlan found by the `where` argument doesn't exist, create a new SubscriptionPlan with this data.
     */
    create: XOR<SubscriptionPlanCreateInput, SubscriptionPlanUncheckedCreateInput>
    /**
     * In case the SubscriptionPlan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriptionPlanUpdateInput, SubscriptionPlanUncheckedUpdateInput>
  }

  /**
   * SubscriptionPlan delete
   */
  export type SubscriptionPlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * Filter which SubscriptionPlan to delete.
     */
    where: SubscriptionPlanWhereUniqueInput
  }

  /**
   * SubscriptionPlan deleteMany
   */
  export type SubscriptionPlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubscriptionPlans to delete
     */
    where?: SubscriptionPlanWhereInput
  }

  /**
   * SubscriptionPlan.users
   */
  export type SubscriptionPlan$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionInclude<ExtArgs> | null
    where?: UserSubscriptionWhereInput
    orderBy?: UserSubscriptionOrderByWithRelationInput | UserSubscriptionOrderByWithRelationInput[]
    cursor?: UserSubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserSubscriptionScalarFieldEnum | UserSubscriptionScalarFieldEnum[]
  }

  /**
   * SubscriptionPlan without action
   */
  export type SubscriptionPlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
  }


  /**
   * Model CourseBundle
   */

  export type AggregateCourseBundle = {
    _count: CourseBundleCountAggregateOutputType | null
    _avg: CourseBundleAvgAggregateOutputType | null
    _sum: CourseBundleSumAggregateOutputType | null
    _min: CourseBundleMinAggregateOutputType | null
    _max: CourseBundleMaxAggregateOutputType | null
  }

  export type CourseBundleAvgAggregateOutputType = {
    price: Decimal | null
    originalPrice: Decimal | null
    discount: number | null
  }

  export type CourseBundleSumAggregateOutputType = {
    price: Decimal | null
    originalPrice: Decimal | null
    discount: number | null
  }

  export type CourseBundleMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    price: Decimal | null
    originalPrice: Decimal | null
    discount: number | null
    featuredBenefit: string | null
    imageUrl: string | null
  }

  export type CourseBundleMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    price: Decimal | null
    originalPrice: Decimal | null
    discount: number | null
    featuredBenefit: string | null
    imageUrl: string | null
  }

  export type CourseBundleCountAggregateOutputType = {
    id: number
    name: number
    description: number
    price: number
    originalPrice: number
    discount: number
    featuredBenefit: number
    benefits: number
    imageUrl: number
    _all: number
  }


  export type CourseBundleAvgAggregateInputType = {
    price?: true
    originalPrice?: true
    discount?: true
  }

  export type CourseBundleSumAggregateInputType = {
    price?: true
    originalPrice?: true
    discount?: true
  }

  export type CourseBundleMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    price?: true
    originalPrice?: true
    discount?: true
    featuredBenefit?: true
    imageUrl?: true
  }

  export type CourseBundleMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    price?: true
    originalPrice?: true
    discount?: true
    featuredBenefit?: true
    imageUrl?: true
  }

  export type CourseBundleCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    price?: true
    originalPrice?: true
    discount?: true
    featuredBenefit?: true
    benefits?: true
    imageUrl?: true
    _all?: true
  }

  export type CourseBundleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseBundle to aggregate.
     */
    where?: CourseBundleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseBundles to fetch.
     */
    orderBy?: CourseBundleOrderByWithRelationInput | CourseBundleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourseBundleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseBundles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseBundles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CourseBundles
    **/
    _count?: true | CourseBundleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CourseBundleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CourseBundleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseBundleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseBundleMaxAggregateInputType
  }

  export type GetCourseBundleAggregateType<T extends CourseBundleAggregateArgs> = {
        [P in keyof T & keyof AggregateCourseBundle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourseBundle[P]>
      : GetScalarType<T[P], AggregateCourseBundle[P]>
  }




  export type CourseBundleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseBundleWhereInput
    orderBy?: CourseBundleOrderByWithAggregationInput | CourseBundleOrderByWithAggregationInput[]
    by: CourseBundleScalarFieldEnum[] | CourseBundleScalarFieldEnum
    having?: CourseBundleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseBundleCountAggregateInputType | true
    _avg?: CourseBundleAvgAggregateInputType
    _sum?: CourseBundleSumAggregateInputType
    _min?: CourseBundleMinAggregateInputType
    _max?: CourseBundleMaxAggregateInputType
  }

  export type CourseBundleGroupByOutputType = {
    id: string
    name: string
    description: string | null
    price: Decimal
    originalPrice: Decimal
    discount: number
    featuredBenefit: string | null
    benefits: string[]
    imageUrl: string | null
    _count: CourseBundleCountAggregateOutputType | null
    _avg: CourseBundleAvgAggregateOutputType | null
    _sum: CourseBundleSumAggregateOutputType | null
    _min: CourseBundleMinAggregateOutputType | null
    _max: CourseBundleMaxAggregateOutputType | null
  }

  type GetCourseBundleGroupByPayload<T extends CourseBundleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourseBundleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseBundleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseBundleGroupByOutputType[P]>
            : GetScalarType<T[P], CourseBundleGroupByOutputType[P]>
        }
      >
    >


  export type CourseBundleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    originalPrice?: boolean
    discount?: boolean
    featuredBenefit?: boolean
    benefits?: boolean
    imageUrl?: boolean
    courses?: boolean | CourseBundle$coursesArgs<ExtArgs>
    owners?: boolean | CourseBundle$ownersArgs<ExtArgs>
    _count?: boolean | CourseBundleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseBundle"]>

  export type CourseBundleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    originalPrice?: boolean
    discount?: boolean
    featuredBenefit?: boolean
    benefits?: boolean
    imageUrl?: boolean
  }, ExtArgs["result"]["courseBundle"]>

  export type CourseBundleSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    originalPrice?: boolean
    discount?: boolean
    featuredBenefit?: boolean
    benefits?: boolean
    imageUrl?: boolean
  }

  export type CourseBundleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courses?: boolean | CourseBundle$coursesArgs<ExtArgs>
    owners?: boolean | CourseBundle$ownersArgs<ExtArgs>
    _count?: boolean | CourseBundleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CourseBundleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CourseBundlePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CourseBundle"
    objects: {
      courses: Prisma.$BundleCoursePayload<ExtArgs>[]
      owners: Prisma.$UserBundlePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      price: Prisma.Decimal
      originalPrice: Prisma.Decimal
      discount: number
      featuredBenefit: string | null
      benefits: string[]
      imageUrl: string | null
    }, ExtArgs["result"]["courseBundle"]>
    composites: {}
  }

  type CourseBundleGetPayload<S extends boolean | null | undefined | CourseBundleDefaultArgs> = $Result.GetResult<Prisma.$CourseBundlePayload, S>

  type CourseBundleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CourseBundleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CourseBundleCountAggregateInputType | true
    }

  export interface CourseBundleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CourseBundle'], meta: { name: 'CourseBundle' } }
    /**
     * Find zero or one CourseBundle that matches the filter.
     * @param {CourseBundleFindUniqueArgs} args - Arguments to find a CourseBundle
     * @example
     * // Get one CourseBundle
     * const courseBundle = await prisma.courseBundle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourseBundleFindUniqueArgs>(args: SelectSubset<T, CourseBundleFindUniqueArgs<ExtArgs>>): Prisma__CourseBundleClient<$Result.GetResult<Prisma.$CourseBundlePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CourseBundle that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CourseBundleFindUniqueOrThrowArgs} args - Arguments to find a CourseBundle
     * @example
     * // Get one CourseBundle
     * const courseBundle = await prisma.courseBundle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourseBundleFindUniqueOrThrowArgs>(args: SelectSubset<T, CourseBundleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourseBundleClient<$Result.GetResult<Prisma.$CourseBundlePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CourseBundle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseBundleFindFirstArgs} args - Arguments to find a CourseBundle
     * @example
     * // Get one CourseBundle
     * const courseBundle = await prisma.courseBundle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourseBundleFindFirstArgs>(args?: SelectSubset<T, CourseBundleFindFirstArgs<ExtArgs>>): Prisma__CourseBundleClient<$Result.GetResult<Prisma.$CourseBundlePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CourseBundle that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseBundleFindFirstOrThrowArgs} args - Arguments to find a CourseBundle
     * @example
     * // Get one CourseBundle
     * const courseBundle = await prisma.courseBundle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourseBundleFindFirstOrThrowArgs>(args?: SelectSubset<T, CourseBundleFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourseBundleClient<$Result.GetResult<Prisma.$CourseBundlePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CourseBundles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseBundleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CourseBundles
     * const courseBundles = await prisma.courseBundle.findMany()
     * 
     * // Get first 10 CourseBundles
     * const courseBundles = await prisma.courseBundle.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const courseBundleWithIdOnly = await prisma.courseBundle.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CourseBundleFindManyArgs>(args?: SelectSubset<T, CourseBundleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseBundlePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CourseBundle.
     * @param {CourseBundleCreateArgs} args - Arguments to create a CourseBundle.
     * @example
     * // Create one CourseBundle
     * const CourseBundle = await prisma.courseBundle.create({
     *   data: {
     *     // ... data to create a CourseBundle
     *   }
     * })
     * 
     */
    create<T extends CourseBundleCreateArgs>(args: SelectSubset<T, CourseBundleCreateArgs<ExtArgs>>): Prisma__CourseBundleClient<$Result.GetResult<Prisma.$CourseBundlePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CourseBundles.
     * @param {CourseBundleCreateManyArgs} args - Arguments to create many CourseBundles.
     * @example
     * // Create many CourseBundles
     * const courseBundle = await prisma.courseBundle.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourseBundleCreateManyArgs>(args?: SelectSubset<T, CourseBundleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CourseBundles and returns the data saved in the database.
     * @param {CourseBundleCreateManyAndReturnArgs} args - Arguments to create many CourseBundles.
     * @example
     * // Create many CourseBundles
     * const courseBundle = await prisma.courseBundle.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CourseBundles and only return the `id`
     * const courseBundleWithIdOnly = await prisma.courseBundle.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CourseBundleCreateManyAndReturnArgs>(args?: SelectSubset<T, CourseBundleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseBundlePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CourseBundle.
     * @param {CourseBundleDeleteArgs} args - Arguments to delete one CourseBundle.
     * @example
     * // Delete one CourseBundle
     * const CourseBundle = await prisma.courseBundle.delete({
     *   where: {
     *     // ... filter to delete one CourseBundle
     *   }
     * })
     * 
     */
    delete<T extends CourseBundleDeleteArgs>(args: SelectSubset<T, CourseBundleDeleteArgs<ExtArgs>>): Prisma__CourseBundleClient<$Result.GetResult<Prisma.$CourseBundlePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CourseBundle.
     * @param {CourseBundleUpdateArgs} args - Arguments to update one CourseBundle.
     * @example
     * // Update one CourseBundle
     * const courseBundle = await prisma.courseBundle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourseBundleUpdateArgs>(args: SelectSubset<T, CourseBundleUpdateArgs<ExtArgs>>): Prisma__CourseBundleClient<$Result.GetResult<Prisma.$CourseBundlePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CourseBundles.
     * @param {CourseBundleDeleteManyArgs} args - Arguments to filter CourseBundles to delete.
     * @example
     * // Delete a few CourseBundles
     * const { count } = await prisma.courseBundle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourseBundleDeleteManyArgs>(args?: SelectSubset<T, CourseBundleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourseBundles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseBundleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CourseBundles
     * const courseBundle = await prisma.courseBundle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourseBundleUpdateManyArgs>(args: SelectSubset<T, CourseBundleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CourseBundle.
     * @param {CourseBundleUpsertArgs} args - Arguments to update or create a CourseBundle.
     * @example
     * // Update or create a CourseBundle
     * const courseBundle = await prisma.courseBundle.upsert({
     *   create: {
     *     // ... data to create a CourseBundle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CourseBundle we want to update
     *   }
     * })
     */
    upsert<T extends CourseBundleUpsertArgs>(args: SelectSubset<T, CourseBundleUpsertArgs<ExtArgs>>): Prisma__CourseBundleClient<$Result.GetResult<Prisma.$CourseBundlePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CourseBundles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseBundleCountArgs} args - Arguments to filter CourseBundles to count.
     * @example
     * // Count the number of CourseBundles
     * const count = await prisma.courseBundle.count({
     *   where: {
     *     // ... the filter for the CourseBundles we want to count
     *   }
     * })
    **/
    count<T extends CourseBundleCountArgs>(
      args?: Subset<T, CourseBundleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseBundleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CourseBundle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseBundleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseBundleAggregateArgs>(args: Subset<T, CourseBundleAggregateArgs>): Prisma.PrismaPromise<GetCourseBundleAggregateType<T>>

    /**
     * Group by CourseBundle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseBundleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseBundleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseBundleGroupByArgs['orderBy'] }
        : { orderBy?: CourseBundleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseBundleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseBundleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CourseBundle model
   */
  readonly fields: CourseBundleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CourseBundle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourseBundleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    courses<T extends CourseBundle$coursesArgs<ExtArgs> = {}>(args?: Subset<T, CourseBundle$coursesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BundleCoursePayload<ExtArgs>, T, "findMany"> | Null>
    owners<T extends CourseBundle$ownersArgs<ExtArgs> = {}>(args?: Subset<T, CourseBundle$ownersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBundlePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CourseBundle model
   */ 
  interface CourseBundleFieldRefs {
    readonly id: FieldRef<"CourseBundle", 'String'>
    readonly name: FieldRef<"CourseBundle", 'String'>
    readonly description: FieldRef<"CourseBundle", 'String'>
    readonly price: FieldRef<"CourseBundle", 'Decimal'>
    readonly originalPrice: FieldRef<"CourseBundle", 'Decimal'>
    readonly discount: FieldRef<"CourseBundle", 'Int'>
    readonly featuredBenefit: FieldRef<"CourseBundle", 'String'>
    readonly benefits: FieldRef<"CourseBundle", 'String[]'>
    readonly imageUrl: FieldRef<"CourseBundle", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CourseBundle findUnique
   */
  export type CourseBundleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseBundle
     */
    select?: CourseBundleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseBundleInclude<ExtArgs> | null
    /**
     * Filter, which CourseBundle to fetch.
     */
    where: CourseBundleWhereUniqueInput
  }

  /**
   * CourseBundle findUniqueOrThrow
   */
  export type CourseBundleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseBundle
     */
    select?: CourseBundleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseBundleInclude<ExtArgs> | null
    /**
     * Filter, which CourseBundle to fetch.
     */
    where: CourseBundleWhereUniqueInput
  }

  /**
   * CourseBundle findFirst
   */
  export type CourseBundleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseBundle
     */
    select?: CourseBundleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseBundleInclude<ExtArgs> | null
    /**
     * Filter, which CourseBundle to fetch.
     */
    where?: CourseBundleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseBundles to fetch.
     */
    orderBy?: CourseBundleOrderByWithRelationInput | CourseBundleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseBundles.
     */
    cursor?: CourseBundleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseBundles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseBundles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseBundles.
     */
    distinct?: CourseBundleScalarFieldEnum | CourseBundleScalarFieldEnum[]
  }

  /**
   * CourseBundle findFirstOrThrow
   */
  export type CourseBundleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseBundle
     */
    select?: CourseBundleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseBundleInclude<ExtArgs> | null
    /**
     * Filter, which CourseBundle to fetch.
     */
    where?: CourseBundleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseBundles to fetch.
     */
    orderBy?: CourseBundleOrderByWithRelationInput | CourseBundleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseBundles.
     */
    cursor?: CourseBundleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseBundles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseBundles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseBundles.
     */
    distinct?: CourseBundleScalarFieldEnum | CourseBundleScalarFieldEnum[]
  }

  /**
   * CourseBundle findMany
   */
  export type CourseBundleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseBundle
     */
    select?: CourseBundleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseBundleInclude<ExtArgs> | null
    /**
     * Filter, which CourseBundles to fetch.
     */
    where?: CourseBundleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseBundles to fetch.
     */
    orderBy?: CourseBundleOrderByWithRelationInput | CourseBundleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CourseBundles.
     */
    cursor?: CourseBundleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseBundles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseBundles.
     */
    skip?: number
    distinct?: CourseBundleScalarFieldEnum | CourseBundleScalarFieldEnum[]
  }

  /**
   * CourseBundle create
   */
  export type CourseBundleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseBundle
     */
    select?: CourseBundleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseBundleInclude<ExtArgs> | null
    /**
     * The data needed to create a CourseBundle.
     */
    data: XOR<CourseBundleCreateInput, CourseBundleUncheckedCreateInput>
  }

  /**
   * CourseBundle createMany
   */
  export type CourseBundleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CourseBundles.
     */
    data: CourseBundleCreateManyInput | CourseBundleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CourseBundle createManyAndReturn
   */
  export type CourseBundleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseBundle
     */
    select?: CourseBundleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CourseBundles.
     */
    data: CourseBundleCreateManyInput | CourseBundleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CourseBundle update
   */
  export type CourseBundleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseBundle
     */
    select?: CourseBundleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseBundleInclude<ExtArgs> | null
    /**
     * The data needed to update a CourseBundle.
     */
    data: XOR<CourseBundleUpdateInput, CourseBundleUncheckedUpdateInput>
    /**
     * Choose, which CourseBundle to update.
     */
    where: CourseBundleWhereUniqueInput
  }

  /**
   * CourseBundle updateMany
   */
  export type CourseBundleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CourseBundles.
     */
    data: XOR<CourseBundleUpdateManyMutationInput, CourseBundleUncheckedUpdateManyInput>
    /**
     * Filter which CourseBundles to update
     */
    where?: CourseBundleWhereInput
  }

  /**
   * CourseBundle upsert
   */
  export type CourseBundleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseBundle
     */
    select?: CourseBundleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseBundleInclude<ExtArgs> | null
    /**
     * The filter to search for the CourseBundle to update in case it exists.
     */
    where: CourseBundleWhereUniqueInput
    /**
     * In case the CourseBundle found by the `where` argument doesn't exist, create a new CourseBundle with this data.
     */
    create: XOR<CourseBundleCreateInput, CourseBundleUncheckedCreateInput>
    /**
     * In case the CourseBundle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourseBundleUpdateInput, CourseBundleUncheckedUpdateInput>
  }

  /**
   * CourseBundle delete
   */
  export type CourseBundleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseBundle
     */
    select?: CourseBundleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseBundleInclude<ExtArgs> | null
    /**
     * Filter which CourseBundle to delete.
     */
    where: CourseBundleWhereUniqueInput
  }

  /**
   * CourseBundle deleteMany
   */
  export type CourseBundleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseBundles to delete
     */
    where?: CourseBundleWhereInput
  }

  /**
   * CourseBundle.courses
   */
  export type CourseBundle$coursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BundleCourse
     */
    select?: BundleCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BundleCourseInclude<ExtArgs> | null
    where?: BundleCourseWhereInput
    orderBy?: BundleCourseOrderByWithRelationInput | BundleCourseOrderByWithRelationInput[]
    cursor?: BundleCourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BundleCourseScalarFieldEnum | BundleCourseScalarFieldEnum[]
  }

  /**
   * CourseBundle.owners
   */
  export type CourseBundle$ownersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBundle
     */
    select?: UserBundleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBundleInclude<ExtArgs> | null
    where?: UserBundleWhereInput
    orderBy?: UserBundleOrderByWithRelationInput | UserBundleOrderByWithRelationInput[]
    cursor?: UserBundleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserBundleScalarFieldEnum | UserBundleScalarFieldEnum[]
  }

  /**
   * CourseBundle without action
   */
  export type CourseBundleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseBundle
     */
    select?: CourseBundleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseBundleInclude<ExtArgs> | null
  }


  /**
   * Model BundleCourse
   */

  export type AggregateBundleCourse = {
    _count: BundleCourseCountAggregateOutputType | null
    _min: BundleCourseMinAggregateOutputType | null
    _max: BundleCourseMaxAggregateOutputType | null
  }

  export type BundleCourseMinAggregateOutputType = {
    bundleId: string | null
    courseId: string | null
  }

  export type BundleCourseMaxAggregateOutputType = {
    bundleId: string | null
    courseId: string | null
  }

  export type BundleCourseCountAggregateOutputType = {
    bundleId: number
    courseId: number
    _all: number
  }


  export type BundleCourseMinAggregateInputType = {
    bundleId?: true
    courseId?: true
  }

  export type BundleCourseMaxAggregateInputType = {
    bundleId?: true
    courseId?: true
  }

  export type BundleCourseCountAggregateInputType = {
    bundleId?: true
    courseId?: true
    _all?: true
  }

  export type BundleCourseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BundleCourse to aggregate.
     */
    where?: BundleCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BundleCourses to fetch.
     */
    orderBy?: BundleCourseOrderByWithRelationInput | BundleCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BundleCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BundleCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BundleCourses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BundleCourses
    **/
    _count?: true | BundleCourseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BundleCourseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BundleCourseMaxAggregateInputType
  }

  export type GetBundleCourseAggregateType<T extends BundleCourseAggregateArgs> = {
        [P in keyof T & keyof AggregateBundleCourse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBundleCourse[P]>
      : GetScalarType<T[P], AggregateBundleCourse[P]>
  }




  export type BundleCourseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BundleCourseWhereInput
    orderBy?: BundleCourseOrderByWithAggregationInput | BundleCourseOrderByWithAggregationInput[]
    by: BundleCourseScalarFieldEnum[] | BundleCourseScalarFieldEnum
    having?: BundleCourseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BundleCourseCountAggregateInputType | true
    _min?: BundleCourseMinAggregateInputType
    _max?: BundleCourseMaxAggregateInputType
  }

  export type BundleCourseGroupByOutputType = {
    bundleId: string
    courseId: string
    _count: BundleCourseCountAggregateOutputType | null
    _min: BundleCourseMinAggregateOutputType | null
    _max: BundleCourseMaxAggregateOutputType | null
  }

  type GetBundleCourseGroupByPayload<T extends BundleCourseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BundleCourseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BundleCourseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BundleCourseGroupByOutputType[P]>
            : GetScalarType<T[P], BundleCourseGroupByOutputType[P]>
        }
      >
    >


  export type BundleCourseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    bundleId?: boolean
    courseId?: boolean
    bundle?: boolean | CourseBundleDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bundleCourse"]>

  export type BundleCourseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    bundleId?: boolean
    courseId?: boolean
    bundle?: boolean | CourseBundleDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bundleCourse"]>

  export type BundleCourseSelectScalar = {
    bundleId?: boolean
    courseId?: boolean
  }

  export type BundleCourseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bundle?: boolean | CourseBundleDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }
  export type BundleCourseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bundle?: boolean | CourseBundleDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }

  export type $BundleCoursePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BundleCourse"
    objects: {
      bundle: Prisma.$CourseBundlePayload<ExtArgs>
      course: Prisma.$CoursePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      bundleId: string
      courseId: string
    }, ExtArgs["result"]["bundleCourse"]>
    composites: {}
  }

  type BundleCourseGetPayload<S extends boolean | null | undefined | BundleCourseDefaultArgs> = $Result.GetResult<Prisma.$BundleCoursePayload, S>

  type BundleCourseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BundleCourseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BundleCourseCountAggregateInputType | true
    }

  export interface BundleCourseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BundleCourse'], meta: { name: 'BundleCourse' } }
    /**
     * Find zero or one BundleCourse that matches the filter.
     * @param {BundleCourseFindUniqueArgs} args - Arguments to find a BundleCourse
     * @example
     * // Get one BundleCourse
     * const bundleCourse = await prisma.bundleCourse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BundleCourseFindUniqueArgs>(args: SelectSubset<T, BundleCourseFindUniqueArgs<ExtArgs>>): Prisma__BundleCourseClient<$Result.GetResult<Prisma.$BundleCoursePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BundleCourse that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BundleCourseFindUniqueOrThrowArgs} args - Arguments to find a BundleCourse
     * @example
     * // Get one BundleCourse
     * const bundleCourse = await prisma.bundleCourse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BundleCourseFindUniqueOrThrowArgs>(args: SelectSubset<T, BundleCourseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BundleCourseClient<$Result.GetResult<Prisma.$BundleCoursePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BundleCourse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BundleCourseFindFirstArgs} args - Arguments to find a BundleCourse
     * @example
     * // Get one BundleCourse
     * const bundleCourse = await prisma.bundleCourse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BundleCourseFindFirstArgs>(args?: SelectSubset<T, BundleCourseFindFirstArgs<ExtArgs>>): Prisma__BundleCourseClient<$Result.GetResult<Prisma.$BundleCoursePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BundleCourse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BundleCourseFindFirstOrThrowArgs} args - Arguments to find a BundleCourse
     * @example
     * // Get one BundleCourse
     * const bundleCourse = await prisma.bundleCourse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BundleCourseFindFirstOrThrowArgs>(args?: SelectSubset<T, BundleCourseFindFirstOrThrowArgs<ExtArgs>>): Prisma__BundleCourseClient<$Result.GetResult<Prisma.$BundleCoursePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BundleCourses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BundleCourseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BundleCourses
     * const bundleCourses = await prisma.bundleCourse.findMany()
     * 
     * // Get first 10 BundleCourses
     * const bundleCourses = await prisma.bundleCourse.findMany({ take: 10 })
     * 
     * // Only select the `bundleId`
     * const bundleCourseWithBundleIdOnly = await prisma.bundleCourse.findMany({ select: { bundleId: true } })
     * 
     */
    findMany<T extends BundleCourseFindManyArgs>(args?: SelectSubset<T, BundleCourseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BundleCoursePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BundleCourse.
     * @param {BundleCourseCreateArgs} args - Arguments to create a BundleCourse.
     * @example
     * // Create one BundleCourse
     * const BundleCourse = await prisma.bundleCourse.create({
     *   data: {
     *     // ... data to create a BundleCourse
     *   }
     * })
     * 
     */
    create<T extends BundleCourseCreateArgs>(args: SelectSubset<T, BundleCourseCreateArgs<ExtArgs>>): Prisma__BundleCourseClient<$Result.GetResult<Prisma.$BundleCoursePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BundleCourses.
     * @param {BundleCourseCreateManyArgs} args - Arguments to create many BundleCourses.
     * @example
     * // Create many BundleCourses
     * const bundleCourse = await prisma.bundleCourse.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BundleCourseCreateManyArgs>(args?: SelectSubset<T, BundleCourseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BundleCourses and returns the data saved in the database.
     * @param {BundleCourseCreateManyAndReturnArgs} args - Arguments to create many BundleCourses.
     * @example
     * // Create many BundleCourses
     * const bundleCourse = await prisma.bundleCourse.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BundleCourses and only return the `bundleId`
     * const bundleCourseWithBundleIdOnly = await prisma.bundleCourse.createManyAndReturn({ 
     *   select: { bundleId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BundleCourseCreateManyAndReturnArgs>(args?: SelectSubset<T, BundleCourseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BundleCoursePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BundleCourse.
     * @param {BundleCourseDeleteArgs} args - Arguments to delete one BundleCourse.
     * @example
     * // Delete one BundleCourse
     * const BundleCourse = await prisma.bundleCourse.delete({
     *   where: {
     *     // ... filter to delete one BundleCourse
     *   }
     * })
     * 
     */
    delete<T extends BundleCourseDeleteArgs>(args: SelectSubset<T, BundleCourseDeleteArgs<ExtArgs>>): Prisma__BundleCourseClient<$Result.GetResult<Prisma.$BundleCoursePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BundleCourse.
     * @param {BundleCourseUpdateArgs} args - Arguments to update one BundleCourse.
     * @example
     * // Update one BundleCourse
     * const bundleCourse = await prisma.bundleCourse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BundleCourseUpdateArgs>(args: SelectSubset<T, BundleCourseUpdateArgs<ExtArgs>>): Prisma__BundleCourseClient<$Result.GetResult<Prisma.$BundleCoursePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BundleCourses.
     * @param {BundleCourseDeleteManyArgs} args - Arguments to filter BundleCourses to delete.
     * @example
     * // Delete a few BundleCourses
     * const { count } = await prisma.bundleCourse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BundleCourseDeleteManyArgs>(args?: SelectSubset<T, BundleCourseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BundleCourses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BundleCourseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BundleCourses
     * const bundleCourse = await prisma.bundleCourse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BundleCourseUpdateManyArgs>(args: SelectSubset<T, BundleCourseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BundleCourse.
     * @param {BundleCourseUpsertArgs} args - Arguments to update or create a BundleCourse.
     * @example
     * // Update or create a BundleCourse
     * const bundleCourse = await prisma.bundleCourse.upsert({
     *   create: {
     *     // ... data to create a BundleCourse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BundleCourse we want to update
     *   }
     * })
     */
    upsert<T extends BundleCourseUpsertArgs>(args: SelectSubset<T, BundleCourseUpsertArgs<ExtArgs>>): Prisma__BundleCourseClient<$Result.GetResult<Prisma.$BundleCoursePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BundleCourses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BundleCourseCountArgs} args - Arguments to filter BundleCourses to count.
     * @example
     * // Count the number of BundleCourses
     * const count = await prisma.bundleCourse.count({
     *   where: {
     *     // ... the filter for the BundleCourses we want to count
     *   }
     * })
    **/
    count<T extends BundleCourseCountArgs>(
      args?: Subset<T, BundleCourseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BundleCourseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BundleCourse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BundleCourseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BundleCourseAggregateArgs>(args: Subset<T, BundleCourseAggregateArgs>): Prisma.PrismaPromise<GetBundleCourseAggregateType<T>>

    /**
     * Group by BundleCourse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BundleCourseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BundleCourseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BundleCourseGroupByArgs['orderBy'] }
        : { orderBy?: BundleCourseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BundleCourseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBundleCourseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BundleCourse model
   */
  readonly fields: BundleCourseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BundleCourse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BundleCourseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bundle<T extends CourseBundleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseBundleDefaultArgs<ExtArgs>>): Prisma__CourseBundleClient<$Result.GetResult<Prisma.$CourseBundlePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BundleCourse model
   */ 
  interface BundleCourseFieldRefs {
    readonly bundleId: FieldRef<"BundleCourse", 'String'>
    readonly courseId: FieldRef<"BundleCourse", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BundleCourse findUnique
   */
  export type BundleCourseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BundleCourse
     */
    select?: BundleCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BundleCourseInclude<ExtArgs> | null
    /**
     * Filter, which BundleCourse to fetch.
     */
    where: BundleCourseWhereUniqueInput
  }

  /**
   * BundleCourse findUniqueOrThrow
   */
  export type BundleCourseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BundleCourse
     */
    select?: BundleCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BundleCourseInclude<ExtArgs> | null
    /**
     * Filter, which BundleCourse to fetch.
     */
    where: BundleCourseWhereUniqueInput
  }

  /**
   * BundleCourse findFirst
   */
  export type BundleCourseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BundleCourse
     */
    select?: BundleCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BundleCourseInclude<ExtArgs> | null
    /**
     * Filter, which BundleCourse to fetch.
     */
    where?: BundleCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BundleCourses to fetch.
     */
    orderBy?: BundleCourseOrderByWithRelationInput | BundleCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BundleCourses.
     */
    cursor?: BundleCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BundleCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BundleCourses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BundleCourses.
     */
    distinct?: BundleCourseScalarFieldEnum | BundleCourseScalarFieldEnum[]
  }

  /**
   * BundleCourse findFirstOrThrow
   */
  export type BundleCourseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BundleCourse
     */
    select?: BundleCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BundleCourseInclude<ExtArgs> | null
    /**
     * Filter, which BundleCourse to fetch.
     */
    where?: BundleCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BundleCourses to fetch.
     */
    orderBy?: BundleCourseOrderByWithRelationInput | BundleCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BundleCourses.
     */
    cursor?: BundleCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BundleCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BundleCourses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BundleCourses.
     */
    distinct?: BundleCourseScalarFieldEnum | BundleCourseScalarFieldEnum[]
  }

  /**
   * BundleCourse findMany
   */
  export type BundleCourseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BundleCourse
     */
    select?: BundleCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BundleCourseInclude<ExtArgs> | null
    /**
     * Filter, which BundleCourses to fetch.
     */
    where?: BundleCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BundleCourses to fetch.
     */
    orderBy?: BundleCourseOrderByWithRelationInput | BundleCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BundleCourses.
     */
    cursor?: BundleCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BundleCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BundleCourses.
     */
    skip?: number
    distinct?: BundleCourseScalarFieldEnum | BundleCourseScalarFieldEnum[]
  }

  /**
   * BundleCourse create
   */
  export type BundleCourseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BundleCourse
     */
    select?: BundleCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BundleCourseInclude<ExtArgs> | null
    /**
     * The data needed to create a BundleCourse.
     */
    data: XOR<BundleCourseCreateInput, BundleCourseUncheckedCreateInput>
  }

  /**
   * BundleCourse createMany
   */
  export type BundleCourseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BundleCourses.
     */
    data: BundleCourseCreateManyInput | BundleCourseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BundleCourse createManyAndReturn
   */
  export type BundleCourseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BundleCourse
     */
    select?: BundleCourseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BundleCourses.
     */
    data: BundleCourseCreateManyInput | BundleCourseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BundleCourseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BundleCourse update
   */
  export type BundleCourseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BundleCourse
     */
    select?: BundleCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BundleCourseInclude<ExtArgs> | null
    /**
     * The data needed to update a BundleCourse.
     */
    data: XOR<BundleCourseUpdateInput, BundleCourseUncheckedUpdateInput>
    /**
     * Choose, which BundleCourse to update.
     */
    where: BundleCourseWhereUniqueInput
  }

  /**
   * BundleCourse updateMany
   */
  export type BundleCourseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BundleCourses.
     */
    data: XOR<BundleCourseUpdateManyMutationInput, BundleCourseUncheckedUpdateManyInput>
    /**
     * Filter which BundleCourses to update
     */
    where?: BundleCourseWhereInput
  }

  /**
   * BundleCourse upsert
   */
  export type BundleCourseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BundleCourse
     */
    select?: BundleCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BundleCourseInclude<ExtArgs> | null
    /**
     * The filter to search for the BundleCourse to update in case it exists.
     */
    where: BundleCourseWhereUniqueInput
    /**
     * In case the BundleCourse found by the `where` argument doesn't exist, create a new BundleCourse with this data.
     */
    create: XOR<BundleCourseCreateInput, BundleCourseUncheckedCreateInput>
    /**
     * In case the BundleCourse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BundleCourseUpdateInput, BundleCourseUncheckedUpdateInput>
  }

  /**
   * BundleCourse delete
   */
  export type BundleCourseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BundleCourse
     */
    select?: BundleCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BundleCourseInclude<ExtArgs> | null
    /**
     * Filter which BundleCourse to delete.
     */
    where: BundleCourseWhereUniqueInput
  }

  /**
   * BundleCourse deleteMany
   */
  export type BundleCourseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BundleCourses to delete
     */
    where?: BundleCourseWhereInput
  }

  /**
   * BundleCourse without action
   */
  export type BundleCourseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BundleCourse
     */
    select?: BundleCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BundleCourseInclude<ExtArgs> | null
  }


  /**
   * Model UserSubscription
   */

  export type AggregateUserSubscription = {
    _count: UserSubscriptionCountAggregateOutputType | null
    _min: UserSubscriptionMinAggregateOutputType | null
    _max: UserSubscriptionMaxAggregateOutputType | null
  }

  export type UserSubscriptionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    planId: string | null
    startDate: Date | null
    endDate: Date | null
    isActive: boolean | null
    autoRenew: boolean | null
    paymentMethod: string | null
    lastPaymentDate: Date | null
  }

  export type UserSubscriptionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    planId: string | null
    startDate: Date | null
    endDate: Date | null
    isActive: boolean | null
    autoRenew: boolean | null
    paymentMethod: string | null
    lastPaymentDate: Date | null
  }

  export type UserSubscriptionCountAggregateOutputType = {
    id: number
    userId: number
    planId: number
    startDate: number
    endDate: number
    isActive: number
    autoRenew: number
    paymentMethod: number
    lastPaymentDate: number
    _all: number
  }


  export type UserSubscriptionMinAggregateInputType = {
    id?: true
    userId?: true
    planId?: true
    startDate?: true
    endDate?: true
    isActive?: true
    autoRenew?: true
    paymentMethod?: true
    lastPaymentDate?: true
  }

  export type UserSubscriptionMaxAggregateInputType = {
    id?: true
    userId?: true
    planId?: true
    startDate?: true
    endDate?: true
    isActive?: true
    autoRenew?: true
    paymentMethod?: true
    lastPaymentDate?: true
  }

  export type UserSubscriptionCountAggregateInputType = {
    id?: true
    userId?: true
    planId?: true
    startDate?: true
    endDate?: true
    isActive?: true
    autoRenew?: true
    paymentMethod?: true
    lastPaymentDate?: true
    _all?: true
  }

  export type UserSubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSubscription to aggregate.
     */
    where?: UserSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSubscriptions to fetch.
     */
    orderBy?: UserSubscriptionOrderByWithRelationInput | UserSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserSubscriptions
    **/
    _count?: true | UserSubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserSubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserSubscriptionMaxAggregateInputType
  }

  export type GetUserSubscriptionAggregateType<T extends UserSubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateUserSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserSubscription[P]>
      : GetScalarType<T[P], AggregateUserSubscription[P]>
  }




  export type UserSubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSubscriptionWhereInput
    orderBy?: UserSubscriptionOrderByWithAggregationInput | UserSubscriptionOrderByWithAggregationInput[]
    by: UserSubscriptionScalarFieldEnum[] | UserSubscriptionScalarFieldEnum
    having?: UserSubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserSubscriptionCountAggregateInputType | true
    _min?: UserSubscriptionMinAggregateInputType
    _max?: UserSubscriptionMaxAggregateInputType
  }

  export type UserSubscriptionGroupByOutputType = {
    id: string
    userId: string
    planId: string
    startDate: Date
    endDate: Date
    isActive: boolean
    autoRenew: boolean
    paymentMethod: string | null
    lastPaymentDate: Date | null
    _count: UserSubscriptionCountAggregateOutputType | null
    _min: UserSubscriptionMinAggregateOutputType | null
    _max: UserSubscriptionMaxAggregateOutputType | null
  }

  type GetUserSubscriptionGroupByPayload<T extends UserSubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserSubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserSubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserSubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], UserSubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type UserSubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    planId?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    autoRenew?: boolean
    paymentMethod?: boolean
    lastPaymentDate?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    plan?: boolean | SubscriptionPlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSubscription"]>

  export type UserSubscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    planId?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    autoRenew?: boolean
    paymentMethod?: boolean
    lastPaymentDate?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    plan?: boolean | SubscriptionPlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSubscription"]>

  export type UserSubscriptionSelectScalar = {
    id?: boolean
    userId?: boolean
    planId?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    autoRenew?: boolean
    paymentMethod?: boolean
    lastPaymentDate?: boolean
  }

  export type UserSubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    plan?: boolean | SubscriptionPlanDefaultArgs<ExtArgs>
  }
  export type UserSubscriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    plan?: boolean | SubscriptionPlanDefaultArgs<ExtArgs>
  }

  export type $UserSubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserSubscription"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      plan: Prisma.$SubscriptionPlanPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      planId: string
      startDate: Date
      endDate: Date
      isActive: boolean
      autoRenew: boolean
      paymentMethod: string | null
      lastPaymentDate: Date | null
    }, ExtArgs["result"]["userSubscription"]>
    composites: {}
  }

  type UserSubscriptionGetPayload<S extends boolean | null | undefined | UserSubscriptionDefaultArgs> = $Result.GetResult<Prisma.$UserSubscriptionPayload, S>

  type UserSubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserSubscriptionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserSubscriptionCountAggregateInputType | true
    }

  export interface UserSubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserSubscription'], meta: { name: 'UserSubscription' } }
    /**
     * Find zero or one UserSubscription that matches the filter.
     * @param {UserSubscriptionFindUniqueArgs} args - Arguments to find a UserSubscription
     * @example
     * // Get one UserSubscription
     * const userSubscription = await prisma.userSubscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserSubscriptionFindUniqueArgs>(args: SelectSubset<T, UserSubscriptionFindUniqueArgs<ExtArgs>>): Prisma__UserSubscriptionClient<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserSubscription that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserSubscriptionFindUniqueOrThrowArgs} args - Arguments to find a UserSubscription
     * @example
     * // Get one UserSubscription
     * const userSubscription = await prisma.userSubscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserSubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, UserSubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserSubscriptionClient<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserSubscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSubscriptionFindFirstArgs} args - Arguments to find a UserSubscription
     * @example
     * // Get one UserSubscription
     * const userSubscription = await prisma.userSubscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserSubscriptionFindFirstArgs>(args?: SelectSubset<T, UserSubscriptionFindFirstArgs<ExtArgs>>): Prisma__UserSubscriptionClient<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserSubscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSubscriptionFindFirstOrThrowArgs} args - Arguments to find a UserSubscription
     * @example
     * // Get one UserSubscription
     * const userSubscription = await prisma.userSubscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserSubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, UserSubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserSubscriptionClient<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserSubscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserSubscriptions
     * const userSubscriptions = await prisma.userSubscription.findMany()
     * 
     * // Get first 10 UserSubscriptions
     * const userSubscriptions = await prisma.userSubscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userSubscriptionWithIdOnly = await prisma.userSubscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserSubscriptionFindManyArgs>(args?: SelectSubset<T, UserSubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserSubscription.
     * @param {UserSubscriptionCreateArgs} args - Arguments to create a UserSubscription.
     * @example
     * // Create one UserSubscription
     * const UserSubscription = await prisma.userSubscription.create({
     *   data: {
     *     // ... data to create a UserSubscription
     *   }
     * })
     * 
     */
    create<T extends UserSubscriptionCreateArgs>(args: SelectSubset<T, UserSubscriptionCreateArgs<ExtArgs>>): Prisma__UserSubscriptionClient<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserSubscriptions.
     * @param {UserSubscriptionCreateManyArgs} args - Arguments to create many UserSubscriptions.
     * @example
     * // Create many UserSubscriptions
     * const userSubscription = await prisma.userSubscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserSubscriptionCreateManyArgs>(args?: SelectSubset<T, UserSubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserSubscriptions and returns the data saved in the database.
     * @param {UserSubscriptionCreateManyAndReturnArgs} args - Arguments to create many UserSubscriptions.
     * @example
     * // Create many UserSubscriptions
     * const userSubscription = await prisma.userSubscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserSubscriptions and only return the `id`
     * const userSubscriptionWithIdOnly = await prisma.userSubscription.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserSubscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, UserSubscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserSubscription.
     * @param {UserSubscriptionDeleteArgs} args - Arguments to delete one UserSubscription.
     * @example
     * // Delete one UserSubscription
     * const UserSubscription = await prisma.userSubscription.delete({
     *   where: {
     *     // ... filter to delete one UserSubscription
     *   }
     * })
     * 
     */
    delete<T extends UserSubscriptionDeleteArgs>(args: SelectSubset<T, UserSubscriptionDeleteArgs<ExtArgs>>): Prisma__UserSubscriptionClient<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserSubscription.
     * @param {UserSubscriptionUpdateArgs} args - Arguments to update one UserSubscription.
     * @example
     * // Update one UserSubscription
     * const userSubscription = await prisma.userSubscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserSubscriptionUpdateArgs>(args: SelectSubset<T, UserSubscriptionUpdateArgs<ExtArgs>>): Prisma__UserSubscriptionClient<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserSubscriptions.
     * @param {UserSubscriptionDeleteManyArgs} args - Arguments to filter UserSubscriptions to delete.
     * @example
     * // Delete a few UserSubscriptions
     * const { count } = await prisma.userSubscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserSubscriptionDeleteManyArgs>(args?: SelectSubset<T, UserSubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserSubscriptions
     * const userSubscription = await prisma.userSubscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserSubscriptionUpdateManyArgs>(args: SelectSubset<T, UserSubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserSubscription.
     * @param {UserSubscriptionUpsertArgs} args - Arguments to update or create a UserSubscription.
     * @example
     * // Update or create a UserSubscription
     * const userSubscription = await prisma.userSubscription.upsert({
     *   create: {
     *     // ... data to create a UserSubscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserSubscription we want to update
     *   }
     * })
     */
    upsert<T extends UserSubscriptionUpsertArgs>(args: SelectSubset<T, UserSubscriptionUpsertArgs<ExtArgs>>): Prisma__UserSubscriptionClient<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSubscriptionCountArgs} args - Arguments to filter UserSubscriptions to count.
     * @example
     * // Count the number of UserSubscriptions
     * const count = await prisma.userSubscription.count({
     *   where: {
     *     // ... the filter for the UserSubscriptions we want to count
     *   }
     * })
    **/
    count<T extends UserSubscriptionCountArgs>(
      args?: Subset<T, UserSubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserSubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserSubscriptionAggregateArgs>(args: Subset<T, UserSubscriptionAggregateArgs>): Prisma.PrismaPromise<GetUserSubscriptionAggregateType<T>>

    /**
     * Group by UserSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserSubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserSubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: UserSubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserSubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserSubscription model
   */
  readonly fields: UserSubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserSubscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserSubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    plan<T extends SubscriptionPlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubscriptionPlanDefaultArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserSubscription model
   */ 
  interface UserSubscriptionFieldRefs {
    readonly id: FieldRef<"UserSubscription", 'String'>
    readonly userId: FieldRef<"UserSubscription", 'String'>
    readonly planId: FieldRef<"UserSubscription", 'String'>
    readonly startDate: FieldRef<"UserSubscription", 'DateTime'>
    readonly endDate: FieldRef<"UserSubscription", 'DateTime'>
    readonly isActive: FieldRef<"UserSubscription", 'Boolean'>
    readonly autoRenew: FieldRef<"UserSubscription", 'Boolean'>
    readonly paymentMethod: FieldRef<"UserSubscription", 'String'>
    readonly lastPaymentDate: FieldRef<"UserSubscription", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserSubscription findUnique
   */
  export type UserSubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which UserSubscription to fetch.
     */
    where: UserSubscriptionWhereUniqueInput
  }

  /**
   * UserSubscription findUniqueOrThrow
   */
  export type UserSubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which UserSubscription to fetch.
     */
    where: UserSubscriptionWhereUniqueInput
  }

  /**
   * UserSubscription findFirst
   */
  export type UserSubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which UserSubscription to fetch.
     */
    where?: UserSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSubscriptions to fetch.
     */
    orderBy?: UserSubscriptionOrderByWithRelationInput | UserSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSubscriptions.
     */
    cursor?: UserSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSubscriptions.
     */
    distinct?: UserSubscriptionScalarFieldEnum | UserSubscriptionScalarFieldEnum[]
  }

  /**
   * UserSubscription findFirstOrThrow
   */
  export type UserSubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which UserSubscription to fetch.
     */
    where?: UserSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSubscriptions to fetch.
     */
    orderBy?: UserSubscriptionOrderByWithRelationInput | UserSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSubscriptions.
     */
    cursor?: UserSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSubscriptions.
     */
    distinct?: UserSubscriptionScalarFieldEnum | UserSubscriptionScalarFieldEnum[]
  }

  /**
   * UserSubscription findMany
   */
  export type UserSubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which UserSubscriptions to fetch.
     */
    where?: UserSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSubscriptions to fetch.
     */
    orderBy?: UserSubscriptionOrderByWithRelationInput | UserSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserSubscriptions.
     */
    cursor?: UserSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSubscriptions.
     */
    skip?: number
    distinct?: UserSubscriptionScalarFieldEnum | UserSubscriptionScalarFieldEnum[]
  }

  /**
   * UserSubscription create
   */
  export type UserSubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a UserSubscription.
     */
    data: XOR<UserSubscriptionCreateInput, UserSubscriptionUncheckedCreateInput>
  }

  /**
   * UserSubscription createMany
   */
  export type UserSubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserSubscriptions.
     */
    data: UserSubscriptionCreateManyInput | UserSubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserSubscription createManyAndReturn
   */
  export type UserSubscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserSubscriptions.
     */
    data: UserSubscriptionCreateManyInput | UserSubscriptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSubscription update
   */
  export type UserSubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a UserSubscription.
     */
    data: XOR<UserSubscriptionUpdateInput, UserSubscriptionUncheckedUpdateInput>
    /**
     * Choose, which UserSubscription to update.
     */
    where: UserSubscriptionWhereUniqueInput
  }

  /**
   * UserSubscription updateMany
   */
  export type UserSubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserSubscriptions.
     */
    data: XOR<UserSubscriptionUpdateManyMutationInput, UserSubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which UserSubscriptions to update
     */
    where?: UserSubscriptionWhereInput
  }

  /**
   * UserSubscription upsert
   */
  export type UserSubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the UserSubscription to update in case it exists.
     */
    where: UserSubscriptionWhereUniqueInput
    /**
     * In case the UserSubscription found by the `where` argument doesn't exist, create a new UserSubscription with this data.
     */
    create: XOR<UserSubscriptionCreateInput, UserSubscriptionUncheckedCreateInput>
    /**
     * In case the UserSubscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserSubscriptionUpdateInput, UserSubscriptionUncheckedUpdateInput>
  }

  /**
   * UserSubscription delete
   */
  export type UserSubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionInclude<ExtArgs> | null
    /**
     * Filter which UserSubscription to delete.
     */
    where: UserSubscriptionWhereUniqueInput
  }

  /**
   * UserSubscription deleteMany
   */
  export type UserSubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSubscriptions to delete
     */
    where?: UserSubscriptionWhereInput
  }

  /**
   * UserSubscription without action
   */
  export type UserSubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionInclude<ExtArgs> | null
  }


  /**
   * Model UserBundle
   */

  export type AggregateUserBundle = {
    _count: UserBundleCountAggregateOutputType | null
    _min: UserBundleMinAggregateOutputType | null
    _max: UserBundleMaxAggregateOutputType | null
  }

  export type UserBundleMinAggregateOutputType = {
    id: string | null
    userId: string | null
    bundleId: string | null
    purchaseDate: Date | null
  }

  export type UserBundleMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    bundleId: string | null
    purchaseDate: Date | null
  }

  export type UserBundleCountAggregateOutputType = {
    id: number
    userId: number
    bundleId: number
    purchaseDate: number
    _all: number
  }


  export type UserBundleMinAggregateInputType = {
    id?: true
    userId?: true
    bundleId?: true
    purchaseDate?: true
  }

  export type UserBundleMaxAggregateInputType = {
    id?: true
    userId?: true
    bundleId?: true
    purchaseDate?: true
  }

  export type UserBundleCountAggregateInputType = {
    id?: true
    userId?: true
    bundleId?: true
    purchaseDate?: true
    _all?: true
  }

  export type UserBundleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserBundle to aggregate.
     */
    where?: UserBundleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBundles to fetch.
     */
    orderBy?: UserBundleOrderByWithRelationInput | UserBundleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserBundleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBundles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBundles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserBundles
    **/
    _count?: true | UserBundleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserBundleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserBundleMaxAggregateInputType
  }

  export type GetUserBundleAggregateType<T extends UserBundleAggregateArgs> = {
        [P in keyof T & keyof AggregateUserBundle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserBundle[P]>
      : GetScalarType<T[P], AggregateUserBundle[P]>
  }




  export type UserBundleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserBundleWhereInput
    orderBy?: UserBundleOrderByWithAggregationInput | UserBundleOrderByWithAggregationInput[]
    by: UserBundleScalarFieldEnum[] | UserBundleScalarFieldEnum
    having?: UserBundleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserBundleCountAggregateInputType | true
    _min?: UserBundleMinAggregateInputType
    _max?: UserBundleMaxAggregateInputType
  }

  export type UserBundleGroupByOutputType = {
    id: string
    userId: string
    bundleId: string
    purchaseDate: Date
    _count: UserBundleCountAggregateOutputType | null
    _min: UserBundleMinAggregateOutputType | null
    _max: UserBundleMaxAggregateOutputType | null
  }

  type GetUserBundleGroupByPayload<T extends UserBundleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserBundleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserBundleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserBundleGroupByOutputType[P]>
            : GetScalarType<T[P], UserBundleGroupByOutputType[P]>
        }
      >
    >


  export type UserBundleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    bundleId?: boolean
    purchaseDate?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    bundle?: boolean | CourseBundleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userBundle"]>

  export type UserBundleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    bundleId?: boolean
    purchaseDate?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    bundle?: boolean | CourseBundleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userBundle"]>

  export type UserBundleSelectScalar = {
    id?: boolean
    userId?: boolean
    bundleId?: boolean
    purchaseDate?: boolean
  }

  export type UserBundleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    bundle?: boolean | CourseBundleDefaultArgs<ExtArgs>
  }
  export type UserBundleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    bundle?: boolean | CourseBundleDefaultArgs<ExtArgs>
  }

  export type $UserBundlePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserBundle"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      bundle: Prisma.$CourseBundlePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      bundleId: string
      purchaseDate: Date
    }, ExtArgs["result"]["userBundle"]>
    composites: {}
  }

  type UserBundleGetPayload<S extends boolean | null | undefined | UserBundleDefaultArgs> = $Result.GetResult<Prisma.$UserBundlePayload, S>

  type UserBundleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserBundleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserBundleCountAggregateInputType | true
    }

  export interface UserBundleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserBundle'], meta: { name: 'UserBundle' } }
    /**
     * Find zero or one UserBundle that matches the filter.
     * @param {UserBundleFindUniqueArgs} args - Arguments to find a UserBundle
     * @example
     * // Get one UserBundle
     * const userBundle = await prisma.userBundle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserBundleFindUniqueArgs>(args: SelectSubset<T, UserBundleFindUniqueArgs<ExtArgs>>): Prisma__UserBundleClient<$Result.GetResult<Prisma.$UserBundlePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserBundle that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserBundleFindUniqueOrThrowArgs} args - Arguments to find a UserBundle
     * @example
     * // Get one UserBundle
     * const userBundle = await prisma.userBundle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserBundleFindUniqueOrThrowArgs>(args: SelectSubset<T, UserBundleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserBundleClient<$Result.GetResult<Prisma.$UserBundlePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserBundle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBundleFindFirstArgs} args - Arguments to find a UserBundle
     * @example
     * // Get one UserBundle
     * const userBundle = await prisma.userBundle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserBundleFindFirstArgs>(args?: SelectSubset<T, UserBundleFindFirstArgs<ExtArgs>>): Prisma__UserBundleClient<$Result.GetResult<Prisma.$UserBundlePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserBundle that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBundleFindFirstOrThrowArgs} args - Arguments to find a UserBundle
     * @example
     * // Get one UserBundle
     * const userBundle = await prisma.userBundle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserBundleFindFirstOrThrowArgs>(args?: SelectSubset<T, UserBundleFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserBundleClient<$Result.GetResult<Prisma.$UserBundlePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserBundles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBundleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserBundles
     * const userBundles = await prisma.userBundle.findMany()
     * 
     * // Get first 10 UserBundles
     * const userBundles = await prisma.userBundle.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userBundleWithIdOnly = await prisma.userBundle.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserBundleFindManyArgs>(args?: SelectSubset<T, UserBundleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBundlePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserBundle.
     * @param {UserBundleCreateArgs} args - Arguments to create a UserBundle.
     * @example
     * // Create one UserBundle
     * const UserBundle = await prisma.userBundle.create({
     *   data: {
     *     // ... data to create a UserBundle
     *   }
     * })
     * 
     */
    create<T extends UserBundleCreateArgs>(args: SelectSubset<T, UserBundleCreateArgs<ExtArgs>>): Prisma__UserBundleClient<$Result.GetResult<Prisma.$UserBundlePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserBundles.
     * @param {UserBundleCreateManyArgs} args - Arguments to create many UserBundles.
     * @example
     * // Create many UserBundles
     * const userBundle = await prisma.userBundle.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserBundleCreateManyArgs>(args?: SelectSubset<T, UserBundleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserBundles and returns the data saved in the database.
     * @param {UserBundleCreateManyAndReturnArgs} args - Arguments to create many UserBundles.
     * @example
     * // Create many UserBundles
     * const userBundle = await prisma.userBundle.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserBundles and only return the `id`
     * const userBundleWithIdOnly = await prisma.userBundle.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserBundleCreateManyAndReturnArgs>(args?: SelectSubset<T, UserBundleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBundlePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserBundle.
     * @param {UserBundleDeleteArgs} args - Arguments to delete one UserBundle.
     * @example
     * // Delete one UserBundle
     * const UserBundle = await prisma.userBundle.delete({
     *   where: {
     *     // ... filter to delete one UserBundle
     *   }
     * })
     * 
     */
    delete<T extends UserBundleDeleteArgs>(args: SelectSubset<T, UserBundleDeleteArgs<ExtArgs>>): Prisma__UserBundleClient<$Result.GetResult<Prisma.$UserBundlePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserBundle.
     * @param {UserBundleUpdateArgs} args - Arguments to update one UserBundle.
     * @example
     * // Update one UserBundle
     * const userBundle = await prisma.userBundle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserBundleUpdateArgs>(args: SelectSubset<T, UserBundleUpdateArgs<ExtArgs>>): Prisma__UserBundleClient<$Result.GetResult<Prisma.$UserBundlePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserBundles.
     * @param {UserBundleDeleteManyArgs} args - Arguments to filter UserBundles to delete.
     * @example
     * // Delete a few UserBundles
     * const { count } = await prisma.userBundle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserBundleDeleteManyArgs>(args?: SelectSubset<T, UserBundleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserBundles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBundleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserBundles
     * const userBundle = await prisma.userBundle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserBundleUpdateManyArgs>(args: SelectSubset<T, UserBundleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserBundle.
     * @param {UserBundleUpsertArgs} args - Arguments to update or create a UserBundle.
     * @example
     * // Update or create a UserBundle
     * const userBundle = await prisma.userBundle.upsert({
     *   create: {
     *     // ... data to create a UserBundle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserBundle we want to update
     *   }
     * })
     */
    upsert<T extends UserBundleUpsertArgs>(args: SelectSubset<T, UserBundleUpsertArgs<ExtArgs>>): Prisma__UserBundleClient<$Result.GetResult<Prisma.$UserBundlePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserBundles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBundleCountArgs} args - Arguments to filter UserBundles to count.
     * @example
     * // Count the number of UserBundles
     * const count = await prisma.userBundle.count({
     *   where: {
     *     // ... the filter for the UserBundles we want to count
     *   }
     * })
    **/
    count<T extends UserBundleCountArgs>(
      args?: Subset<T, UserBundleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserBundleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserBundle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBundleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserBundleAggregateArgs>(args: Subset<T, UserBundleAggregateArgs>): Prisma.PrismaPromise<GetUserBundleAggregateType<T>>

    /**
     * Group by UserBundle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBundleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserBundleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserBundleGroupByArgs['orderBy'] }
        : { orderBy?: UserBundleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserBundleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserBundleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserBundle model
   */
  readonly fields: UserBundleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserBundle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserBundleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    bundle<T extends CourseBundleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseBundleDefaultArgs<ExtArgs>>): Prisma__CourseBundleClient<$Result.GetResult<Prisma.$CourseBundlePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserBundle model
   */ 
  interface UserBundleFieldRefs {
    readonly id: FieldRef<"UserBundle", 'String'>
    readonly userId: FieldRef<"UserBundle", 'String'>
    readonly bundleId: FieldRef<"UserBundle", 'String'>
    readonly purchaseDate: FieldRef<"UserBundle", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserBundle findUnique
   */
  export type UserBundleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBundle
     */
    select?: UserBundleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBundleInclude<ExtArgs> | null
    /**
     * Filter, which UserBundle to fetch.
     */
    where: UserBundleWhereUniqueInput
  }

  /**
   * UserBundle findUniqueOrThrow
   */
  export type UserBundleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBundle
     */
    select?: UserBundleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBundleInclude<ExtArgs> | null
    /**
     * Filter, which UserBundle to fetch.
     */
    where: UserBundleWhereUniqueInput
  }

  /**
   * UserBundle findFirst
   */
  export type UserBundleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBundle
     */
    select?: UserBundleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBundleInclude<ExtArgs> | null
    /**
     * Filter, which UserBundle to fetch.
     */
    where?: UserBundleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBundles to fetch.
     */
    orderBy?: UserBundleOrderByWithRelationInput | UserBundleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserBundles.
     */
    cursor?: UserBundleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBundles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBundles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserBundles.
     */
    distinct?: UserBundleScalarFieldEnum | UserBundleScalarFieldEnum[]
  }

  /**
   * UserBundle findFirstOrThrow
   */
  export type UserBundleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBundle
     */
    select?: UserBundleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBundleInclude<ExtArgs> | null
    /**
     * Filter, which UserBundle to fetch.
     */
    where?: UserBundleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBundles to fetch.
     */
    orderBy?: UserBundleOrderByWithRelationInput | UserBundleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserBundles.
     */
    cursor?: UserBundleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBundles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBundles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserBundles.
     */
    distinct?: UserBundleScalarFieldEnum | UserBundleScalarFieldEnum[]
  }

  /**
   * UserBundle findMany
   */
  export type UserBundleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBundle
     */
    select?: UserBundleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBundleInclude<ExtArgs> | null
    /**
     * Filter, which UserBundles to fetch.
     */
    where?: UserBundleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBundles to fetch.
     */
    orderBy?: UserBundleOrderByWithRelationInput | UserBundleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserBundles.
     */
    cursor?: UserBundleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBundles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBundles.
     */
    skip?: number
    distinct?: UserBundleScalarFieldEnum | UserBundleScalarFieldEnum[]
  }

  /**
   * UserBundle create
   */
  export type UserBundleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBundle
     */
    select?: UserBundleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBundleInclude<ExtArgs> | null
    /**
     * The data needed to create a UserBundle.
     */
    data: XOR<UserBundleCreateInput, UserBundleUncheckedCreateInput>
  }

  /**
   * UserBundle createMany
   */
  export type UserBundleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserBundles.
     */
    data: UserBundleCreateManyInput | UserBundleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserBundle createManyAndReturn
   */
  export type UserBundleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBundle
     */
    select?: UserBundleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserBundles.
     */
    data: UserBundleCreateManyInput | UserBundleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBundleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserBundle update
   */
  export type UserBundleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBundle
     */
    select?: UserBundleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBundleInclude<ExtArgs> | null
    /**
     * The data needed to update a UserBundle.
     */
    data: XOR<UserBundleUpdateInput, UserBundleUncheckedUpdateInput>
    /**
     * Choose, which UserBundle to update.
     */
    where: UserBundleWhereUniqueInput
  }

  /**
   * UserBundle updateMany
   */
  export type UserBundleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserBundles.
     */
    data: XOR<UserBundleUpdateManyMutationInput, UserBundleUncheckedUpdateManyInput>
    /**
     * Filter which UserBundles to update
     */
    where?: UserBundleWhereInput
  }

  /**
   * UserBundle upsert
   */
  export type UserBundleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBundle
     */
    select?: UserBundleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBundleInclude<ExtArgs> | null
    /**
     * The filter to search for the UserBundle to update in case it exists.
     */
    where: UserBundleWhereUniqueInput
    /**
     * In case the UserBundle found by the `where` argument doesn't exist, create a new UserBundle with this data.
     */
    create: XOR<UserBundleCreateInput, UserBundleUncheckedCreateInput>
    /**
     * In case the UserBundle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserBundleUpdateInput, UserBundleUncheckedUpdateInput>
  }

  /**
   * UserBundle delete
   */
  export type UserBundleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBundle
     */
    select?: UserBundleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBundleInclude<ExtArgs> | null
    /**
     * Filter which UserBundle to delete.
     */
    where: UserBundleWhereUniqueInput
  }

  /**
   * UserBundle deleteMany
   */
  export type UserBundleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserBundles to delete
     */
    where?: UserBundleWhereInput
  }

  /**
   * UserBundle without action
   */
  export type UserBundleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBundle
     */
    select?: UserBundleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBundleInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type PaymentSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    userId: string | null
    amount: Decimal | null
    currency: string | null
    paymentMethod: string | null
    status: $Enums.PaymentStatus | null
    referenceType: $Enums.PaymentReferenceType | null
    referenceId: string | null
    transactionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    amount: Decimal | null
    currency: string | null
    paymentMethod: string | null
    status: $Enums.PaymentStatus | null
    referenceType: $Enums.PaymentReferenceType | null
    referenceId: string | null
    transactionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    userId: number
    amount: number
    currency: number
    paymentMethod: number
    status: number
    referenceType: number
    referenceId: number
    transactionId: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    amount?: true
  }

  export type PaymentSumAggregateInputType = {
    amount?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    currency?: true
    paymentMethod?: true
    status?: true
    referenceType?: true
    referenceId?: true
    transactionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    currency?: true
    paymentMethod?: true
    status?: true
    referenceType?: true
    referenceId?: true
    transactionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    currency?: true
    paymentMethod?: true
    status?: true
    referenceType?: true
    referenceId?: true
    transactionId?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: string
    userId: string
    amount: Decimal
    currency: string
    paymentMethod: string | null
    status: $Enums.PaymentStatus
    referenceType: $Enums.PaymentReferenceType
    referenceId: string | null
    transactionId: string | null
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    amount?: boolean
    currency?: boolean
    paymentMethod?: boolean
    status?: boolean
    referenceType?: boolean
    referenceId?: boolean
    transactionId?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    amount?: boolean
    currency?: boolean
    paymentMethod?: boolean
    status?: boolean
    referenceType?: boolean
    referenceId?: boolean
    transactionId?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    userId?: boolean
    amount?: boolean
    currency?: boolean
    paymentMethod?: boolean
    status?: boolean
    referenceType?: boolean
    referenceId?: boolean
    transactionId?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      amount: Prisma.Decimal
      currency: string
      paymentMethod: string | null
      status: $Enums.PaymentStatus
      referenceType: $Enums.PaymentReferenceType
      referenceId: string | null
      transactionId: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */ 
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'String'>
    readonly userId: FieldRef<"Payment", 'String'>
    readonly amount: FieldRef<"Payment", 'Decimal'>
    readonly currency: FieldRef<"Payment", 'String'>
    readonly paymentMethod: FieldRef<"Payment", 'String'>
    readonly status: FieldRef<"Payment", 'PaymentStatus'>
    readonly referenceType: FieldRef<"Payment", 'PaymentReferenceType'>
    readonly referenceId: FieldRef<"Payment", 'String'>
    readonly transactionId: FieldRef<"Payment", 'String'>
    readonly metadata: FieldRef<"Payment", 'Json'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
    readonly updatedAt: FieldRef<"Payment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model CalendarEvent
   */

  export type AggregateCalendarEvent = {
    _count: CalendarEventCountAggregateOutputType | null
    _min: CalendarEventMinAggregateOutputType | null
    _max: CalendarEventMaxAggregateOutputType | null
  }

  export type CalendarEventMinAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    description: string | null
    type: string | null
    startTime: Date | null
    endTime: Date | null
    courseId: string | null
    lessonId: string | null
    teacherId: string | null
    studentId: string | null
    location: string | null
    createdAt: Date | null
  }

  export type CalendarEventMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    description: string | null
    type: string | null
    startTime: Date | null
    endTime: Date | null
    courseId: string | null
    lessonId: string | null
    teacherId: string | null
    studentId: string | null
    location: string | null
    createdAt: Date | null
  }

  export type CalendarEventCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    description: number
    type: number
    startTime: number
    endTime: number
    courseId: number
    lessonId: number
    teacherId: number
    studentId: number
    location: number
    createdAt: number
    _all: number
  }


  export type CalendarEventMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    description?: true
    type?: true
    startTime?: true
    endTime?: true
    courseId?: true
    lessonId?: true
    teacherId?: true
    studentId?: true
    location?: true
    createdAt?: true
  }

  export type CalendarEventMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    description?: true
    type?: true
    startTime?: true
    endTime?: true
    courseId?: true
    lessonId?: true
    teacherId?: true
    studentId?: true
    location?: true
    createdAt?: true
  }

  export type CalendarEventCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    description?: true
    type?: true
    startTime?: true
    endTime?: true
    courseId?: true
    lessonId?: true
    teacherId?: true
    studentId?: true
    location?: true
    createdAt?: true
    _all?: true
  }

  export type CalendarEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CalendarEvent to aggregate.
     */
    where?: CalendarEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarEvents to fetch.
     */
    orderBy?: CalendarEventOrderByWithRelationInput | CalendarEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CalendarEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CalendarEvents
    **/
    _count?: true | CalendarEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CalendarEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CalendarEventMaxAggregateInputType
  }

  export type GetCalendarEventAggregateType<T extends CalendarEventAggregateArgs> = {
        [P in keyof T & keyof AggregateCalendarEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCalendarEvent[P]>
      : GetScalarType<T[P], AggregateCalendarEvent[P]>
  }




  export type CalendarEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CalendarEventWhereInput
    orderBy?: CalendarEventOrderByWithAggregationInput | CalendarEventOrderByWithAggregationInput[]
    by: CalendarEventScalarFieldEnum[] | CalendarEventScalarFieldEnum
    having?: CalendarEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CalendarEventCountAggregateInputType | true
    _min?: CalendarEventMinAggregateInputType
    _max?: CalendarEventMaxAggregateInputType
  }

  export type CalendarEventGroupByOutputType = {
    id: string
    userId: string
    title: string
    description: string | null
    type: string
    startTime: Date
    endTime: Date | null
    courseId: string | null
    lessonId: string | null
    teacherId: string | null
    studentId: string | null
    location: string | null
    createdAt: Date
    _count: CalendarEventCountAggregateOutputType | null
    _min: CalendarEventMinAggregateOutputType | null
    _max: CalendarEventMaxAggregateOutputType | null
  }

  type GetCalendarEventGroupByPayload<T extends CalendarEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CalendarEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CalendarEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CalendarEventGroupByOutputType[P]>
            : GetScalarType<T[P], CalendarEventGroupByOutputType[P]>
        }
      >
    >


  export type CalendarEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    startTime?: boolean
    endTime?: boolean
    courseId?: boolean
    lessonId?: boolean
    teacherId?: boolean
    studentId?: boolean
    location?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CalendarEvent$courseArgs<ExtArgs>
    lesson?: boolean | CalendarEvent$lessonArgs<ExtArgs>
    teacher?: boolean | CalendarEvent$teacherArgs<ExtArgs>
    student?: boolean | CalendarEvent$studentArgs<ExtArgs>
  }, ExtArgs["result"]["calendarEvent"]>

  export type CalendarEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    startTime?: boolean
    endTime?: boolean
    courseId?: boolean
    lessonId?: boolean
    teacherId?: boolean
    studentId?: boolean
    location?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CalendarEvent$courseArgs<ExtArgs>
    lesson?: boolean | CalendarEvent$lessonArgs<ExtArgs>
    teacher?: boolean | CalendarEvent$teacherArgs<ExtArgs>
    student?: boolean | CalendarEvent$studentArgs<ExtArgs>
  }, ExtArgs["result"]["calendarEvent"]>

  export type CalendarEventSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    startTime?: boolean
    endTime?: boolean
    courseId?: boolean
    lessonId?: boolean
    teacherId?: boolean
    studentId?: boolean
    location?: boolean
    createdAt?: boolean
  }

  export type CalendarEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CalendarEvent$courseArgs<ExtArgs>
    lesson?: boolean | CalendarEvent$lessonArgs<ExtArgs>
    teacher?: boolean | CalendarEvent$teacherArgs<ExtArgs>
    student?: boolean | CalendarEvent$studentArgs<ExtArgs>
  }
  export type CalendarEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CalendarEvent$courseArgs<ExtArgs>
    lesson?: boolean | CalendarEvent$lessonArgs<ExtArgs>
    teacher?: boolean | CalendarEvent$teacherArgs<ExtArgs>
    student?: boolean | CalendarEvent$studentArgs<ExtArgs>
  }

  export type $CalendarEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CalendarEvent"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      course: Prisma.$CoursePayload<ExtArgs> | null
      lesson: Prisma.$LessonPayload<ExtArgs> | null
      teacher: Prisma.$UserPayload<ExtArgs> | null
      student: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      title: string
      description: string | null
      type: string
      startTime: Date
      endTime: Date | null
      courseId: string | null
      lessonId: string | null
      teacherId: string | null
      studentId: string | null
      location: string | null
      createdAt: Date
    }, ExtArgs["result"]["calendarEvent"]>
    composites: {}
  }

  type CalendarEventGetPayload<S extends boolean | null | undefined | CalendarEventDefaultArgs> = $Result.GetResult<Prisma.$CalendarEventPayload, S>

  type CalendarEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CalendarEventFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CalendarEventCountAggregateInputType | true
    }

  export interface CalendarEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CalendarEvent'], meta: { name: 'CalendarEvent' } }
    /**
     * Find zero or one CalendarEvent that matches the filter.
     * @param {CalendarEventFindUniqueArgs} args - Arguments to find a CalendarEvent
     * @example
     * // Get one CalendarEvent
     * const calendarEvent = await prisma.calendarEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CalendarEventFindUniqueArgs>(args: SelectSubset<T, CalendarEventFindUniqueArgs<ExtArgs>>): Prisma__CalendarEventClient<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CalendarEvent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CalendarEventFindUniqueOrThrowArgs} args - Arguments to find a CalendarEvent
     * @example
     * // Get one CalendarEvent
     * const calendarEvent = await prisma.calendarEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CalendarEventFindUniqueOrThrowArgs>(args: SelectSubset<T, CalendarEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CalendarEventClient<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CalendarEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEventFindFirstArgs} args - Arguments to find a CalendarEvent
     * @example
     * // Get one CalendarEvent
     * const calendarEvent = await prisma.calendarEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CalendarEventFindFirstArgs>(args?: SelectSubset<T, CalendarEventFindFirstArgs<ExtArgs>>): Prisma__CalendarEventClient<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CalendarEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEventFindFirstOrThrowArgs} args - Arguments to find a CalendarEvent
     * @example
     * // Get one CalendarEvent
     * const calendarEvent = await prisma.calendarEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CalendarEventFindFirstOrThrowArgs>(args?: SelectSubset<T, CalendarEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__CalendarEventClient<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CalendarEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CalendarEvents
     * const calendarEvents = await prisma.calendarEvent.findMany()
     * 
     * // Get first 10 CalendarEvents
     * const calendarEvents = await prisma.calendarEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const calendarEventWithIdOnly = await prisma.calendarEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CalendarEventFindManyArgs>(args?: SelectSubset<T, CalendarEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CalendarEvent.
     * @param {CalendarEventCreateArgs} args - Arguments to create a CalendarEvent.
     * @example
     * // Create one CalendarEvent
     * const CalendarEvent = await prisma.calendarEvent.create({
     *   data: {
     *     // ... data to create a CalendarEvent
     *   }
     * })
     * 
     */
    create<T extends CalendarEventCreateArgs>(args: SelectSubset<T, CalendarEventCreateArgs<ExtArgs>>): Prisma__CalendarEventClient<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CalendarEvents.
     * @param {CalendarEventCreateManyArgs} args - Arguments to create many CalendarEvents.
     * @example
     * // Create many CalendarEvents
     * const calendarEvent = await prisma.calendarEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CalendarEventCreateManyArgs>(args?: SelectSubset<T, CalendarEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CalendarEvents and returns the data saved in the database.
     * @param {CalendarEventCreateManyAndReturnArgs} args - Arguments to create many CalendarEvents.
     * @example
     * // Create many CalendarEvents
     * const calendarEvent = await prisma.calendarEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CalendarEvents and only return the `id`
     * const calendarEventWithIdOnly = await prisma.calendarEvent.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CalendarEventCreateManyAndReturnArgs>(args?: SelectSubset<T, CalendarEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CalendarEvent.
     * @param {CalendarEventDeleteArgs} args - Arguments to delete one CalendarEvent.
     * @example
     * // Delete one CalendarEvent
     * const CalendarEvent = await prisma.calendarEvent.delete({
     *   where: {
     *     // ... filter to delete one CalendarEvent
     *   }
     * })
     * 
     */
    delete<T extends CalendarEventDeleteArgs>(args: SelectSubset<T, CalendarEventDeleteArgs<ExtArgs>>): Prisma__CalendarEventClient<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CalendarEvent.
     * @param {CalendarEventUpdateArgs} args - Arguments to update one CalendarEvent.
     * @example
     * // Update one CalendarEvent
     * const calendarEvent = await prisma.calendarEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CalendarEventUpdateArgs>(args: SelectSubset<T, CalendarEventUpdateArgs<ExtArgs>>): Prisma__CalendarEventClient<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CalendarEvents.
     * @param {CalendarEventDeleteManyArgs} args - Arguments to filter CalendarEvents to delete.
     * @example
     * // Delete a few CalendarEvents
     * const { count } = await prisma.calendarEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CalendarEventDeleteManyArgs>(args?: SelectSubset<T, CalendarEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CalendarEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CalendarEvents
     * const calendarEvent = await prisma.calendarEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CalendarEventUpdateManyArgs>(args: SelectSubset<T, CalendarEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CalendarEvent.
     * @param {CalendarEventUpsertArgs} args - Arguments to update or create a CalendarEvent.
     * @example
     * // Update or create a CalendarEvent
     * const calendarEvent = await prisma.calendarEvent.upsert({
     *   create: {
     *     // ... data to create a CalendarEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CalendarEvent we want to update
     *   }
     * })
     */
    upsert<T extends CalendarEventUpsertArgs>(args: SelectSubset<T, CalendarEventUpsertArgs<ExtArgs>>): Prisma__CalendarEventClient<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CalendarEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEventCountArgs} args - Arguments to filter CalendarEvents to count.
     * @example
     * // Count the number of CalendarEvents
     * const count = await prisma.calendarEvent.count({
     *   where: {
     *     // ... the filter for the CalendarEvents we want to count
     *   }
     * })
    **/
    count<T extends CalendarEventCountArgs>(
      args?: Subset<T, CalendarEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CalendarEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CalendarEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CalendarEventAggregateArgs>(args: Subset<T, CalendarEventAggregateArgs>): Prisma.PrismaPromise<GetCalendarEventAggregateType<T>>

    /**
     * Group by CalendarEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CalendarEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CalendarEventGroupByArgs['orderBy'] }
        : { orderBy?: CalendarEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CalendarEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCalendarEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CalendarEvent model
   */
  readonly fields: CalendarEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CalendarEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CalendarEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    course<T extends CalendarEvent$courseArgs<ExtArgs> = {}>(args?: Subset<T, CalendarEvent$courseArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    lesson<T extends CalendarEvent$lessonArgs<ExtArgs> = {}>(args?: Subset<T, CalendarEvent$lessonArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    teacher<T extends CalendarEvent$teacherArgs<ExtArgs> = {}>(args?: Subset<T, CalendarEvent$teacherArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    student<T extends CalendarEvent$studentArgs<ExtArgs> = {}>(args?: Subset<T, CalendarEvent$studentArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CalendarEvent model
   */ 
  interface CalendarEventFieldRefs {
    readonly id: FieldRef<"CalendarEvent", 'String'>
    readonly userId: FieldRef<"CalendarEvent", 'String'>
    readonly title: FieldRef<"CalendarEvent", 'String'>
    readonly description: FieldRef<"CalendarEvent", 'String'>
    readonly type: FieldRef<"CalendarEvent", 'String'>
    readonly startTime: FieldRef<"CalendarEvent", 'DateTime'>
    readonly endTime: FieldRef<"CalendarEvent", 'DateTime'>
    readonly courseId: FieldRef<"CalendarEvent", 'String'>
    readonly lessonId: FieldRef<"CalendarEvent", 'String'>
    readonly teacherId: FieldRef<"CalendarEvent", 'String'>
    readonly studentId: FieldRef<"CalendarEvent", 'String'>
    readonly location: FieldRef<"CalendarEvent", 'String'>
    readonly createdAt: FieldRef<"CalendarEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CalendarEvent findUnique
   */
  export type CalendarEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventInclude<ExtArgs> | null
    /**
     * Filter, which CalendarEvent to fetch.
     */
    where: CalendarEventWhereUniqueInput
  }

  /**
   * CalendarEvent findUniqueOrThrow
   */
  export type CalendarEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventInclude<ExtArgs> | null
    /**
     * Filter, which CalendarEvent to fetch.
     */
    where: CalendarEventWhereUniqueInput
  }

  /**
   * CalendarEvent findFirst
   */
  export type CalendarEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventInclude<ExtArgs> | null
    /**
     * Filter, which CalendarEvent to fetch.
     */
    where?: CalendarEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarEvents to fetch.
     */
    orderBy?: CalendarEventOrderByWithRelationInput | CalendarEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CalendarEvents.
     */
    cursor?: CalendarEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CalendarEvents.
     */
    distinct?: CalendarEventScalarFieldEnum | CalendarEventScalarFieldEnum[]
  }

  /**
   * CalendarEvent findFirstOrThrow
   */
  export type CalendarEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventInclude<ExtArgs> | null
    /**
     * Filter, which CalendarEvent to fetch.
     */
    where?: CalendarEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarEvents to fetch.
     */
    orderBy?: CalendarEventOrderByWithRelationInput | CalendarEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CalendarEvents.
     */
    cursor?: CalendarEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CalendarEvents.
     */
    distinct?: CalendarEventScalarFieldEnum | CalendarEventScalarFieldEnum[]
  }

  /**
   * CalendarEvent findMany
   */
  export type CalendarEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventInclude<ExtArgs> | null
    /**
     * Filter, which CalendarEvents to fetch.
     */
    where?: CalendarEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarEvents to fetch.
     */
    orderBy?: CalendarEventOrderByWithRelationInput | CalendarEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CalendarEvents.
     */
    cursor?: CalendarEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarEvents.
     */
    skip?: number
    distinct?: CalendarEventScalarFieldEnum | CalendarEventScalarFieldEnum[]
  }

  /**
   * CalendarEvent create
   */
  export type CalendarEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventInclude<ExtArgs> | null
    /**
     * The data needed to create a CalendarEvent.
     */
    data: XOR<CalendarEventCreateInput, CalendarEventUncheckedCreateInput>
  }

  /**
   * CalendarEvent createMany
   */
  export type CalendarEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CalendarEvents.
     */
    data: CalendarEventCreateManyInput | CalendarEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CalendarEvent createManyAndReturn
   */
  export type CalendarEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CalendarEvents.
     */
    data: CalendarEventCreateManyInput | CalendarEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CalendarEvent update
   */
  export type CalendarEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventInclude<ExtArgs> | null
    /**
     * The data needed to update a CalendarEvent.
     */
    data: XOR<CalendarEventUpdateInput, CalendarEventUncheckedUpdateInput>
    /**
     * Choose, which CalendarEvent to update.
     */
    where: CalendarEventWhereUniqueInput
  }

  /**
   * CalendarEvent updateMany
   */
  export type CalendarEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CalendarEvents.
     */
    data: XOR<CalendarEventUpdateManyMutationInput, CalendarEventUncheckedUpdateManyInput>
    /**
     * Filter which CalendarEvents to update
     */
    where?: CalendarEventWhereInput
  }

  /**
   * CalendarEvent upsert
   */
  export type CalendarEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventInclude<ExtArgs> | null
    /**
     * The filter to search for the CalendarEvent to update in case it exists.
     */
    where: CalendarEventWhereUniqueInput
    /**
     * In case the CalendarEvent found by the `where` argument doesn't exist, create a new CalendarEvent with this data.
     */
    create: XOR<CalendarEventCreateInput, CalendarEventUncheckedCreateInput>
    /**
     * In case the CalendarEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CalendarEventUpdateInput, CalendarEventUncheckedUpdateInput>
  }

  /**
   * CalendarEvent delete
   */
  export type CalendarEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventInclude<ExtArgs> | null
    /**
     * Filter which CalendarEvent to delete.
     */
    where: CalendarEventWhereUniqueInput
  }

  /**
   * CalendarEvent deleteMany
   */
  export type CalendarEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CalendarEvents to delete
     */
    where?: CalendarEventWhereInput
  }

  /**
   * CalendarEvent.course
   */
  export type CalendarEvent$courseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    where?: CourseWhereInput
  }

  /**
   * CalendarEvent.lesson
   */
  export type CalendarEvent$lessonArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    where?: LessonWhereInput
  }

  /**
   * CalendarEvent.teacher
   */
  export type CalendarEvent$teacherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * CalendarEvent.student
   */
  export type CalendarEvent$studentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * CalendarEvent without action
   */
  export type CalendarEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventInclude<ExtArgs> | null
  }


  /**
   * Model BlogPost
   */

  export type AggregateBlogPost = {
    _count: BlogPostCountAggregateOutputType | null
    _avg: BlogPostAvgAggregateOutputType | null
    _sum: BlogPostSumAggregateOutputType | null
    _min: BlogPostMinAggregateOutputType | null
    _max: BlogPostMaxAggregateOutputType | null
  }

  export type BlogPostAvgAggregateOutputType = {
    readTime: number | null
  }

  export type BlogPostSumAggregateOutputType = {
    readTime: number | null
  }

  export type BlogPostMinAggregateOutputType = {
    id: string | null
    title: string | null
    excerpt: string | null
    content: string | null
    image: string | null
    authorId: string | null
    published: boolean | null
    publishedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    readTime: number | null
  }

  export type BlogPostMaxAggregateOutputType = {
    id: string | null
    title: string | null
    excerpt: string | null
    content: string | null
    image: string | null
    authorId: string | null
    published: boolean | null
    publishedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    readTime: number | null
  }

  export type BlogPostCountAggregateOutputType = {
    id: number
    title: number
    excerpt: number
    content: number
    image: number
    authorId: number
    published: number
    publishedAt: number
    createdAt: number
    updatedAt: number
    readTime: number
    _all: number
  }


  export type BlogPostAvgAggregateInputType = {
    readTime?: true
  }

  export type BlogPostSumAggregateInputType = {
    readTime?: true
  }

  export type BlogPostMinAggregateInputType = {
    id?: true
    title?: true
    excerpt?: true
    content?: true
    image?: true
    authorId?: true
    published?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
    readTime?: true
  }

  export type BlogPostMaxAggregateInputType = {
    id?: true
    title?: true
    excerpt?: true
    content?: true
    image?: true
    authorId?: true
    published?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
    readTime?: true
  }

  export type BlogPostCountAggregateInputType = {
    id?: true
    title?: true
    excerpt?: true
    content?: true
    image?: true
    authorId?: true
    published?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
    readTime?: true
    _all?: true
  }

  export type BlogPostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlogPost to aggregate.
     */
    where?: BlogPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogPosts to fetch.
     */
    orderBy?: BlogPostOrderByWithRelationInput | BlogPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BlogPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BlogPosts
    **/
    _count?: true | BlogPostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BlogPostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BlogPostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlogPostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlogPostMaxAggregateInputType
  }

  export type GetBlogPostAggregateType<T extends BlogPostAggregateArgs> = {
        [P in keyof T & keyof AggregateBlogPost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlogPost[P]>
      : GetScalarType<T[P], AggregateBlogPost[P]>
  }




  export type BlogPostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogPostWhereInput
    orderBy?: BlogPostOrderByWithAggregationInput | BlogPostOrderByWithAggregationInput[]
    by: BlogPostScalarFieldEnum[] | BlogPostScalarFieldEnum
    having?: BlogPostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlogPostCountAggregateInputType | true
    _avg?: BlogPostAvgAggregateInputType
    _sum?: BlogPostSumAggregateInputType
    _min?: BlogPostMinAggregateInputType
    _max?: BlogPostMaxAggregateInputType
  }

  export type BlogPostGroupByOutputType = {
    id: string
    title: string
    excerpt: string | null
    content: string
    image: string | null
    authorId: string
    published: boolean
    publishedAt: Date | null
    createdAt: Date
    updatedAt: Date
    readTime: number | null
    _count: BlogPostCountAggregateOutputType | null
    _avg: BlogPostAvgAggregateOutputType | null
    _sum: BlogPostSumAggregateOutputType | null
    _min: BlogPostMinAggregateOutputType | null
    _max: BlogPostMaxAggregateOutputType | null
  }

  type GetBlogPostGroupByPayload<T extends BlogPostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlogPostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlogPostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlogPostGroupByOutputType[P]>
            : GetScalarType<T[P], BlogPostGroupByOutputType[P]>
        }
      >
    >


  export type BlogPostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    excerpt?: boolean
    content?: boolean
    image?: boolean
    authorId?: boolean
    published?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    readTime?: boolean
    author?: boolean | UserDefaultArgs<ExtArgs>
    categories?: boolean | BlogPost$categoriesArgs<ExtArgs>
    tags?: boolean | BlogPost$tagsArgs<ExtArgs>
    comments?: boolean | BlogPost$commentsArgs<ExtArgs>
    _count?: boolean | BlogPostCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blogPost"]>

  export type BlogPostSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    excerpt?: boolean
    content?: boolean
    image?: boolean
    authorId?: boolean
    published?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    readTime?: boolean
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blogPost"]>

  export type BlogPostSelectScalar = {
    id?: boolean
    title?: boolean
    excerpt?: boolean
    content?: boolean
    image?: boolean
    authorId?: boolean
    published?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    readTime?: boolean
  }

  export type BlogPostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
    categories?: boolean | BlogPost$categoriesArgs<ExtArgs>
    tags?: boolean | BlogPost$tagsArgs<ExtArgs>
    comments?: boolean | BlogPost$commentsArgs<ExtArgs>
    _count?: boolean | BlogPostCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BlogPostIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $BlogPostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BlogPost"
    objects: {
      author: Prisma.$UserPayload<ExtArgs>
      categories: Prisma.$PostCategoryPayload<ExtArgs>[]
      tags: Prisma.$PostTagPayload<ExtArgs>[]
      comments: Prisma.$BlogCommentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      excerpt: string | null
      content: string
      image: string | null
      authorId: string
      published: boolean
      publishedAt: Date | null
      createdAt: Date
      updatedAt: Date
      readTime: number | null
    }, ExtArgs["result"]["blogPost"]>
    composites: {}
  }

  type BlogPostGetPayload<S extends boolean | null | undefined | BlogPostDefaultArgs> = $Result.GetResult<Prisma.$BlogPostPayload, S>

  type BlogPostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BlogPostFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BlogPostCountAggregateInputType | true
    }

  export interface BlogPostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BlogPost'], meta: { name: 'BlogPost' } }
    /**
     * Find zero or one BlogPost that matches the filter.
     * @param {BlogPostFindUniqueArgs} args - Arguments to find a BlogPost
     * @example
     * // Get one BlogPost
     * const blogPost = await prisma.blogPost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BlogPostFindUniqueArgs>(args: SelectSubset<T, BlogPostFindUniqueArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BlogPost that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BlogPostFindUniqueOrThrowArgs} args - Arguments to find a BlogPost
     * @example
     * // Get one BlogPost
     * const blogPost = await prisma.blogPost.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BlogPostFindUniqueOrThrowArgs>(args: SelectSubset<T, BlogPostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BlogPost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostFindFirstArgs} args - Arguments to find a BlogPost
     * @example
     * // Get one BlogPost
     * const blogPost = await prisma.blogPost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BlogPostFindFirstArgs>(args?: SelectSubset<T, BlogPostFindFirstArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BlogPost that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostFindFirstOrThrowArgs} args - Arguments to find a BlogPost
     * @example
     * // Get one BlogPost
     * const blogPost = await prisma.blogPost.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BlogPostFindFirstOrThrowArgs>(args?: SelectSubset<T, BlogPostFindFirstOrThrowArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BlogPosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BlogPosts
     * const blogPosts = await prisma.blogPost.findMany()
     * 
     * // Get first 10 BlogPosts
     * const blogPosts = await prisma.blogPost.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blogPostWithIdOnly = await prisma.blogPost.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BlogPostFindManyArgs>(args?: SelectSubset<T, BlogPostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BlogPost.
     * @param {BlogPostCreateArgs} args - Arguments to create a BlogPost.
     * @example
     * // Create one BlogPost
     * const BlogPost = await prisma.blogPost.create({
     *   data: {
     *     // ... data to create a BlogPost
     *   }
     * })
     * 
     */
    create<T extends BlogPostCreateArgs>(args: SelectSubset<T, BlogPostCreateArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BlogPosts.
     * @param {BlogPostCreateManyArgs} args - Arguments to create many BlogPosts.
     * @example
     * // Create many BlogPosts
     * const blogPost = await prisma.blogPost.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BlogPostCreateManyArgs>(args?: SelectSubset<T, BlogPostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BlogPosts and returns the data saved in the database.
     * @param {BlogPostCreateManyAndReturnArgs} args - Arguments to create many BlogPosts.
     * @example
     * // Create many BlogPosts
     * const blogPost = await prisma.blogPost.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BlogPosts and only return the `id`
     * const blogPostWithIdOnly = await prisma.blogPost.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BlogPostCreateManyAndReturnArgs>(args?: SelectSubset<T, BlogPostCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BlogPost.
     * @param {BlogPostDeleteArgs} args - Arguments to delete one BlogPost.
     * @example
     * // Delete one BlogPost
     * const BlogPost = await prisma.blogPost.delete({
     *   where: {
     *     // ... filter to delete one BlogPost
     *   }
     * })
     * 
     */
    delete<T extends BlogPostDeleteArgs>(args: SelectSubset<T, BlogPostDeleteArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BlogPost.
     * @param {BlogPostUpdateArgs} args - Arguments to update one BlogPost.
     * @example
     * // Update one BlogPost
     * const blogPost = await prisma.blogPost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BlogPostUpdateArgs>(args: SelectSubset<T, BlogPostUpdateArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BlogPosts.
     * @param {BlogPostDeleteManyArgs} args - Arguments to filter BlogPosts to delete.
     * @example
     * // Delete a few BlogPosts
     * const { count } = await prisma.blogPost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BlogPostDeleteManyArgs>(args?: SelectSubset<T, BlogPostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlogPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BlogPosts
     * const blogPost = await prisma.blogPost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BlogPostUpdateManyArgs>(args: SelectSubset<T, BlogPostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BlogPost.
     * @param {BlogPostUpsertArgs} args - Arguments to update or create a BlogPost.
     * @example
     * // Update or create a BlogPost
     * const blogPost = await prisma.blogPost.upsert({
     *   create: {
     *     // ... data to create a BlogPost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BlogPost we want to update
     *   }
     * })
     */
    upsert<T extends BlogPostUpsertArgs>(args: SelectSubset<T, BlogPostUpsertArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BlogPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostCountArgs} args - Arguments to filter BlogPosts to count.
     * @example
     * // Count the number of BlogPosts
     * const count = await prisma.blogPost.count({
     *   where: {
     *     // ... the filter for the BlogPosts we want to count
     *   }
     * })
    **/
    count<T extends BlogPostCountArgs>(
      args?: Subset<T, BlogPostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlogPostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BlogPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlogPostAggregateArgs>(args: Subset<T, BlogPostAggregateArgs>): Prisma.PrismaPromise<GetBlogPostAggregateType<T>>

    /**
     * Group by BlogPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlogPostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlogPostGroupByArgs['orderBy'] }
        : { orderBy?: BlogPostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlogPostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlogPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BlogPost model
   */
  readonly fields: BlogPostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BlogPost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BlogPostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    categories<T extends BlogPost$categoriesArgs<ExtArgs> = {}>(args?: Subset<T, BlogPost$categoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostCategoryPayload<ExtArgs>, T, "findMany"> | Null>
    tags<T extends BlogPost$tagsArgs<ExtArgs> = {}>(args?: Subset<T, BlogPost$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostTagPayload<ExtArgs>, T, "findMany"> | Null>
    comments<T extends BlogPost$commentsArgs<ExtArgs> = {}>(args?: Subset<T, BlogPost$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogCommentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BlogPost model
   */ 
  interface BlogPostFieldRefs {
    readonly id: FieldRef<"BlogPost", 'String'>
    readonly title: FieldRef<"BlogPost", 'String'>
    readonly excerpt: FieldRef<"BlogPost", 'String'>
    readonly content: FieldRef<"BlogPost", 'String'>
    readonly image: FieldRef<"BlogPost", 'String'>
    readonly authorId: FieldRef<"BlogPost", 'String'>
    readonly published: FieldRef<"BlogPost", 'Boolean'>
    readonly publishedAt: FieldRef<"BlogPost", 'DateTime'>
    readonly createdAt: FieldRef<"BlogPost", 'DateTime'>
    readonly updatedAt: FieldRef<"BlogPost", 'DateTime'>
    readonly readTime: FieldRef<"BlogPost", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * BlogPost findUnique
   */
  export type BlogPostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * Filter, which BlogPost to fetch.
     */
    where: BlogPostWhereUniqueInput
  }

  /**
   * BlogPost findUniqueOrThrow
   */
  export type BlogPostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * Filter, which BlogPost to fetch.
     */
    where: BlogPostWhereUniqueInput
  }

  /**
   * BlogPost findFirst
   */
  export type BlogPostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * Filter, which BlogPost to fetch.
     */
    where?: BlogPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogPosts to fetch.
     */
    orderBy?: BlogPostOrderByWithRelationInput | BlogPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlogPosts.
     */
    cursor?: BlogPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlogPosts.
     */
    distinct?: BlogPostScalarFieldEnum | BlogPostScalarFieldEnum[]
  }

  /**
   * BlogPost findFirstOrThrow
   */
  export type BlogPostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * Filter, which BlogPost to fetch.
     */
    where?: BlogPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogPosts to fetch.
     */
    orderBy?: BlogPostOrderByWithRelationInput | BlogPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlogPosts.
     */
    cursor?: BlogPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlogPosts.
     */
    distinct?: BlogPostScalarFieldEnum | BlogPostScalarFieldEnum[]
  }

  /**
   * BlogPost findMany
   */
  export type BlogPostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * Filter, which BlogPosts to fetch.
     */
    where?: BlogPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogPosts to fetch.
     */
    orderBy?: BlogPostOrderByWithRelationInput | BlogPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BlogPosts.
     */
    cursor?: BlogPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogPosts.
     */
    skip?: number
    distinct?: BlogPostScalarFieldEnum | BlogPostScalarFieldEnum[]
  }

  /**
   * BlogPost create
   */
  export type BlogPostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * The data needed to create a BlogPost.
     */
    data: XOR<BlogPostCreateInput, BlogPostUncheckedCreateInput>
  }

  /**
   * BlogPost createMany
   */
  export type BlogPostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BlogPosts.
     */
    data: BlogPostCreateManyInput | BlogPostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BlogPost createManyAndReturn
   */
  export type BlogPostCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BlogPosts.
     */
    data: BlogPostCreateManyInput | BlogPostCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BlogPost update
   */
  export type BlogPostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * The data needed to update a BlogPost.
     */
    data: XOR<BlogPostUpdateInput, BlogPostUncheckedUpdateInput>
    /**
     * Choose, which BlogPost to update.
     */
    where: BlogPostWhereUniqueInput
  }

  /**
   * BlogPost updateMany
   */
  export type BlogPostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BlogPosts.
     */
    data: XOR<BlogPostUpdateManyMutationInput, BlogPostUncheckedUpdateManyInput>
    /**
     * Filter which BlogPosts to update
     */
    where?: BlogPostWhereInput
  }

  /**
   * BlogPost upsert
   */
  export type BlogPostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * The filter to search for the BlogPost to update in case it exists.
     */
    where: BlogPostWhereUniqueInput
    /**
     * In case the BlogPost found by the `where` argument doesn't exist, create a new BlogPost with this data.
     */
    create: XOR<BlogPostCreateInput, BlogPostUncheckedCreateInput>
    /**
     * In case the BlogPost was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BlogPostUpdateInput, BlogPostUncheckedUpdateInput>
  }

  /**
   * BlogPost delete
   */
  export type BlogPostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * Filter which BlogPost to delete.
     */
    where: BlogPostWhereUniqueInput
  }

  /**
   * BlogPost deleteMany
   */
  export type BlogPostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlogPosts to delete
     */
    where?: BlogPostWhereInput
  }

  /**
   * BlogPost.categories
   */
  export type BlogPost$categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostCategory
     */
    select?: PostCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostCategoryInclude<ExtArgs> | null
    where?: PostCategoryWhereInput
    orderBy?: PostCategoryOrderByWithRelationInput | PostCategoryOrderByWithRelationInput[]
    cursor?: PostCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostCategoryScalarFieldEnum | PostCategoryScalarFieldEnum[]
  }

  /**
   * BlogPost.tags
   */
  export type BlogPost$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTag
     */
    select?: PostTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTagInclude<ExtArgs> | null
    where?: PostTagWhereInput
    orderBy?: PostTagOrderByWithRelationInput | PostTagOrderByWithRelationInput[]
    cursor?: PostTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostTagScalarFieldEnum | PostTagScalarFieldEnum[]
  }

  /**
   * BlogPost.comments
   */
  export type BlogPost$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogComment
     */
    select?: BlogCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogCommentInclude<ExtArgs> | null
    where?: BlogCommentWhereInput
    orderBy?: BlogCommentOrderByWithRelationInput | BlogCommentOrderByWithRelationInput[]
    cursor?: BlogCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlogCommentScalarFieldEnum | BlogCommentScalarFieldEnum[]
  }

  /**
   * BlogPost without action
   */
  export type BlogPostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
  }


  /**
   * Model Category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    description: number
    _all: number
  }


  export type CategoryMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Category to aggregate.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithAggregationInput | CategoryOrderByWithAggregationInput[]
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }

  export type CategoryGroupByOutputType = {
    id: string
    name: string
    slug: string
    description: string | null
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    posts?: boolean | Category$postsArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
  }, ExtArgs["result"]["category"]>

  export type CategorySelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
  }

  export type CategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posts?: boolean | Category$postsArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Category"
    objects: {
      posts: Prisma.$PostCategoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      description: string | null
    }, ExtArgs["result"]["category"]>
    composites: {}
  }

  type CategoryGetPayload<S extends boolean | null | undefined | CategoryDefaultArgs> = $Result.GetResult<Prisma.$CategoryPayload, S>

  type CategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CategoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface CategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Category'], meta: { name: 'Category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoryFindUniqueArgs>(args: SelectSubset<T, CategoryFindUniqueArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Category that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoryFindFirstArgs>(args?: SelectSubset<T, CategoryFindFirstArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategoryFindManyArgs>(args?: SelectSubset<T, CategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
     */
    create<T extends CategoryCreateArgs>(args: SelectSubset<T, CategoryCreateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Categories.
     * @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoryCreateManyArgs>(args?: SelectSubset<T, CategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Categories and returns the data saved in the database.
     * @param {CategoryCreateManyAndReturnArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, CategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
     */
    delete<T extends CategoryDeleteArgs>(args: SelectSubset<T, CategoryDeleteArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoryUpdateArgs>(args: SelectSubset<T, CategoryUpdateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoryDeleteManyArgs>(args?: SelectSubset<T, CategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoryUpdateManyArgs>(args: SelectSubset<T, CategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
     */
    upsert<T extends CategoryUpsertArgs>(args: SelectSubset<T, CategoryUpsertArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Category model
   */
  readonly fields: CategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    posts<T extends Category$postsArgs<ExtArgs> = {}>(args?: Subset<T, Category$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostCategoryPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Category model
   */ 
  interface CategoryFieldRefs {
    readonly id: FieldRef<"Category", 'String'>
    readonly name: FieldRef<"Category", 'String'>
    readonly slug: FieldRef<"Category", 'String'>
    readonly description: FieldRef<"Category", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Category findUnique
   */
  export type CategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findFirst
   */
  export type CategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findMany
   */
  export type CategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category create
   */
  export type CategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Category.
     */
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }

  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category createManyAndReturn
   */
  export type CategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category update
   */
  export type CategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Category.
     */
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
  }

  /**
   * Category upsert
   */
  export type CategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Category to update in case it exists.
     */
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     */
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }

  /**
   * Category delete
   */
  export type CategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter which Category to delete.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoryWhereInput
  }

  /**
   * Category.posts
   */
  export type Category$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostCategory
     */
    select?: PostCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostCategoryInclude<ExtArgs> | null
    where?: PostCategoryWhereInput
    orderBy?: PostCategoryOrderByWithRelationInput | PostCategoryOrderByWithRelationInput[]
    cursor?: PostCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostCategoryScalarFieldEnum | PostCategoryScalarFieldEnum[]
  }

  /**
   * Category without action
   */
  export type CategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
  }


  /**
   * Model PostCategory
   */

  export type AggregatePostCategory = {
    _count: PostCategoryCountAggregateOutputType | null
    _min: PostCategoryMinAggregateOutputType | null
    _max: PostCategoryMaxAggregateOutputType | null
  }

  export type PostCategoryMinAggregateOutputType = {
    postId: string | null
    categoryId: string | null
  }

  export type PostCategoryMaxAggregateOutputType = {
    postId: string | null
    categoryId: string | null
  }

  export type PostCategoryCountAggregateOutputType = {
    postId: number
    categoryId: number
    _all: number
  }


  export type PostCategoryMinAggregateInputType = {
    postId?: true
    categoryId?: true
  }

  export type PostCategoryMaxAggregateInputType = {
    postId?: true
    categoryId?: true
  }

  export type PostCategoryCountAggregateInputType = {
    postId?: true
    categoryId?: true
    _all?: true
  }

  export type PostCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostCategory to aggregate.
     */
    where?: PostCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostCategories to fetch.
     */
    orderBy?: PostCategoryOrderByWithRelationInput | PostCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PostCategories
    **/
    _count?: true | PostCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostCategoryMaxAggregateInputType
  }

  export type GetPostCategoryAggregateType<T extends PostCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregatePostCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePostCategory[P]>
      : GetScalarType<T[P], AggregatePostCategory[P]>
  }




  export type PostCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostCategoryWhereInput
    orderBy?: PostCategoryOrderByWithAggregationInput | PostCategoryOrderByWithAggregationInput[]
    by: PostCategoryScalarFieldEnum[] | PostCategoryScalarFieldEnum
    having?: PostCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostCategoryCountAggregateInputType | true
    _min?: PostCategoryMinAggregateInputType
    _max?: PostCategoryMaxAggregateInputType
  }

  export type PostCategoryGroupByOutputType = {
    postId: string
    categoryId: string
    _count: PostCategoryCountAggregateOutputType | null
    _min: PostCategoryMinAggregateOutputType | null
    _max: PostCategoryMaxAggregateOutputType | null
  }

  type GetPostCategoryGroupByPayload<T extends PostCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], PostCategoryGroupByOutputType[P]>
        }
      >
    >


  export type PostCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    postId?: boolean
    categoryId?: boolean
    post?: boolean | BlogPostDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postCategory"]>

  export type PostCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    postId?: boolean
    categoryId?: boolean
    post?: boolean | BlogPostDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postCategory"]>

  export type PostCategorySelectScalar = {
    postId?: boolean
    categoryId?: boolean
  }

  export type PostCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | BlogPostDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }
  export type PostCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | BlogPostDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }

  export type $PostCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PostCategory"
    objects: {
      post: Prisma.$BlogPostPayload<ExtArgs>
      category: Prisma.$CategoryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      postId: string
      categoryId: string
    }, ExtArgs["result"]["postCategory"]>
    composites: {}
  }

  type PostCategoryGetPayload<S extends boolean | null | undefined | PostCategoryDefaultArgs> = $Result.GetResult<Prisma.$PostCategoryPayload, S>

  type PostCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PostCategoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PostCategoryCountAggregateInputType | true
    }

  export interface PostCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PostCategory'], meta: { name: 'PostCategory' } }
    /**
     * Find zero or one PostCategory that matches the filter.
     * @param {PostCategoryFindUniqueArgs} args - Arguments to find a PostCategory
     * @example
     * // Get one PostCategory
     * const postCategory = await prisma.postCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PostCategoryFindUniqueArgs>(args: SelectSubset<T, PostCategoryFindUniqueArgs<ExtArgs>>): Prisma__PostCategoryClient<$Result.GetResult<Prisma.$PostCategoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PostCategory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PostCategoryFindUniqueOrThrowArgs} args - Arguments to find a PostCategory
     * @example
     * // Get one PostCategory
     * const postCategory = await prisma.postCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PostCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, PostCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PostCategoryClient<$Result.GetResult<Prisma.$PostCategoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PostCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostCategoryFindFirstArgs} args - Arguments to find a PostCategory
     * @example
     * // Get one PostCategory
     * const postCategory = await prisma.postCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PostCategoryFindFirstArgs>(args?: SelectSubset<T, PostCategoryFindFirstArgs<ExtArgs>>): Prisma__PostCategoryClient<$Result.GetResult<Prisma.$PostCategoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PostCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostCategoryFindFirstOrThrowArgs} args - Arguments to find a PostCategory
     * @example
     * // Get one PostCategory
     * const postCategory = await prisma.postCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PostCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, PostCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__PostCategoryClient<$Result.GetResult<Prisma.$PostCategoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PostCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PostCategories
     * const postCategories = await prisma.postCategory.findMany()
     * 
     * // Get first 10 PostCategories
     * const postCategories = await prisma.postCategory.findMany({ take: 10 })
     * 
     * // Only select the `postId`
     * const postCategoryWithPostIdOnly = await prisma.postCategory.findMany({ select: { postId: true } })
     * 
     */
    findMany<T extends PostCategoryFindManyArgs>(args?: SelectSubset<T, PostCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostCategoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PostCategory.
     * @param {PostCategoryCreateArgs} args - Arguments to create a PostCategory.
     * @example
     * // Create one PostCategory
     * const PostCategory = await prisma.postCategory.create({
     *   data: {
     *     // ... data to create a PostCategory
     *   }
     * })
     * 
     */
    create<T extends PostCategoryCreateArgs>(args: SelectSubset<T, PostCategoryCreateArgs<ExtArgs>>): Prisma__PostCategoryClient<$Result.GetResult<Prisma.$PostCategoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PostCategories.
     * @param {PostCategoryCreateManyArgs} args - Arguments to create many PostCategories.
     * @example
     * // Create many PostCategories
     * const postCategory = await prisma.postCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PostCategoryCreateManyArgs>(args?: SelectSubset<T, PostCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PostCategories and returns the data saved in the database.
     * @param {PostCategoryCreateManyAndReturnArgs} args - Arguments to create many PostCategories.
     * @example
     * // Create many PostCategories
     * const postCategory = await prisma.postCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PostCategories and only return the `postId`
     * const postCategoryWithPostIdOnly = await prisma.postCategory.createManyAndReturn({ 
     *   select: { postId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PostCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, PostCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostCategoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PostCategory.
     * @param {PostCategoryDeleteArgs} args - Arguments to delete one PostCategory.
     * @example
     * // Delete one PostCategory
     * const PostCategory = await prisma.postCategory.delete({
     *   where: {
     *     // ... filter to delete one PostCategory
     *   }
     * })
     * 
     */
    delete<T extends PostCategoryDeleteArgs>(args: SelectSubset<T, PostCategoryDeleteArgs<ExtArgs>>): Prisma__PostCategoryClient<$Result.GetResult<Prisma.$PostCategoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PostCategory.
     * @param {PostCategoryUpdateArgs} args - Arguments to update one PostCategory.
     * @example
     * // Update one PostCategory
     * const postCategory = await prisma.postCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PostCategoryUpdateArgs>(args: SelectSubset<T, PostCategoryUpdateArgs<ExtArgs>>): Prisma__PostCategoryClient<$Result.GetResult<Prisma.$PostCategoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PostCategories.
     * @param {PostCategoryDeleteManyArgs} args - Arguments to filter PostCategories to delete.
     * @example
     * // Delete a few PostCategories
     * const { count } = await prisma.postCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PostCategoryDeleteManyArgs>(args?: SelectSubset<T, PostCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PostCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PostCategories
     * const postCategory = await prisma.postCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PostCategoryUpdateManyArgs>(args: SelectSubset<T, PostCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PostCategory.
     * @param {PostCategoryUpsertArgs} args - Arguments to update or create a PostCategory.
     * @example
     * // Update or create a PostCategory
     * const postCategory = await prisma.postCategory.upsert({
     *   create: {
     *     // ... data to create a PostCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PostCategory we want to update
     *   }
     * })
     */
    upsert<T extends PostCategoryUpsertArgs>(args: SelectSubset<T, PostCategoryUpsertArgs<ExtArgs>>): Prisma__PostCategoryClient<$Result.GetResult<Prisma.$PostCategoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PostCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostCategoryCountArgs} args - Arguments to filter PostCategories to count.
     * @example
     * // Count the number of PostCategories
     * const count = await prisma.postCategory.count({
     *   where: {
     *     // ... the filter for the PostCategories we want to count
     *   }
     * })
    **/
    count<T extends PostCategoryCountArgs>(
      args?: Subset<T, PostCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PostCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostCategoryAggregateArgs>(args: Subset<T, PostCategoryAggregateArgs>): Prisma.PrismaPromise<GetPostCategoryAggregateType<T>>

    /**
     * Group by PostCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostCategoryGroupByArgs['orderBy'] }
        : { orderBy?: PostCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PostCategory model
   */
  readonly fields: PostCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PostCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PostCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    post<T extends BlogPostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BlogPostDefaultArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    category<T extends CategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CategoryDefaultArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PostCategory model
   */ 
  interface PostCategoryFieldRefs {
    readonly postId: FieldRef<"PostCategory", 'String'>
    readonly categoryId: FieldRef<"PostCategory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PostCategory findUnique
   */
  export type PostCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostCategory
     */
    select?: PostCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostCategoryInclude<ExtArgs> | null
    /**
     * Filter, which PostCategory to fetch.
     */
    where: PostCategoryWhereUniqueInput
  }

  /**
   * PostCategory findUniqueOrThrow
   */
  export type PostCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostCategory
     */
    select?: PostCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostCategoryInclude<ExtArgs> | null
    /**
     * Filter, which PostCategory to fetch.
     */
    where: PostCategoryWhereUniqueInput
  }

  /**
   * PostCategory findFirst
   */
  export type PostCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostCategory
     */
    select?: PostCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostCategoryInclude<ExtArgs> | null
    /**
     * Filter, which PostCategory to fetch.
     */
    where?: PostCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostCategories to fetch.
     */
    orderBy?: PostCategoryOrderByWithRelationInput | PostCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostCategories.
     */
    cursor?: PostCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostCategories.
     */
    distinct?: PostCategoryScalarFieldEnum | PostCategoryScalarFieldEnum[]
  }

  /**
   * PostCategory findFirstOrThrow
   */
  export type PostCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostCategory
     */
    select?: PostCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostCategoryInclude<ExtArgs> | null
    /**
     * Filter, which PostCategory to fetch.
     */
    where?: PostCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostCategories to fetch.
     */
    orderBy?: PostCategoryOrderByWithRelationInput | PostCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostCategories.
     */
    cursor?: PostCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostCategories.
     */
    distinct?: PostCategoryScalarFieldEnum | PostCategoryScalarFieldEnum[]
  }

  /**
   * PostCategory findMany
   */
  export type PostCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostCategory
     */
    select?: PostCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostCategoryInclude<ExtArgs> | null
    /**
     * Filter, which PostCategories to fetch.
     */
    where?: PostCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostCategories to fetch.
     */
    orderBy?: PostCategoryOrderByWithRelationInput | PostCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PostCategories.
     */
    cursor?: PostCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostCategories.
     */
    skip?: number
    distinct?: PostCategoryScalarFieldEnum | PostCategoryScalarFieldEnum[]
  }

  /**
   * PostCategory create
   */
  export type PostCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostCategory
     */
    select?: PostCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a PostCategory.
     */
    data: XOR<PostCategoryCreateInput, PostCategoryUncheckedCreateInput>
  }

  /**
   * PostCategory createMany
   */
  export type PostCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PostCategories.
     */
    data: PostCategoryCreateManyInput | PostCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PostCategory createManyAndReturn
   */
  export type PostCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostCategory
     */
    select?: PostCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PostCategories.
     */
    data: PostCategoryCreateManyInput | PostCategoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostCategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PostCategory update
   */
  export type PostCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostCategory
     */
    select?: PostCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a PostCategory.
     */
    data: XOR<PostCategoryUpdateInput, PostCategoryUncheckedUpdateInput>
    /**
     * Choose, which PostCategory to update.
     */
    where: PostCategoryWhereUniqueInput
  }

  /**
   * PostCategory updateMany
   */
  export type PostCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PostCategories.
     */
    data: XOR<PostCategoryUpdateManyMutationInput, PostCategoryUncheckedUpdateManyInput>
    /**
     * Filter which PostCategories to update
     */
    where?: PostCategoryWhereInput
  }

  /**
   * PostCategory upsert
   */
  export type PostCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostCategory
     */
    select?: PostCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the PostCategory to update in case it exists.
     */
    where: PostCategoryWhereUniqueInput
    /**
     * In case the PostCategory found by the `where` argument doesn't exist, create a new PostCategory with this data.
     */
    create: XOR<PostCategoryCreateInput, PostCategoryUncheckedCreateInput>
    /**
     * In case the PostCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostCategoryUpdateInput, PostCategoryUncheckedUpdateInput>
  }

  /**
   * PostCategory delete
   */
  export type PostCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostCategory
     */
    select?: PostCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostCategoryInclude<ExtArgs> | null
    /**
     * Filter which PostCategory to delete.
     */
    where: PostCategoryWhereUniqueInput
  }

  /**
   * PostCategory deleteMany
   */
  export type PostCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostCategories to delete
     */
    where?: PostCategoryWhereInput
  }

  /**
   * PostCategory without action
   */
  export type PostCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostCategory
     */
    select?: PostCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostCategoryInclude<ExtArgs> | null
  }


  /**
   * Model Tag
   */

  export type AggregateTag = {
    _count: TagCountAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  export type TagMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
  }

  export type TagMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
  }

  export type TagCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    _all: number
  }


  export type TagMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
  }

  export type TagMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
  }

  export type TagCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    _all?: true
  }

  export type TagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tag to aggregate.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tags
    **/
    _count?: true | TagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagMaxAggregateInputType
  }

  export type GetTagAggregateType<T extends TagAggregateArgs> = {
        [P in keyof T & keyof AggregateTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTag[P]>
      : GetScalarType<T[P], AggregateTag[P]>
  }




  export type TagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
    orderBy?: TagOrderByWithAggregationInput | TagOrderByWithAggregationInput[]
    by: TagScalarFieldEnum[] | TagScalarFieldEnum
    having?: TagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagCountAggregateInputType | true
    _min?: TagMinAggregateInputType
    _max?: TagMaxAggregateInputType
  }

  export type TagGroupByOutputType = {
    id: string
    name: string
    slug: string
    _count: TagCountAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  type GetTagGroupByPayload<T extends TagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TagGroupByOutputType[P]>
            : GetScalarType<T[P], TagGroupByOutputType[P]>
        }
      >
    >


  export type TagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    posts?: boolean | Tag$postsArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tag"]>

  export type TagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
  }, ExtArgs["result"]["tag"]>

  export type TagSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
  }

  export type TagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posts?: boolean | Tag$postsArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tag"
    objects: {
      posts: Prisma.$PostTagPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
    }, ExtArgs["result"]["tag"]>
    composites: {}
  }

  type TagGetPayload<S extends boolean | null | undefined | TagDefaultArgs> = $Result.GetResult<Prisma.$TagPayload, S>

  type TagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TagFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TagCountAggregateInputType | true
    }

  export interface TagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tag'], meta: { name: 'Tag' } }
    /**
     * Find zero or one Tag that matches the filter.
     * @param {TagFindUniqueArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TagFindUniqueArgs>(args: SelectSubset<T, TagFindUniqueArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Tag that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TagFindUniqueOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TagFindUniqueOrThrowArgs>(args: SelectSubset<T, TagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Tag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TagFindFirstArgs>(args?: SelectSubset<T, TagFindFirstArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Tag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TagFindFirstOrThrowArgs>(args?: SelectSubset<T, TagFindFirstOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tags
     * const tags = await prisma.tag.findMany()
     * 
     * // Get first 10 Tags
     * const tags = await prisma.tag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tagWithIdOnly = await prisma.tag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TagFindManyArgs>(args?: SelectSubset<T, TagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Tag.
     * @param {TagCreateArgs} args - Arguments to create a Tag.
     * @example
     * // Create one Tag
     * const Tag = await prisma.tag.create({
     *   data: {
     *     // ... data to create a Tag
     *   }
     * })
     * 
     */
    create<T extends TagCreateArgs>(args: SelectSubset<T, TagCreateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tags.
     * @param {TagCreateManyArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TagCreateManyArgs>(args?: SelectSubset<T, TagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tags and returns the data saved in the database.
     * @param {TagCreateManyAndReturnArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tags and only return the `id`
     * const tagWithIdOnly = await prisma.tag.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TagCreateManyAndReturnArgs>(args?: SelectSubset<T, TagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Tag.
     * @param {TagDeleteArgs} args - Arguments to delete one Tag.
     * @example
     * // Delete one Tag
     * const Tag = await prisma.tag.delete({
     *   where: {
     *     // ... filter to delete one Tag
     *   }
     * })
     * 
     */
    delete<T extends TagDeleteArgs>(args: SelectSubset<T, TagDeleteArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Tag.
     * @param {TagUpdateArgs} args - Arguments to update one Tag.
     * @example
     * // Update one Tag
     * const tag = await prisma.tag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TagUpdateArgs>(args: SelectSubset<T, TagUpdateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tags.
     * @param {TagDeleteManyArgs} args - Arguments to filter Tags to delete.
     * @example
     * // Delete a few Tags
     * const { count } = await prisma.tag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TagDeleteManyArgs>(args?: SelectSubset<T, TagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TagUpdateManyArgs>(args: SelectSubset<T, TagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tag.
     * @param {TagUpsertArgs} args - Arguments to update or create a Tag.
     * @example
     * // Update or create a Tag
     * const tag = await prisma.tag.upsert({
     *   create: {
     *     // ... data to create a Tag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tag we want to update
     *   }
     * })
     */
    upsert<T extends TagUpsertArgs>(args: SelectSubset<T, TagUpsertArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagCountArgs} args - Arguments to filter Tags to count.
     * @example
     * // Count the number of Tags
     * const count = await prisma.tag.count({
     *   where: {
     *     // ... the filter for the Tags we want to count
     *   }
     * })
    **/
    count<T extends TagCountArgs>(
      args?: Subset<T, TagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagAggregateArgs>(args: Subset<T, TagAggregateArgs>): Prisma.PrismaPromise<GetTagAggregateType<T>>

    /**
     * Group by Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TagGroupByArgs['orderBy'] }
        : { orderBy?: TagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tag model
   */
  readonly fields: TagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    posts<T extends Tag$postsArgs<ExtArgs> = {}>(args?: Subset<T, Tag$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostTagPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tag model
   */ 
  interface TagFieldRefs {
    readonly id: FieldRef<"Tag", 'String'>
    readonly name: FieldRef<"Tag", 'String'>
    readonly slug: FieldRef<"Tag", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Tag findUnique
   */
  export type TagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findUniqueOrThrow
   */
  export type TagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findFirst
   */
  export type TagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findFirstOrThrow
   */
  export type TagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findMany
   */
  export type TagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag create
   */
  export type TagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to create a Tag.
     */
    data: XOR<TagCreateInput, TagUncheckedCreateInput>
  }

  /**
   * Tag createMany
   */
  export type TagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tag createManyAndReturn
   */
  export type TagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tag update
   */
  export type TagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to update a Tag.
     */
    data: XOR<TagUpdateInput, TagUncheckedUpdateInput>
    /**
     * Choose, which Tag to update.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag updateMany
   */
  export type TagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
  }

  /**
   * Tag upsert
   */
  export type TagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The filter to search for the Tag to update in case it exists.
     */
    where: TagWhereUniqueInput
    /**
     * In case the Tag found by the `where` argument doesn't exist, create a new Tag with this data.
     */
    create: XOR<TagCreateInput, TagUncheckedCreateInput>
    /**
     * In case the Tag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TagUpdateInput, TagUncheckedUpdateInput>
  }

  /**
   * Tag delete
   */
  export type TagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter which Tag to delete.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag deleteMany
   */
  export type TagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tags to delete
     */
    where?: TagWhereInput
  }

  /**
   * Tag.posts
   */
  export type Tag$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTag
     */
    select?: PostTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTagInclude<ExtArgs> | null
    where?: PostTagWhereInput
    orderBy?: PostTagOrderByWithRelationInput | PostTagOrderByWithRelationInput[]
    cursor?: PostTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostTagScalarFieldEnum | PostTagScalarFieldEnum[]
  }

  /**
   * Tag without action
   */
  export type TagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
  }


  /**
   * Model PostTag
   */

  export type AggregatePostTag = {
    _count: PostTagCountAggregateOutputType | null
    _min: PostTagMinAggregateOutputType | null
    _max: PostTagMaxAggregateOutputType | null
  }

  export type PostTagMinAggregateOutputType = {
    postId: string | null
    tagId: string | null
  }

  export type PostTagMaxAggregateOutputType = {
    postId: string | null
    tagId: string | null
  }

  export type PostTagCountAggregateOutputType = {
    postId: number
    tagId: number
    _all: number
  }


  export type PostTagMinAggregateInputType = {
    postId?: true
    tagId?: true
  }

  export type PostTagMaxAggregateInputType = {
    postId?: true
    tagId?: true
  }

  export type PostTagCountAggregateInputType = {
    postId?: true
    tagId?: true
    _all?: true
  }

  export type PostTagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostTag to aggregate.
     */
    where?: PostTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostTags to fetch.
     */
    orderBy?: PostTagOrderByWithRelationInput | PostTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PostTags
    **/
    _count?: true | PostTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostTagMaxAggregateInputType
  }

  export type GetPostTagAggregateType<T extends PostTagAggregateArgs> = {
        [P in keyof T & keyof AggregatePostTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePostTag[P]>
      : GetScalarType<T[P], AggregatePostTag[P]>
  }




  export type PostTagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostTagWhereInput
    orderBy?: PostTagOrderByWithAggregationInput | PostTagOrderByWithAggregationInput[]
    by: PostTagScalarFieldEnum[] | PostTagScalarFieldEnum
    having?: PostTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostTagCountAggregateInputType | true
    _min?: PostTagMinAggregateInputType
    _max?: PostTagMaxAggregateInputType
  }

  export type PostTagGroupByOutputType = {
    postId: string
    tagId: string
    _count: PostTagCountAggregateOutputType | null
    _min: PostTagMinAggregateOutputType | null
    _max: PostTagMaxAggregateOutputType | null
  }

  type GetPostTagGroupByPayload<T extends PostTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostTagGroupByOutputType[P]>
            : GetScalarType<T[P], PostTagGroupByOutputType[P]>
        }
      >
    >


  export type PostTagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    postId?: boolean
    tagId?: boolean
    post?: boolean | BlogPostDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postTag"]>

  export type PostTagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    postId?: boolean
    tagId?: boolean
    post?: boolean | BlogPostDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postTag"]>

  export type PostTagSelectScalar = {
    postId?: boolean
    tagId?: boolean
  }

  export type PostTagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | BlogPostDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }
  export type PostTagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | BlogPostDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }

  export type $PostTagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PostTag"
    objects: {
      post: Prisma.$BlogPostPayload<ExtArgs>
      tag: Prisma.$TagPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      postId: string
      tagId: string
    }, ExtArgs["result"]["postTag"]>
    composites: {}
  }

  type PostTagGetPayload<S extends boolean | null | undefined | PostTagDefaultArgs> = $Result.GetResult<Prisma.$PostTagPayload, S>

  type PostTagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PostTagFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PostTagCountAggregateInputType | true
    }

  export interface PostTagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PostTag'], meta: { name: 'PostTag' } }
    /**
     * Find zero or one PostTag that matches the filter.
     * @param {PostTagFindUniqueArgs} args - Arguments to find a PostTag
     * @example
     * // Get one PostTag
     * const postTag = await prisma.postTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PostTagFindUniqueArgs>(args: SelectSubset<T, PostTagFindUniqueArgs<ExtArgs>>): Prisma__PostTagClient<$Result.GetResult<Prisma.$PostTagPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PostTag that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PostTagFindUniqueOrThrowArgs} args - Arguments to find a PostTag
     * @example
     * // Get one PostTag
     * const postTag = await prisma.postTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PostTagFindUniqueOrThrowArgs>(args: SelectSubset<T, PostTagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PostTagClient<$Result.GetResult<Prisma.$PostTagPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PostTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostTagFindFirstArgs} args - Arguments to find a PostTag
     * @example
     * // Get one PostTag
     * const postTag = await prisma.postTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PostTagFindFirstArgs>(args?: SelectSubset<T, PostTagFindFirstArgs<ExtArgs>>): Prisma__PostTagClient<$Result.GetResult<Prisma.$PostTagPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PostTag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostTagFindFirstOrThrowArgs} args - Arguments to find a PostTag
     * @example
     * // Get one PostTag
     * const postTag = await prisma.postTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PostTagFindFirstOrThrowArgs>(args?: SelectSubset<T, PostTagFindFirstOrThrowArgs<ExtArgs>>): Prisma__PostTagClient<$Result.GetResult<Prisma.$PostTagPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PostTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostTagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PostTags
     * const postTags = await prisma.postTag.findMany()
     * 
     * // Get first 10 PostTags
     * const postTags = await prisma.postTag.findMany({ take: 10 })
     * 
     * // Only select the `postId`
     * const postTagWithPostIdOnly = await prisma.postTag.findMany({ select: { postId: true } })
     * 
     */
    findMany<T extends PostTagFindManyArgs>(args?: SelectSubset<T, PostTagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostTagPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PostTag.
     * @param {PostTagCreateArgs} args - Arguments to create a PostTag.
     * @example
     * // Create one PostTag
     * const PostTag = await prisma.postTag.create({
     *   data: {
     *     // ... data to create a PostTag
     *   }
     * })
     * 
     */
    create<T extends PostTagCreateArgs>(args: SelectSubset<T, PostTagCreateArgs<ExtArgs>>): Prisma__PostTagClient<$Result.GetResult<Prisma.$PostTagPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PostTags.
     * @param {PostTagCreateManyArgs} args - Arguments to create many PostTags.
     * @example
     * // Create many PostTags
     * const postTag = await prisma.postTag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PostTagCreateManyArgs>(args?: SelectSubset<T, PostTagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PostTags and returns the data saved in the database.
     * @param {PostTagCreateManyAndReturnArgs} args - Arguments to create many PostTags.
     * @example
     * // Create many PostTags
     * const postTag = await prisma.postTag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PostTags and only return the `postId`
     * const postTagWithPostIdOnly = await prisma.postTag.createManyAndReturn({ 
     *   select: { postId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PostTagCreateManyAndReturnArgs>(args?: SelectSubset<T, PostTagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostTagPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PostTag.
     * @param {PostTagDeleteArgs} args - Arguments to delete one PostTag.
     * @example
     * // Delete one PostTag
     * const PostTag = await prisma.postTag.delete({
     *   where: {
     *     // ... filter to delete one PostTag
     *   }
     * })
     * 
     */
    delete<T extends PostTagDeleteArgs>(args: SelectSubset<T, PostTagDeleteArgs<ExtArgs>>): Prisma__PostTagClient<$Result.GetResult<Prisma.$PostTagPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PostTag.
     * @param {PostTagUpdateArgs} args - Arguments to update one PostTag.
     * @example
     * // Update one PostTag
     * const postTag = await prisma.postTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PostTagUpdateArgs>(args: SelectSubset<T, PostTagUpdateArgs<ExtArgs>>): Prisma__PostTagClient<$Result.GetResult<Prisma.$PostTagPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PostTags.
     * @param {PostTagDeleteManyArgs} args - Arguments to filter PostTags to delete.
     * @example
     * // Delete a few PostTags
     * const { count } = await prisma.postTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PostTagDeleteManyArgs>(args?: SelectSubset<T, PostTagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PostTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PostTags
     * const postTag = await prisma.postTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PostTagUpdateManyArgs>(args: SelectSubset<T, PostTagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PostTag.
     * @param {PostTagUpsertArgs} args - Arguments to update or create a PostTag.
     * @example
     * // Update or create a PostTag
     * const postTag = await prisma.postTag.upsert({
     *   create: {
     *     // ... data to create a PostTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PostTag we want to update
     *   }
     * })
     */
    upsert<T extends PostTagUpsertArgs>(args: SelectSubset<T, PostTagUpsertArgs<ExtArgs>>): Prisma__PostTagClient<$Result.GetResult<Prisma.$PostTagPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PostTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostTagCountArgs} args - Arguments to filter PostTags to count.
     * @example
     * // Count the number of PostTags
     * const count = await prisma.postTag.count({
     *   where: {
     *     // ... the filter for the PostTags we want to count
     *   }
     * })
    **/
    count<T extends PostTagCountArgs>(
      args?: Subset<T, PostTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PostTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostTagAggregateArgs>(args: Subset<T, PostTagAggregateArgs>): Prisma.PrismaPromise<GetPostTagAggregateType<T>>

    /**
     * Group by PostTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostTagGroupByArgs['orderBy'] }
        : { orderBy?: PostTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PostTag model
   */
  readonly fields: PostTagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PostTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PostTagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    post<T extends BlogPostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BlogPostDefaultArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    tag<T extends TagDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TagDefaultArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PostTag model
   */ 
  interface PostTagFieldRefs {
    readonly postId: FieldRef<"PostTag", 'String'>
    readonly tagId: FieldRef<"PostTag", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PostTag findUnique
   */
  export type PostTagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTag
     */
    select?: PostTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTagInclude<ExtArgs> | null
    /**
     * Filter, which PostTag to fetch.
     */
    where: PostTagWhereUniqueInput
  }

  /**
   * PostTag findUniqueOrThrow
   */
  export type PostTagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTag
     */
    select?: PostTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTagInclude<ExtArgs> | null
    /**
     * Filter, which PostTag to fetch.
     */
    where: PostTagWhereUniqueInput
  }

  /**
   * PostTag findFirst
   */
  export type PostTagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTag
     */
    select?: PostTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTagInclude<ExtArgs> | null
    /**
     * Filter, which PostTag to fetch.
     */
    where?: PostTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostTags to fetch.
     */
    orderBy?: PostTagOrderByWithRelationInput | PostTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostTags.
     */
    cursor?: PostTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostTags.
     */
    distinct?: PostTagScalarFieldEnum | PostTagScalarFieldEnum[]
  }

  /**
   * PostTag findFirstOrThrow
   */
  export type PostTagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTag
     */
    select?: PostTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTagInclude<ExtArgs> | null
    /**
     * Filter, which PostTag to fetch.
     */
    where?: PostTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostTags to fetch.
     */
    orderBy?: PostTagOrderByWithRelationInput | PostTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostTags.
     */
    cursor?: PostTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostTags.
     */
    distinct?: PostTagScalarFieldEnum | PostTagScalarFieldEnum[]
  }

  /**
   * PostTag findMany
   */
  export type PostTagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTag
     */
    select?: PostTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTagInclude<ExtArgs> | null
    /**
     * Filter, which PostTags to fetch.
     */
    where?: PostTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostTags to fetch.
     */
    orderBy?: PostTagOrderByWithRelationInput | PostTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PostTags.
     */
    cursor?: PostTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostTags.
     */
    skip?: number
    distinct?: PostTagScalarFieldEnum | PostTagScalarFieldEnum[]
  }

  /**
   * PostTag create
   */
  export type PostTagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTag
     */
    select?: PostTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTagInclude<ExtArgs> | null
    /**
     * The data needed to create a PostTag.
     */
    data: XOR<PostTagCreateInput, PostTagUncheckedCreateInput>
  }

  /**
   * PostTag createMany
   */
  export type PostTagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PostTags.
     */
    data: PostTagCreateManyInput | PostTagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PostTag createManyAndReturn
   */
  export type PostTagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTag
     */
    select?: PostTagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PostTags.
     */
    data: PostTagCreateManyInput | PostTagCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTagIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PostTag update
   */
  export type PostTagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTag
     */
    select?: PostTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTagInclude<ExtArgs> | null
    /**
     * The data needed to update a PostTag.
     */
    data: XOR<PostTagUpdateInput, PostTagUncheckedUpdateInput>
    /**
     * Choose, which PostTag to update.
     */
    where: PostTagWhereUniqueInput
  }

  /**
   * PostTag updateMany
   */
  export type PostTagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PostTags.
     */
    data: XOR<PostTagUpdateManyMutationInput, PostTagUncheckedUpdateManyInput>
    /**
     * Filter which PostTags to update
     */
    where?: PostTagWhereInput
  }

  /**
   * PostTag upsert
   */
  export type PostTagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTag
     */
    select?: PostTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTagInclude<ExtArgs> | null
    /**
     * The filter to search for the PostTag to update in case it exists.
     */
    where: PostTagWhereUniqueInput
    /**
     * In case the PostTag found by the `where` argument doesn't exist, create a new PostTag with this data.
     */
    create: XOR<PostTagCreateInput, PostTagUncheckedCreateInput>
    /**
     * In case the PostTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostTagUpdateInput, PostTagUncheckedUpdateInput>
  }

  /**
   * PostTag delete
   */
  export type PostTagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTag
     */
    select?: PostTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTagInclude<ExtArgs> | null
    /**
     * Filter which PostTag to delete.
     */
    where: PostTagWhereUniqueInput
  }

  /**
   * PostTag deleteMany
   */
  export type PostTagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostTags to delete
     */
    where?: PostTagWhereInput
  }

  /**
   * PostTag without action
   */
  export type PostTagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTag
     */
    select?: PostTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTagInclude<ExtArgs> | null
  }


  /**
   * Model BlogComment
   */

  export type AggregateBlogComment = {
    _count: BlogCommentCountAggregateOutputType | null
    _min: BlogCommentMinAggregateOutputType | null
    _max: BlogCommentMaxAggregateOutputType | null
  }

  export type BlogCommentMinAggregateOutputType = {
    id: string | null
    postId: string | null
    userId: string | null
    content: string | null
    createdAt: Date | null
    parentId: string | null
  }

  export type BlogCommentMaxAggregateOutputType = {
    id: string | null
    postId: string | null
    userId: string | null
    content: string | null
    createdAt: Date | null
    parentId: string | null
  }

  export type BlogCommentCountAggregateOutputType = {
    id: number
    postId: number
    userId: number
    content: number
    createdAt: number
    parentId: number
    _all: number
  }


  export type BlogCommentMinAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    content?: true
    createdAt?: true
    parentId?: true
  }

  export type BlogCommentMaxAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    content?: true
    createdAt?: true
    parentId?: true
  }

  export type BlogCommentCountAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    content?: true
    createdAt?: true
    parentId?: true
    _all?: true
  }

  export type BlogCommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlogComment to aggregate.
     */
    where?: BlogCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogComments to fetch.
     */
    orderBy?: BlogCommentOrderByWithRelationInput | BlogCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BlogCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BlogComments
    **/
    _count?: true | BlogCommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlogCommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlogCommentMaxAggregateInputType
  }

  export type GetBlogCommentAggregateType<T extends BlogCommentAggregateArgs> = {
        [P in keyof T & keyof AggregateBlogComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlogComment[P]>
      : GetScalarType<T[P], AggregateBlogComment[P]>
  }




  export type BlogCommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogCommentWhereInput
    orderBy?: BlogCommentOrderByWithAggregationInput | BlogCommentOrderByWithAggregationInput[]
    by: BlogCommentScalarFieldEnum[] | BlogCommentScalarFieldEnum
    having?: BlogCommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlogCommentCountAggregateInputType | true
    _min?: BlogCommentMinAggregateInputType
    _max?: BlogCommentMaxAggregateInputType
  }

  export type BlogCommentGroupByOutputType = {
    id: string
    postId: string
    userId: string
    content: string
    createdAt: Date
    parentId: string | null
    _count: BlogCommentCountAggregateOutputType | null
    _min: BlogCommentMinAggregateOutputType | null
    _max: BlogCommentMaxAggregateOutputType | null
  }

  type GetBlogCommentGroupByPayload<T extends BlogCommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlogCommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlogCommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlogCommentGroupByOutputType[P]>
            : GetScalarType<T[P], BlogCommentGroupByOutputType[P]>
        }
      >
    >


  export type BlogCommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    userId?: boolean
    content?: boolean
    createdAt?: boolean
    parentId?: boolean
    post?: boolean | BlogPostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | BlogComment$parentArgs<ExtArgs>
    replies?: boolean | BlogComment$repliesArgs<ExtArgs>
    _count?: boolean | BlogCommentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blogComment"]>

  export type BlogCommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    userId?: boolean
    content?: boolean
    createdAt?: boolean
    parentId?: boolean
    post?: boolean | BlogPostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | BlogComment$parentArgs<ExtArgs>
  }, ExtArgs["result"]["blogComment"]>

  export type BlogCommentSelectScalar = {
    id?: boolean
    postId?: boolean
    userId?: boolean
    content?: boolean
    createdAt?: boolean
    parentId?: boolean
  }

  export type BlogCommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | BlogPostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | BlogComment$parentArgs<ExtArgs>
    replies?: boolean | BlogComment$repliesArgs<ExtArgs>
    _count?: boolean | BlogCommentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BlogCommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | BlogPostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | BlogComment$parentArgs<ExtArgs>
  }

  export type $BlogCommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BlogComment"
    objects: {
      post: Prisma.$BlogPostPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      parent: Prisma.$BlogCommentPayload<ExtArgs> | null
      replies: Prisma.$BlogCommentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      postId: string
      userId: string
      content: string
      createdAt: Date
      parentId: string | null
    }, ExtArgs["result"]["blogComment"]>
    composites: {}
  }

  type BlogCommentGetPayload<S extends boolean | null | undefined | BlogCommentDefaultArgs> = $Result.GetResult<Prisma.$BlogCommentPayload, S>

  type BlogCommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BlogCommentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BlogCommentCountAggregateInputType | true
    }

  export interface BlogCommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BlogComment'], meta: { name: 'BlogComment' } }
    /**
     * Find zero or one BlogComment that matches the filter.
     * @param {BlogCommentFindUniqueArgs} args - Arguments to find a BlogComment
     * @example
     * // Get one BlogComment
     * const blogComment = await prisma.blogComment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BlogCommentFindUniqueArgs>(args: SelectSubset<T, BlogCommentFindUniqueArgs<ExtArgs>>): Prisma__BlogCommentClient<$Result.GetResult<Prisma.$BlogCommentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BlogComment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BlogCommentFindUniqueOrThrowArgs} args - Arguments to find a BlogComment
     * @example
     * // Get one BlogComment
     * const blogComment = await prisma.blogComment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BlogCommentFindUniqueOrThrowArgs>(args: SelectSubset<T, BlogCommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BlogCommentClient<$Result.GetResult<Prisma.$BlogCommentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BlogComment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogCommentFindFirstArgs} args - Arguments to find a BlogComment
     * @example
     * // Get one BlogComment
     * const blogComment = await prisma.blogComment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BlogCommentFindFirstArgs>(args?: SelectSubset<T, BlogCommentFindFirstArgs<ExtArgs>>): Prisma__BlogCommentClient<$Result.GetResult<Prisma.$BlogCommentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BlogComment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogCommentFindFirstOrThrowArgs} args - Arguments to find a BlogComment
     * @example
     * // Get one BlogComment
     * const blogComment = await prisma.blogComment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BlogCommentFindFirstOrThrowArgs>(args?: SelectSubset<T, BlogCommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__BlogCommentClient<$Result.GetResult<Prisma.$BlogCommentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BlogComments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogCommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BlogComments
     * const blogComments = await prisma.blogComment.findMany()
     * 
     * // Get first 10 BlogComments
     * const blogComments = await prisma.blogComment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blogCommentWithIdOnly = await prisma.blogComment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BlogCommentFindManyArgs>(args?: SelectSubset<T, BlogCommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogCommentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BlogComment.
     * @param {BlogCommentCreateArgs} args - Arguments to create a BlogComment.
     * @example
     * // Create one BlogComment
     * const BlogComment = await prisma.blogComment.create({
     *   data: {
     *     // ... data to create a BlogComment
     *   }
     * })
     * 
     */
    create<T extends BlogCommentCreateArgs>(args: SelectSubset<T, BlogCommentCreateArgs<ExtArgs>>): Prisma__BlogCommentClient<$Result.GetResult<Prisma.$BlogCommentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BlogComments.
     * @param {BlogCommentCreateManyArgs} args - Arguments to create many BlogComments.
     * @example
     * // Create many BlogComments
     * const blogComment = await prisma.blogComment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BlogCommentCreateManyArgs>(args?: SelectSubset<T, BlogCommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BlogComments and returns the data saved in the database.
     * @param {BlogCommentCreateManyAndReturnArgs} args - Arguments to create many BlogComments.
     * @example
     * // Create many BlogComments
     * const blogComment = await prisma.blogComment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BlogComments and only return the `id`
     * const blogCommentWithIdOnly = await prisma.blogComment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BlogCommentCreateManyAndReturnArgs>(args?: SelectSubset<T, BlogCommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogCommentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BlogComment.
     * @param {BlogCommentDeleteArgs} args - Arguments to delete one BlogComment.
     * @example
     * // Delete one BlogComment
     * const BlogComment = await prisma.blogComment.delete({
     *   where: {
     *     // ... filter to delete one BlogComment
     *   }
     * })
     * 
     */
    delete<T extends BlogCommentDeleteArgs>(args: SelectSubset<T, BlogCommentDeleteArgs<ExtArgs>>): Prisma__BlogCommentClient<$Result.GetResult<Prisma.$BlogCommentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BlogComment.
     * @param {BlogCommentUpdateArgs} args - Arguments to update one BlogComment.
     * @example
     * // Update one BlogComment
     * const blogComment = await prisma.blogComment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BlogCommentUpdateArgs>(args: SelectSubset<T, BlogCommentUpdateArgs<ExtArgs>>): Prisma__BlogCommentClient<$Result.GetResult<Prisma.$BlogCommentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BlogComments.
     * @param {BlogCommentDeleteManyArgs} args - Arguments to filter BlogComments to delete.
     * @example
     * // Delete a few BlogComments
     * const { count } = await prisma.blogComment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BlogCommentDeleteManyArgs>(args?: SelectSubset<T, BlogCommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlogComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogCommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BlogComments
     * const blogComment = await prisma.blogComment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BlogCommentUpdateManyArgs>(args: SelectSubset<T, BlogCommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BlogComment.
     * @param {BlogCommentUpsertArgs} args - Arguments to update or create a BlogComment.
     * @example
     * // Update or create a BlogComment
     * const blogComment = await prisma.blogComment.upsert({
     *   create: {
     *     // ... data to create a BlogComment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BlogComment we want to update
     *   }
     * })
     */
    upsert<T extends BlogCommentUpsertArgs>(args: SelectSubset<T, BlogCommentUpsertArgs<ExtArgs>>): Prisma__BlogCommentClient<$Result.GetResult<Prisma.$BlogCommentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BlogComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogCommentCountArgs} args - Arguments to filter BlogComments to count.
     * @example
     * // Count the number of BlogComments
     * const count = await prisma.blogComment.count({
     *   where: {
     *     // ... the filter for the BlogComments we want to count
     *   }
     * })
    **/
    count<T extends BlogCommentCountArgs>(
      args?: Subset<T, BlogCommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlogCommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BlogComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogCommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlogCommentAggregateArgs>(args: Subset<T, BlogCommentAggregateArgs>): Prisma.PrismaPromise<GetBlogCommentAggregateType<T>>

    /**
     * Group by BlogComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogCommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlogCommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlogCommentGroupByArgs['orderBy'] }
        : { orderBy?: BlogCommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlogCommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlogCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BlogComment model
   */
  readonly fields: BlogCommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BlogComment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BlogCommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    post<T extends BlogPostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BlogPostDefaultArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    parent<T extends BlogComment$parentArgs<ExtArgs> = {}>(args?: Subset<T, BlogComment$parentArgs<ExtArgs>>): Prisma__BlogCommentClient<$Result.GetResult<Prisma.$BlogCommentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    replies<T extends BlogComment$repliesArgs<ExtArgs> = {}>(args?: Subset<T, BlogComment$repliesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogCommentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BlogComment model
   */ 
  interface BlogCommentFieldRefs {
    readonly id: FieldRef<"BlogComment", 'String'>
    readonly postId: FieldRef<"BlogComment", 'String'>
    readonly userId: FieldRef<"BlogComment", 'String'>
    readonly content: FieldRef<"BlogComment", 'String'>
    readonly createdAt: FieldRef<"BlogComment", 'DateTime'>
    readonly parentId: FieldRef<"BlogComment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BlogComment findUnique
   */
  export type BlogCommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogComment
     */
    select?: BlogCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogCommentInclude<ExtArgs> | null
    /**
     * Filter, which BlogComment to fetch.
     */
    where: BlogCommentWhereUniqueInput
  }

  /**
   * BlogComment findUniqueOrThrow
   */
  export type BlogCommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogComment
     */
    select?: BlogCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogCommentInclude<ExtArgs> | null
    /**
     * Filter, which BlogComment to fetch.
     */
    where: BlogCommentWhereUniqueInput
  }

  /**
   * BlogComment findFirst
   */
  export type BlogCommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogComment
     */
    select?: BlogCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogCommentInclude<ExtArgs> | null
    /**
     * Filter, which BlogComment to fetch.
     */
    where?: BlogCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogComments to fetch.
     */
    orderBy?: BlogCommentOrderByWithRelationInput | BlogCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlogComments.
     */
    cursor?: BlogCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlogComments.
     */
    distinct?: BlogCommentScalarFieldEnum | BlogCommentScalarFieldEnum[]
  }

  /**
   * BlogComment findFirstOrThrow
   */
  export type BlogCommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogComment
     */
    select?: BlogCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogCommentInclude<ExtArgs> | null
    /**
     * Filter, which BlogComment to fetch.
     */
    where?: BlogCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogComments to fetch.
     */
    orderBy?: BlogCommentOrderByWithRelationInput | BlogCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlogComments.
     */
    cursor?: BlogCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlogComments.
     */
    distinct?: BlogCommentScalarFieldEnum | BlogCommentScalarFieldEnum[]
  }

  /**
   * BlogComment findMany
   */
  export type BlogCommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogComment
     */
    select?: BlogCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogCommentInclude<ExtArgs> | null
    /**
     * Filter, which BlogComments to fetch.
     */
    where?: BlogCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogComments to fetch.
     */
    orderBy?: BlogCommentOrderByWithRelationInput | BlogCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BlogComments.
     */
    cursor?: BlogCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogComments.
     */
    skip?: number
    distinct?: BlogCommentScalarFieldEnum | BlogCommentScalarFieldEnum[]
  }

  /**
   * BlogComment create
   */
  export type BlogCommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogComment
     */
    select?: BlogCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogCommentInclude<ExtArgs> | null
    /**
     * The data needed to create a BlogComment.
     */
    data: XOR<BlogCommentCreateInput, BlogCommentUncheckedCreateInput>
  }

  /**
   * BlogComment createMany
   */
  export type BlogCommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BlogComments.
     */
    data: BlogCommentCreateManyInput | BlogCommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BlogComment createManyAndReturn
   */
  export type BlogCommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogComment
     */
    select?: BlogCommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BlogComments.
     */
    data: BlogCommentCreateManyInput | BlogCommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogCommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BlogComment update
   */
  export type BlogCommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogComment
     */
    select?: BlogCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogCommentInclude<ExtArgs> | null
    /**
     * The data needed to update a BlogComment.
     */
    data: XOR<BlogCommentUpdateInput, BlogCommentUncheckedUpdateInput>
    /**
     * Choose, which BlogComment to update.
     */
    where: BlogCommentWhereUniqueInput
  }

  /**
   * BlogComment updateMany
   */
  export type BlogCommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BlogComments.
     */
    data: XOR<BlogCommentUpdateManyMutationInput, BlogCommentUncheckedUpdateManyInput>
    /**
     * Filter which BlogComments to update
     */
    where?: BlogCommentWhereInput
  }

  /**
   * BlogComment upsert
   */
  export type BlogCommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogComment
     */
    select?: BlogCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogCommentInclude<ExtArgs> | null
    /**
     * The filter to search for the BlogComment to update in case it exists.
     */
    where: BlogCommentWhereUniqueInput
    /**
     * In case the BlogComment found by the `where` argument doesn't exist, create a new BlogComment with this data.
     */
    create: XOR<BlogCommentCreateInput, BlogCommentUncheckedCreateInput>
    /**
     * In case the BlogComment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BlogCommentUpdateInput, BlogCommentUncheckedUpdateInput>
  }

  /**
   * BlogComment delete
   */
  export type BlogCommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogComment
     */
    select?: BlogCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogCommentInclude<ExtArgs> | null
    /**
     * Filter which BlogComment to delete.
     */
    where: BlogCommentWhereUniqueInput
  }

  /**
   * BlogComment deleteMany
   */
  export type BlogCommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlogComments to delete
     */
    where?: BlogCommentWhereInput
  }

  /**
   * BlogComment.parent
   */
  export type BlogComment$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogComment
     */
    select?: BlogCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogCommentInclude<ExtArgs> | null
    where?: BlogCommentWhereInput
  }

  /**
   * BlogComment.replies
   */
  export type BlogComment$repliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogComment
     */
    select?: BlogCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogCommentInclude<ExtArgs> | null
    where?: BlogCommentWhereInput
    orderBy?: BlogCommentOrderByWithRelationInput | BlogCommentOrderByWithRelationInput[]
    cursor?: BlogCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlogCommentScalarFieldEnum | BlogCommentScalarFieldEnum[]
  }

  /**
   * BlogComment without action
   */
  export type BlogCommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogComment
     */
    select?: BlogCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogCommentInclude<ExtArgs> | null
  }


  /**
   * Model ReferralCode
   */

  export type AggregateReferralCode = {
    _count: ReferralCodeCountAggregateOutputType | null
    _avg: ReferralCodeAvgAggregateOutputType | null
    _sum: ReferralCodeSumAggregateOutputType | null
    _min: ReferralCodeMinAggregateOutputType | null
    _max: ReferralCodeMaxAggregateOutputType | null
  }

  export type ReferralCodeAvgAggregateOutputType = {
    usageLimit: number | null
    maxUses: number | null
    pointsReward: number | null
  }

  export type ReferralCodeSumAggregateOutputType = {
    usageLimit: number | null
    maxUses: number | null
    pointsReward: number | null
  }

  export type ReferralCodeMinAggregateOutputType = {
    id: string | null
    code: string | null
    userId: string | null
    isActive: boolean | null
    usageLimit: number | null
    maxUses: number | null
    pointsReward: number | null
    isUserCode: boolean | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReferralCodeMaxAggregateOutputType = {
    id: string | null
    code: string | null
    userId: string | null
    isActive: boolean | null
    usageLimit: number | null
    maxUses: number | null
    pointsReward: number | null
    isUserCode: boolean | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReferralCodeCountAggregateOutputType = {
    id: number
    code: number
    userId: number
    isActive: number
    usageLimit: number
    maxUses: number
    pointsReward: number
    isUserCode: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReferralCodeAvgAggregateInputType = {
    usageLimit?: true
    maxUses?: true
    pointsReward?: true
  }

  export type ReferralCodeSumAggregateInputType = {
    usageLimit?: true
    maxUses?: true
    pointsReward?: true
  }

  export type ReferralCodeMinAggregateInputType = {
    id?: true
    code?: true
    userId?: true
    isActive?: true
    usageLimit?: true
    maxUses?: true
    pointsReward?: true
    isUserCode?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReferralCodeMaxAggregateInputType = {
    id?: true
    code?: true
    userId?: true
    isActive?: true
    usageLimit?: true
    maxUses?: true
    pointsReward?: true
    isUserCode?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReferralCodeCountAggregateInputType = {
    id?: true
    code?: true
    userId?: true
    isActive?: true
    usageLimit?: true
    maxUses?: true
    pointsReward?: true
    isUserCode?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReferralCodeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReferralCode to aggregate.
     */
    where?: ReferralCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReferralCodes to fetch.
     */
    orderBy?: ReferralCodeOrderByWithRelationInput | ReferralCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReferralCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReferralCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReferralCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReferralCodes
    **/
    _count?: true | ReferralCodeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReferralCodeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReferralCodeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReferralCodeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReferralCodeMaxAggregateInputType
  }

  export type GetReferralCodeAggregateType<T extends ReferralCodeAggregateArgs> = {
        [P in keyof T & keyof AggregateReferralCode]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReferralCode[P]>
      : GetScalarType<T[P], AggregateReferralCode[P]>
  }




  export type ReferralCodeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferralCodeWhereInput
    orderBy?: ReferralCodeOrderByWithAggregationInput | ReferralCodeOrderByWithAggregationInput[]
    by: ReferralCodeScalarFieldEnum[] | ReferralCodeScalarFieldEnum
    having?: ReferralCodeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReferralCodeCountAggregateInputType | true
    _avg?: ReferralCodeAvgAggregateInputType
    _sum?: ReferralCodeSumAggregateInputType
    _min?: ReferralCodeMinAggregateInputType
    _max?: ReferralCodeMaxAggregateInputType
  }

  export type ReferralCodeGroupByOutputType = {
    id: string
    code: string
    userId: string
    isActive: boolean
    usageLimit: number | null
    maxUses: number | null
    pointsReward: number
    isUserCode: boolean
    expiresAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: ReferralCodeCountAggregateOutputType | null
    _avg: ReferralCodeAvgAggregateOutputType | null
    _sum: ReferralCodeSumAggregateOutputType | null
    _min: ReferralCodeMinAggregateOutputType | null
    _max: ReferralCodeMaxAggregateOutputType | null
  }

  type GetReferralCodeGroupByPayload<T extends ReferralCodeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReferralCodeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReferralCodeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReferralCodeGroupByOutputType[P]>
            : GetScalarType<T[P], ReferralCodeGroupByOutputType[P]>
        }
      >
    >


  export type ReferralCodeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    userId?: boolean
    isActive?: boolean
    usageLimit?: boolean
    maxUses?: boolean
    pointsReward?: boolean
    isUserCode?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    uses?: boolean | ReferralCode$usesArgs<ExtArgs>
    _count?: boolean | ReferralCodeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["referralCode"]>

  export type ReferralCodeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    userId?: boolean
    isActive?: boolean
    usageLimit?: boolean
    maxUses?: boolean
    pointsReward?: boolean
    isUserCode?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["referralCode"]>

  export type ReferralCodeSelectScalar = {
    id?: boolean
    code?: boolean
    userId?: boolean
    isActive?: boolean
    usageLimit?: boolean
    maxUses?: boolean
    pointsReward?: boolean
    isUserCode?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ReferralCodeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    uses?: boolean | ReferralCode$usesArgs<ExtArgs>
    _count?: boolean | ReferralCodeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ReferralCodeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ReferralCodePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReferralCode"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      uses: Prisma.$ReferralUsePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      userId: string
      isActive: boolean
      usageLimit: number | null
      maxUses: number | null
      pointsReward: number
      isUserCode: boolean
      expiresAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["referralCode"]>
    composites: {}
  }

  type ReferralCodeGetPayload<S extends boolean | null | undefined | ReferralCodeDefaultArgs> = $Result.GetResult<Prisma.$ReferralCodePayload, S>

  type ReferralCodeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReferralCodeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReferralCodeCountAggregateInputType | true
    }

  export interface ReferralCodeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReferralCode'], meta: { name: 'ReferralCode' } }
    /**
     * Find zero or one ReferralCode that matches the filter.
     * @param {ReferralCodeFindUniqueArgs} args - Arguments to find a ReferralCode
     * @example
     * // Get one ReferralCode
     * const referralCode = await prisma.referralCode.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReferralCodeFindUniqueArgs>(args: SelectSubset<T, ReferralCodeFindUniqueArgs<ExtArgs>>): Prisma__ReferralCodeClient<$Result.GetResult<Prisma.$ReferralCodePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ReferralCode that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReferralCodeFindUniqueOrThrowArgs} args - Arguments to find a ReferralCode
     * @example
     * // Get one ReferralCode
     * const referralCode = await prisma.referralCode.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReferralCodeFindUniqueOrThrowArgs>(args: SelectSubset<T, ReferralCodeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReferralCodeClient<$Result.GetResult<Prisma.$ReferralCodePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ReferralCode that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralCodeFindFirstArgs} args - Arguments to find a ReferralCode
     * @example
     * // Get one ReferralCode
     * const referralCode = await prisma.referralCode.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReferralCodeFindFirstArgs>(args?: SelectSubset<T, ReferralCodeFindFirstArgs<ExtArgs>>): Prisma__ReferralCodeClient<$Result.GetResult<Prisma.$ReferralCodePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ReferralCode that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralCodeFindFirstOrThrowArgs} args - Arguments to find a ReferralCode
     * @example
     * // Get one ReferralCode
     * const referralCode = await prisma.referralCode.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReferralCodeFindFirstOrThrowArgs>(args?: SelectSubset<T, ReferralCodeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReferralCodeClient<$Result.GetResult<Prisma.$ReferralCodePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ReferralCodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralCodeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReferralCodes
     * const referralCodes = await prisma.referralCode.findMany()
     * 
     * // Get first 10 ReferralCodes
     * const referralCodes = await prisma.referralCode.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const referralCodeWithIdOnly = await prisma.referralCode.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReferralCodeFindManyArgs>(args?: SelectSubset<T, ReferralCodeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralCodePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ReferralCode.
     * @param {ReferralCodeCreateArgs} args - Arguments to create a ReferralCode.
     * @example
     * // Create one ReferralCode
     * const ReferralCode = await prisma.referralCode.create({
     *   data: {
     *     // ... data to create a ReferralCode
     *   }
     * })
     * 
     */
    create<T extends ReferralCodeCreateArgs>(args: SelectSubset<T, ReferralCodeCreateArgs<ExtArgs>>): Prisma__ReferralCodeClient<$Result.GetResult<Prisma.$ReferralCodePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ReferralCodes.
     * @param {ReferralCodeCreateManyArgs} args - Arguments to create many ReferralCodes.
     * @example
     * // Create many ReferralCodes
     * const referralCode = await prisma.referralCode.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReferralCodeCreateManyArgs>(args?: SelectSubset<T, ReferralCodeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReferralCodes and returns the data saved in the database.
     * @param {ReferralCodeCreateManyAndReturnArgs} args - Arguments to create many ReferralCodes.
     * @example
     * // Create many ReferralCodes
     * const referralCode = await prisma.referralCode.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReferralCodes and only return the `id`
     * const referralCodeWithIdOnly = await prisma.referralCode.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReferralCodeCreateManyAndReturnArgs>(args?: SelectSubset<T, ReferralCodeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralCodePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ReferralCode.
     * @param {ReferralCodeDeleteArgs} args - Arguments to delete one ReferralCode.
     * @example
     * // Delete one ReferralCode
     * const ReferralCode = await prisma.referralCode.delete({
     *   where: {
     *     // ... filter to delete one ReferralCode
     *   }
     * })
     * 
     */
    delete<T extends ReferralCodeDeleteArgs>(args: SelectSubset<T, ReferralCodeDeleteArgs<ExtArgs>>): Prisma__ReferralCodeClient<$Result.GetResult<Prisma.$ReferralCodePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ReferralCode.
     * @param {ReferralCodeUpdateArgs} args - Arguments to update one ReferralCode.
     * @example
     * // Update one ReferralCode
     * const referralCode = await prisma.referralCode.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReferralCodeUpdateArgs>(args: SelectSubset<T, ReferralCodeUpdateArgs<ExtArgs>>): Prisma__ReferralCodeClient<$Result.GetResult<Prisma.$ReferralCodePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ReferralCodes.
     * @param {ReferralCodeDeleteManyArgs} args - Arguments to filter ReferralCodes to delete.
     * @example
     * // Delete a few ReferralCodes
     * const { count } = await prisma.referralCode.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReferralCodeDeleteManyArgs>(args?: SelectSubset<T, ReferralCodeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReferralCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralCodeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReferralCodes
     * const referralCode = await prisma.referralCode.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReferralCodeUpdateManyArgs>(args: SelectSubset<T, ReferralCodeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ReferralCode.
     * @param {ReferralCodeUpsertArgs} args - Arguments to update or create a ReferralCode.
     * @example
     * // Update or create a ReferralCode
     * const referralCode = await prisma.referralCode.upsert({
     *   create: {
     *     // ... data to create a ReferralCode
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReferralCode we want to update
     *   }
     * })
     */
    upsert<T extends ReferralCodeUpsertArgs>(args: SelectSubset<T, ReferralCodeUpsertArgs<ExtArgs>>): Prisma__ReferralCodeClient<$Result.GetResult<Prisma.$ReferralCodePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ReferralCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralCodeCountArgs} args - Arguments to filter ReferralCodes to count.
     * @example
     * // Count the number of ReferralCodes
     * const count = await prisma.referralCode.count({
     *   where: {
     *     // ... the filter for the ReferralCodes we want to count
     *   }
     * })
    **/
    count<T extends ReferralCodeCountArgs>(
      args?: Subset<T, ReferralCodeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReferralCodeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReferralCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralCodeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReferralCodeAggregateArgs>(args: Subset<T, ReferralCodeAggregateArgs>): Prisma.PrismaPromise<GetReferralCodeAggregateType<T>>

    /**
     * Group by ReferralCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralCodeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReferralCodeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReferralCodeGroupByArgs['orderBy'] }
        : { orderBy?: ReferralCodeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReferralCodeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReferralCodeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReferralCode model
   */
  readonly fields: ReferralCodeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReferralCode.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReferralCodeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    uses<T extends ReferralCode$usesArgs<ExtArgs> = {}>(args?: Subset<T, ReferralCode$usesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralUsePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReferralCode model
   */ 
  interface ReferralCodeFieldRefs {
    readonly id: FieldRef<"ReferralCode", 'String'>
    readonly code: FieldRef<"ReferralCode", 'String'>
    readonly userId: FieldRef<"ReferralCode", 'String'>
    readonly isActive: FieldRef<"ReferralCode", 'Boolean'>
    readonly usageLimit: FieldRef<"ReferralCode", 'Int'>
    readonly maxUses: FieldRef<"ReferralCode", 'Int'>
    readonly pointsReward: FieldRef<"ReferralCode", 'Int'>
    readonly isUserCode: FieldRef<"ReferralCode", 'Boolean'>
    readonly expiresAt: FieldRef<"ReferralCode", 'DateTime'>
    readonly createdAt: FieldRef<"ReferralCode", 'DateTime'>
    readonly updatedAt: FieldRef<"ReferralCode", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ReferralCode findUnique
   */
  export type ReferralCodeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralCode
     */
    select?: ReferralCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralCodeInclude<ExtArgs> | null
    /**
     * Filter, which ReferralCode to fetch.
     */
    where: ReferralCodeWhereUniqueInput
  }

  /**
   * ReferralCode findUniqueOrThrow
   */
  export type ReferralCodeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralCode
     */
    select?: ReferralCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralCodeInclude<ExtArgs> | null
    /**
     * Filter, which ReferralCode to fetch.
     */
    where: ReferralCodeWhereUniqueInput
  }

  /**
   * ReferralCode findFirst
   */
  export type ReferralCodeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralCode
     */
    select?: ReferralCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralCodeInclude<ExtArgs> | null
    /**
     * Filter, which ReferralCode to fetch.
     */
    where?: ReferralCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReferralCodes to fetch.
     */
    orderBy?: ReferralCodeOrderByWithRelationInput | ReferralCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReferralCodes.
     */
    cursor?: ReferralCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReferralCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReferralCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReferralCodes.
     */
    distinct?: ReferralCodeScalarFieldEnum | ReferralCodeScalarFieldEnum[]
  }

  /**
   * ReferralCode findFirstOrThrow
   */
  export type ReferralCodeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralCode
     */
    select?: ReferralCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralCodeInclude<ExtArgs> | null
    /**
     * Filter, which ReferralCode to fetch.
     */
    where?: ReferralCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReferralCodes to fetch.
     */
    orderBy?: ReferralCodeOrderByWithRelationInput | ReferralCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReferralCodes.
     */
    cursor?: ReferralCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReferralCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReferralCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReferralCodes.
     */
    distinct?: ReferralCodeScalarFieldEnum | ReferralCodeScalarFieldEnum[]
  }

  /**
   * ReferralCode findMany
   */
  export type ReferralCodeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralCode
     */
    select?: ReferralCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralCodeInclude<ExtArgs> | null
    /**
     * Filter, which ReferralCodes to fetch.
     */
    where?: ReferralCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReferralCodes to fetch.
     */
    orderBy?: ReferralCodeOrderByWithRelationInput | ReferralCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReferralCodes.
     */
    cursor?: ReferralCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReferralCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReferralCodes.
     */
    skip?: number
    distinct?: ReferralCodeScalarFieldEnum | ReferralCodeScalarFieldEnum[]
  }

  /**
   * ReferralCode create
   */
  export type ReferralCodeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralCode
     */
    select?: ReferralCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralCodeInclude<ExtArgs> | null
    /**
     * The data needed to create a ReferralCode.
     */
    data: XOR<ReferralCodeCreateInput, ReferralCodeUncheckedCreateInput>
  }

  /**
   * ReferralCode createMany
   */
  export type ReferralCodeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReferralCodes.
     */
    data: ReferralCodeCreateManyInput | ReferralCodeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReferralCode createManyAndReturn
   */
  export type ReferralCodeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralCode
     */
    select?: ReferralCodeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ReferralCodes.
     */
    data: ReferralCodeCreateManyInput | ReferralCodeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralCodeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReferralCode update
   */
  export type ReferralCodeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralCode
     */
    select?: ReferralCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralCodeInclude<ExtArgs> | null
    /**
     * The data needed to update a ReferralCode.
     */
    data: XOR<ReferralCodeUpdateInput, ReferralCodeUncheckedUpdateInput>
    /**
     * Choose, which ReferralCode to update.
     */
    where: ReferralCodeWhereUniqueInput
  }

  /**
   * ReferralCode updateMany
   */
  export type ReferralCodeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReferralCodes.
     */
    data: XOR<ReferralCodeUpdateManyMutationInput, ReferralCodeUncheckedUpdateManyInput>
    /**
     * Filter which ReferralCodes to update
     */
    where?: ReferralCodeWhereInput
  }

  /**
   * ReferralCode upsert
   */
  export type ReferralCodeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralCode
     */
    select?: ReferralCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralCodeInclude<ExtArgs> | null
    /**
     * The filter to search for the ReferralCode to update in case it exists.
     */
    where: ReferralCodeWhereUniqueInput
    /**
     * In case the ReferralCode found by the `where` argument doesn't exist, create a new ReferralCode with this data.
     */
    create: XOR<ReferralCodeCreateInput, ReferralCodeUncheckedCreateInput>
    /**
     * In case the ReferralCode was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReferralCodeUpdateInput, ReferralCodeUncheckedUpdateInput>
  }

  /**
   * ReferralCode delete
   */
  export type ReferralCodeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralCode
     */
    select?: ReferralCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralCodeInclude<ExtArgs> | null
    /**
     * Filter which ReferralCode to delete.
     */
    where: ReferralCodeWhereUniqueInput
  }

  /**
   * ReferralCode deleteMany
   */
  export type ReferralCodeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReferralCodes to delete
     */
    where?: ReferralCodeWhereInput
  }

  /**
   * ReferralCode.uses
   */
  export type ReferralCode$usesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralUse
     */
    select?: ReferralUseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralUseInclude<ExtArgs> | null
    where?: ReferralUseWhereInput
    orderBy?: ReferralUseOrderByWithRelationInput | ReferralUseOrderByWithRelationInput[]
    cursor?: ReferralUseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReferralUseScalarFieldEnum | ReferralUseScalarFieldEnum[]
  }

  /**
   * ReferralCode without action
   */
  export type ReferralCodeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralCode
     */
    select?: ReferralCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralCodeInclude<ExtArgs> | null
  }


  /**
   * Model ReferralUse
   */

  export type AggregateReferralUse = {
    _count: ReferralUseCountAggregateOutputType | null
    _avg: ReferralUseAvgAggregateOutputType | null
    _sum: ReferralUseSumAggregateOutputType | null
    _min: ReferralUseMinAggregateOutputType | null
    _max: ReferralUseMaxAggregateOutputType | null
  }

  export type ReferralUseAvgAggregateOutputType = {
    pointsAwarded: number | null
  }

  export type ReferralUseSumAggregateOutputType = {
    pointsAwarded: number | null
  }

  export type ReferralUseMinAggregateOutputType = {
    id: string | null
    referralCodeId: string | null
    userId: string | null
    pointsAwarded: number | null
    createdAt: Date | null
  }

  export type ReferralUseMaxAggregateOutputType = {
    id: string | null
    referralCodeId: string | null
    userId: string | null
    pointsAwarded: number | null
    createdAt: Date | null
  }

  export type ReferralUseCountAggregateOutputType = {
    id: number
    referralCodeId: number
    userId: number
    pointsAwarded: number
    createdAt: number
    _all: number
  }


  export type ReferralUseAvgAggregateInputType = {
    pointsAwarded?: true
  }

  export type ReferralUseSumAggregateInputType = {
    pointsAwarded?: true
  }

  export type ReferralUseMinAggregateInputType = {
    id?: true
    referralCodeId?: true
    userId?: true
    pointsAwarded?: true
    createdAt?: true
  }

  export type ReferralUseMaxAggregateInputType = {
    id?: true
    referralCodeId?: true
    userId?: true
    pointsAwarded?: true
    createdAt?: true
  }

  export type ReferralUseCountAggregateInputType = {
    id?: true
    referralCodeId?: true
    userId?: true
    pointsAwarded?: true
    createdAt?: true
    _all?: true
  }

  export type ReferralUseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReferralUse to aggregate.
     */
    where?: ReferralUseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReferralUses to fetch.
     */
    orderBy?: ReferralUseOrderByWithRelationInput | ReferralUseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReferralUseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReferralUses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReferralUses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReferralUses
    **/
    _count?: true | ReferralUseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReferralUseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReferralUseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReferralUseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReferralUseMaxAggregateInputType
  }

  export type GetReferralUseAggregateType<T extends ReferralUseAggregateArgs> = {
        [P in keyof T & keyof AggregateReferralUse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReferralUse[P]>
      : GetScalarType<T[P], AggregateReferralUse[P]>
  }




  export type ReferralUseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferralUseWhereInput
    orderBy?: ReferralUseOrderByWithAggregationInput | ReferralUseOrderByWithAggregationInput[]
    by: ReferralUseScalarFieldEnum[] | ReferralUseScalarFieldEnum
    having?: ReferralUseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReferralUseCountAggregateInputType | true
    _avg?: ReferralUseAvgAggregateInputType
    _sum?: ReferralUseSumAggregateInputType
    _min?: ReferralUseMinAggregateInputType
    _max?: ReferralUseMaxAggregateInputType
  }

  export type ReferralUseGroupByOutputType = {
    id: string
    referralCodeId: string
    userId: string
    pointsAwarded: number
    createdAt: Date
    _count: ReferralUseCountAggregateOutputType | null
    _avg: ReferralUseAvgAggregateOutputType | null
    _sum: ReferralUseSumAggregateOutputType | null
    _min: ReferralUseMinAggregateOutputType | null
    _max: ReferralUseMaxAggregateOutputType | null
  }

  type GetReferralUseGroupByPayload<T extends ReferralUseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReferralUseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReferralUseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReferralUseGroupByOutputType[P]>
            : GetScalarType<T[P], ReferralUseGroupByOutputType[P]>
        }
      >
    >


  export type ReferralUseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    referralCodeId?: boolean
    userId?: boolean
    pointsAwarded?: boolean
    createdAt?: boolean
    referralCode?: boolean | ReferralCodeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["referralUse"]>

  export type ReferralUseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    referralCodeId?: boolean
    userId?: boolean
    pointsAwarded?: boolean
    createdAt?: boolean
    referralCode?: boolean | ReferralCodeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["referralUse"]>

  export type ReferralUseSelectScalar = {
    id?: boolean
    referralCodeId?: boolean
    userId?: boolean
    pointsAwarded?: boolean
    createdAt?: boolean
  }

  export type ReferralUseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    referralCode?: boolean | ReferralCodeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ReferralUseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    referralCode?: boolean | ReferralCodeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ReferralUsePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReferralUse"
    objects: {
      referralCode: Prisma.$ReferralCodePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      referralCodeId: string
      userId: string
      pointsAwarded: number
      createdAt: Date
    }, ExtArgs["result"]["referralUse"]>
    composites: {}
  }

  type ReferralUseGetPayload<S extends boolean | null | undefined | ReferralUseDefaultArgs> = $Result.GetResult<Prisma.$ReferralUsePayload, S>

  type ReferralUseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReferralUseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReferralUseCountAggregateInputType | true
    }

  export interface ReferralUseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReferralUse'], meta: { name: 'ReferralUse' } }
    /**
     * Find zero or one ReferralUse that matches the filter.
     * @param {ReferralUseFindUniqueArgs} args - Arguments to find a ReferralUse
     * @example
     * // Get one ReferralUse
     * const referralUse = await prisma.referralUse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReferralUseFindUniqueArgs>(args: SelectSubset<T, ReferralUseFindUniqueArgs<ExtArgs>>): Prisma__ReferralUseClient<$Result.GetResult<Prisma.$ReferralUsePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ReferralUse that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReferralUseFindUniqueOrThrowArgs} args - Arguments to find a ReferralUse
     * @example
     * // Get one ReferralUse
     * const referralUse = await prisma.referralUse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReferralUseFindUniqueOrThrowArgs>(args: SelectSubset<T, ReferralUseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReferralUseClient<$Result.GetResult<Prisma.$ReferralUsePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ReferralUse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralUseFindFirstArgs} args - Arguments to find a ReferralUse
     * @example
     * // Get one ReferralUse
     * const referralUse = await prisma.referralUse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReferralUseFindFirstArgs>(args?: SelectSubset<T, ReferralUseFindFirstArgs<ExtArgs>>): Prisma__ReferralUseClient<$Result.GetResult<Prisma.$ReferralUsePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ReferralUse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralUseFindFirstOrThrowArgs} args - Arguments to find a ReferralUse
     * @example
     * // Get one ReferralUse
     * const referralUse = await prisma.referralUse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReferralUseFindFirstOrThrowArgs>(args?: SelectSubset<T, ReferralUseFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReferralUseClient<$Result.GetResult<Prisma.$ReferralUsePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ReferralUses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralUseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReferralUses
     * const referralUses = await prisma.referralUse.findMany()
     * 
     * // Get first 10 ReferralUses
     * const referralUses = await prisma.referralUse.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const referralUseWithIdOnly = await prisma.referralUse.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReferralUseFindManyArgs>(args?: SelectSubset<T, ReferralUseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralUsePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ReferralUse.
     * @param {ReferralUseCreateArgs} args - Arguments to create a ReferralUse.
     * @example
     * // Create one ReferralUse
     * const ReferralUse = await prisma.referralUse.create({
     *   data: {
     *     // ... data to create a ReferralUse
     *   }
     * })
     * 
     */
    create<T extends ReferralUseCreateArgs>(args: SelectSubset<T, ReferralUseCreateArgs<ExtArgs>>): Prisma__ReferralUseClient<$Result.GetResult<Prisma.$ReferralUsePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ReferralUses.
     * @param {ReferralUseCreateManyArgs} args - Arguments to create many ReferralUses.
     * @example
     * // Create many ReferralUses
     * const referralUse = await prisma.referralUse.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReferralUseCreateManyArgs>(args?: SelectSubset<T, ReferralUseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReferralUses and returns the data saved in the database.
     * @param {ReferralUseCreateManyAndReturnArgs} args - Arguments to create many ReferralUses.
     * @example
     * // Create many ReferralUses
     * const referralUse = await prisma.referralUse.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReferralUses and only return the `id`
     * const referralUseWithIdOnly = await prisma.referralUse.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReferralUseCreateManyAndReturnArgs>(args?: SelectSubset<T, ReferralUseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralUsePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ReferralUse.
     * @param {ReferralUseDeleteArgs} args - Arguments to delete one ReferralUse.
     * @example
     * // Delete one ReferralUse
     * const ReferralUse = await prisma.referralUse.delete({
     *   where: {
     *     // ... filter to delete one ReferralUse
     *   }
     * })
     * 
     */
    delete<T extends ReferralUseDeleteArgs>(args: SelectSubset<T, ReferralUseDeleteArgs<ExtArgs>>): Prisma__ReferralUseClient<$Result.GetResult<Prisma.$ReferralUsePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ReferralUse.
     * @param {ReferralUseUpdateArgs} args - Arguments to update one ReferralUse.
     * @example
     * // Update one ReferralUse
     * const referralUse = await prisma.referralUse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReferralUseUpdateArgs>(args: SelectSubset<T, ReferralUseUpdateArgs<ExtArgs>>): Prisma__ReferralUseClient<$Result.GetResult<Prisma.$ReferralUsePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ReferralUses.
     * @param {ReferralUseDeleteManyArgs} args - Arguments to filter ReferralUses to delete.
     * @example
     * // Delete a few ReferralUses
     * const { count } = await prisma.referralUse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReferralUseDeleteManyArgs>(args?: SelectSubset<T, ReferralUseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReferralUses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralUseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReferralUses
     * const referralUse = await prisma.referralUse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReferralUseUpdateManyArgs>(args: SelectSubset<T, ReferralUseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ReferralUse.
     * @param {ReferralUseUpsertArgs} args - Arguments to update or create a ReferralUse.
     * @example
     * // Update or create a ReferralUse
     * const referralUse = await prisma.referralUse.upsert({
     *   create: {
     *     // ... data to create a ReferralUse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReferralUse we want to update
     *   }
     * })
     */
    upsert<T extends ReferralUseUpsertArgs>(args: SelectSubset<T, ReferralUseUpsertArgs<ExtArgs>>): Prisma__ReferralUseClient<$Result.GetResult<Prisma.$ReferralUsePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ReferralUses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralUseCountArgs} args - Arguments to filter ReferralUses to count.
     * @example
     * // Count the number of ReferralUses
     * const count = await prisma.referralUse.count({
     *   where: {
     *     // ... the filter for the ReferralUses we want to count
     *   }
     * })
    **/
    count<T extends ReferralUseCountArgs>(
      args?: Subset<T, ReferralUseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReferralUseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReferralUse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralUseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReferralUseAggregateArgs>(args: Subset<T, ReferralUseAggregateArgs>): Prisma.PrismaPromise<GetReferralUseAggregateType<T>>

    /**
     * Group by ReferralUse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralUseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReferralUseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReferralUseGroupByArgs['orderBy'] }
        : { orderBy?: ReferralUseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReferralUseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReferralUseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReferralUse model
   */
  readonly fields: ReferralUseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReferralUse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReferralUseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    referralCode<T extends ReferralCodeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ReferralCodeDefaultArgs<ExtArgs>>): Prisma__ReferralCodeClient<$Result.GetResult<Prisma.$ReferralCodePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReferralUse model
   */ 
  interface ReferralUseFieldRefs {
    readonly id: FieldRef<"ReferralUse", 'String'>
    readonly referralCodeId: FieldRef<"ReferralUse", 'String'>
    readonly userId: FieldRef<"ReferralUse", 'String'>
    readonly pointsAwarded: FieldRef<"ReferralUse", 'Int'>
    readonly createdAt: FieldRef<"ReferralUse", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ReferralUse findUnique
   */
  export type ReferralUseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralUse
     */
    select?: ReferralUseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralUseInclude<ExtArgs> | null
    /**
     * Filter, which ReferralUse to fetch.
     */
    where: ReferralUseWhereUniqueInput
  }

  /**
   * ReferralUse findUniqueOrThrow
   */
  export type ReferralUseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralUse
     */
    select?: ReferralUseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralUseInclude<ExtArgs> | null
    /**
     * Filter, which ReferralUse to fetch.
     */
    where: ReferralUseWhereUniqueInput
  }

  /**
   * ReferralUse findFirst
   */
  export type ReferralUseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralUse
     */
    select?: ReferralUseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralUseInclude<ExtArgs> | null
    /**
     * Filter, which ReferralUse to fetch.
     */
    where?: ReferralUseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReferralUses to fetch.
     */
    orderBy?: ReferralUseOrderByWithRelationInput | ReferralUseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReferralUses.
     */
    cursor?: ReferralUseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReferralUses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReferralUses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReferralUses.
     */
    distinct?: ReferralUseScalarFieldEnum | ReferralUseScalarFieldEnum[]
  }

  /**
   * ReferralUse findFirstOrThrow
   */
  export type ReferralUseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralUse
     */
    select?: ReferralUseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralUseInclude<ExtArgs> | null
    /**
     * Filter, which ReferralUse to fetch.
     */
    where?: ReferralUseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReferralUses to fetch.
     */
    orderBy?: ReferralUseOrderByWithRelationInput | ReferralUseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReferralUses.
     */
    cursor?: ReferralUseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReferralUses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReferralUses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReferralUses.
     */
    distinct?: ReferralUseScalarFieldEnum | ReferralUseScalarFieldEnum[]
  }

  /**
   * ReferralUse findMany
   */
  export type ReferralUseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralUse
     */
    select?: ReferralUseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralUseInclude<ExtArgs> | null
    /**
     * Filter, which ReferralUses to fetch.
     */
    where?: ReferralUseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReferralUses to fetch.
     */
    orderBy?: ReferralUseOrderByWithRelationInput | ReferralUseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReferralUses.
     */
    cursor?: ReferralUseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReferralUses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReferralUses.
     */
    skip?: number
    distinct?: ReferralUseScalarFieldEnum | ReferralUseScalarFieldEnum[]
  }

  /**
   * ReferralUse create
   */
  export type ReferralUseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralUse
     */
    select?: ReferralUseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralUseInclude<ExtArgs> | null
    /**
     * The data needed to create a ReferralUse.
     */
    data: XOR<ReferralUseCreateInput, ReferralUseUncheckedCreateInput>
  }

  /**
   * ReferralUse createMany
   */
  export type ReferralUseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReferralUses.
     */
    data: ReferralUseCreateManyInput | ReferralUseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReferralUse createManyAndReturn
   */
  export type ReferralUseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralUse
     */
    select?: ReferralUseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ReferralUses.
     */
    data: ReferralUseCreateManyInput | ReferralUseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralUseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReferralUse update
   */
  export type ReferralUseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralUse
     */
    select?: ReferralUseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralUseInclude<ExtArgs> | null
    /**
     * The data needed to update a ReferralUse.
     */
    data: XOR<ReferralUseUpdateInput, ReferralUseUncheckedUpdateInput>
    /**
     * Choose, which ReferralUse to update.
     */
    where: ReferralUseWhereUniqueInput
  }

  /**
   * ReferralUse updateMany
   */
  export type ReferralUseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReferralUses.
     */
    data: XOR<ReferralUseUpdateManyMutationInput, ReferralUseUncheckedUpdateManyInput>
    /**
     * Filter which ReferralUses to update
     */
    where?: ReferralUseWhereInput
  }

  /**
   * ReferralUse upsert
   */
  export type ReferralUseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralUse
     */
    select?: ReferralUseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralUseInclude<ExtArgs> | null
    /**
     * The filter to search for the ReferralUse to update in case it exists.
     */
    where: ReferralUseWhereUniqueInput
    /**
     * In case the ReferralUse found by the `where` argument doesn't exist, create a new ReferralUse with this data.
     */
    create: XOR<ReferralUseCreateInput, ReferralUseUncheckedCreateInput>
    /**
     * In case the ReferralUse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReferralUseUpdateInput, ReferralUseUncheckedUpdateInput>
  }

  /**
   * ReferralUse delete
   */
  export type ReferralUseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralUse
     */
    select?: ReferralUseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralUseInclude<ExtArgs> | null
    /**
     * Filter which ReferralUse to delete.
     */
    where: ReferralUseWhereUniqueInput
  }

  /**
   * ReferralUse deleteMany
   */
  export type ReferralUseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReferralUses to delete
     */
    where?: ReferralUseWhereInput
  }

  /**
   * ReferralUse without action
   */
  export type ReferralUseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralUse
     */
    select?: ReferralUseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralUseInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    passwordHash: 'passwordHash',
    role: 'role',
    avatar: 'avatar',
    bio: 'bio',
    createdAt: 'createdAt',
    points: 'points',
    referralCode: 'referralCode',
    referredById: 'referredById',
    lastLogin: 'lastLogin'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const TeacherProfileScalarFieldEnum: {
    userId: 'userId',
    specialization: 'specialization',
    rating: 'rating',
    students: 'students',
    education: 'education',
    experience: 'experience',
    certificates: 'certificates'
  };

  export type TeacherProfileScalarFieldEnum = (typeof TeacherProfileScalarFieldEnum)[keyof typeof TeacherProfileScalarFieldEnum]


  export const UserAvailabilityScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    dayOfWeek: 'dayOfWeek',
    startTime: 'startTime',
    endTime: 'endTime'
  };

  export type UserAvailabilityScalarFieldEnum = (typeof UserAvailabilityScalarFieldEnum)[keyof typeof UserAvailabilityScalarFieldEnum]


  export const PointsTransactionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    amount: 'amount',
    type: 'type',
    description: 'description',
    createdAt: 'createdAt'
  };

  export type PointsTransactionScalarFieldEnum = (typeof PointsTransactionScalarFieldEnum)[keyof typeof PointsTransactionScalarFieldEnum]


  export const PointsPackageScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    points: 'points',
    price: 'price',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PointsPackageScalarFieldEnum = (typeof PointsPackageScalarFieldEnum)[keyof typeof PointsPackageScalarFieldEnum]


  export const CourseScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    subject: 'subject',
    image: 'image',
    price: 'price',
    pointsPrice: 'pointsPrice',
    teacherId: 'teacherId',
    students: 'students',
    rating: 'rating',
    status: 'status',
    featured: 'featured',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CourseScalarFieldEnum = (typeof CourseScalarFieldEnum)[keyof typeof CourseScalarFieldEnum]


  export const TopicScalarFieldEnum: {
    id: 'id',
    courseId: 'courseId',
    title: 'title',
    description: 'description',
    orderIndex: 'orderIndex'
  };

  export type TopicScalarFieldEnum = (typeof TopicScalarFieldEnum)[keyof typeof TopicScalarFieldEnum]


  export const LessonScalarFieldEnum: {
    id: 'id',
    topicId: 'topicId',
    title: 'title',
    description: 'description',
    videoUrl: 'videoUrl',
    content: 'content',
    duration: 'duration',
    orderIndex: 'orderIndex',
    type: 'type',
    courseId: 'courseId'
  };

  export type LessonScalarFieldEnum = (typeof LessonScalarFieldEnum)[keyof typeof LessonScalarFieldEnum]


  export const QuizScalarFieldEnum: {
    id: 'id',
    lessonId: 'lessonId',
    title: 'title',
    description: 'description',
    timeLimit: 'timeLimit'
  };

  export type QuizScalarFieldEnum = (typeof QuizScalarFieldEnum)[keyof typeof QuizScalarFieldEnum]


  export const QuestionScalarFieldEnum: {
    id: 'id',
    quizId: 'quizId',
    questionText: 'questionText',
    type: 'type',
    options: 'options',
    correctOptions: 'correctOptions',
    orderIndex: 'orderIndex'
  };

  export type QuestionScalarFieldEnum = (typeof QuestionScalarFieldEnum)[keyof typeof QuestionScalarFieldEnum]


  export const AssignmentScalarFieldEnum: {
    id: 'id',
    lessonId: 'lessonId',
    title: 'title',
    description: 'description',
    dueDate: 'dueDate',
    maxScore: 'maxScore',
    allowFileUpload: 'allowFileUpload',
    allowedFileTypes: 'allowedFileTypes',
    unitTests: 'unitTests'
  };

  export type AssignmentScalarFieldEnum = (typeof AssignmentScalarFieldEnum)[keyof typeof AssignmentScalarFieldEnum]


  export const EnrollmentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    courseId: 'courseId',
    enrolledAt: 'enrolledAt',
    completed: 'completed',
    completedAt: 'completedAt',
    status: 'status'
  };

  export type EnrollmentScalarFieldEnum = (typeof EnrollmentScalarFieldEnum)[keyof typeof EnrollmentScalarFieldEnum]


  export const SavedCourseScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    courseId: 'courseId',
    savedAt: 'savedAt'
  };

  export type SavedCourseScalarFieldEnum = (typeof SavedCourseScalarFieldEnum)[keyof typeof SavedCourseScalarFieldEnum]


  export const LikedCourseScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    courseId: 'courseId',
    likedAt: 'likedAt'
  };

  export type LikedCourseScalarFieldEnum = (typeof LikedCourseScalarFieldEnum)[keyof typeof LikedCourseScalarFieldEnum]


  export const LessonProgressScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    lessonId: 'lessonId',
    completed: 'completed',
    completedAt: 'completedAt',
    lastPosition: 'lastPosition'
  };

  export type LessonProgressScalarFieldEnum = (typeof LessonProgressScalarFieldEnum)[keyof typeof LessonProgressScalarFieldEnum]


  export const QuizAttemptScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    quizId: 'quizId',
    score: 'score',
    duration: 'duration',
    completedAt: 'completedAt',
    answers: 'answers',
    courseId: 'courseId'
  };

  export type QuizAttemptScalarFieldEnum = (typeof QuizAttemptScalarFieldEnum)[keyof typeof QuizAttemptScalarFieldEnum]


  export const AssignmentSubmissionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    assignmentId: 'assignmentId',
    content: 'content',
    fileUrls: 'fileUrls',
    submittedAt: 'submittedAt',
    score: 'score',
    feedback: 'feedback',
    gradedAt: 'gradedAt',
    gradedById: 'gradedById'
  };

  export type AssignmentSubmissionScalarFieldEnum = (typeof AssignmentSubmissionScalarFieldEnum)[keyof typeof AssignmentSubmissionScalarFieldEnum]


  export const CourseReviewScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    courseId: 'courseId',
    rating: 'rating',
    comment: 'comment',
    createdAt: 'createdAt'
  };

  export type CourseReviewScalarFieldEnum = (typeof CourseReviewScalarFieldEnum)[keyof typeof CourseReviewScalarFieldEnum]


  export const TutoringSessionScalarFieldEnum: {
    id: 'id',
    teacherId: 'teacherId',
    subject: 'subject',
    description: 'description',
    pricePerHour: 'pricePerHour',
    locationType: 'locationType',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    maxStudents: 'maxStudents',
    prerequisites: 'prerequisites',
    level: 'level',
    tags: 'tags',
    featured: 'featured'
  };

  export type TutoringSessionScalarFieldEnum = (typeof TutoringSessionScalarFieldEnum)[keyof typeof TutoringSessionScalarFieldEnum]


  export const TutoringAvailabilityScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    dayOfWeek: 'dayOfWeek',
    startTime: 'startTime',
    endTime: 'endTime'
  };

  export type TutoringAvailabilityScalarFieldEnum = (typeof TutoringAvailabilityScalarFieldEnum)[keyof typeof TutoringAvailabilityScalarFieldEnum]


  export const TutoringRequestScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    studentId: 'studentId',
    message: 'message',
    preferredDates: 'preferredDates',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TutoringRequestScalarFieldEnum = (typeof TutoringRequestScalarFieldEnum)[keyof typeof TutoringRequestScalarFieldEnum]


  export const TutoringAppointmentScalarFieldEnum: {
    id: 'id',
    requestId: 'requestId',
    sessionId: 'sessionId',
    scheduledAt: 'scheduledAt',
    duration: 'duration',
    notes: 'notes',
    meetingLink: 'meetingLink',
    status: 'status',
    price: 'price',
    teacherId: 'teacherId',
    studentId: 'studentId'
  };

  export type TutoringAppointmentScalarFieldEnum = (typeof TutoringAppointmentScalarFieldEnum)[keyof typeof TutoringAppointmentScalarFieldEnum]


  export const TutoringReviewScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    studentId: 'studentId',
    rating: 'rating',
    comment: 'comment',
    createdAt: 'createdAt'
  };

  export type TutoringReviewScalarFieldEnum = (typeof TutoringReviewScalarFieldEnum)[keyof typeof TutoringReviewScalarFieldEnum]


  export const TutoringMessageScalarFieldEnum: {
    id: 'id',
    requestId: 'requestId',
    senderId: 'senderId',
    message: 'message',
    read: 'read',
    createdAt: 'createdAt'
  };

  export type TutoringMessageScalarFieldEnum = (typeof TutoringMessageScalarFieldEnum)[keyof typeof TutoringMessageScalarFieldEnum]


  export const AchievementScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    pointsRewarded: 'pointsRewarded',
    icon: 'icon',
    category: 'category'
  };

  export type AchievementScalarFieldEnum = (typeof AchievementScalarFieldEnum)[keyof typeof AchievementScalarFieldEnum]


  export const UserAchievementScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    achievementId: 'achievementId',
    completed: 'completed',
    completedAt: 'completedAt',
    progress: 'progress'
  };

  export type UserAchievementScalarFieldEnum = (typeof UserAchievementScalarFieldEnum)[keyof typeof UserAchievementScalarFieldEnum]


  export const BadgeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    imageUrl: 'imageUrl',
    type: 'type',
    category: 'category'
  };

  export type BadgeScalarFieldEnum = (typeof BadgeScalarFieldEnum)[keyof typeof BadgeScalarFieldEnum]


  export const CertificateScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    issueDate: 'issueDate',
    type: 'type',
    courseId: 'courseId',
    courseName: 'courseName',
    tutoringId: 'tutoringId',
    tutoringSubject: 'tutoringSubject',
    teacherId: 'teacherId',
    teacherName: 'teacherName',
    customMessage: 'customMessage',
    imageUrl: 'imageUrl',
    badgeId: 'badgeId'
  };

  export type CertificateScalarFieldEnum = (typeof CertificateScalarFieldEnum)[keyof typeof CertificateScalarFieldEnum]


  export const ConversationScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ConversationScalarFieldEnum = (typeof ConversationScalarFieldEnum)[keyof typeof ConversationScalarFieldEnum]


  export const ConversationParticipantScalarFieldEnum: {
    conversationId: 'conversationId',
    userId: 'userId'
  };

  export type ConversationParticipantScalarFieldEnum = (typeof ConversationParticipantScalarFieldEnum)[keyof typeof ConversationParticipantScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    conversationId: 'conversationId',
    senderId: 'senderId',
    content: 'content',
    timestamp: 'timestamp',
    read: 'read'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const AttachmentScalarFieldEnum: {
    id: 'id',
    messageId: 'messageId',
    userId: 'userId',
    fileName: 'fileName',
    fileUrl: 'fileUrl',
    fileType: 'fileType',
    fileSize: 'fileSize'
  };

  export type AttachmentScalarFieldEnum = (typeof AttachmentScalarFieldEnum)[keyof typeof AttachmentScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    message: 'message',
    read: 'read',
    type: 'type',
    link: 'link',
    createdAt: 'createdAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const SubscriptionPlanScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    price: 'price',
    period: 'period',
    featuredBenefit: 'featuredBenefit',
    benefits: 'benefits',
    isPopular: 'isPopular'
  };

  export type SubscriptionPlanScalarFieldEnum = (typeof SubscriptionPlanScalarFieldEnum)[keyof typeof SubscriptionPlanScalarFieldEnum]


  export const CourseBundleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    price: 'price',
    originalPrice: 'originalPrice',
    discount: 'discount',
    featuredBenefit: 'featuredBenefit',
    benefits: 'benefits',
    imageUrl: 'imageUrl'
  };

  export type CourseBundleScalarFieldEnum = (typeof CourseBundleScalarFieldEnum)[keyof typeof CourseBundleScalarFieldEnum]


  export const BundleCourseScalarFieldEnum: {
    bundleId: 'bundleId',
    courseId: 'courseId'
  };

  export type BundleCourseScalarFieldEnum = (typeof BundleCourseScalarFieldEnum)[keyof typeof BundleCourseScalarFieldEnum]


  export const UserSubscriptionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    planId: 'planId',
    startDate: 'startDate',
    endDate: 'endDate',
    isActive: 'isActive',
    autoRenew: 'autoRenew',
    paymentMethod: 'paymentMethod',
    lastPaymentDate: 'lastPaymentDate'
  };

  export type UserSubscriptionScalarFieldEnum = (typeof UserSubscriptionScalarFieldEnum)[keyof typeof UserSubscriptionScalarFieldEnum]


  export const UserBundleScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    bundleId: 'bundleId',
    purchaseDate: 'purchaseDate'
  };

  export type UserBundleScalarFieldEnum = (typeof UserBundleScalarFieldEnum)[keyof typeof UserBundleScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    amount: 'amount',
    currency: 'currency',
    paymentMethod: 'paymentMethod',
    status: 'status',
    referenceType: 'referenceType',
    referenceId: 'referenceId',
    transactionId: 'transactionId',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const CalendarEventScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    description: 'description',
    type: 'type',
    startTime: 'startTime',
    endTime: 'endTime',
    courseId: 'courseId',
    lessonId: 'lessonId',
    teacherId: 'teacherId',
    studentId: 'studentId',
    location: 'location',
    createdAt: 'createdAt'
  };

  export type CalendarEventScalarFieldEnum = (typeof CalendarEventScalarFieldEnum)[keyof typeof CalendarEventScalarFieldEnum]


  export const BlogPostScalarFieldEnum: {
    id: 'id',
    title: 'title',
    excerpt: 'excerpt',
    content: 'content',
    image: 'image',
    authorId: 'authorId',
    published: 'published',
    publishedAt: 'publishedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    readTime: 'readTime'
  };

  export type BlogPostScalarFieldEnum = (typeof BlogPostScalarFieldEnum)[keyof typeof BlogPostScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    description: 'description'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const PostCategoryScalarFieldEnum: {
    postId: 'postId',
    categoryId: 'categoryId'
  };

  export type PostCategoryScalarFieldEnum = (typeof PostCategoryScalarFieldEnum)[keyof typeof PostCategoryScalarFieldEnum]


  export const TagScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug'
  };

  export type TagScalarFieldEnum = (typeof TagScalarFieldEnum)[keyof typeof TagScalarFieldEnum]


  export const PostTagScalarFieldEnum: {
    postId: 'postId',
    tagId: 'tagId'
  };

  export type PostTagScalarFieldEnum = (typeof PostTagScalarFieldEnum)[keyof typeof PostTagScalarFieldEnum]


  export const BlogCommentScalarFieldEnum: {
    id: 'id',
    postId: 'postId',
    userId: 'userId',
    content: 'content',
    createdAt: 'createdAt',
    parentId: 'parentId'
  };

  export type BlogCommentScalarFieldEnum = (typeof BlogCommentScalarFieldEnum)[keyof typeof BlogCommentScalarFieldEnum]


  export const ReferralCodeScalarFieldEnum: {
    id: 'id',
    code: 'code',
    userId: 'userId',
    isActive: 'isActive',
    usageLimit: 'usageLimit',
    maxUses: 'maxUses',
    pointsReward: 'pointsReward',
    isUserCode: 'isUserCode',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReferralCodeScalarFieldEnum = (typeof ReferralCodeScalarFieldEnum)[keyof typeof ReferralCodeScalarFieldEnum]


  export const ReferralUseScalarFieldEnum: {
    id: 'id',
    referralCodeId: 'referralCodeId',
    userId: 'userId',
    pointsAwarded: 'pointsAwarded',
    createdAt: 'createdAt'
  };

  export type ReferralUseScalarFieldEnum = (typeof ReferralUseScalarFieldEnum)[keyof typeof ReferralUseScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'PointsTxnType'
   */
  export type EnumPointsTxnTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PointsTxnType'>
    


  /**
   * Reference to a field of type 'PointsTxnType[]'
   */
  export type ListEnumPointsTxnTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PointsTxnType[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'CourseStatus'
   */
  export type EnumCourseStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CourseStatus'>
    


  /**
   * Reference to a field of type 'CourseStatus[]'
   */
  export type ListEnumCourseStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CourseStatus[]'>
    


  /**
   * Reference to a field of type 'LessonType'
   */
  export type EnumLessonTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LessonType'>
    


  /**
   * Reference to a field of type 'LessonType[]'
   */
  export type ListEnumLessonTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LessonType[]'>
    


  /**
   * Reference to a field of type 'QuestionType'
   */
  export type EnumQuestionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuestionType'>
    


  /**
   * Reference to a field of type 'QuestionType[]'
   */
  export type ListEnumQuestionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuestionType[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'TutoringLocationType'
   */
  export type EnumTutoringLocationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TutoringLocationType'>
    


  /**
   * Reference to a field of type 'TutoringLocationType[]'
   */
  export type ListEnumTutoringLocationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TutoringLocationType[]'>
    


  /**
   * Reference to a field of type 'TutoringStatus'
   */
  export type EnumTutoringStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TutoringStatus'>
    


  /**
   * Reference to a field of type 'TutoringStatus[]'
   */
  export type ListEnumTutoringStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TutoringStatus[]'>
    


  /**
   * Reference to a field of type 'TutoringRequestStatus'
   */
  export type EnumTutoringRequestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TutoringRequestStatus'>
    


  /**
   * Reference to a field of type 'TutoringRequestStatus[]'
   */
  export type ListEnumTutoringRequestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TutoringRequestStatus[]'>
    


  /**
   * Reference to a field of type 'AppointmentStatus'
   */
  export type EnumAppointmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AppointmentStatus'>
    


  /**
   * Reference to a field of type 'AppointmentStatus[]'
   */
  export type ListEnumAppointmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AppointmentStatus[]'>
    


  /**
   * Reference to a field of type 'AchievementCategory'
   */
  export type EnumAchievementCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AchievementCategory'>
    


  /**
   * Reference to a field of type 'AchievementCategory[]'
   */
  export type ListEnumAchievementCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AchievementCategory[]'>
    


  /**
   * Reference to a field of type 'BadgeType'
   */
  export type EnumBadgeTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BadgeType'>
    


  /**
   * Reference to a field of type 'BadgeType[]'
   */
  export type ListEnumBadgeTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BadgeType[]'>
    


  /**
   * Reference to a field of type 'NotificationType'
   */
  export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>
    


  /**
   * Reference to a field of type 'NotificationType[]'
   */
  export type ListEnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType[]'>
    


  /**
   * Reference to a field of type 'SubscriptionPeriod'
   */
  export type EnumSubscriptionPeriodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionPeriod'>
    


  /**
   * Reference to a field of type 'SubscriptionPeriod[]'
   */
  export type ListEnumSubscriptionPeriodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionPeriod[]'>
    


  /**
   * Reference to a field of type 'PaymentStatus'
   */
  export type EnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus'>
    


  /**
   * Reference to a field of type 'PaymentStatus[]'
   */
  export type ListEnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus[]'>
    


  /**
   * Reference to a field of type 'PaymentReferenceType'
   */
  export type EnumPaymentReferenceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentReferenceType'>
    


  /**
   * Reference to a field of type 'PaymentReferenceType[]'
   */
  export type ListEnumPaymentReferenceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentReferenceType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    avatar?: StringNullableFilter<"User"> | string | null
    bio?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    points?: IntFilter<"User"> | number
    referralCode?: StringNullableFilter<"User"> | string | null
    referredById?: StringNullableFilter<"User"> | string | null
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    referredBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    referrals?: UserListRelationFilter
    teacherProfile?: XOR<TeacherProfileNullableRelationFilter, TeacherProfileWhereInput> | null
    availability?: UserAvailabilityListRelationFilter
    pointsTransactions?: PointsTransactionListRelationFilter
    courses?: CourseListRelationFilter
    enrollments?: EnrollmentListRelationFilter
    savedCourses?: SavedCourseListRelationFilter
    likedCourses?: LikedCourseListRelationFilter
    lessonProgress?: LessonProgressListRelationFilter
    quizAttempts?: QuizAttemptListRelationFilter
    assignmentSubs?: AssignmentSubmissionListRelationFilter
    courseReviews?: CourseReviewListRelationFilter
    tutoringSessions?: TutoringSessionListRelationFilter
    tutoringRequests?: TutoringRequestListRelationFilter
    tutoringAppointmentsAsTeacher?: TutoringAppointmentListRelationFilter
    tutoringAppointmentsAsStudent?: TutoringAppointmentListRelationFilter
    tutoringReviews?: TutoringReviewListRelationFilter
    tutoringMessages?: TutoringMessageListRelationFilter
    achievements?: UserAchievementListRelationFilter
    certificates?: CertificateListRelationFilter
    conversationParts?: ConversationParticipantListRelationFilter
    sentMessages?: MessageListRelationFilter
    attachments?: AttachmentListRelationFilter
    notifications?: NotificationListRelationFilter
    subscriptionRecords?: UserSubscriptionListRelationFilter
    bundlesOwned?: UserBundleListRelationFilter
    payments?: PaymentListRelationFilter
    calendarEvents?: CalendarEventListRelationFilter
    eventsAsTeacher?: CalendarEventListRelationFilter
    eventsAsStudent?: CalendarEventListRelationFilter
    blogPosts?: BlogPostListRelationFilter
    blogComments?: BlogCommentListRelationFilter
    submissionsGraded?: AssignmentSubmissionListRelationFilter
    referralCodesOwned?: ReferralCodeListRelationFilter
    referralUsesGained?: ReferralUseListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    avatar?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    points?: SortOrder
    referralCode?: SortOrderInput | SortOrder
    referredById?: SortOrderInput | SortOrder
    lastLogin?: SortOrderInput | SortOrder
    referredBy?: UserOrderByWithRelationInput
    referrals?: UserOrderByRelationAggregateInput
    teacherProfile?: TeacherProfileOrderByWithRelationInput
    availability?: UserAvailabilityOrderByRelationAggregateInput
    pointsTransactions?: PointsTransactionOrderByRelationAggregateInput
    courses?: CourseOrderByRelationAggregateInput
    enrollments?: EnrollmentOrderByRelationAggregateInput
    savedCourses?: SavedCourseOrderByRelationAggregateInput
    likedCourses?: LikedCourseOrderByRelationAggregateInput
    lessonProgress?: LessonProgressOrderByRelationAggregateInput
    quizAttempts?: QuizAttemptOrderByRelationAggregateInput
    assignmentSubs?: AssignmentSubmissionOrderByRelationAggregateInput
    courseReviews?: CourseReviewOrderByRelationAggregateInput
    tutoringSessions?: TutoringSessionOrderByRelationAggregateInput
    tutoringRequests?: TutoringRequestOrderByRelationAggregateInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentOrderByRelationAggregateInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentOrderByRelationAggregateInput
    tutoringReviews?: TutoringReviewOrderByRelationAggregateInput
    tutoringMessages?: TutoringMessageOrderByRelationAggregateInput
    achievements?: UserAchievementOrderByRelationAggregateInput
    certificates?: CertificateOrderByRelationAggregateInput
    conversationParts?: ConversationParticipantOrderByRelationAggregateInput
    sentMessages?: MessageOrderByRelationAggregateInput
    attachments?: AttachmentOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    subscriptionRecords?: UserSubscriptionOrderByRelationAggregateInput
    bundlesOwned?: UserBundleOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
    calendarEvents?: CalendarEventOrderByRelationAggregateInput
    eventsAsTeacher?: CalendarEventOrderByRelationAggregateInput
    eventsAsStudent?: CalendarEventOrderByRelationAggregateInput
    blogPosts?: BlogPostOrderByRelationAggregateInput
    blogComments?: BlogCommentOrderByRelationAggregateInput
    submissionsGraded?: AssignmentSubmissionOrderByRelationAggregateInput
    referralCodesOwned?: ReferralCodeOrderByRelationAggregateInput
    referralUsesGained?: ReferralUseOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    referralCode?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    avatar?: StringNullableFilter<"User"> | string | null
    bio?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    points?: IntFilter<"User"> | number
    referredById?: StringNullableFilter<"User"> | string | null
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    referredBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    referrals?: UserListRelationFilter
    teacherProfile?: XOR<TeacherProfileNullableRelationFilter, TeacherProfileWhereInput> | null
    availability?: UserAvailabilityListRelationFilter
    pointsTransactions?: PointsTransactionListRelationFilter
    courses?: CourseListRelationFilter
    enrollments?: EnrollmentListRelationFilter
    savedCourses?: SavedCourseListRelationFilter
    likedCourses?: LikedCourseListRelationFilter
    lessonProgress?: LessonProgressListRelationFilter
    quizAttempts?: QuizAttemptListRelationFilter
    assignmentSubs?: AssignmentSubmissionListRelationFilter
    courseReviews?: CourseReviewListRelationFilter
    tutoringSessions?: TutoringSessionListRelationFilter
    tutoringRequests?: TutoringRequestListRelationFilter
    tutoringAppointmentsAsTeacher?: TutoringAppointmentListRelationFilter
    tutoringAppointmentsAsStudent?: TutoringAppointmentListRelationFilter
    tutoringReviews?: TutoringReviewListRelationFilter
    tutoringMessages?: TutoringMessageListRelationFilter
    achievements?: UserAchievementListRelationFilter
    certificates?: CertificateListRelationFilter
    conversationParts?: ConversationParticipantListRelationFilter
    sentMessages?: MessageListRelationFilter
    attachments?: AttachmentListRelationFilter
    notifications?: NotificationListRelationFilter
    subscriptionRecords?: UserSubscriptionListRelationFilter
    bundlesOwned?: UserBundleListRelationFilter
    payments?: PaymentListRelationFilter
    calendarEvents?: CalendarEventListRelationFilter
    eventsAsTeacher?: CalendarEventListRelationFilter
    eventsAsStudent?: CalendarEventListRelationFilter
    blogPosts?: BlogPostListRelationFilter
    blogComments?: BlogCommentListRelationFilter
    submissionsGraded?: AssignmentSubmissionListRelationFilter
    referralCodesOwned?: ReferralCodeListRelationFilter
    referralUsesGained?: ReferralUseListRelationFilter
  }, "id" | "email" | "referralCode">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    avatar?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    points?: SortOrder
    referralCode?: SortOrderInput | SortOrder
    referredById?: SortOrderInput | SortOrder
    lastLogin?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringWithAggregatesFilter<"User"> | string
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    avatar?: StringNullableWithAggregatesFilter<"User"> | string | null
    bio?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    points?: IntWithAggregatesFilter<"User"> | number
    referralCode?: StringNullableWithAggregatesFilter<"User"> | string | null
    referredById?: StringNullableWithAggregatesFilter<"User"> | string | null
    lastLogin?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
  }

  export type TeacherProfileWhereInput = {
    AND?: TeacherProfileWhereInput | TeacherProfileWhereInput[]
    OR?: TeacherProfileWhereInput[]
    NOT?: TeacherProfileWhereInput | TeacherProfileWhereInput[]
    userId?: StringFilter<"TeacherProfile"> | string
    specialization?: StringNullableListFilter<"TeacherProfile">
    rating?: DecimalNullableFilter<"TeacherProfile"> | Decimal | DecimalJsLike | number | string | null
    students?: IntFilter<"TeacherProfile"> | number
    education?: StringNullableFilter<"TeacherProfile"> | string | null
    experience?: StringNullableFilter<"TeacherProfile"> | string | null
    certificates?: StringNullableListFilter<"TeacherProfile">
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type TeacherProfileOrderByWithRelationInput = {
    userId?: SortOrder
    specialization?: SortOrder
    rating?: SortOrderInput | SortOrder
    students?: SortOrder
    education?: SortOrderInput | SortOrder
    experience?: SortOrderInput | SortOrder
    certificates?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type TeacherProfileWhereUniqueInput = Prisma.AtLeast<{
    userId?: string
    AND?: TeacherProfileWhereInput | TeacherProfileWhereInput[]
    OR?: TeacherProfileWhereInput[]
    NOT?: TeacherProfileWhereInput | TeacherProfileWhereInput[]
    specialization?: StringNullableListFilter<"TeacherProfile">
    rating?: DecimalNullableFilter<"TeacherProfile"> | Decimal | DecimalJsLike | number | string | null
    students?: IntFilter<"TeacherProfile"> | number
    education?: StringNullableFilter<"TeacherProfile"> | string | null
    experience?: StringNullableFilter<"TeacherProfile"> | string | null
    certificates?: StringNullableListFilter<"TeacherProfile">
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "userId">

  export type TeacherProfileOrderByWithAggregationInput = {
    userId?: SortOrder
    specialization?: SortOrder
    rating?: SortOrderInput | SortOrder
    students?: SortOrder
    education?: SortOrderInput | SortOrder
    experience?: SortOrderInput | SortOrder
    certificates?: SortOrder
    _count?: TeacherProfileCountOrderByAggregateInput
    _avg?: TeacherProfileAvgOrderByAggregateInput
    _max?: TeacherProfileMaxOrderByAggregateInput
    _min?: TeacherProfileMinOrderByAggregateInput
    _sum?: TeacherProfileSumOrderByAggregateInput
  }

  export type TeacherProfileScalarWhereWithAggregatesInput = {
    AND?: TeacherProfileScalarWhereWithAggregatesInput | TeacherProfileScalarWhereWithAggregatesInput[]
    OR?: TeacherProfileScalarWhereWithAggregatesInput[]
    NOT?: TeacherProfileScalarWhereWithAggregatesInput | TeacherProfileScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"TeacherProfile"> | string
    specialization?: StringNullableListFilter<"TeacherProfile">
    rating?: DecimalNullableWithAggregatesFilter<"TeacherProfile"> | Decimal | DecimalJsLike | number | string | null
    students?: IntWithAggregatesFilter<"TeacherProfile"> | number
    education?: StringNullableWithAggregatesFilter<"TeacherProfile"> | string | null
    experience?: StringNullableWithAggregatesFilter<"TeacherProfile"> | string | null
    certificates?: StringNullableListFilter<"TeacherProfile">
  }

  export type UserAvailabilityWhereInput = {
    AND?: UserAvailabilityWhereInput | UserAvailabilityWhereInput[]
    OR?: UserAvailabilityWhereInput[]
    NOT?: UserAvailabilityWhereInput | UserAvailabilityWhereInput[]
    id?: StringFilter<"UserAvailability"> | string
    userId?: StringFilter<"UserAvailability"> | string
    dayOfWeek?: IntFilter<"UserAvailability"> | number
    startTime?: DateTimeFilter<"UserAvailability"> | Date | string
    endTime?: DateTimeFilter<"UserAvailability"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserAvailabilityOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserAvailabilityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_dayOfWeek_startTime?: UserAvailabilityUserIdDayOfWeekStartTimeCompoundUniqueInput
    AND?: UserAvailabilityWhereInput | UserAvailabilityWhereInput[]
    OR?: UserAvailabilityWhereInput[]
    NOT?: UserAvailabilityWhereInput | UserAvailabilityWhereInput[]
    userId?: StringFilter<"UserAvailability"> | string
    dayOfWeek?: IntFilter<"UserAvailability"> | number
    startTime?: DateTimeFilter<"UserAvailability"> | Date | string
    endTime?: DateTimeFilter<"UserAvailability"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId_dayOfWeek_startTime">

  export type UserAvailabilityOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    _count?: UserAvailabilityCountOrderByAggregateInput
    _avg?: UserAvailabilityAvgOrderByAggregateInput
    _max?: UserAvailabilityMaxOrderByAggregateInput
    _min?: UserAvailabilityMinOrderByAggregateInput
    _sum?: UserAvailabilitySumOrderByAggregateInput
  }

  export type UserAvailabilityScalarWhereWithAggregatesInput = {
    AND?: UserAvailabilityScalarWhereWithAggregatesInput | UserAvailabilityScalarWhereWithAggregatesInput[]
    OR?: UserAvailabilityScalarWhereWithAggregatesInput[]
    NOT?: UserAvailabilityScalarWhereWithAggregatesInput | UserAvailabilityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserAvailability"> | string
    userId?: StringWithAggregatesFilter<"UserAvailability"> | string
    dayOfWeek?: IntWithAggregatesFilter<"UserAvailability"> | number
    startTime?: DateTimeWithAggregatesFilter<"UserAvailability"> | Date | string
    endTime?: DateTimeWithAggregatesFilter<"UserAvailability"> | Date | string
  }

  export type PointsTransactionWhereInput = {
    AND?: PointsTransactionWhereInput | PointsTransactionWhereInput[]
    OR?: PointsTransactionWhereInput[]
    NOT?: PointsTransactionWhereInput | PointsTransactionWhereInput[]
    id?: StringFilter<"PointsTransaction"> | string
    userId?: StringFilter<"PointsTransaction"> | string
    amount?: IntFilter<"PointsTransaction"> | number
    type?: EnumPointsTxnTypeFilter<"PointsTransaction"> | $Enums.PointsTxnType
    description?: StringNullableFilter<"PointsTransaction"> | string | null
    createdAt?: DateTimeFilter<"PointsTransaction"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type PointsTransactionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type PointsTransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PointsTransactionWhereInput | PointsTransactionWhereInput[]
    OR?: PointsTransactionWhereInput[]
    NOT?: PointsTransactionWhereInput | PointsTransactionWhereInput[]
    userId?: StringFilter<"PointsTransaction"> | string
    amount?: IntFilter<"PointsTransaction"> | number
    type?: EnumPointsTxnTypeFilter<"PointsTransaction"> | $Enums.PointsTxnType
    description?: StringNullableFilter<"PointsTransaction"> | string | null
    createdAt?: DateTimeFilter<"PointsTransaction"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type PointsTransactionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PointsTransactionCountOrderByAggregateInput
    _avg?: PointsTransactionAvgOrderByAggregateInput
    _max?: PointsTransactionMaxOrderByAggregateInput
    _min?: PointsTransactionMinOrderByAggregateInput
    _sum?: PointsTransactionSumOrderByAggregateInput
  }

  export type PointsTransactionScalarWhereWithAggregatesInput = {
    AND?: PointsTransactionScalarWhereWithAggregatesInput | PointsTransactionScalarWhereWithAggregatesInput[]
    OR?: PointsTransactionScalarWhereWithAggregatesInput[]
    NOT?: PointsTransactionScalarWhereWithAggregatesInput | PointsTransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PointsTransaction"> | string
    userId?: StringWithAggregatesFilter<"PointsTransaction"> | string
    amount?: IntWithAggregatesFilter<"PointsTransaction"> | number
    type?: EnumPointsTxnTypeWithAggregatesFilter<"PointsTransaction"> | $Enums.PointsTxnType
    description?: StringNullableWithAggregatesFilter<"PointsTransaction"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PointsTransaction"> | Date | string
  }

  export type PointsPackageWhereInput = {
    AND?: PointsPackageWhereInput | PointsPackageWhereInput[]
    OR?: PointsPackageWhereInput[]
    NOT?: PointsPackageWhereInput | PointsPackageWhereInput[]
    id?: StringFilter<"PointsPackage"> | string
    name?: StringFilter<"PointsPackage"> | string
    description?: StringNullableFilter<"PointsPackage"> | string | null
    points?: IntFilter<"PointsPackage"> | number
    price?: DecimalFilter<"PointsPackage"> | Decimal | DecimalJsLike | number | string
    active?: BoolFilter<"PointsPackage"> | boolean
    createdAt?: DateTimeFilter<"PointsPackage"> | Date | string
    updatedAt?: DateTimeFilter<"PointsPackage"> | Date | string
  }

  export type PointsPackageOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    points?: SortOrder
    price?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PointsPackageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PointsPackageWhereInput | PointsPackageWhereInput[]
    OR?: PointsPackageWhereInput[]
    NOT?: PointsPackageWhereInput | PointsPackageWhereInput[]
    name?: StringFilter<"PointsPackage"> | string
    description?: StringNullableFilter<"PointsPackage"> | string | null
    points?: IntFilter<"PointsPackage"> | number
    price?: DecimalFilter<"PointsPackage"> | Decimal | DecimalJsLike | number | string
    active?: BoolFilter<"PointsPackage"> | boolean
    createdAt?: DateTimeFilter<"PointsPackage"> | Date | string
    updatedAt?: DateTimeFilter<"PointsPackage"> | Date | string
  }, "id">

  export type PointsPackageOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    points?: SortOrder
    price?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PointsPackageCountOrderByAggregateInput
    _avg?: PointsPackageAvgOrderByAggregateInput
    _max?: PointsPackageMaxOrderByAggregateInput
    _min?: PointsPackageMinOrderByAggregateInput
    _sum?: PointsPackageSumOrderByAggregateInput
  }

  export type PointsPackageScalarWhereWithAggregatesInput = {
    AND?: PointsPackageScalarWhereWithAggregatesInput | PointsPackageScalarWhereWithAggregatesInput[]
    OR?: PointsPackageScalarWhereWithAggregatesInput[]
    NOT?: PointsPackageScalarWhereWithAggregatesInput | PointsPackageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PointsPackage"> | string
    name?: StringWithAggregatesFilter<"PointsPackage"> | string
    description?: StringNullableWithAggregatesFilter<"PointsPackage"> | string | null
    points?: IntWithAggregatesFilter<"PointsPackage"> | number
    price?: DecimalWithAggregatesFilter<"PointsPackage"> | Decimal | DecimalJsLike | number | string
    active?: BoolWithAggregatesFilter<"PointsPackage"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"PointsPackage"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PointsPackage"> | Date | string
  }

  export type CourseWhereInput = {
    AND?: CourseWhereInput | CourseWhereInput[]
    OR?: CourseWhereInput[]
    NOT?: CourseWhereInput | CourseWhereInput[]
    id?: StringFilter<"Course"> | string
    title?: StringFilter<"Course"> | string
    description?: StringNullableFilter<"Course"> | string | null
    subject?: StringFilter<"Course"> | string
    image?: StringNullableFilter<"Course"> | string | null
    price?: DecimalFilter<"Course"> | Decimal | DecimalJsLike | number | string
    pointsPrice?: IntFilter<"Course"> | number
    teacherId?: StringFilter<"Course"> | string
    students?: IntFilter<"Course"> | number
    rating?: DecimalNullableFilter<"Course"> | Decimal | DecimalJsLike | number | string | null
    status?: EnumCourseStatusFilter<"Course"> | $Enums.CourseStatus
    featured?: BoolFilter<"Course"> | boolean
    createdAt?: DateTimeFilter<"Course"> | Date | string
    updatedAt?: DateTimeFilter<"Course"> | Date | string
    teacher?: XOR<UserRelationFilter, UserWhereInput>
    topics?: TopicListRelationFilter
    enrollments?: EnrollmentListRelationFilter
    savedBy?: SavedCourseListRelationFilter
    likedBy?: LikedCourseListRelationFilter
    reviews?: CourseReviewListRelationFilter
    lessons?: LessonListRelationFilter
    quizAttempts?: QuizAttemptListRelationFilter
    certificates?: CertificateListRelationFilter
    bundleCourses?: BundleCourseListRelationFilter
    calendarEvents?: CalendarEventListRelationFilter
  }

  export type CourseOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    subject?: SortOrder
    image?: SortOrderInput | SortOrder
    price?: SortOrder
    pointsPrice?: SortOrder
    teacherId?: SortOrder
    students?: SortOrder
    rating?: SortOrderInput | SortOrder
    status?: SortOrder
    featured?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    teacher?: UserOrderByWithRelationInput
    topics?: TopicOrderByRelationAggregateInput
    enrollments?: EnrollmentOrderByRelationAggregateInput
    savedBy?: SavedCourseOrderByRelationAggregateInput
    likedBy?: LikedCourseOrderByRelationAggregateInput
    reviews?: CourseReviewOrderByRelationAggregateInput
    lessons?: LessonOrderByRelationAggregateInput
    quizAttempts?: QuizAttemptOrderByRelationAggregateInput
    certificates?: CertificateOrderByRelationAggregateInput
    bundleCourses?: BundleCourseOrderByRelationAggregateInput
    calendarEvents?: CalendarEventOrderByRelationAggregateInput
  }

  export type CourseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CourseWhereInput | CourseWhereInput[]
    OR?: CourseWhereInput[]
    NOT?: CourseWhereInput | CourseWhereInput[]
    title?: StringFilter<"Course"> | string
    description?: StringNullableFilter<"Course"> | string | null
    subject?: StringFilter<"Course"> | string
    image?: StringNullableFilter<"Course"> | string | null
    price?: DecimalFilter<"Course"> | Decimal | DecimalJsLike | number | string
    pointsPrice?: IntFilter<"Course"> | number
    teacherId?: StringFilter<"Course"> | string
    students?: IntFilter<"Course"> | number
    rating?: DecimalNullableFilter<"Course"> | Decimal | DecimalJsLike | number | string | null
    status?: EnumCourseStatusFilter<"Course"> | $Enums.CourseStatus
    featured?: BoolFilter<"Course"> | boolean
    createdAt?: DateTimeFilter<"Course"> | Date | string
    updatedAt?: DateTimeFilter<"Course"> | Date | string
    teacher?: XOR<UserRelationFilter, UserWhereInput>
    topics?: TopicListRelationFilter
    enrollments?: EnrollmentListRelationFilter
    savedBy?: SavedCourseListRelationFilter
    likedBy?: LikedCourseListRelationFilter
    reviews?: CourseReviewListRelationFilter
    lessons?: LessonListRelationFilter
    quizAttempts?: QuizAttemptListRelationFilter
    certificates?: CertificateListRelationFilter
    bundleCourses?: BundleCourseListRelationFilter
    calendarEvents?: CalendarEventListRelationFilter
  }, "id">

  export type CourseOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    subject?: SortOrder
    image?: SortOrderInput | SortOrder
    price?: SortOrder
    pointsPrice?: SortOrder
    teacherId?: SortOrder
    students?: SortOrder
    rating?: SortOrderInput | SortOrder
    status?: SortOrder
    featured?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CourseCountOrderByAggregateInput
    _avg?: CourseAvgOrderByAggregateInput
    _max?: CourseMaxOrderByAggregateInput
    _min?: CourseMinOrderByAggregateInput
    _sum?: CourseSumOrderByAggregateInput
  }

  export type CourseScalarWhereWithAggregatesInput = {
    AND?: CourseScalarWhereWithAggregatesInput | CourseScalarWhereWithAggregatesInput[]
    OR?: CourseScalarWhereWithAggregatesInput[]
    NOT?: CourseScalarWhereWithAggregatesInput | CourseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Course"> | string
    title?: StringWithAggregatesFilter<"Course"> | string
    description?: StringNullableWithAggregatesFilter<"Course"> | string | null
    subject?: StringWithAggregatesFilter<"Course"> | string
    image?: StringNullableWithAggregatesFilter<"Course"> | string | null
    price?: DecimalWithAggregatesFilter<"Course"> | Decimal | DecimalJsLike | number | string
    pointsPrice?: IntWithAggregatesFilter<"Course"> | number
    teacherId?: StringWithAggregatesFilter<"Course"> | string
    students?: IntWithAggregatesFilter<"Course"> | number
    rating?: DecimalNullableWithAggregatesFilter<"Course"> | Decimal | DecimalJsLike | number | string | null
    status?: EnumCourseStatusWithAggregatesFilter<"Course"> | $Enums.CourseStatus
    featured?: BoolWithAggregatesFilter<"Course"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Course"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Course"> | Date | string
  }

  export type TopicWhereInput = {
    AND?: TopicWhereInput | TopicWhereInput[]
    OR?: TopicWhereInput[]
    NOT?: TopicWhereInput | TopicWhereInput[]
    id?: StringFilter<"Topic"> | string
    courseId?: StringFilter<"Topic"> | string
    title?: StringFilter<"Topic"> | string
    description?: StringNullableFilter<"Topic"> | string | null
    orderIndex?: IntFilter<"Topic"> | number
    course?: XOR<CourseRelationFilter, CourseWhereInput>
    lessons?: LessonListRelationFilter
  }

  export type TopicOrderByWithRelationInput = {
    id?: SortOrder
    courseId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    orderIndex?: SortOrder
    course?: CourseOrderByWithRelationInput
    lessons?: LessonOrderByRelationAggregateInput
  }

  export type TopicWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    courseId_orderIndex?: TopicCourseIdOrderIndexCompoundUniqueInput
    AND?: TopicWhereInput | TopicWhereInput[]
    OR?: TopicWhereInput[]
    NOT?: TopicWhereInput | TopicWhereInput[]
    courseId?: StringFilter<"Topic"> | string
    title?: StringFilter<"Topic"> | string
    description?: StringNullableFilter<"Topic"> | string | null
    orderIndex?: IntFilter<"Topic"> | number
    course?: XOR<CourseRelationFilter, CourseWhereInput>
    lessons?: LessonListRelationFilter
  }, "id" | "courseId_orderIndex">

  export type TopicOrderByWithAggregationInput = {
    id?: SortOrder
    courseId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    orderIndex?: SortOrder
    _count?: TopicCountOrderByAggregateInput
    _avg?: TopicAvgOrderByAggregateInput
    _max?: TopicMaxOrderByAggregateInput
    _min?: TopicMinOrderByAggregateInput
    _sum?: TopicSumOrderByAggregateInput
  }

  export type TopicScalarWhereWithAggregatesInput = {
    AND?: TopicScalarWhereWithAggregatesInput | TopicScalarWhereWithAggregatesInput[]
    OR?: TopicScalarWhereWithAggregatesInput[]
    NOT?: TopicScalarWhereWithAggregatesInput | TopicScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Topic"> | string
    courseId?: StringWithAggregatesFilter<"Topic"> | string
    title?: StringWithAggregatesFilter<"Topic"> | string
    description?: StringNullableWithAggregatesFilter<"Topic"> | string | null
    orderIndex?: IntWithAggregatesFilter<"Topic"> | number
  }

  export type LessonWhereInput = {
    AND?: LessonWhereInput | LessonWhereInput[]
    OR?: LessonWhereInput[]
    NOT?: LessonWhereInput | LessonWhereInput[]
    id?: StringFilter<"Lesson"> | string
    topicId?: StringFilter<"Lesson"> | string
    title?: StringFilter<"Lesson"> | string
    description?: StringNullableFilter<"Lesson"> | string | null
    videoUrl?: StringNullableFilter<"Lesson"> | string | null
    content?: StringNullableFilter<"Lesson"> | string | null
    duration?: IntNullableFilter<"Lesson"> | number | null
    orderIndex?: IntFilter<"Lesson"> | number
    type?: EnumLessonTypeFilter<"Lesson"> | $Enums.LessonType
    courseId?: StringNullableFilter<"Lesson"> | string | null
    topic?: XOR<TopicRelationFilter, TopicWhereInput>
    quiz?: XOR<QuizNullableRelationFilter, QuizWhereInput> | null
    assignment?: XOR<AssignmentNullableRelationFilter, AssignmentWhereInput> | null
    progress?: LessonProgressListRelationFilter
    calendarEvents?: CalendarEventListRelationFilter
    course?: XOR<CourseNullableRelationFilter, CourseWhereInput> | null
  }

  export type LessonOrderByWithRelationInput = {
    id?: SortOrder
    topicId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    videoUrl?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    orderIndex?: SortOrder
    type?: SortOrder
    courseId?: SortOrderInput | SortOrder
    topic?: TopicOrderByWithRelationInput
    quiz?: QuizOrderByWithRelationInput
    assignment?: AssignmentOrderByWithRelationInput
    progress?: LessonProgressOrderByRelationAggregateInput
    calendarEvents?: CalendarEventOrderByRelationAggregateInput
    course?: CourseOrderByWithRelationInput
  }

  export type LessonWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    topicId_orderIndex?: LessonTopicIdOrderIndexCompoundUniqueInput
    AND?: LessonWhereInput | LessonWhereInput[]
    OR?: LessonWhereInput[]
    NOT?: LessonWhereInput | LessonWhereInput[]
    topicId?: StringFilter<"Lesson"> | string
    title?: StringFilter<"Lesson"> | string
    description?: StringNullableFilter<"Lesson"> | string | null
    videoUrl?: StringNullableFilter<"Lesson"> | string | null
    content?: StringNullableFilter<"Lesson"> | string | null
    duration?: IntNullableFilter<"Lesson"> | number | null
    orderIndex?: IntFilter<"Lesson"> | number
    type?: EnumLessonTypeFilter<"Lesson"> | $Enums.LessonType
    courseId?: StringNullableFilter<"Lesson"> | string | null
    topic?: XOR<TopicRelationFilter, TopicWhereInput>
    quiz?: XOR<QuizNullableRelationFilter, QuizWhereInput> | null
    assignment?: XOR<AssignmentNullableRelationFilter, AssignmentWhereInput> | null
    progress?: LessonProgressListRelationFilter
    calendarEvents?: CalendarEventListRelationFilter
    course?: XOR<CourseNullableRelationFilter, CourseWhereInput> | null
  }, "id" | "topicId_orderIndex">

  export type LessonOrderByWithAggregationInput = {
    id?: SortOrder
    topicId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    videoUrl?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    orderIndex?: SortOrder
    type?: SortOrder
    courseId?: SortOrderInput | SortOrder
    _count?: LessonCountOrderByAggregateInput
    _avg?: LessonAvgOrderByAggregateInput
    _max?: LessonMaxOrderByAggregateInput
    _min?: LessonMinOrderByAggregateInput
    _sum?: LessonSumOrderByAggregateInput
  }

  export type LessonScalarWhereWithAggregatesInput = {
    AND?: LessonScalarWhereWithAggregatesInput | LessonScalarWhereWithAggregatesInput[]
    OR?: LessonScalarWhereWithAggregatesInput[]
    NOT?: LessonScalarWhereWithAggregatesInput | LessonScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Lesson"> | string
    topicId?: StringWithAggregatesFilter<"Lesson"> | string
    title?: StringWithAggregatesFilter<"Lesson"> | string
    description?: StringNullableWithAggregatesFilter<"Lesson"> | string | null
    videoUrl?: StringNullableWithAggregatesFilter<"Lesson"> | string | null
    content?: StringNullableWithAggregatesFilter<"Lesson"> | string | null
    duration?: IntNullableWithAggregatesFilter<"Lesson"> | number | null
    orderIndex?: IntWithAggregatesFilter<"Lesson"> | number
    type?: EnumLessonTypeWithAggregatesFilter<"Lesson"> | $Enums.LessonType
    courseId?: StringNullableWithAggregatesFilter<"Lesson"> | string | null
  }

  export type QuizWhereInput = {
    AND?: QuizWhereInput | QuizWhereInput[]
    OR?: QuizWhereInput[]
    NOT?: QuizWhereInput | QuizWhereInput[]
    id?: StringFilter<"Quiz"> | string
    lessonId?: StringFilter<"Quiz"> | string
    title?: StringFilter<"Quiz"> | string
    description?: StringNullableFilter<"Quiz"> | string | null
    timeLimit?: IntNullableFilter<"Quiz"> | number | null
    lesson?: XOR<LessonRelationFilter, LessonWhereInput>
    questions?: QuestionListRelationFilter
    attempts?: QuizAttemptListRelationFilter
  }

  export type QuizOrderByWithRelationInput = {
    id?: SortOrder
    lessonId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    timeLimit?: SortOrderInput | SortOrder
    lesson?: LessonOrderByWithRelationInput
    questions?: QuestionOrderByRelationAggregateInput
    attempts?: QuizAttemptOrderByRelationAggregateInput
  }

  export type QuizWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    lessonId?: string
    AND?: QuizWhereInput | QuizWhereInput[]
    OR?: QuizWhereInput[]
    NOT?: QuizWhereInput | QuizWhereInput[]
    title?: StringFilter<"Quiz"> | string
    description?: StringNullableFilter<"Quiz"> | string | null
    timeLimit?: IntNullableFilter<"Quiz"> | number | null
    lesson?: XOR<LessonRelationFilter, LessonWhereInput>
    questions?: QuestionListRelationFilter
    attempts?: QuizAttemptListRelationFilter
  }, "id" | "lessonId">

  export type QuizOrderByWithAggregationInput = {
    id?: SortOrder
    lessonId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    timeLimit?: SortOrderInput | SortOrder
    _count?: QuizCountOrderByAggregateInput
    _avg?: QuizAvgOrderByAggregateInput
    _max?: QuizMaxOrderByAggregateInput
    _min?: QuizMinOrderByAggregateInput
    _sum?: QuizSumOrderByAggregateInput
  }

  export type QuizScalarWhereWithAggregatesInput = {
    AND?: QuizScalarWhereWithAggregatesInput | QuizScalarWhereWithAggregatesInput[]
    OR?: QuizScalarWhereWithAggregatesInput[]
    NOT?: QuizScalarWhereWithAggregatesInput | QuizScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Quiz"> | string
    lessonId?: StringWithAggregatesFilter<"Quiz"> | string
    title?: StringWithAggregatesFilter<"Quiz"> | string
    description?: StringNullableWithAggregatesFilter<"Quiz"> | string | null
    timeLimit?: IntNullableWithAggregatesFilter<"Quiz"> | number | null
  }

  export type QuestionWhereInput = {
    AND?: QuestionWhereInput | QuestionWhereInput[]
    OR?: QuestionWhereInput[]
    NOT?: QuestionWhereInput | QuestionWhereInput[]
    id?: StringFilter<"Question"> | string
    quizId?: StringFilter<"Question"> | string
    questionText?: StringFilter<"Question"> | string
    type?: EnumQuestionTypeFilter<"Question"> | $Enums.QuestionType
    options?: JsonFilter<"Question">
    correctOptions?: IntNullableListFilter<"Question">
    orderIndex?: IntNullableFilter<"Question"> | number | null
    quiz?: XOR<QuizRelationFilter, QuizWhereInput>
  }

  export type QuestionOrderByWithRelationInput = {
    id?: SortOrder
    quizId?: SortOrder
    questionText?: SortOrder
    type?: SortOrder
    options?: SortOrder
    correctOptions?: SortOrder
    orderIndex?: SortOrderInput | SortOrder
    quiz?: QuizOrderByWithRelationInput
  }

  export type QuestionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: QuestionWhereInput | QuestionWhereInput[]
    OR?: QuestionWhereInput[]
    NOT?: QuestionWhereInput | QuestionWhereInput[]
    quizId?: StringFilter<"Question"> | string
    questionText?: StringFilter<"Question"> | string
    type?: EnumQuestionTypeFilter<"Question"> | $Enums.QuestionType
    options?: JsonFilter<"Question">
    correctOptions?: IntNullableListFilter<"Question">
    orderIndex?: IntNullableFilter<"Question"> | number | null
    quiz?: XOR<QuizRelationFilter, QuizWhereInput>
  }, "id">

  export type QuestionOrderByWithAggregationInput = {
    id?: SortOrder
    quizId?: SortOrder
    questionText?: SortOrder
    type?: SortOrder
    options?: SortOrder
    correctOptions?: SortOrder
    orderIndex?: SortOrderInput | SortOrder
    _count?: QuestionCountOrderByAggregateInput
    _avg?: QuestionAvgOrderByAggregateInput
    _max?: QuestionMaxOrderByAggregateInput
    _min?: QuestionMinOrderByAggregateInput
    _sum?: QuestionSumOrderByAggregateInput
  }

  export type QuestionScalarWhereWithAggregatesInput = {
    AND?: QuestionScalarWhereWithAggregatesInput | QuestionScalarWhereWithAggregatesInput[]
    OR?: QuestionScalarWhereWithAggregatesInput[]
    NOT?: QuestionScalarWhereWithAggregatesInput | QuestionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Question"> | string
    quizId?: StringWithAggregatesFilter<"Question"> | string
    questionText?: StringWithAggregatesFilter<"Question"> | string
    type?: EnumQuestionTypeWithAggregatesFilter<"Question"> | $Enums.QuestionType
    options?: JsonWithAggregatesFilter<"Question">
    correctOptions?: IntNullableListFilter<"Question">
    orderIndex?: IntNullableWithAggregatesFilter<"Question"> | number | null
  }

  export type AssignmentWhereInput = {
    AND?: AssignmentWhereInput | AssignmentWhereInput[]
    OR?: AssignmentWhereInput[]
    NOT?: AssignmentWhereInput | AssignmentWhereInput[]
    id?: StringFilter<"Assignment"> | string
    lessonId?: StringFilter<"Assignment"> | string
    title?: StringFilter<"Assignment"> | string
    description?: StringNullableFilter<"Assignment"> | string | null
    dueDate?: DateTimeNullableFilter<"Assignment"> | Date | string | null
    maxScore?: IntFilter<"Assignment"> | number
    allowFileUpload?: BoolFilter<"Assignment"> | boolean
    allowedFileTypes?: StringNullableListFilter<"Assignment">
    unitTests?: JsonNullableFilter<"Assignment">
    lesson?: XOR<LessonRelationFilter, LessonWhereInput>
    submissions?: AssignmentSubmissionListRelationFilter
  }

  export type AssignmentOrderByWithRelationInput = {
    id?: SortOrder
    lessonId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    dueDate?: SortOrderInput | SortOrder
    maxScore?: SortOrder
    allowFileUpload?: SortOrder
    allowedFileTypes?: SortOrder
    unitTests?: SortOrderInput | SortOrder
    lesson?: LessonOrderByWithRelationInput
    submissions?: AssignmentSubmissionOrderByRelationAggregateInput
  }

  export type AssignmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    lessonId?: string
    AND?: AssignmentWhereInput | AssignmentWhereInput[]
    OR?: AssignmentWhereInput[]
    NOT?: AssignmentWhereInput | AssignmentWhereInput[]
    title?: StringFilter<"Assignment"> | string
    description?: StringNullableFilter<"Assignment"> | string | null
    dueDate?: DateTimeNullableFilter<"Assignment"> | Date | string | null
    maxScore?: IntFilter<"Assignment"> | number
    allowFileUpload?: BoolFilter<"Assignment"> | boolean
    allowedFileTypes?: StringNullableListFilter<"Assignment">
    unitTests?: JsonNullableFilter<"Assignment">
    lesson?: XOR<LessonRelationFilter, LessonWhereInput>
    submissions?: AssignmentSubmissionListRelationFilter
  }, "id" | "lessonId">

  export type AssignmentOrderByWithAggregationInput = {
    id?: SortOrder
    lessonId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    dueDate?: SortOrderInput | SortOrder
    maxScore?: SortOrder
    allowFileUpload?: SortOrder
    allowedFileTypes?: SortOrder
    unitTests?: SortOrderInput | SortOrder
    _count?: AssignmentCountOrderByAggregateInput
    _avg?: AssignmentAvgOrderByAggregateInput
    _max?: AssignmentMaxOrderByAggregateInput
    _min?: AssignmentMinOrderByAggregateInput
    _sum?: AssignmentSumOrderByAggregateInput
  }

  export type AssignmentScalarWhereWithAggregatesInput = {
    AND?: AssignmentScalarWhereWithAggregatesInput | AssignmentScalarWhereWithAggregatesInput[]
    OR?: AssignmentScalarWhereWithAggregatesInput[]
    NOT?: AssignmentScalarWhereWithAggregatesInput | AssignmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Assignment"> | string
    lessonId?: StringWithAggregatesFilter<"Assignment"> | string
    title?: StringWithAggregatesFilter<"Assignment"> | string
    description?: StringNullableWithAggregatesFilter<"Assignment"> | string | null
    dueDate?: DateTimeNullableWithAggregatesFilter<"Assignment"> | Date | string | null
    maxScore?: IntWithAggregatesFilter<"Assignment"> | number
    allowFileUpload?: BoolWithAggregatesFilter<"Assignment"> | boolean
    allowedFileTypes?: StringNullableListFilter<"Assignment">
    unitTests?: JsonNullableWithAggregatesFilter<"Assignment">
  }

  export type EnrollmentWhereInput = {
    AND?: EnrollmentWhereInput | EnrollmentWhereInput[]
    OR?: EnrollmentWhereInput[]
    NOT?: EnrollmentWhereInput | EnrollmentWhereInput[]
    id?: StringFilter<"Enrollment"> | string
    userId?: StringFilter<"Enrollment"> | string
    courseId?: StringFilter<"Enrollment"> | string
    enrolledAt?: DateTimeFilter<"Enrollment"> | Date | string
    completed?: BoolFilter<"Enrollment"> | boolean
    completedAt?: DateTimeNullableFilter<"Enrollment"> | Date | string | null
    status?: StringFilter<"Enrollment"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    course?: XOR<CourseRelationFilter, CourseWhereInput>
  }

  export type EnrollmentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    enrolledAt?: SortOrder
    completed?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    user?: UserOrderByWithRelationInput
    course?: CourseOrderByWithRelationInput
  }

  export type EnrollmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_courseId?: EnrollmentUserIdCourseIdCompoundUniqueInput
    AND?: EnrollmentWhereInput | EnrollmentWhereInput[]
    OR?: EnrollmentWhereInput[]
    NOT?: EnrollmentWhereInput | EnrollmentWhereInput[]
    userId?: StringFilter<"Enrollment"> | string
    courseId?: StringFilter<"Enrollment"> | string
    enrolledAt?: DateTimeFilter<"Enrollment"> | Date | string
    completed?: BoolFilter<"Enrollment"> | boolean
    completedAt?: DateTimeNullableFilter<"Enrollment"> | Date | string | null
    status?: StringFilter<"Enrollment"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    course?: XOR<CourseRelationFilter, CourseWhereInput>
  }, "id" | "userId_courseId">

  export type EnrollmentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    enrolledAt?: SortOrder
    completed?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    _count?: EnrollmentCountOrderByAggregateInput
    _max?: EnrollmentMaxOrderByAggregateInput
    _min?: EnrollmentMinOrderByAggregateInput
  }

  export type EnrollmentScalarWhereWithAggregatesInput = {
    AND?: EnrollmentScalarWhereWithAggregatesInput | EnrollmentScalarWhereWithAggregatesInput[]
    OR?: EnrollmentScalarWhereWithAggregatesInput[]
    NOT?: EnrollmentScalarWhereWithAggregatesInput | EnrollmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Enrollment"> | string
    userId?: StringWithAggregatesFilter<"Enrollment"> | string
    courseId?: StringWithAggregatesFilter<"Enrollment"> | string
    enrolledAt?: DateTimeWithAggregatesFilter<"Enrollment"> | Date | string
    completed?: BoolWithAggregatesFilter<"Enrollment"> | boolean
    completedAt?: DateTimeNullableWithAggregatesFilter<"Enrollment"> | Date | string | null
    status?: StringWithAggregatesFilter<"Enrollment"> | string
  }

  export type SavedCourseWhereInput = {
    AND?: SavedCourseWhereInput | SavedCourseWhereInput[]
    OR?: SavedCourseWhereInput[]
    NOT?: SavedCourseWhereInput | SavedCourseWhereInput[]
    id?: StringFilter<"SavedCourse"> | string
    userId?: StringFilter<"SavedCourse"> | string
    courseId?: StringFilter<"SavedCourse"> | string
    savedAt?: DateTimeFilter<"SavedCourse"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    course?: XOR<CourseRelationFilter, CourseWhereInput>
  }

  export type SavedCourseOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    savedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    course?: CourseOrderByWithRelationInput
  }

  export type SavedCourseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_courseId?: SavedCourseUserIdCourseIdCompoundUniqueInput
    AND?: SavedCourseWhereInput | SavedCourseWhereInput[]
    OR?: SavedCourseWhereInput[]
    NOT?: SavedCourseWhereInput | SavedCourseWhereInput[]
    userId?: StringFilter<"SavedCourse"> | string
    courseId?: StringFilter<"SavedCourse"> | string
    savedAt?: DateTimeFilter<"SavedCourse"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    course?: XOR<CourseRelationFilter, CourseWhereInput>
  }, "id" | "userId_courseId">

  export type SavedCourseOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    savedAt?: SortOrder
    _count?: SavedCourseCountOrderByAggregateInput
    _max?: SavedCourseMaxOrderByAggregateInput
    _min?: SavedCourseMinOrderByAggregateInput
  }

  export type SavedCourseScalarWhereWithAggregatesInput = {
    AND?: SavedCourseScalarWhereWithAggregatesInput | SavedCourseScalarWhereWithAggregatesInput[]
    OR?: SavedCourseScalarWhereWithAggregatesInput[]
    NOT?: SavedCourseScalarWhereWithAggregatesInput | SavedCourseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SavedCourse"> | string
    userId?: StringWithAggregatesFilter<"SavedCourse"> | string
    courseId?: StringWithAggregatesFilter<"SavedCourse"> | string
    savedAt?: DateTimeWithAggregatesFilter<"SavedCourse"> | Date | string
  }

  export type LikedCourseWhereInput = {
    AND?: LikedCourseWhereInput | LikedCourseWhereInput[]
    OR?: LikedCourseWhereInput[]
    NOT?: LikedCourseWhereInput | LikedCourseWhereInput[]
    id?: StringFilter<"LikedCourse"> | string
    userId?: StringFilter<"LikedCourse"> | string
    courseId?: StringFilter<"LikedCourse"> | string
    likedAt?: DateTimeFilter<"LikedCourse"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    course?: XOR<CourseRelationFilter, CourseWhereInput>
  }

  export type LikedCourseOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    likedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    course?: CourseOrderByWithRelationInput
  }

  export type LikedCourseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_courseId?: LikedCourseUserIdCourseIdCompoundUniqueInput
    AND?: LikedCourseWhereInput | LikedCourseWhereInput[]
    OR?: LikedCourseWhereInput[]
    NOT?: LikedCourseWhereInput | LikedCourseWhereInput[]
    userId?: StringFilter<"LikedCourse"> | string
    courseId?: StringFilter<"LikedCourse"> | string
    likedAt?: DateTimeFilter<"LikedCourse"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    course?: XOR<CourseRelationFilter, CourseWhereInput>
  }, "id" | "userId_courseId">

  export type LikedCourseOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    likedAt?: SortOrder
    _count?: LikedCourseCountOrderByAggregateInput
    _max?: LikedCourseMaxOrderByAggregateInput
    _min?: LikedCourseMinOrderByAggregateInput
  }

  export type LikedCourseScalarWhereWithAggregatesInput = {
    AND?: LikedCourseScalarWhereWithAggregatesInput | LikedCourseScalarWhereWithAggregatesInput[]
    OR?: LikedCourseScalarWhereWithAggregatesInput[]
    NOT?: LikedCourseScalarWhereWithAggregatesInput | LikedCourseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LikedCourse"> | string
    userId?: StringWithAggregatesFilter<"LikedCourse"> | string
    courseId?: StringWithAggregatesFilter<"LikedCourse"> | string
    likedAt?: DateTimeWithAggregatesFilter<"LikedCourse"> | Date | string
  }

  export type LessonProgressWhereInput = {
    AND?: LessonProgressWhereInput | LessonProgressWhereInput[]
    OR?: LessonProgressWhereInput[]
    NOT?: LessonProgressWhereInput | LessonProgressWhereInput[]
    id?: StringFilter<"LessonProgress"> | string
    userId?: StringFilter<"LessonProgress"> | string
    lessonId?: StringFilter<"LessonProgress"> | string
    completed?: BoolFilter<"LessonProgress"> | boolean
    completedAt?: DateTimeNullableFilter<"LessonProgress"> | Date | string | null
    lastPosition?: IntFilter<"LessonProgress"> | number
    user?: XOR<UserRelationFilter, UserWhereInput>
    lesson?: XOR<LessonRelationFilter, LessonWhereInput>
  }

  export type LessonProgressOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    lessonId?: SortOrder
    completed?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    lastPosition?: SortOrder
    user?: UserOrderByWithRelationInput
    lesson?: LessonOrderByWithRelationInput
  }

  export type LessonProgressWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_lessonId?: LessonProgressUserIdLessonIdCompoundUniqueInput
    AND?: LessonProgressWhereInput | LessonProgressWhereInput[]
    OR?: LessonProgressWhereInput[]
    NOT?: LessonProgressWhereInput | LessonProgressWhereInput[]
    userId?: StringFilter<"LessonProgress"> | string
    lessonId?: StringFilter<"LessonProgress"> | string
    completed?: BoolFilter<"LessonProgress"> | boolean
    completedAt?: DateTimeNullableFilter<"LessonProgress"> | Date | string | null
    lastPosition?: IntFilter<"LessonProgress"> | number
    user?: XOR<UserRelationFilter, UserWhereInput>
    lesson?: XOR<LessonRelationFilter, LessonWhereInput>
  }, "id" | "userId_lessonId">

  export type LessonProgressOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    lessonId?: SortOrder
    completed?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    lastPosition?: SortOrder
    _count?: LessonProgressCountOrderByAggregateInput
    _avg?: LessonProgressAvgOrderByAggregateInput
    _max?: LessonProgressMaxOrderByAggregateInput
    _min?: LessonProgressMinOrderByAggregateInput
    _sum?: LessonProgressSumOrderByAggregateInput
  }

  export type LessonProgressScalarWhereWithAggregatesInput = {
    AND?: LessonProgressScalarWhereWithAggregatesInput | LessonProgressScalarWhereWithAggregatesInput[]
    OR?: LessonProgressScalarWhereWithAggregatesInput[]
    NOT?: LessonProgressScalarWhereWithAggregatesInput | LessonProgressScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LessonProgress"> | string
    userId?: StringWithAggregatesFilter<"LessonProgress"> | string
    lessonId?: StringWithAggregatesFilter<"LessonProgress"> | string
    completed?: BoolWithAggregatesFilter<"LessonProgress"> | boolean
    completedAt?: DateTimeNullableWithAggregatesFilter<"LessonProgress"> | Date | string | null
    lastPosition?: IntWithAggregatesFilter<"LessonProgress"> | number
  }

  export type QuizAttemptWhereInput = {
    AND?: QuizAttemptWhereInput | QuizAttemptWhereInput[]
    OR?: QuizAttemptWhereInput[]
    NOT?: QuizAttemptWhereInput | QuizAttemptWhereInput[]
    id?: StringFilter<"QuizAttempt"> | string
    userId?: StringFilter<"QuizAttempt"> | string
    quizId?: StringFilter<"QuizAttempt"> | string
    score?: IntFilter<"QuizAttempt"> | number
    duration?: IntNullableFilter<"QuizAttempt"> | number | null
    completedAt?: DateTimeFilter<"QuizAttempt"> | Date | string
    answers?: JsonFilter<"QuizAttempt">
    courseId?: StringNullableFilter<"QuizAttempt"> | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    quiz?: XOR<QuizRelationFilter, QuizWhereInput>
    course?: XOR<CourseNullableRelationFilter, CourseWhereInput> | null
  }

  export type QuizAttemptOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    quizId?: SortOrder
    score?: SortOrder
    duration?: SortOrderInput | SortOrder
    completedAt?: SortOrder
    answers?: SortOrder
    courseId?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    quiz?: QuizOrderByWithRelationInput
    course?: CourseOrderByWithRelationInput
  }

  export type QuizAttemptWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: QuizAttemptWhereInput | QuizAttemptWhereInput[]
    OR?: QuizAttemptWhereInput[]
    NOT?: QuizAttemptWhereInput | QuizAttemptWhereInput[]
    userId?: StringFilter<"QuizAttempt"> | string
    quizId?: StringFilter<"QuizAttempt"> | string
    score?: IntFilter<"QuizAttempt"> | number
    duration?: IntNullableFilter<"QuizAttempt"> | number | null
    completedAt?: DateTimeFilter<"QuizAttempt"> | Date | string
    answers?: JsonFilter<"QuizAttempt">
    courseId?: StringNullableFilter<"QuizAttempt"> | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    quiz?: XOR<QuizRelationFilter, QuizWhereInput>
    course?: XOR<CourseNullableRelationFilter, CourseWhereInput> | null
  }, "id">

  export type QuizAttemptOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    quizId?: SortOrder
    score?: SortOrder
    duration?: SortOrderInput | SortOrder
    completedAt?: SortOrder
    answers?: SortOrder
    courseId?: SortOrderInput | SortOrder
    _count?: QuizAttemptCountOrderByAggregateInput
    _avg?: QuizAttemptAvgOrderByAggregateInput
    _max?: QuizAttemptMaxOrderByAggregateInput
    _min?: QuizAttemptMinOrderByAggregateInput
    _sum?: QuizAttemptSumOrderByAggregateInput
  }

  export type QuizAttemptScalarWhereWithAggregatesInput = {
    AND?: QuizAttemptScalarWhereWithAggregatesInput | QuizAttemptScalarWhereWithAggregatesInput[]
    OR?: QuizAttemptScalarWhereWithAggregatesInput[]
    NOT?: QuizAttemptScalarWhereWithAggregatesInput | QuizAttemptScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"QuizAttempt"> | string
    userId?: StringWithAggregatesFilter<"QuizAttempt"> | string
    quizId?: StringWithAggregatesFilter<"QuizAttempt"> | string
    score?: IntWithAggregatesFilter<"QuizAttempt"> | number
    duration?: IntNullableWithAggregatesFilter<"QuizAttempt"> | number | null
    completedAt?: DateTimeWithAggregatesFilter<"QuizAttempt"> | Date | string
    answers?: JsonWithAggregatesFilter<"QuizAttempt">
    courseId?: StringNullableWithAggregatesFilter<"QuizAttempt"> | string | null
  }

  export type AssignmentSubmissionWhereInput = {
    AND?: AssignmentSubmissionWhereInput | AssignmentSubmissionWhereInput[]
    OR?: AssignmentSubmissionWhereInput[]
    NOT?: AssignmentSubmissionWhereInput | AssignmentSubmissionWhereInput[]
    id?: StringFilter<"AssignmentSubmission"> | string
    userId?: StringFilter<"AssignmentSubmission"> | string
    assignmentId?: StringFilter<"AssignmentSubmission"> | string
    content?: StringNullableFilter<"AssignmentSubmission"> | string | null
    fileUrls?: StringNullableListFilter<"AssignmentSubmission">
    submittedAt?: DateTimeFilter<"AssignmentSubmission"> | Date | string
    score?: IntNullableFilter<"AssignmentSubmission"> | number | null
    feedback?: StringNullableFilter<"AssignmentSubmission"> | string | null
    gradedAt?: DateTimeNullableFilter<"AssignmentSubmission"> | Date | string | null
    gradedById?: StringNullableFilter<"AssignmentSubmission"> | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    assignment?: XOR<AssignmentRelationFilter, AssignmentWhereInput>
    gradedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type AssignmentSubmissionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    assignmentId?: SortOrder
    content?: SortOrderInput | SortOrder
    fileUrls?: SortOrder
    submittedAt?: SortOrder
    score?: SortOrderInput | SortOrder
    feedback?: SortOrderInput | SortOrder
    gradedAt?: SortOrderInput | SortOrder
    gradedById?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    assignment?: AssignmentOrderByWithRelationInput
    gradedBy?: UserOrderByWithRelationInput
  }

  export type AssignmentSubmissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AssignmentSubmissionWhereInput | AssignmentSubmissionWhereInput[]
    OR?: AssignmentSubmissionWhereInput[]
    NOT?: AssignmentSubmissionWhereInput | AssignmentSubmissionWhereInput[]
    userId?: StringFilter<"AssignmentSubmission"> | string
    assignmentId?: StringFilter<"AssignmentSubmission"> | string
    content?: StringNullableFilter<"AssignmentSubmission"> | string | null
    fileUrls?: StringNullableListFilter<"AssignmentSubmission">
    submittedAt?: DateTimeFilter<"AssignmentSubmission"> | Date | string
    score?: IntNullableFilter<"AssignmentSubmission"> | number | null
    feedback?: StringNullableFilter<"AssignmentSubmission"> | string | null
    gradedAt?: DateTimeNullableFilter<"AssignmentSubmission"> | Date | string | null
    gradedById?: StringNullableFilter<"AssignmentSubmission"> | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    assignment?: XOR<AssignmentRelationFilter, AssignmentWhereInput>
    gradedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type AssignmentSubmissionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    assignmentId?: SortOrder
    content?: SortOrderInput | SortOrder
    fileUrls?: SortOrder
    submittedAt?: SortOrder
    score?: SortOrderInput | SortOrder
    feedback?: SortOrderInput | SortOrder
    gradedAt?: SortOrderInput | SortOrder
    gradedById?: SortOrderInput | SortOrder
    _count?: AssignmentSubmissionCountOrderByAggregateInput
    _avg?: AssignmentSubmissionAvgOrderByAggregateInput
    _max?: AssignmentSubmissionMaxOrderByAggregateInput
    _min?: AssignmentSubmissionMinOrderByAggregateInput
    _sum?: AssignmentSubmissionSumOrderByAggregateInput
  }

  export type AssignmentSubmissionScalarWhereWithAggregatesInput = {
    AND?: AssignmentSubmissionScalarWhereWithAggregatesInput | AssignmentSubmissionScalarWhereWithAggregatesInput[]
    OR?: AssignmentSubmissionScalarWhereWithAggregatesInput[]
    NOT?: AssignmentSubmissionScalarWhereWithAggregatesInput | AssignmentSubmissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AssignmentSubmission"> | string
    userId?: StringWithAggregatesFilter<"AssignmentSubmission"> | string
    assignmentId?: StringWithAggregatesFilter<"AssignmentSubmission"> | string
    content?: StringNullableWithAggregatesFilter<"AssignmentSubmission"> | string | null
    fileUrls?: StringNullableListFilter<"AssignmentSubmission">
    submittedAt?: DateTimeWithAggregatesFilter<"AssignmentSubmission"> | Date | string
    score?: IntNullableWithAggregatesFilter<"AssignmentSubmission"> | number | null
    feedback?: StringNullableWithAggregatesFilter<"AssignmentSubmission"> | string | null
    gradedAt?: DateTimeNullableWithAggregatesFilter<"AssignmentSubmission"> | Date | string | null
    gradedById?: StringNullableWithAggregatesFilter<"AssignmentSubmission"> | string | null
  }

  export type CourseReviewWhereInput = {
    AND?: CourseReviewWhereInput | CourseReviewWhereInput[]
    OR?: CourseReviewWhereInput[]
    NOT?: CourseReviewWhereInput | CourseReviewWhereInput[]
    id?: StringFilter<"CourseReview"> | string
    userId?: StringFilter<"CourseReview"> | string
    courseId?: StringFilter<"CourseReview"> | string
    rating?: IntFilter<"CourseReview"> | number
    comment?: StringNullableFilter<"CourseReview"> | string | null
    createdAt?: DateTimeFilter<"CourseReview"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    course?: XOR<CourseRelationFilter, CourseWhereInput>
  }

  export type CourseReviewOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    rating?: SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    course?: CourseOrderByWithRelationInput
  }

  export type CourseReviewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_courseId?: CourseReviewUserIdCourseIdCompoundUniqueInput
    AND?: CourseReviewWhereInput | CourseReviewWhereInput[]
    OR?: CourseReviewWhereInput[]
    NOT?: CourseReviewWhereInput | CourseReviewWhereInput[]
    userId?: StringFilter<"CourseReview"> | string
    courseId?: StringFilter<"CourseReview"> | string
    rating?: IntFilter<"CourseReview"> | number
    comment?: StringNullableFilter<"CourseReview"> | string | null
    createdAt?: DateTimeFilter<"CourseReview"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    course?: XOR<CourseRelationFilter, CourseWhereInput>
  }, "id" | "userId_courseId">

  export type CourseReviewOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    rating?: SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: CourseReviewCountOrderByAggregateInput
    _avg?: CourseReviewAvgOrderByAggregateInput
    _max?: CourseReviewMaxOrderByAggregateInput
    _min?: CourseReviewMinOrderByAggregateInput
    _sum?: CourseReviewSumOrderByAggregateInput
  }

  export type CourseReviewScalarWhereWithAggregatesInput = {
    AND?: CourseReviewScalarWhereWithAggregatesInput | CourseReviewScalarWhereWithAggregatesInput[]
    OR?: CourseReviewScalarWhereWithAggregatesInput[]
    NOT?: CourseReviewScalarWhereWithAggregatesInput | CourseReviewScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CourseReview"> | string
    userId?: StringWithAggregatesFilter<"CourseReview"> | string
    courseId?: StringWithAggregatesFilter<"CourseReview"> | string
    rating?: IntWithAggregatesFilter<"CourseReview"> | number
    comment?: StringNullableWithAggregatesFilter<"CourseReview"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CourseReview"> | Date | string
  }

  export type TutoringSessionWhereInput = {
    AND?: TutoringSessionWhereInput | TutoringSessionWhereInput[]
    OR?: TutoringSessionWhereInput[]
    NOT?: TutoringSessionWhereInput | TutoringSessionWhereInput[]
    id?: StringFilter<"TutoringSession"> | string
    teacherId?: StringFilter<"TutoringSession"> | string
    subject?: StringFilter<"TutoringSession"> | string
    description?: StringNullableFilter<"TutoringSession"> | string | null
    pricePerHour?: DecimalFilter<"TutoringSession"> | Decimal | DecimalJsLike | number | string
    locationType?: EnumTutoringLocationTypeFilter<"TutoringSession"> | $Enums.TutoringLocationType
    status?: EnumTutoringStatusFilter<"TutoringSession"> | $Enums.TutoringStatus
    createdAt?: DateTimeFilter<"TutoringSession"> | Date | string
    updatedAt?: DateTimeFilter<"TutoringSession"> | Date | string
    maxStudents?: IntFilter<"TutoringSession"> | number
    prerequisites?: StringNullableListFilter<"TutoringSession">
    level?: StringNullableFilter<"TutoringSession"> | string | null
    tags?: StringNullableListFilter<"TutoringSession">
    featured?: BoolFilter<"TutoringSession"> | boolean
    teacher?: XOR<UserRelationFilter, UserWhereInput>
    availability?: TutoringAvailabilityListRelationFilter
    requests?: TutoringRequestListRelationFilter
    appointments?: TutoringAppointmentListRelationFilter
    reviews?: TutoringReviewListRelationFilter
    certificates?: CertificateListRelationFilter
  }

  export type TutoringSessionOrderByWithRelationInput = {
    id?: SortOrder
    teacherId?: SortOrder
    subject?: SortOrder
    description?: SortOrderInput | SortOrder
    pricePerHour?: SortOrder
    locationType?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    maxStudents?: SortOrder
    prerequisites?: SortOrder
    level?: SortOrderInput | SortOrder
    tags?: SortOrder
    featured?: SortOrder
    teacher?: UserOrderByWithRelationInput
    availability?: TutoringAvailabilityOrderByRelationAggregateInput
    requests?: TutoringRequestOrderByRelationAggregateInput
    appointments?: TutoringAppointmentOrderByRelationAggregateInput
    reviews?: TutoringReviewOrderByRelationAggregateInput
    certificates?: CertificateOrderByRelationAggregateInput
  }

  export type TutoringSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TutoringSessionWhereInput | TutoringSessionWhereInput[]
    OR?: TutoringSessionWhereInput[]
    NOT?: TutoringSessionWhereInput | TutoringSessionWhereInput[]
    teacherId?: StringFilter<"TutoringSession"> | string
    subject?: StringFilter<"TutoringSession"> | string
    description?: StringNullableFilter<"TutoringSession"> | string | null
    pricePerHour?: DecimalFilter<"TutoringSession"> | Decimal | DecimalJsLike | number | string
    locationType?: EnumTutoringLocationTypeFilter<"TutoringSession"> | $Enums.TutoringLocationType
    status?: EnumTutoringStatusFilter<"TutoringSession"> | $Enums.TutoringStatus
    createdAt?: DateTimeFilter<"TutoringSession"> | Date | string
    updatedAt?: DateTimeFilter<"TutoringSession"> | Date | string
    maxStudents?: IntFilter<"TutoringSession"> | number
    prerequisites?: StringNullableListFilter<"TutoringSession">
    level?: StringNullableFilter<"TutoringSession"> | string | null
    tags?: StringNullableListFilter<"TutoringSession">
    featured?: BoolFilter<"TutoringSession"> | boolean
    teacher?: XOR<UserRelationFilter, UserWhereInput>
    availability?: TutoringAvailabilityListRelationFilter
    requests?: TutoringRequestListRelationFilter
    appointments?: TutoringAppointmentListRelationFilter
    reviews?: TutoringReviewListRelationFilter
    certificates?: CertificateListRelationFilter
  }, "id">

  export type TutoringSessionOrderByWithAggregationInput = {
    id?: SortOrder
    teacherId?: SortOrder
    subject?: SortOrder
    description?: SortOrderInput | SortOrder
    pricePerHour?: SortOrder
    locationType?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    maxStudents?: SortOrder
    prerequisites?: SortOrder
    level?: SortOrderInput | SortOrder
    tags?: SortOrder
    featured?: SortOrder
    _count?: TutoringSessionCountOrderByAggregateInput
    _avg?: TutoringSessionAvgOrderByAggregateInput
    _max?: TutoringSessionMaxOrderByAggregateInput
    _min?: TutoringSessionMinOrderByAggregateInput
    _sum?: TutoringSessionSumOrderByAggregateInput
  }

  export type TutoringSessionScalarWhereWithAggregatesInput = {
    AND?: TutoringSessionScalarWhereWithAggregatesInput | TutoringSessionScalarWhereWithAggregatesInput[]
    OR?: TutoringSessionScalarWhereWithAggregatesInput[]
    NOT?: TutoringSessionScalarWhereWithAggregatesInput | TutoringSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TutoringSession"> | string
    teacherId?: StringWithAggregatesFilter<"TutoringSession"> | string
    subject?: StringWithAggregatesFilter<"TutoringSession"> | string
    description?: StringNullableWithAggregatesFilter<"TutoringSession"> | string | null
    pricePerHour?: DecimalWithAggregatesFilter<"TutoringSession"> | Decimal | DecimalJsLike | number | string
    locationType?: EnumTutoringLocationTypeWithAggregatesFilter<"TutoringSession"> | $Enums.TutoringLocationType
    status?: EnumTutoringStatusWithAggregatesFilter<"TutoringSession"> | $Enums.TutoringStatus
    createdAt?: DateTimeWithAggregatesFilter<"TutoringSession"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TutoringSession"> | Date | string
    maxStudents?: IntWithAggregatesFilter<"TutoringSession"> | number
    prerequisites?: StringNullableListFilter<"TutoringSession">
    level?: StringNullableWithAggregatesFilter<"TutoringSession"> | string | null
    tags?: StringNullableListFilter<"TutoringSession">
    featured?: BoolWithAggregatesFilter<"TutoringSession"> | boolean
  }

  export type TutoringAvailabilityWhereInput = {
    AND?: TutoringAvailabilityWhereInput | TutoringAvailabilityWhereInput[]
    OR?: TutoringAvailabilityWhereInput[]
    NOT?: TutoringAvailabilityWhereInput | TutoringAvailabilityWhereInput[]
    id?: StringFilter<"TutoringAvailability"> | string
    sessionId?: StringFilter<"TutoringAvailability"> | string
    dayOfWeek?: IntFilter<"TutoringAvailability"> | number
    startTime?: DateTimeFilter<"TutoringAvailability"> | Date | string
    endTime?: DateTimeFilter<"TutoringAvailability"> | Date | string
    session?: XOR<TutoringSessionRelationFilter, TutoringSessionWhereInput>
  }

  export type TutoringAvailabilityOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    session?: TutoringSessionOrderByWithRelationInput
  }

  export type TutoringAvailabilityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TutoringAvailabilityWhereInput | TutoringAvailabilityWhereInput[]
    OR?: TutoringAvailabilityWhereInput[]
    NOT?: TutoringAvailabilityWhereInput | TutoringAvailabilityWhereInput[]
    sessionId?: StringFilter<"TutoringAvailability"> | string
    dayOfWeek?: IntFilter<"TutoringAvailability"> | number
    startTime?: DateTimeFilter<"TutoringAvailability"> | Date | string
    endTime?: DateTimeFilter<"TutoringAvailability"> | Date | string
    session?: XOR<TutoringSessionRelationFilter, TutoringSessionWhereInput>
  }, "id">

  export type TutoringAvailabilityOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    _count?: TutoringAvailabilityCountOrderByAggregateInput
    _avg?: TutoringAvailabilityAvgOrderByAggregateInput
    _max?: TutoringAvailabilityMaxOrderByAggregateInput
    _min?: TutoringAvailabilityMinOrderByAggregateInput
    _sum?: TutoringAvailabilitySumOrderByAggregateInput
  }

  export type TutoringAvailabilityScalarWhereWithAggregatesInput = {
    AND?: TutoringAvailabilityScalarWhereWithAggregatesInput | TutoringAvailabilityScalarWhereWithAggregatesInput[]
    OR?: TutoringAvailabilityScalarWhereWithAggregatesInput[]
    NOT?: TutoringAvailabilityScalarWhereWithAggregatesInput | TutoringAvailabilityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TutoringAvailability"> | string
    sessionId?: StringWithAggregatesFilter<"TutoringAvailability"> | string
    dayOfWeek?: IntWithAggregatesFilter<"TutoringAvailability"> | number
    startTime?: DateTimeWithAggregatesFilter<"TutoringAvailability"> | Date | string
    endTime?: DateTimeWithAggregatesFilter<"TutoringAvailability"> | Date | string
  }

  export type TutoringRequestWhereInput = {
    AND?: TutoringRequestWhereInput | TutoringRequestWhereInput[]
    OR?: TutoringRequestWhereInput[]
    NOT?: TutoringRequestWhereInput | TutoringRequestWhereInput[]
    id?: StringFilter<"TutoringRequest"> | string
    sessionId?: StringFilter<"TutoringRequest"> | string
    studentId?: StringFilter<"TutoringRequest"> | string
    message?: StringNullableFilter<"TutoringRequest"> | string | null
    preferredDates?: DateTimeNullableListFilter<"TutoringRequest">
    status?: EnumTutoringRequestStatusFilter<"TutoringRequest"> | $Enums.TutoringRequestStatus
    createdAt?: DateTimeFilter<"TutoringRequest"> | Date | string
    updatedAt?: DateTimeFilter<"TutoringRequest"> | Date | string
    session?: XOR<TutoringSessionRelationFilter, TutoringSessionWhereInput>
    student?: XOR<UserRelationFilter, UserWhereInput>
    appointment?: XOR<TutoringAppointmentNullableRelationFilter, TutoringAppointmentWhereInput> | null
    messages?: TutoringMessageListRelationFilter
  }

  export type TutoringRequestOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    studentId?: SortOrder
    message?: SortOrderInput | SortOrder
    preferredDates?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    session?: TutoringSessionOrderByWithRelationInput
    student?: UserOrderByWithRelationInput
    appointment?: TutoringAppointmentOrderByWithRelationInput
    messages?: TutoringMessageOrderByRelationAggregateInput
  }

  export type TutoringRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TutoringRequestWhereInput | TutoringRequestWhereInput[]
    OR?: TutoringRequestWhereInput[]
    NOT?: TutoringRequestWhereInput | TutoringRequestWhereInput[]
    sessionId?: StringFilter<"TutoringRequest"> | string
    studentId?: StringFilter<"TutoringRequest"> | string
    message?: StringNullableFilter<"TutoringRequest"> | string | null
    preferredDates?: DateTimeNullableListFilter<"TutoringRequest">
    status?: EnumTutoringRequestStatusFilter<"TutoringRequest"> | $Enums.TutoringRequestStatus
    createdAt?: DateTimeFilter<"TutoringRequest"> | Date | string
    updatedAt?: DateTimeFilter<"TutoringRequest"> | Date | string
    session?: XOR<TutoringSessionRelationFilter, TutoringSessionWhereInput>
    student?: XOR<UserRelationFilter, UserWhereInput>
    appointment?: XOR<TutoringAppointmentNullableRelationFilter, TutoringAppointmentWhereInput> | null
    messages?: TutoringMessageListRelationFilter
  }, "id">

  export type TutoringRequestOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    studentId?: SortOrder
    message?: SortOrderInput | SortOrder
    preferredDates?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TutoringRequestCountOrderByAggregateInput
    _max?: TutoringRequestMaxOrderByAggregateInput
    _min?: TutoringRequestMinOrderByAggregateInput
  }

  export type TutoringRequestScalarWhereWithAggregatesInput = {
    AND?: TutoringRequestScalarWhereWithAggregatesInput | TutoringRequestScalarWhereWithAggregatesInput[]
    OR?: TutoringRequestScalarWhereWithAggregatesInput[]
    NOT?: TutoringRequestScalarWhereWithAggregatesInput | TutoringRequestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TutoringRequest"> | string
    sessionId?: StringWithAggregatesFilter<"TutoringRequest"> | string
    studentId?: StringWithAggregatesFilter<"TutoringRequest"> | string
    message?: StringNullableWithAggregatesFilter<"TutoringRequest"> | string | null
    preferredDates?: DateTimeNullableListFilter<"TutoringRequest">
    status?: EnumTutoringRequestStatusWithAggregatesFilter<"TutoringRequest"> | $Enums.TutoringRequestStatus
    createdAt?: DateTimeWithAggregatesFilter<"TutoringRequest"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TutoringRequest"> | Date | string
  }

  export type TutoringAppointmentWhereInput = {
    AND?: TutoringAppointmentWhereInput | TutoringAppointmentWhereInput[]
    OR?: TutoringAppointmentWhereInput[]
    NOT?: TutoringAppointmentWhereInput | TutoringAppointmentWhereInput[]
    id?: StringFilter<"TutoringAppointment"> | string
    requestId?: StringFilter<"TutoringAppointment"> | string
    sessionId?: StringFilter<"TutoringAppointment"> | string
    scheduledAt?: DateTimeFilter<"TutoringAppointment"> | Date | string
    duration?: IntFilter<"TutoringAppointment"> | number
    notes?: StringNullableFilter<"TutoringAppointment"> | string | null
    meetingLink?: StringNullableFilter<"TutoringAppointment"> | string | null
    status?: EnumAppointmentStatusFilter<"TutoringAppointment"> | $Enums.AppointmentStatus
    price?: DecimalFilter<"TutoringAppointment"> | Decimal | DecimalJsLike | number | string
    teacherId?: StringFilter<"TutoringAppointment"> | string
    studentId?: StringFilter<"TutoringAppointment"> | string
    request?: XOR<TutoringRequestRelationFilter, TutoringRequestWhereInput>
    session?: XOR<TutoringSessionRelationFilter, TutoringSessionWhereInput>
    teacher?: XOR<UserRelationFilter, UserWhereInput>
    student?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type TutoringAppointmentOrderByWithRelationInput = {
    id?: SortOrder
    requestId?: SortOrder
    sessionId?: SortOrder
    scheduledAt?: SortOrder
    duration?: SortOrder
    notes?: SortOrderInput | SortOrder
    meetingLink?: SortOrderInput | SortOrder
    status?: SortOrder
    price?: SortOrder
    teacherId?: SortOrder
    studentId?: SortOrder
    request?: TutoringRequestOrderByWithRelationInput
    session?: TutoringSessionOrderByWithRelationInput
    teacher?: UserOrderByWithRelationInput
    student?: UserOrderByWithRelationInput
  }

  export type TutoringAppointmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    requestId?: string
    AND?: TutoringAppointmentWhereInput | TutoringAppointmentWhereInput[]
    OR?: TutoringAppointmentWhereInput[]
    NOT?: TutoringAppointmentWhereInput | TutoringAppointmentWhereInput[]
    sessionId?: StringFilter<"TutoringAppointment"> | string
    scheduledAt?: DateTimeFilter<"TutoringAppointment"> | Date | string
    duration?: IntFilter<"TutoringAppointment"> | number
    notes?: StringNullableFilter<"TutoringAppointment"> | string | null
    meetingLink?: StringNullableFilter<"TutoringAppointment"> | string | null
    status?: EnumAppointmentStatusFilter<"TutoringAppointment"> | $Enums.AppointmentStatus
    price?: DecimalFilter<"TutoringAppointment"> | Decimal | DecimalJsLike | number | string
    teacherId?: StringFilter<"TutoringAppointment"> | string
    studentId?: StringFilter<"TutoringAppointment"> | string
    request?: XOR<TutoringRequestRelationFilter, TutoringRequestWhereInput>
    session?: XOR<TutoringSessionRelationFilter, TutoringSessionWhereInput>
    teacher?: XOR<UserRelationFilter, UserWhereInput>
    student?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "requestId">

  export type TutoringAppointmentOrderByWithAggregationInput = {
    id?: SortOrder
    requestId?: SortOrder
    sessionId?: SortOrder
    scheduledAt?: SortOrder
    duration?: SortOrder
    notes?: SortOrderInput | SortOrder
    meetingLink?: SortOrderInput | SortOrder
    status?: SortOrder
    price?: SortOrder
    teacherId?: SortOrder
    studentId?: SortOrder
    _count?: TutoringAppointmentCountOrderByAggregateInput
    _avg?: TutoringAppointmentAvgOrderByAggregateInput
    _max?: TutoringAppointmentMaxOrderByAggregateInput
    _min?: TutoringAppointmentMinOrderByAggregateInput
    _sum?: TutoringAppointmentSumOrderByAggregateInput
  }

  export type TutoringAppointmentScalarWhereWithAggregatesInput = {
    AND?: TutoringAppointmentScalarWhereWithAggregatesInput | TutoringAppointmentScalarWhereWithAggregatesInput[]
    OR?: TutoringAppointmentScalarWhereWithAggregatesInput[]
    NOT?: TutoringAppointmentScalarWhereWithAggregatesInput | TutoringAppointmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TutoringAppointment"> | string
    requestId?: StringWithAggregatesFilter<"TutoringAppointment"> | string
    sessionId?: StringWithAggregatesFilter<"TutoringAppointment"> | string
    scheduledAt?: DateTimeWithAggregatesFilter<"TutoringAppointment"> | Date | string
    duration?: IntWithAggregatesFilter<"TutoringAppointment"> | number
    notes?: StringNullableWithAggregatesFilter<"TutoringAppointment"> | string | null
    meetingLink?: StringNullableWithAggregatesFilter<"TutoringAppointment"> | string | null
    status?: EnumAppointmentStatusWithAggregatesFilter<"TutoringAppointment"> | $Enums.AppointmentStatus
    price?: DecimalWithAggregatesFilter<"TutoringAppointment"> | Decimal | DecimalJsLike | number | string
    teacherId?: StringWithAggregatesFilter<"TutoringAppointment"> | string
    studentId?: StringWithAggregatesFilter<"TutoringAppointment"> | string
  }

  export type TutoringReviewWhereInput = {
    AND?: TutoringReviewWhereInput | TutoringReviewWhereInput[]
    OR?: TutoringReviewWhereInput[]
    NOT?: TutoringReviewWhereInput | TutoringReviewWhereInput[]
    id?: StringFilter<"TutoringReview"> | string
    sessionId?: StringFilter<"TutoringReview"> | string
    studentId?: StringFilter<"TutoringReview"> | string
    rating?: IntFilter<"TutoringReview"> | number
    comment?: StringNullableFilter<"TutoringReview"> | string | null
    createdAt?: DateTimeFilter<"TutoringReview"> | Date | string
    session?: XOR<TutoringSessionRelationFilter, TutoringSessionWhereInput>
    student?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type TutoringReviewOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    studentId?: SortOrder
    rating?: SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    session?: TutoringSessionOrderByWithRelationInput
    student?: UserOrderByWithRelationInput
  }

  export type TutoringReviewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    studentId_sessionId?: TutoringReviewStudentIdSessionIdCompoundUniqueInput
    AND?: TutoringReviewWhereInput | TutoringReviewWhereInput[]
    OR?: TutoringReviewWhereInput[]
    NOT?: TutoringReviewWhereInput | TutoringReviewWhereInput[]
    sessionId?: StringFilter<"TutoringReview"> | string
    studentId?: StringFilter<"TutoringReview"> | string
    rating?: IntFilter<"TutoringReview"> | number
    comment?: StringNullableFilter<"TutoringReview"> | string | null
    createdAt?: DateTimeFilter<"TutoringReview"> | Date | string
    session?: XOR<TutoringSessionRelationFilter, TutoringSessionWhereInput>
    student?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "studentId_sessionId">

  export type TutoringReviewOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    studentId?: SortOrder
    rating?: SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: TutoringReviewCountOrderByAggregateInput
    _avg?: TutoringReviewAvgOrderByAggregateInput
    _max?: TutoringReviewMaxOrderByAggregateInput
    _min?: TutoringReviewMinOrderByAggregateInput
    _sum?: TutoringReviewSumOrderByAggregateInput
  }

  export type TutoringReviewScalarWhereWithAggregatesInput = {
    AND?: TutoringReviewScalarWhereWithAggregatesInput | TutoringReviewScalarWhereWithAggregatesInput[]
    OR?: TutoringReviewScalarWhereWithAggregatesInput[]
    NOT?: TutoringReviewScalarWhereWithAggregatesInput | TutoringReviewScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TutoringReview"> | string
    sessionId?: StringWithAggregatesFilter<"TutoringReview"> | string
    studentId?: StringWithAggregatesFilter<"TutoringReview"> | string
    rating?: IntWithAggregatesFilter<"TutoringReview"> | number
    comment?: StringNullableWithAggregatesFilter<"TutoringReview"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TutoringReview"> | Date | string
  }

  export type TutoringMessageWhereInput = {
    AND?: TutoringMessageWhereInput | TutoringMessageWhereInput[]
    OR?: TutoringMessageWhereInput[]
    NOT?: TutoringMessageWhereInput | TutoringMessageWhereInput[]
    id?: StringFilter<"TutoringMessage"> | string
    requestId?: StringFilter<"TutoringMessage"> | string
    senderId?: StringFilter<"TutoringMessage"> | string
    message?: StringFilter<"TutoringMessage"> | string
    read?: BoolFilter<"TutoringMessage"> | boolean
    createdAt?: DateTimeFilter<"TutoringMessage"> | Date | string
    request?: XOR<TutoringRequestRelationFilter, TutoringRequestWhereInput>
    sender?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type TutoringMessageOrderByWithRelationInput = {
    id?: SortOrder
    requestId?: SortOrder
    senderId?: SortOrder
    message?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    request?: TutoringRequestOrderByWithRelationInput
    sender?: UserOrderByWithRelationInput
  }

  export type TutoringMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TutoringMessageWhereInput | TutoringMessageWhereInput[]
    OR?: TutoringMessageWhereInput[]
    NOT?: TutoringMessageWhereInput | TutoringMessageWhereInput[]
    requestId?: StringFilter<"TutoringMessage"> | string
    senderId?: StringFilter<"TutoringMessage"> | string
    message?: StringFilter<"TutoringMessage"> | string
    read?: BoolFilter<"TutoringMessage"> | boolean
    createdAt?: DateTimeFilter<"TutoringMessage"> | Date | string
    request?: XOR<TutoringRequestRelationFilter, TutoringRequestWhereInput>
    sender?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type TutoringMessageOrderByWithAggregationInput = {
    id?: SortOrder
    requestId?: SortOrder
    senderId?: SortOrder
    message?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    _count?: TutoringMessageCountOrderByAggregateInput
    _max?: TutoringMessageMaxOrderByAggregateInput
    _min?: TutoringMessageMinOrderByAggregateInput
  }

  export type TutoringMessageScalarWhereWithAggregatesInput = {
    AND?: TutoringMessageScalarWhereWithAggregatesInput | TutoringMessageScalarWhereWithAggregatesInput[]
    OR?: TutoringMessageScalarWhereWithAggregatesInput[]
    NOT?: TutoringMessageScalarWhereWithAggregatesInput | TutoringMessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TutoringMessage"> | string
    requestId?: StringWithAggregatesFilter<"TutoringMessage"> | string
    senderId?: StringWithAggregatesFilter<"TutoringMessage"> | string
    message?: StringWithAggregatesFilter<"TutoringMessage"> | string
    read?: BoolWithAggregatesFilter<"TutoringMessage"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"TutoringMessage"> | Date | string
  }

  export type AchievementWhereInput = {
    AND?: AchievementWhereInput | AchievementWhereInput[]
    OR?: AchievementWhereInput[]
    NOT?: AchievementWhereInput | AchievementWhereInput[]
    id?: StringFilter<"Achievement"> | string
    name?: StringFilter<"Achievement"> | string
    description?: StringNullableFilter<"Achievement"> | string | null
    pointsRewarded?: IntFilter<"Achievement"> | number
    icon?: StringNullableFilter<"Achievement"> | string | null
    category?: EnumAchievementCategoryFilter<"Achievement"> | $Enums.AchievementCategory
    users?: UserAchievementListRelationFilter
  }

  export type AchievementOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    pointsRewarded?: SortOrder
    icon?: SortOrderInput | SortOrder
    category?: SortOrder
    users?: UserAchievementOrderByRelationAggregateInput
  }

  export type AchievementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AchievementWhereInput | AchievementWhereInput[]
    OR?: AchievementWhereInput[]
    NOT?: AchievementWhereInput | AchievementWhereInput[]
    name?: StringFilter<"Achievement"> | string
    description?: StringNullableFilter<"Achievement"> | string | null
    pointsRewarded?: IntFilter<"Achievement"> | number
    icon?: StringNullableFilter<"Achievement"> | string | null
    category?: EnumAchievementCategoryFilter<"Achievement"> | $Enums.AchievementCategory
    users?: UserAchievementListRelationFilter
  }, "id">

  export type AchievementOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    pointsRewarded?: SortOrder
    icon?: SortOrderInput | SortOrder
    category?: SortOrder
    _count?: AchievementCountOrderByAggregateInput
    _avg?: AchievementAvgOrderByAggregateInput
    _max?: AchievementMaxOrderByAggregateInput
    _min?: AchievementMinOrderByAggregateInput
    _sum?: AchievementSumOrderByAggregateInput
  }

  export type AchievementScalarWhereWithAggregatesInput = {
    AND?: AchievementScalarWhereWithAggregatesInput | AchievementScalarWhereWithAggregatesInput[]
    OR?: AchievementScalarWhereWithAggregatesInput[]
    NOT?: AchievementScalarWhereWithAggregatesInput | AchievementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Achievement"> | string
    name?: StringWithAggregatesFilter<"Achievement"> | string
    description?: StringNullableWithAggregatesFilter<"Achievement"> | string | null
    pointsRewarded?: IntWithAggregatesFilter<"Achievement"> | number
    icon?: StringNullableWithAggregatesFilter<"Achievement"> | string | null
    category?: EnumAchievementCategoryWithAggregatesFilter<"Achievement"> | $Enums.AchievementCategory
  }

  export type UserAchievementWhereInput = {
    AND?: UserAchievementWhereInput | UserAchievementWhereInput[]
    OR?: UserAchievementWhereInput[]
    NOT?: UserAchievementWhereInput | UserAchievementWhereInput[]
    id?: StringFilter<"UserAchievement"> | string
    userId?: StringFilter<"UserAchievement"> | string
    achievementId?: StringFilter<"UserAchievement"> | string
    completed?: BoolFilter<"UserAchievement"> | boolean
    completedAt?: DateTimeNullableFilter<"UserAchievement"> | Date | string | null
    progress?: IntFilter<"UserAchievement"> | number
    user?: XOR<UserRelationFilter, UserWhereInput>
    achievement?: XOR<AchievementRelationFilter, AchievementWhereInput>
  }

  export type UserAchievementOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    achievementId?: SortOrder
    completed?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    progress?: SortOrder
    user?: UserOrderByWithRelationInput
    achievement?: AchievementOrderByWithRelationInput
  }

  export type UserAchievementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_achievementId?: UserAchievementUserIdAchievementIdCompoundUniqueInput
    AND?: UserAchievementWhereInput | UserAchievementWhereInput[]
    OR?: UserAchievementWhereInput[]
    NOT?: UserAchievementWhereInput | UserAchievementWhereInput[]
    userId?: StringFilter<"UserAchievement"> | string
    achievementId?: StringFilter<"UserAchievement"> | string
    completed?: BoolFilter<"UserAchievement"> | boolean
    completedAt?: DateTimeNullableFilter<"UserAchievement"> | Date | string | null
    progress?: IntFilter<"UserAchievement"> | number
    user?: XOR<UserRelationFilter, UserWhereInput>
    achievement?: XOR<AchievementRelationFilter, AchievementWhereInput>
  }, "id" | "userId_achievementId">

  export type UserAchievementOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    achievementId?: SortOrder
    completed?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    progress?: SortOrder
    _count?: UserAchievementCountOrderByAggregateInput
    _avg?: UserAchievementAvgOrderByAggregateInput
    _max?: UserAchievementMaxOrderByAggregateInput
    _min?: UserAchievementMinOrderByAggregateInput
    _sum?: UserAchievementSumOrderByAggregateInput
  }

  export type UserAchievementScalarWhereWithAggregatesInput = {
    AND?: UserAchievementScalarWhereWithAggregatesInput | UserAchievementScalarWhereWithAggregatesInput[]
    OR?: UserAchievementScalarWhereWithAggregatesInput[]
    NOT?: UserAchievementScalarWhereWithAggregatesInput | UserAchievementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserAchievement"> | string
    userId?: StringWithAggregatesFilter<"UserAchievement"> | string
    achievementId?: StringWithAggregatesFilter<"UserAchievement"> | string
    completed?: BoolWithAggregatesFilter<"UserAchievement"> | boolean
    completedAt?: DateTimeNullableWithAggregatesFilter<"UserAchievement"> | Date | string | null
    progress?: IntWithAggregatesFilter<"UserAchievement"> | number
  }

  export type BadgeWhereInput = {
    AND?: BadgeWhereInput | BadgeWhereInput[]
    OR?: BadgeWhereInput[]
    NOT?: BadgeWhereInput | BadgeWhereInput[]
    id?: StringFilter<"Badge"> | string
    name?: StringFilter<"Badge"> | string
    description?: StringNullableFilter<"Badge"> | string | null
    imageUrl?: StringNullableFilter<"Badge"> | string | null
    type?: EnumBadgeTypeFilter<"Badge"> | $Enums.BadgeType
    category?: StringNullableFilter<"Badge"> | string | null
    certificates?: CertificateListRelationFilter
  }

  export type BadgeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    type?: SortOrder
    category?: SortOrderInput | SortOrder
    certificates?: CertificateOrderByRelationAggregateInput
  }

  export type BadgeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BadgeWhereInput | BadgeWhereInput[]
    OR?: BadgeWhereInput[]
    NOT?: BadgeWhereInput | BadgeWhereInput[]
    name?: StringFilter<"Badge"> | string
    description?: StringNullableFilter<"Badge"> | string | null
    imageUrl?: StringNullableFilter<"Badge"> | string | null
    type?: EnumBadgeTypeFilter<"Badge"> | $Enums.BadgeType
    category?: StringNullableFilter<"Badge"> | string | null
    certificates?: CertificateListRelationFilter
  }, "id">

  export type BadgeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    type?: SortOrder
    category?: SortOrderInput | SortOrder
    _count?: BadgeCountOrderByAggregateInput
    _max?: BadgeMaxOrderByAggregateInput
    _min?: BadgeMinOrderByAggregateInput
  }

  export type BadgeScalarWhereWithAggregatesInput = {
    AND?: BadgeScalarWhereWithAggregatesInput | BadgeScalarWhereWithAggregatesInput[]
    OR?: BadgeScalarWhereWithAggregatesInput[]
    NOT?: BadgeScalarWhereWithAggregatesInput | BadgeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Badge"> | string
    name?: StringWithAggregatesFilter<"Badge"> | string
    description?: StringNullableWithAggregatesFilter<"Badge"> | string | null
    imageUrl?: StringNullableWithAggregatesFilter<"Badge"> | string | null
    type?: EnumBadgeTypeWithAggregatesFilter<"Badge"> | $Enums.BadgeType
    category?: StringNullableWithAggregatesFilter<"Badge"> | string | null
  }

  export type CertificateWhereInput = {
    AND?: CertificateWhereInput | CertificateWhereInput[]
    OR?: CertificateWhereInput[]
    NOT?: CertificateWhereInput | CertificateWhereInput[]
    id?: StringFilter<"Certificate"> | string
    userId?: StringFilter<"Certificate"> | string
    title?: StringFilter<"Certificate"> | string
    issueDate?: DateTimeFilter<"Certificate"> | Date | string
    type?: StringFilter<"Certificate"> | string
    courseId?: StringNullableFilter<"Certificate"> | string | null
    courseName?: StringNullableFilter<"Certificate"> | string | null
    tutoringId?: StringNullableFilter<"Certificate"> | string | null
    tutoringSubject?: StringNullableFilter<"Certificate"> | string | null
    teacherId?: StringNullableFilter<"Certificate"> | string | null
    teacherName?: StringNullableFilter<"Certificate"> | string | null
    customMessage?: StringNullableFilter<"Certificate"> | string | null
    imageUrl?: StringNullableFilter<"Certificate"> | string | null
    badgeId?: StringNullableFilter<"Certificate"> | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    course?: XOR<CourseNullableRelationFilter, CourseWhereInput> | null
    tutoring?: XOR<TutoringSessionNullableRelationFilter, TutoringSessionWhereInput> | null
    badge?: XOR<BadgeNullableRelationFilter, BadgeWhereInput> | null
  }

  export type CertificateOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    issueDate?: SortOrder
    type?: SortOrder
    courseId?: SortOrderInput | SortOrder
    courseName?: SortOrderInput | SortOrder
    tutoringId?: SortOrderInput | SortOrder
    tutoringSubject?: SortOrderInput | SortOrder
    teacherId?: SortOrderInput | SortOrder
    teacherName?: SortOrderInput | SortOrder
    customMessage?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    badgeId?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    course?: CourseOrderByWithRelationInput
    tutoring?: TutoringSessionOrderByWithRelationInput
    badge?: BadgeOrderByWithRelationInput
  }

  export type CertificateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CertificateWhereInput | CertificateWhereInput[]
    OR?: CertificateWhereInput[]
    NOT?: CertificateWhereInput | CertificateWhereInput[]
    userId?: StringFilter<"Certificate"> | string
    title?: StringFilter<"Certificate"> | string
    issueDate?: DateTimeFilter<"Certificate"> | Date | string
    type?: StringFilter<"Certificate"> | string
    courseId?: StringNullableFilter<"Certificate"> | string | null
    courseName?: StringNullableFilter<"Certificate"> | string | null
    tutoringId?: StringNullableFilter<"Certificate"> | string | null
    tutoringSubject?: StringNullableFilter<"Certificate"> | string | null
    teacherId?: StringNullableFilter<"Certificate"> | string | null
    teacherName?: StringNullableFilter<"Certificate"> | string | null
    customMessage?: StringNullableFilter<"Certificate"> | string | null
    imageUrl?: StringNullableFilter<"Certificate"> | string | null
    badgeId?: StringNullableFilter<"Certificate"> | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    course?: XOR<CourseNullableRelationFilter, CourseWhereInput> | null
    tutoring?: XOR<TutoringSessionNullableRelationFilter, TutoringSessionWhereInput> | null
    badge?: XOR<BadgeNullableRelationFilter, BadgeWhereInput> | null
  }, "id">

  export type CertificateOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    issueDate?: SortOrder
    type?: SortOrder
    courseId?: SortOrderInput | SortOrder
    courseName?: SortOrderInput | SortOrder
    tutoringId?: SortOrderInput | SortOrder
    tutoringSubject?: SortOrderInput | SortOrder
    teacherId?: SortOrderInput | SortOrder
    teacherName?: SortOrderInput | SortOrder
    customMessage?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    badgeId?: SortOrderInput | SortOrder
    _count?: CertificateCountOrderByAggregateInput
    _max?: CertificateMaxOrderByAggregateInput
    _min?: CertificateMinOrderByAggregateInput
  }

  export type CertificateScalarWhereWithAggregatesInput = {
    AND?: CertificateScalarWhereWithAggregatesInput | CertificateScalarWhereWithAggregatesInput[]
    OR?: CertificateScalarWhereWithAggregatesInput[]
    NOT?: CertificateScalarWhereWithAggregatesInput | CertificateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Certificate"> | string
    userId?: StringWithAggregatesFilter<"Certificate"> | string
    title?: StringWithAggregatesFilter<"Certificate"> | string
    issueDate?: DateTimeWithAggregatesFilter<"Certificate"> | Date | string
    type?: StringWithAggregatesFilter<"Certificate"> | string
    courseId?: StringNullableWithAggregatesFilter<"Certificate"> | string | null
    courseName?: StringNullableWithAggregatesFilter<"Certificate"> | string | null
    tutoringId?: StringNullableWithAggregatesFilter<"Certificate"> | string | null
    tutoringSubject?: StringNullableWithAggregatesFilter<"Certificate"> | string | null
    teacherId?: StringNullableWithAggregatesFilter<"Certificate"> | string | null
    teacherName?: StringNullableWithAggregatesFilter<"Certificate"> | string | null
    customMessage?: StringNullableWithAggregatesFilter<"Certificate"> | string | null
    imageUrl?: StringNullableWithAggregatesFilter<"Certificate"> | string | null
    badgeId?: StringNullableWithAggregatesFilter<"Certificate"> | string | null
  }

  export type ConversationWhereInput = {
    AND?: ConversationWhereInput | ConversationWhereInput[]
    OR?: ConversationWhereInput[]
    NOT?: ConversationWhereInput | ConversationWhereInput[]
    id?: StringFilter<"Conversation"> | string
    createdAt?: DateTimeFilter<"Conversation"> | Date | string
    updatedAt?: DateTimeFilter<"Conversation"> | Date | string
    participants?: ConversationParticipantListRelationFilter
    messages?: MessageListRelationFilter
  }

  export type ConversationOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    participants?: ConversationParticipantOrderByRelationAggregateInput
    messages?: MessageOrderByRelationAggregateInput
  }

  export type ConversationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ConversationWhereInput | ConversationWhereInput[]
    OR?: ConversationWhereInput[]
    NOT?: ConversationWhereInput | ConversationWhereInput[]
    createdAt?: DateTimeFilter<"Conversation"> | Date | string
    updatedAt?: DateTimeFilter<"Conversation"> | Date | string
    participants?: ConversationParticipantListRelationFilter
    messages?: MessageListRelationFilter
  }, "id">

  export type ConversationOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ConversationCountOrderByAggregateInput
    _max?: ConversationMaxOrderByAggregateInput
    _min?: ConversationMinOrderByAggregateInput
  }

  export type ConversationScalarWhereWithAggregatesInput = {
    AND?: ConversationScalarWhereWithAggregatesInput | ConversationScalarWhereWithAggregatesInput[]
    OR?: ConversationScalarWhereWithAggregatesInput[]
    NOT?: ConversationScalarWhereWithAggregatesInput | ConversationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Conversation"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Conversation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Conversation"> | Date | string
  }

  export type ConversationParticipantWhereInput = {
    AND?: ConversationParticipantWhereInput | ConversationParticipantWhereInput[]
    OR?: ConversationParticipantWhereInput[]
    NOT?: ConversationParticipantWhereInput | ConversationParticipantWhereInput[]
    conversationId?: StringFilter<"ConversationParticipant"> | string
    userId?: StringFilter<"ConversationParticipant"> | string
    conversation?: XOR<ConversationRelationFilter, ConversationWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ConversationParticipantOrderByWithRelationInput = {
    conversationId?: SortOrder
    userId?: SortOrder
    conversation?: ConversationOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ConversationParticipantWhereUniqueInput = Prisma.AtLeast<{
    conversationId_userId?: ConversationParticipantConversationIdUserIdCompoundUniqueInput
    AND?: ConversationParticipantWhereInput | ConversationParticipantWhereInput[]
    OR?: ConversationParticipantWhereInput[]
    NOT?: ConversationParticipantWhereInput | ConversationParticipantWhereInput[]
    conversationId?: StringFilter<"ConversationParticipant"> | string
    userId?: StringFilter<"ConversationParticipant"> | string
    conversation?: XOR<ConversationRelationFilter, ConversationWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "conversationId_userId">

  export type ConversationParticipantOrderByWithAggregationInput = {
    conversationId?: SortOrder
    userId?: SortOrder
    _count?: ConversationParticipantCountOrderByAggregateInput
    _max?: ConversationParticipantMaxOrderByAggregateInput
    _min?: ConversationParticipantMinOrderByAggregateInput
  }

  export type ConversationParticipantScalarWhereWithAggregatesInput = {
    AND?: ConversationParticipantScalarWhereWithAggregatesInput | ConversationParticipantScalarWhereWithAggregatesInput[]
    OR?: ConversationParticipantScalarWhereWithAggregatesInput[]
    NOT?: ConversationParticipantScalarWhereWithAggregatesInput | ConversationParticipantScalarWhereWithAggregatesInput[]
    conversationId?: StringWithAggregatesFilter<"ConversationParticipant"> | string
    userId?: StringWithAggregatesFilter<"ConversationParticipant"> | string
  }

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    id?: StringFilter<"Message"> | string
    conversationId?: StringFilter<"Message"> | string
    senderId?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    timestamp?: DateTimeFilter<"Message"> | Date | string
    read?: BoolFilter<"Message"> | boolean
    conversation?: XOR<ConversationRelationFilter, ConversationWhereInput>
    sender?: XOR<UserRelationFilter, UserWhereInput>
    attachments?: AttachmentListRelationFilter
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    timestamp?: SortOrder
    read?: SortOrder
    conversation?: ConversationOrderByWithRelationInput
    sender?: UserOrderByWithRelationInput
    attachments?: AttachmentOrderByRelationAggregateInput
  }

  export type MessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    conversationId?: StringFilter<"Message"> | string
    senderId?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    timestamp?: DateTimeFilter<"Message"> | Date | string
    read?: BoolFilter<"Message"> | boolean
    conversation?: XOR<ConversationRelationFilter, ConversationWhereInput>
    sender?: XOR<UserRelationFilter, UserWhereInput>
    attachments?: AttachmentListRelationFilter
  }, "id">

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    timestamp?: SortOrder
    read?: SortOrder
    _count?: MessageCountOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    OR?: MessageScalarWhereWithAggregatesInput[]
    NOT?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Message"> | string
    conversationId?: StringWithAggregatesFilter<"Message"> | string
    senderId?: StringWithAggregatesFilter<"Message"> | string
    content?: StringWithAggregatesFilter<"Message"> | string
    timestamp?: DateTimeWithAggregatesFilter<"Message"> | Date | string
    read?: BoolWithAggregatesFilter<"Message"> | boolean
  }

  export type AttachmentWhereInput = {
    AND?: AttachmentWhereInput | AttachmentWhereInput[]
    OR?: AttachmentWhereInput[]
    NOT?: AttachmentWhereInput | AttachmentWhereInput[]
    id?: StringFilter<"Attachment"> | string
    messageId?: StringFilter<"Attachment"> | string
    userId?: StringNullableFilter<"Attachment"> | string | null
    fileName?: StringFilter<"Attachment"> | string
    fileUrl?: StringFilter<"Attachment"> | string
    fileType?: StringFilter<"Attachment"> | string
    fileSize?: IntFilter<"Attachment"> | number
    message?: XOR<MessageRelationFilter, MessageWhereInput>
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type AttachmentOrderByWithRelationInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrderInput | SortOrder
    fileName?: SortOrder
    fileUrl?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
    message?: MessageOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type AttachmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AttachmentWhereInput | AttachmentWhereInput[]
    OR?: AttachmentWhereInput[]
    NOT?: AttachmentWhereInput | AttachmentWhereInput[]
    messageId?: StringFilter<"Attachment"> | string
    userId?: StringNullableFilter<"Attachment"> | string | null
    fileName?: StringFilter<"Attachment"> | string
    fileUrl?: StringFilter<"Attachment"> | string
    fileType?: StringFilter<"Attachment"> | string
    fileSize?: IntFilter<"Attachment"> | number
    message?: XOR<MessageRelationFilter, MessageWhereInput>
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type AttachmentOrderByWithAggregationInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrderInput | SortOrder
    fileName?: SortOrder
    fileUrl?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
    _count?: AttachmentCountOrderByAggregateInput
    _avg?: AttachmentAvgOrderByAggregateInput
    _max?: AttachmentMaxOrderByAggregateInput
    _min?: AttachmentMinOrderByAggregateInput
    _sum?: AttachmentSumOrderByAggregateInput
  }

  export type AttachmentScalarWhereWithAggregatesInput = {
    AND?: AttachmentScalarWhereWithAggregatesInput | AttachmentScalarWhereWithAggregatesInput[]
    OR?: AttachmentScalarWhereWithAggregatesInput[]
    NOT?: AttachmentScalarWhereWithAggregatesInput | AttachmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Attachment"> | string
    messageId?: StringWithAggregatesFilter<"Attachment"> | string
    userId?: StringNullableWithAggregatesFilter<"Attachment"> | string | null
    fileName?: StringWithAggregatesFilter<"Attachment"> | string
    fileUrl?: StringWithAggregatesFilter<"Attachment"> | string
    fileType?: StringWithAggregatesFilter<"Attachment"> | string
    fileSize?: IntWithAggregatesFilter<"Attachment"> | number
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    read?: BoolFilter<"Notification"> | boolean
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    link?: StringNullableFilter<"Notification"> | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    read?: SortOrder
    type?: SortOrder
    link?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    read?: BoolFilter<"Notification"> | boolean
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    link?: StringNullableFilter<"Notification"> | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    read?: SortOrder
    type?: SortOrder
    link?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    userId?: StringWithAggregatesFilter<"Notification"> | string
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    read?: BoolWithAggregatesFilter<"Notification"> | boolean
    type?: EnumNotificationTypeWithAggregatesFilter<"Notification"> | $Enums.NotificationType
    link?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type SubscriptionPlanWhereInput = {
    AND?: SubscriptionPlanWhereInput | SubscriptionPlanWhereInput[]
    OR?: SubscriptionPlanWhereInput[]
    NOT?: SubscriptionPlanWhereInput | SubscriptionPlanWhereInput[]
    id?: StringFilter<"SubscriptionPlan"> | string
    name?: StringFilter<"SubscriptionPlan"> | string
    description?: StringNullableFilter<"SubscriptionPlan"> | string | null
    price?: DecimalFilter<"SubscriptionPlan"> | Decimal | DecimalJsLike | number | string
    period?: EnumSubscriptionPeriodFilter<"SubscriptionPlan"> | $Enums.SubscriptionPeriod
    featuredBenefit?: StringNullableFilter<"SubscriptionPlan"> | string | null
    benefits?: StringNullableListFilter<"SubscriptionPlan">
    isPopular?: BoolFilter<"SubscriptionPlan"> | boolean
    users?: UserSubscriptionListRelationFilter
  }

  export type SubscriptionPlanOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    period?: SortOrder
    featuredBenefit?: SortOrderInput | SortOrder
    benefits?: SortOrder
    isPopular?: SortOrder
    users?: UserSubscriptionOrderByRelationAggregateInput
  }

  export type SubscriptionPlanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SubscriptionPlanWhereInput | SubscriptionPlanWhereInput[]
    OR?: SubscriptionPlanWhereInput[]
    NOT?: SubscriptionPlanWhereInput | SubscriptionPlanWhereInput[]
    name?: StringFilter<"SubscriptionPlan"> | string
    description?: StringNullableFilter<"SubscriptionPlan"> | string | null
    price?: DecimalFilter<"SubscriptionPlan"> | Decimal | DecimalJsLike | number | string
    period?: EnumSubscriptionPeriodFilter<"SubscriptionPlan"> | $Enums.SubscriptionPeriod
    featuredBenefit?: StringNullableFilter<"SubscriptionPlan"> | string | null
    benefits?: StringNullableListFilter<"SubscriptionPlan">
    isPopular?: BoolFilter<"SubscriptionPlan"> | boolean
    users?: UserSubscriptionListRelationFilter
  }, "id">

  export type SubscriptionPlanOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    period?: SortOrder
    featuredBenefit?: SortOrderInput | SortOrder
    benefits?: SortOrder
    isPopular?: SortOrder
    _count?: SubscriptionPlanCountOrderByAggregateInput
    _avg?: SubscriptionPlanAvgOrderByAggregateInput
    _max?: SubscriptionPlanMaxOrderByAggregateInput
    _min?: SubscriptionPlanMinOrderByAggregateInput
    _sum?: SubscriptionPlanSumOrderByAggregateInput
  }

  export type SubscriptionPlanScalarWhereWithAggregatesInput = {
    AND?: SubscriptionPlanScalarWhereWithAggregatesInput | SubscriptionPlanScalarWhereWithAggregatesInput[]
    OR?: SubscriptionPlanScalarWhereWithAggregatesInput[]
    NOT?: SubscriptionPlanScalarWhereWithAggregatesInput | SubscriptionPlanScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SubscriptionPlan"> | string
    name?: StringWithAggregatesFilter<"SubscriptionPlan"> | string
    description?: StringNullableWithAggregatesFilter<"SubscriptionPlan"> | string | null
    price?: DecimalWithAggregatesFilter<"SubscriptionPlan"> | Decimal | DecimalJsLike | number | string
    period?: EnumSubscriptionPeriodWithAggregatesFilter<"SubscriptionPlan"> | $Enums.SubscriptionPeriod
    featuredBenefit?: StringNullableWithAggregatesFilter<"SubscriptionPlan"> | string | null
    benefits?: StringNullableListFilter<"SubscriptionPlan">
    isPopular?: BoolWithAggregatesFilter<"SubscriptionPlan"> | boolean
  }

  export type CourseBundleWhereInput = {
    AND?: CourseBundleWhereInput | CourseBundleWhereInput[]
    OR?: CourseBundleWhereInput[]
    NOT?: CourseBundleWhereInput | CourseBundleWhereInput[]
    id?: StringFilter<"CourseBundle"> | string
    name?: StringFilter<"CourseBundle"> | string
    description?: StringNullableFilter<"CourseBundle"> | string | null
    price?: DecimalFilter<"CourseBundle"> | Decimal | DecimalJsLike | number | string
    originalPrice?: DecimalFilter<"CourseBundle"> | Decimal | DecimalJsLike | number | string
    discount?: IntFilter<"CourseBundle"> | number
    featuredBenefit?: StringNullableFilter<"CourseBundle"> | string | null
    benefits?: StringNullableListFilter<"CourseBundle">
    imageUrl?: StringNullableFilter<"CourseBundle"> | string | null
    courses?: BundleCourseListRelationFilter
    owners?: UserBundleListRelationFilter
  }

  export type CourseBundleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    originalPrice?: SortOrder
    discount?: SortOrder
    featuredBenefit?: SortOrderInput | SortOrder
    benefits?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    courses?: BundleCourseOrderByRelationAggregateInput
    owners?: UserBundleOrderByRelationAggregateInput
  }

  export type CourseBundleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CourseBundleWhereInput | CourseBundleWhereInput[]
    OR?: CourseBundleWhereInput[]
    NOT?: CourseBundleWhereInput | CourseBundleWhereInput[]
    name?: StringFilter<"CourseBundle"> | string
    description?: StringNullableFilter<"CourseBundle"> | string | null
    price?: DecimalFilter<"CourseBundle"> | Decimal | DecimalJsLike | number | string
    originalPrice?: DecimalFilter<"CourseBundle"> | Decimal | DecimalJsLike | number | string
    discount?: IntFilter<"CourseBundle"> | number
    featuredBenefit?: StringNullableFilter<"CourseBundle"> | string | null
    benefits?: StringNullableListFilter<"CourseBundle">
    imageUrl?: StringNullableFilter<"CourseBundle"> | string | null
    courses?: BundleCourseListRelationFilter
    owners?: UserBundleListRelationFilter
  }, "id">

  export type CourseBundleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    originalPrice?: SortOrder
    discount?: SortOrder
    featuredBenefit?: SortOrderInput | SortOrder
    benefits?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    _count?: CourseBundleCountOrderByAggregateInput
    _avg?: CourseBundleAvgOrderByAggregateInput
    _max?: CourseBundleMaxOrderByAggregateInput
    _min?: CourseBundleMinOrderByAggregateInput
    _sum?: CourseBundleSumOrderByAggregateInput
  }

  export type CourseBundleScalarWhereWithAggregatesInput = {
    AND?: CourseBundleScalarWhereWithAggregatesInput | CourseBundleScalarWhereWithAggregatesInput[]
    OR?: CourseBundleScalarWhereWithAggregatesInput[]
    NOT?: CourseBundleScalarWhereWithAggregatesInput | CourseBundleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CourseBundle"> | string
    name?: StringWithAggregatesFilter<"CourseBundle"> | string
    description?: StringNullableWithAggregatesFilter<"CourseBundle"> | string | null
    price?: DecimalWithAggregatesFilter<"CourseBundle"> | Decimal | DecimalJsLike | number | string
    originalPrice?: DecimalWithAggregatesFilter<"CourseBundle"> | Decimal | DecimalJsLike | number | string
    discount?: IntWithAggregatesFilter<"CourseBundle"> | number
    featuredBenefit?: StringNullableWithAggregatesFilter<"CourseBundle"> | string | null
    benefits?: StringNullableListFilter<"CourseBundle">
    imageUrl?: StringNullableWithAggregatesFilter<"CourseBundle"> | string | null
  }

  export type BundleCourseWhereInput = {
    AND?: BundleCourseWhereInput | BundleCourseWhereInput[]
    OR?: BundleCourseWhereInput[]
    NOT?: BundleCourseWhereInput | BundleCourseWhereInput[]
    bundleId?: StringFilter<"BundleCourse"> | string
    courseId?: StringFilter<"BundleCourse"> | string
    bundle?: XOR<CourseBundleRelationFilter, CourseBundleWhereInput>
    course?: XOR<CourseRelationFilter, CourseWhereInput>
  }

  export type BundleCourseOrderByWithRelationInput = {
    bundleId?: SortOrder
    courseId?: SortOrder
    bundle?: CourseBundleOrderByWithRelationInput
    course?: CourseOrderByWithRelationInput
  }

  export type BundleCourseWhereUniqueInput = Prisma.AtLeast<{
    bundleId_courseId?: BundleCourseBundleIdCourseIdCompoundUniqueInput
    AND?: BundleCourseWhereInput | BundleCourseWhereInput[]
    OR?: BundleCourseWhereInput[]
    NOT?: BundleCourseWhereInput | BundleCourseWhereInput[]
    bundleId?: StringFilter<"BundleCourse"> | string
    courseId?: StringFilter<"BundleCourse"> | string
    bundle?: XOR<CourseBundleRelationFilter, CourseBundleWhereInput>
    course?: XOR<CourseRelationFilter, CourseWhereInput>
  }, "bundleId_courseId">

  export type BundleCourseOrderByWithAggregationInput = {
    bundleId?: SortOrder
    courseId?: SortOrder
    _count?: BundleCourseCountOrderByAggregateInput
    _max?: BundleCourseMaxOrderByAggregateInput
    _min?: BundleCourseMinOrderByAggregateInput
  }

  export type BundleCourseScalarWhereWithAggregatesInput = {
    AND?: BundleCourseScalarWhereWithAggregatesInput | BundleCourseScalarWhereWithAggregatesInput[]
    OR?: BundleCourseScalarWhereWithAggregatesInput[]
    NOT?: BundleCourseScalarWhereWithAggregatesInput | BundleCourseScalarWhereWithAggregatesInput[]
    bundleId?: StringWithAggregatesFilter<"BundleCourse"> | string
    courseId?: StringWithAggregatesFilter<"BundleCourse"> | string
  }

  export type UserSubscriptionWhereInput = {
    AND?: UserSubscriptionWhereInput | UserSubscriptionWhereInput[]
    OR?: UserSubscriptionWhereInput[]
    NOT?: UserSubscriptionWhereInput | UserSubscriptionWhereInput[]
    id?: StringFilter<"UserSubscription"> | string
    userId?: StringFilter<"UserSubscription"> | string
    planId?: StringFilter<"UserSubscription"> | string
    startDate?: DateTimeFilter<"UserSubscription"> | Date | string
    endDate?: DateTimeFilter<"UserSubscription"> | Date | string
    isActive?: BoolFilter<"UserSubscription"> | boolean
    autoRenew?: BoolFilter<"UserSubscription"> | boolean
    paymentMethod?: StringNullableFilter<"UserSubscription"> | string | null
    lastPaymentDate?: DateTimeNullableFilter<"UserSubscription"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    plan?: XOR<SubscriptionPlanRelationFilter, SubscriptionPlanWhereInput>
  }

  export type UserSubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    planId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    autoRenew?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    lastPaymentDate?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    plan?: SubscriptionPlanOrderByWithRelationInput
  }

  export type UserSubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserSubscriptionWhereInput | UserSubscriptionWhereInput[]
    OR?: UserSubscriptionWhereInput[]
    NOT?: UserSubscriptionWhereInput | UserSubscriptionWhereInput[]
    userId?: StringFilter<"UserSubscription"> | string
    planId?: StringFilter<"UserSubscription"> | string
    startDate?: DateTimeFilter<"UserSubscription"> | Date | string
    endDate?: DateTimeFilter<"UserSubscription"> | Date | string
    isActive?: BoolFilter<"UserSubscription"> | boolean
    autoRenew?: BoolFilter<"UserSubscription"> | boolean
    paymentMethod?: StringNullableFilter<"UserSubscription"> | string | null
    lastPaymentDate?: DateTimeNullableFilter<"UserSubscription"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    plan?: XOR<SubscriptionPlanRelationFilter, SubscriptionPlanWhereInput>
  }, "id">

  export type UserSubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    planId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    autoRenew?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    lastPaymentDate?: SortOrderInput | SortOrder
    _count?: UserSubscriptionCountOrderByAggregateInput
    _max?: UserSubscriptionMaxOrderByAggregateInput
    _min?: UserSubscriptionMinOrderByAggregateInput
  }

  export type UserSubscriptionScalarWhereWithAggregatesInput = {
    AND?: UserSubscriptionScalarWhereWithAggregatesInput | UserSubscriptionScalarWhereWithAggregatesInput[]
    OR?: UserSubscriptionScalarWhereWithAggregatesInput[]
    NOT?: UserSubscriptionScalarWhereWithAggregatesInput | UserSubscriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserSubscription"> | string
    userId?: StringWithAggregatesFilter<"UserSubscription"> | string
    planId?: StringWithAggregatesFilter<"UserSubscription"> | string
    startDate?: DateTimeWithAggregatesFilter<"UserSubscription"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"UserSubscription"> | Date | string
    isActive?: BoolWithAggregatesFilter<"UserSubscription"> | boolean
    autoRenew?: BoolWithAggregatesFilter<"UserSubscription"> | boolean
    paymentMethod?: StringNullableWithAggregatesFilter<"UserSubscription"> | string | null
    lastPaymentDate?: DateTimeNullableWithAggregatesFilter<"UserSubscription"> | Date | string | null
  }

  export type UserBundleWhereInput = {
    AND?: UserBundleWhereInput | UserBundleWhereInput[]
    OR?: UserBundleWhereInput[]
    NOT?: UserBundleWhereInput | UserBundleWhereInput[]
    id?: StringFilter<"UserBundle"> | string
    userId?: StringFilter<"UserBundle"> | string
    bundleId?: StringFilter<"UserBundle"> | string
    purchaseDate?: DateTimeFilter<"UserBundle"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    bundle?: XOR<CourseBundleRelationFilter, CourseBundleWhereInput>
  }

  export type UserBundleOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    bundleId?: SortOrder
    purchaseDate?: SortOrder
    user?: UserOrderByWithRelationInput
    bundle?: CourseBundleOrderByWithRelationInput
  }

  export type UserBundleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserBundleWhereInput | UserBundleWhereInput[]
    OR?: UserBundleWhereInput[]
    NOT?: UserBundleWhereInput | UserBundleWhereInput[]
    userId?: StringFilter<"UserBundle"> | string
    bundleId?: StringFilter<"UserBundle"> | string
    purchaseDate?: DateTimeFilter<"UserBundle"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    bundle?: XOR<CourseBundleRelationFilter, CourseBundleWhereInput>
  }, "id">

  export type UserBundleOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    bundleId?: SortOrder
    purchaseDate?: SortOrder
    _count?: UserBundleCountOrderByAggregateInput
    _max?: UserBundleMaxOrderByAggregateInput
    _min?: UserBundleMinOrderByAggregateInput
  }

  export type UserBundleScalarWhereWithAggregatesInput = {
    AND?: UserBundleScalarWhereWithAggregatesInput | UserBundleScalarWhereWithAggregatesInput[]
    OR?: UserBundleScalarWhereWithAggregatesInput[]
    NOT?: UserBundleScalarWhereWithAggregatesInput | UserBundleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserBundle"> | string
    userId?: StringWithAggregatesFilter<"UserBundle"> | string
    bundleId?: StringWithAggregatesFilter<"UserBundle"> | string
    purchaseDate?: DateTimeWithAggregatesFilter<"UserBundle"> | Date | string
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: StringFilter<"Payment"> | string
    userId?: StringFilter<"Payment"> | string
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Payment"> | string
    paymentMethod?: StringNullableFilter<"Payment"> | string | null
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    referenceType?: EnumPaymentReferenceTypeFilter<"Payment"> | $Enums.PaymentReferenceType
    referenceId?: StringNullableFilter<"Payment"> | string | null
    transactionId?: StringNullableFilter<"Payment"> | string | null
    metadata?: JsonNullableFilter<"Payment">
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    status?: SortOrder
    referenceType?: SortOrder
    referenceId?: SortOrderInput | SortOrder
    transactionId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    userId?: StringFilter<"Payment"> | string
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Payment"> | string
    paymentMethod?: StringNullableFilter<"Payment"> | string | null
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    referenceType?: EnumPaymentReferenceTypeFilter<"Payment"> | $Enums.PaymentReferenceType
    referenceId?: StringNullableFilter<"Payment"> | string | null
    transactionId?: StringNullableFilter<"Payment"> | string | null
    metadata?: JsonNullableFilter<"Payment">
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    status?: SortOrder
    referenceType?: SortOrder
    referenceId?: SortOrderInput | SortOrder
    transactionId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Payment"> | string
    userId?: StringWithAggregatesFilter<"Payment"> | string
    amount?: DecimalWithAggregatesFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"Payment"> | string
    paymentMethod?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    status?: EnumPaymentStatusWithAggregatesFilter<"Payment"> | $Enums.PaymentStatus
    referenceType?: EnumPaymentReferenceTypeWithAggregatesFilter<"Payment"> | $Enums.PaymentReferenceType
    referenceId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    transactionId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Payment">
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
  }

  export type CalendarEventWhereInput = {
    AND?: CalendarEventWhereInput | CalendarEventWhereInput[]
    OR?: CalendarEventWhereInput[]
    NOT?: CalendarEventWhereInput | CalendarEventWhereInput[]
    id?: StringFilter<"CalendarEvent"> | string
    userId?: StringFilter<"CalendarEvent"> | string
    title?: StringFilter<"CalendarEvent"> | string
    description?: StringNullableFilter<"CalendarEvent"> | string | null
    type?: StringFilter<"CalendarEvent"> | string
    startTime?: DateTimeFilter<"CalendarEvent"> | Date | string
    endTime?: DateTimeNullableFilter<"CalendarEvent"> | Date | string | null
    courseId?: StringNullableFilter<"CalendarEvent"> | string | null
    lessonId?: StringNullableFilter<"CalendarEvent"> | string | null
    teacherId?: StringNullableFilter<"CalendarEvent"> | string | null
    studentId?: StringNullableFilter<"CalendarEvent"> | string | null
    location?: StringNullableFilter<"CalendarEvent"> | string | null
    createdAt?: DateTimeFilter<"CalendarEvent"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    course?: XOR<CourseNullableRelationFilter, CourseWhereInput> | null
    lesson?: XOR<LessonNullableRelationFilter, LessonWhereInput> | null
    teacher?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    student?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type CalendarEventOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    courseId?: SortOrderInput | SortOrder
    lessonId?: SortOrderInput | SortOrder
    teacherId?: SortOrderInput | SortOrder
    studentId?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    course?: CourseOrderByWithRelationInput
    lesson?: LessonOrderByWithRelationInput
    teacher?: UserOrderByWithRelationInput
    student?: UserOrderByWithRelationInput
  }

  export type CalendarEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CalendarEventWhereInput | CalendarEventWhereInput[]
    OR?: CalendarEventWhereInput[]
    NOT?: CalendarEventWhereInput | CalendarEventWhereInput[]
    userId?: StringFilter<"CalendarEvent"> | string
    title?: StringFilter<"CalendarEvent"> | string
    description?: StringNullableFilter<"CalendarEvent"> | string | null
    type?: StringFilter<"CalendarEvent"> | string
    startTime?: DateTimeFilter<"CalendarEvent"> | Date | string
    endTime?: DateTimeNullableFilter<"CalendarEvent"> | Date | string | null
    courseId?: StringNullableFilter<"CalendarEvent"> | string | null
    lessonId?: StringNullableFilter<"CalendarEvent"> | string | null
    teacherId?: StringNullableFilter<"CalendarEvent"> | string | null
    studentId?: StringNullableFilter<"CalendarEvent"> | string | null
    location?: StringNullableFilter<"CalendarEvent"> | string | null
    createdAt?: DateTimeFilter<"CalendarEvent"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    course?: XOR<CourseNullableRelationFilter, CourseWhereInput> | null
    lesson?: XOR<LessonNullableRelationFilter, LessonWhereInput> | null
    teacher?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    student?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type CalendarEventOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    courseId?: SortOrderInput | SortOrder
    lessonId?: SortOrderInput | SortOrder
    teacherId?: SortOrderInput | SortOrder
    studentId?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: CalendarEventCountOrderByAggregateInput
    _max?: CalendarEventMaxOrderByAggregateInput
    _min?: CalendarEventMinOrderByAggregateInput
  }

  export type CalendarEventScalarWhereWithAggregatesInput = {
    AND?: CalendarEventScalarWhereWithAggregatesInput | CalendarEventScalarWhereWithAggregatesInput[]
    OR?: CalendarEventScalarWhereWithAggregatesInput[]
    NOT?: CalendarEventScalarWhereWithAggregatesInput | CalendarEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CalendarEvent"> | string
    userId?: StringWithAggregatesFilter<"CalendarEvent"> | string
    title?: StringWithAggregatesFilter<"CalendarEvent"> | string
    description?: StringNullableWithAggregatesFilter<"CalendarEvent"> | string | null
    type?: StringWithAggregatesFilter<"CalendarEvent"> | string
    startTime?: DateTimeWithAggregatesFilter<"CalendarEvent"> | Date | string
    endTime?: DateTimeNullableWithAggregatesFilter<"CalendarEvent"> | Date | string | null
    courseId?: StringNullableWithAggregatesFilter<"CalendarEvent"> | string | null
    lessonId?: StringNullableWithAggregatesFilter<"CalendarEvent"> | string | null
    teacherId?: StringNullableWithAggregatesFilter<"CalendarEvent"> | string | null
    studentId?: StringNullableWithAggregatesFilter<"CalendarEvent"> | string | null
    location?: StringNullableWithAggregatesFilter<"CalendarEvent"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CalendarEvent"> | Date | string
  }

  export type BlogPostWhereInput = {
    AND?: BlogPostWhereInput | BlogPostWhereInput[]
    OR?: BlogPostWhereInput[]
    NOT?: BlogPostWhereInput | BlogPostWhereInput[]
    id?: StringFilter<"BlogPost"> | string
    title?: StringFilter<"BlogPost"> | string
    excerpt?: StringNullableFilter<"BlogPost"> | string | null
    content?: StringFilter<"BlogPost"> | string
    image?: StringNullableFilter<"BlogPost"> | string | null
    authorId?: StringFilter<"BlogPost"> | string
    published?: BoolFilter<"BlogPost"> | boolean
    publishedAt?: DateTimeNullableFilter<"BlogPost"> | Date | string | null
    createdAt?: DateTimeFilter<"BlogPost"> | Date | string
    updatedAt?: DateTimeFilter<"BlogPost"> | Date | string
    readTime?: IntNullableFilter<"BlogPost"> | number | null
    author?: XOR<UserRelationFilter, UserWhereInput>
    categories?: PostCategoryListRelationFilter
    tags?: PostTagListRelationFilter
    comments?: BlogCommentListRelationFilter
  }

  export type BlogPostOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    excerpt?: SortOrderInput | SortOrder
    content?: SortOrder
    image?: SortOrderInput | SortOrder
    authorId?: SortOrder
    published?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    readTime?: SortOrderInput | SortOrder
    author?: UserOrderByWithRelationInput
    categories?: PostCategoryOrderByRelationAggregateInput
    tags?: PostTagOrderByRelationAggregateInput
    comments?: BlogCommentOrderByRelationAggregateInput
  }

  export type BlogPostWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BlogPostWhereInput | BlogPostWhereInput[]
    OR?: BlogPostWhereInput[]
    NOT?: BlogPostWhereInput | BlogPostWhereInput[]
    title?: StringFilter<"BlogPost"> | string
    excerpt?: StringNullableFilter<"BlogPost"> | string | null
    content?: StringFilter<"BlogPost"> | string
    image?: StringNullableFilter<"BlogPost"> | string | null
    authorId?: StringFilter<"BlogPost"> | string
    published?: BoolFilter<"BlogPost"> | boolean
    publishedAt?: DateTimeNullableFilter<"BlogPost"> | Date | string | null
    createdAt?: DateTimeFilter<"BlogPost"> | Date | string
    updatedAt?: DateTimeFilter<"BlogPost"> | Date | string
    readTime?: IntNullableFilter<"BlogPost"> | number | null
    author?: XOR<UserRelationFilter, UserWhereInput>
    categories?: PostCategoryListRelationFilter
    tags?: PostTagListRelationFilter
    comments?: BlogCommentListRelationFilter
  }, "id">

  export type BlogPostOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    excerpt?: SortOrderInput | SortOrder
    content?: SortOrder
    image?: SortOrderInput | SortOrder
    authorId?: SortOrder
    published?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    readTime?: SortOrderInput | SortOrder
    _count?: BlogPostCountOrderByAggregateInput
    _avg?: BlogPostAvgOrderByAggregateInput
    _max?: BlogPostMaxOrderByAggregateInput
    _min?: BlogPostMinOrderByAggregateInput
    _sum?: BlogPostSumOrderByAggregateInput
  }

  export type BlogPostScalarWhereWithAggregatesInput = {
    AND?: BlogPostScalarWhereWithAggregatesInput | BlogPostScalarWhereWithAggregatesInput[]
    OR?: BlogPostScalarWhereWithAggregatesInput[]
    NOT?: BlogPostScalarWhereWithAggregatesInput | BlogPostScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BlogPost"> | string
    title?: StringWithAggregatesFilter<"BlogPost"> | string
    excerpt?: StringNullableWithAggregatesFilter<"BlogPost"> | string | null
    content?: StringWithAggregatesFilter<"BlogPost"> | string
    image?: StringNullableWithAggregatesFilter<"BlogPost"> | string | null
    authorId?: StringWithAggregatesFilter<"BlogPost"> | string
    published?: BoolWithAggregatesFilter<"BlogPost"> | boolean
    publishedAt?: DateTimeNullableWithAggregatesFilter<"BlogPost"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"BlogPost"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BlogPost"> | Date | string
    readTime?: IntNullableWithAggregatesFilter<"BlogPost"> | number | null
  }

  export type CategoryWhereInput = {
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    id?: StringFilter<"Category"> | string
    name?: StringFilter<"Category"> | string
    slug?: StringFilter<"Category"> | string
    description?: StringNullableFilter<"Category"> | string | null
    posts?: PostCategoryListRelationFilter
  }

  export type CategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    posts?: PostCategoryOrderByRelationAggregateInput
  }

  export type CategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    slug?: string
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    description?: StringNullableFilter<"Category"> | string | null
    posts?: PostCategoryListRelationFilter
  }, "id" | "name" | "slug">

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    OR?: CategoryScalarWhereWithAggregatesInput[]
    NOT?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Category"> | string
    name?: StringWithAggregatesFilter<"Category"> | string
    slug?: StringWithAggregatesFilter<"Category"> | string
    description?: StringNullableWithAggregatesFilter<"Category"> | string | null
  }

  export type PostCategoryWhereInput = {
    AND?: PostCategoryWhereInput | PostCategoryWhereInput[]
    OR?: PostCategoryWhereInput[]
    NOT?: PostCategoryWhereInput | PostCategoryWhereInput[]
    postId?: StringFilter<"PostCategory"> | string
    categoryId?: StringFilter<"PostCategory"> | string
    post?: XOR<BlogPostRelationFilter, BlogPostWhereInput>
    category?: XOR<CategoryRelationFilter, CategoryWhereInput>
  }

  export type PostCategoryOrderByWithRelationInput = {
    postId?: SortOrder
    categoryId?: SortOrder
    post?: BlogPostOrderByWithRelationInput
    category?: CategoryOrderByWithRelationInput
  }

  export type PostCategoryWhereUniqueInput = Prisma.AtLeast<{
    postId_categoryId?: PostCategoryPostIdCategoryIdCompoundUniqueInput
    AND?: PostCategoryWhereInput | PostCategoryWhereInput[]
    OR?: PostCategoryWhereInput[]
    NOT?: PostCategoryWhereInput | PostCategoryWhereInput[]
    postId?: StringFilter<"PostCategory"> | string
    categoryId?: StringFilter<"PostCategory"> | string
    post?: XOR<BlogPostRelationFilter, BlogPostWhereInput>
    category?: XOR<CategoryRelationFilter, CategoryWhereInput>
  }, "postId_categoryId">

  export type PostCategoryOrderByWithAggregationInput = {
    postId?: SortOrder
    categoryId?: SortOrder
    _count?: PostCategoryCountOrderByAggregateInput
    _max?: PostCategoryMaxOrderByAggregateInput
    _min?: PostCategoryMinOrderByAggregateInput
  }

  export type PostCategoryScalarWhereWithAggregatesInput = {
    AND?: PostCategoryScalarWhereWithAggregatesInput | PostCategoryScalarWhereWithAggregatesInput[]
    OR?: PostCategoryScalarWhereWithAggregatesInput[]
    NOT?: PostCategoryScalarWhereWithAggregatesInput | PostCategoryScalarWhereWithAggregatesInput[]
    postId?: StringWithAggregatesFilter<"PostCategory"> | string
    categoryId?: StringWithAggregatesFilter<"PostCategory"> | string
  }

  export type TagWhereInput = {
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    id?: StringFilter<"Tag"> | string
    name?: StringFilter<"Tag"> | string
    slug?: StringFilter<"Tag"> | string
    posts?: PostTagListRelationFilter
  }

  export type TagOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    posts?: PostTagOrderByRelationAggregateInput
  }

  export type TagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    slug?: string
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    posts?: PostTagListRelationFilter
  }, "id" | "name" | "slug">

  export type TagOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    _count?: TagCountOrderByAggregateInput
    _max?: TagMaxOrderByAggregateInput
    _min?: TagMinOrderByAggregateInput
  }

  export type TagScalarWhereWithAggregatesInput = {
    AND?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    OR?: TagScalarWhereWithAggregatesInput[]
    NOT?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tag"> | string
    name?: StringWithAggregatesFilter<"Tag"> | string
    slug?: StringWithAggregatesFilter<"Tag"> | string
  }

  export type PostTagWhereInput = {
    AND?: PostTagWhereInput | PostTagWhereInput[]
    OR?: PostTagWhereInput[]
    NOT?: PostTagWhereInput | PostTagWhereInput[]
    postId?: StringFilter<"PostTag"> | string
    tagId?: StringFilter<"PostTag"> | string
    post?: XOR<BlogPostRelationFilter, BlogPostWhereInput>
    tag?: XOR<TagRelationFilter, TagWhereInput>
  }

  export type PostTagOrderByWithRelationInput = {
    postId?: SortOrder
    tagId?: SortOrder
    post?: BlogPostOrderByWithRelationInput
    tag?: TagOrderByWithRelationInput
  }

  export type PostTagWhereUniqueInput = Prisma.AtLeast<{
    postId_tagId?: PostTagPostIdTagIdCompoundUniqueInput
    AND?: PostTagWhereInput | PostTagWhereInput[]
    OR?: PostTagWhereInput[]
    NOT?: PostTagWhereInput | PostTagWhereInput[]
    postId?: StringFilter<"PostTag"> | string
    tagId?: StringFilter<"PostTag"> | string
    post?: XOR<BlogPostRelationFilter, BlogPostWhereInput>
    tag?: XOR<TagRelationFilter, TagWhereInput>
  }, "postId_tagId">

  export type PostTagOrderByWithAggregationInput = {
    postId?: SortOrder
    tagId?: SortOrder
    _count?: PostTagCountOrderByAggregateInput
    _max?: PostTagMaxOrderByAggregateInput
    _min?: PostTagMinOrderByAggregateInput
  }

  export type PostTagScalarWhereWithAggregatesInput = {
    AND?: PostTagScalarWhereWithAggregatesInput | PostTagScalarWhereWithAggregatesInput[]
    OR?: PostTagScalarWhereWithAggregatesInput[]
    NOT?: PostTagScalarWhereWithAggregatesInput | PostTagScalarWhereWithAggregatesInput[]
    postId?: StringWithAggregatesFilter<"PostTag"> | string
    tagId?: StringWithAggregatesFilter<"PostTag"> | string
  }

  export type BlogCommentWhereInput = {
    AND?: BlogCommentWhereInput | BlogCommentWhereInput[]
    OR?: BlogCommentWhereInput[]
    NOT?: BlogCommentWhereInput | BlogCommentWhereInput[]
    id?: StringFilter<"BlogComment"> | string
    postId?: StringFilter<"BlogComment"> | string
    userId?: StringFilter<"BlogComment"> | string
    content?: StringFilter<"BlogComment"> | string
    createdAt?: DateTimeFilter<"BlogComment"> | Date | string
    parentId?: StringNullableFilter<"BlogComment"> | string | null
    post?: XOR<BlogPostRelationFilter, BlogPostWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    parent?: XOR<BlogCommentNullableRelationFilter, BlogCommentWhereInput> | null
    replies?: BlogCommentListRelationFilter
  }

  export type BlogCommentOrderByWithRelationInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    parentId?: SortOrderInput | SortOrder
    post?: BlogPostOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    parent?: BlogCommentOrderByWithRelationInput
    replies?: BlogCommentOrderByRelationAggregateInput
  }

  export type BlogCommentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BlogCommentWhereInput | BlogCommentWhereInput[]
    OR?: BlogCommentWhereInput[]
    NOT?: BlogCommentWhereInput | BlogCommentWhereInput[]
    postId?: StringFilter<"BlogComment"> | string
    userId?: StringFilter<"BlogComment"> | string
    content?: StringFilter<"BlogComment"> | string
    createdAt?: DateTimeFilter<"BlogComment"> | Date | string
    parentId?: StringNullableFilter<"BlogComment"> | string | null
    post?: XOR<BlogPostRelationFilter, BlogPostWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    parent?: XOR<BlogCommentNullableRelationFilter, BlogCommentWhereInput> | null
    replies?: BlogCommentListRelationFilter
  }, "id">

  export type BlogCommentOrderByWithAggregationInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    parentId?: SortOrderInput | SortOrder
    _count?: BlogCommentCountOrderByAggregateInput
    _max?: BlogCommentMaxOrderByAggregateInput
    _min?: BlogCommentMinOrderByAggregateInput
  }

  export type BlogCommentScalarWhereWithAggregatesInput = {
    AND?: BlogCommentScalarWhereWithAggregatesInput | BlogCommentScalarWhereWithAggregatesInput[]
    OR?: BlogCommentScalarWhereWithAggregatesInput[]
    NOT?: BlogCommentScalarWhereWithAggregatesInput | BlogCommentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BlogComment"> | string
    postId?: StringWithAggregatesFilter<"BlogComment"> | string
    userId?: StringWithAggregatesFilter<"BlogComment"> | string
    content?: StringWithAggregatesFilter<"BlogComment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"BlogComment"> | Date | string
    parentId?: StringNullableWithAggregatesFilter<"BlogComment"> | string | null
  }

  export type ReferralCodeWhereInput = {
    AND?: ReferralCodeWhereInput | ReferralCodeWhereInput[]
    OR?: ReferralCodeWhereInput[]
    NOT?: ReferralCodeWhereInput | ReferralCodeWhereInput[]
    id?: StringFilter<"ReferralCode"> | string
    code?: StringFilter<"ReferralCode"> | string
    userId?: StringFilter<"ReferralCode"> | string
    isActive?: BoolFilter<"ReferralCode"> | boolean
    usageLimit?: IntNullableFilter<"ReferralCode"> | number | null
    maxUses?: IntNullableFilter<"ReferralCode"> | number | null
    pointsReward?: IntFilter<"ReferralCode"> | number
    isUserCode?: BoolFilter<"ReferralCode"> | boolean
    expiresAt?: DateTimeNullableFilter<"ReferralCode"> | Date | string | null
    createdAt?: DateTimeFilter<"ReferralCode"> | Date | string
    updatedAt?: DateTimeFilter<"ReferralCode"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    uses?: ReferralUseListRelationFilter
  }

  export type ReferralCodeOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    userId?: SortOrder
    isActive?: SortOrder
    usageLimit?: SortOrderInput | SortOrder
    maxUses?: SortOrderInput | SortOrder
    pointsReward?: SortOrder
    isUserCode?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    uses?: ReferralUseOrderByRelationAggregateInput
  }

  export type ReferralCodeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: ReferralCodeWhereInput | ReferralCodeWhereInput[]
    OR?: ReferralCodeWhereInput[]
    NOT?: ReferralCodeWhereInput | ReferralCodeWhereInput[]
    userId?: StringFilter<"ReferralCode"> | string
    isActive?: BoolFilter<"ReferralCode"> | boolean
    usageLimit?: IntNullableFilter<"ReferralCode"> | number | null
    maxUses?: IntNullableFilter<"ReferralCode"> | number | null
    pointsReward?: IntFilter<"ReferralCode"> | number
    isUserCode?: BoolFilter<"ReferralCode"> | boolean
    expiresAt?: DateTimeNullableFilter<"ReferralCode"> | Date | string | null
    createdAt?: DateTimeFilter<"ReferralCode"> | Date | string
    updatedAt?: DateTimeFilter<"ReferralCode"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    uses?: ReferralUseListRelationFilter
  }, "id" | "code">

  export type ReferralCodeOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    userId?: SortOrder
    isActive?: SortOrder
    usageLimit?: SortOrderInput | SortOrder
    maxUses?: SortOrderInput | SortOrder
    pointsReward?: SortOrder
    isUserCode?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReferralCodeCountOrderByAggregateInput
    _avg?: ReferralCodeAvgOrderByAggregateInput
    _max?: ReferralCodeMaxOrderByAggregateInput
    _min?: ReferralCodeMinOrderByAggregateInput
    _sum?: ReferralCodeSumOrderByAggregateInput
  }

  export type ReferralCodeScalarWhereWithAggregatesInput = {
    AND?: ReferralCodeScalarWhereWithAggregatesInput | ReferralCodeScalarWhereWithAggregatesInput[]
    OR?: ReferralCodeScalarWhereWithAggregatesInput[]
    NOT?: ReferralCodeScalarWhereWithAggregatesInput | ReferralCodeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ReferralCode"> | string
    code?: StringWithAggregatesFilter<"ReferralCode"> | string
    userId?: StringWithAggregatesFilter<"ReferralCode"> | string
    isActive?: BoolWithAggregatesFilter<"ReferralCode"> | boolean
    usageLimit?: IntNullableWithAggregatesFilter<"ReferralCode"> | number | null
    maxUses?: IntNullableWithAggregatesFilter<"ReferralCode"> | number | null
    pointsReward?: IntWithAggregatesFilter<"ReferralCode"> | number
    isUserCode?: BoolWithAggregatesFilter<"ReferralCode"> | boolean
    expiresAt?: DateTimeNullableWithAggregatesFilter<"ReferralCode"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ReferralCode"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ReferralCode"> | Date | string
  }

  export type ReferralUseWhereInput = {
    AND?: ReferralUseWhereInput | ReferralUseWhereInput[]
    OR?: ReferralUseWhereInput[]
    NOT?: ReferralUseWhereInput | ReferralUseWhereInput[]
    id?: StringFilter<"ReferralUse"> | string
    referralCodeId?: StringFilter<"ReferralUse"> | string
    userId?: StringFilter<"ReferralUse"> | string
    pointsAwarded?: IntFilter<"ReferralUse"> | number
    createdAt?: DateTimeFilter<"ReferralUse"> | Date | string
    referralCode?: XOR<ReferralCodeRelationFilter, ReferralCodeWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ReferralUseOrderByWithRelationInput = {
    id?: SortOrder
    referralCodeId?: SortOrder
    userId?: SortOrder
    pointsAwarded?: SortOrder
    createdAt?: SortOrder
    referralCode?: ReferralCodeOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ReferralUseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    referralCodeId_userId?: ReferralUseReferralCodeIdUserIdCompoundUniqueInput
    AND?: ReferralUseWhereInput | ReferralUseWhereInput[]
    OR?: ReferralUseWhereInput[]
    NOT?: ReferralUseWhereInput | ReferralUseWhereInput[]
    referralCodeId?: StringFilter<"ReferralUse"> | string
    userId?: StringFilter<"ReferralUse"> | string
    pointsAwarded?: IntFilter<"ReferralUse"> | number
    createdAt?: DateTimeFilter<"ReferralUse"> | Date | string
    referralCode?: XOR<ReferralCodeRelationFilter, ReferralCodeWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "referralCodeId_userId">

  export type ReferralUseOrderByWithAggregationInput = {
    id?: SortOrder
    referralCodeId?: SortOrder
    userId?: SortOrder
    pointsAwarded?: SortOrder
    createdAt?: SortOrder
    _count?: ReferralUseCountOrderByAggregateInput
    _avg?: ReferralUseAvgOrderByAggregateInput
    _max?: ReferralUseMaxOrderByAggregateInput
    _min?: ReferralUseMinOrderByAggregateInput
    _sum?: ReferralUseSumOrderByAggregateInput
  }

  export type ReferralUseScalarWhereWithAggregatesInput = {
    AND?: ReferralUseScalarWhereWithAggregatesInput | ReferralUseScalarWhereWithAggregatesInput[]
    OR?: ReferralUseScalarWhereWithAggregatesInput[]
    NOT?: ReferralUseScalarWhereWithAggregatesInput | ReferralUseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ReferralUse"> | string
    referralCodeId?: StringWithAggregatesFilter<"ReferralUse"> | string
    userId?: StringWithAggregatesFilter<"ReferralUse"> | string
    pointsAwarded?: IntWithAggregatesFilter<"ReferralUse"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ReferralUse"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    avatar?: string | null
    bio?: string | null
    createdAt?: Date | string
    points?: number
    referralCode?: string | null
    lastLogin?: Date | string | null
    referredBy?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferredByInput
    teacherProfile?: TeacherProfileCreateNestedOneWithoutUserInput
    availability?: UserAvailabilityCreateNestedManyWithoutUserInput
    pointsTransactions?: PointsTransactionCreateNestedManyWithoutUserInput
    courses?: CourseCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    savedCourses?: SavedCourseCreateNestedManyWithoutUserInput
    likedCourses?: LikedCourseCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutUserInput
    assignmentSubs?: AssignmentSubmissionCreateNestedManyWithoutUserInput
    courseReviews?: CourseReviewCreateNestedManyWithoutUserInput
    tutoringSessions?: TutoringSessionCreateNestedManyWithoutTeacherInput
    tutoringRequests?: TutoringRequestCreateNestedManyWithoutStudentInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentCreateNestedManyWithoutTeacherInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentCreateNestedManyWithoutStudentInput
    tutoringReviews?: TutoringReviewCreateNestedManyWithoutStudentInput
    tutoringMessages?: TutoringMessageCreateNestedManyWithoutSenderInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    conversationParts?: ConversationParticipantCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    attachments?: AttachmentCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    subscriptionRecords?: UserSubscriptionCreateNestedManyWithoutUserInput
    bundlesOwned?: UserBundleCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventCreateNestedManyWithoutUserInput
    eventsAsTeacher?: CalendarEventCreateNestedManyWithoutTeacherInput
    eventsAsStudent?: CalendarEventCreateNestedManyWithoutStudentInput
    blogPosts?: BlogPostCreateNestedManyWithoutAuthorInput
    blogComments?: BlogCommentCreateNestedManyWithoutUserInput
    submissionsGraded?: AssignmentSubmissionCreateNestedManyWithoutGradedByInput
    referralCodesOwned?: ReferralCodeCreateNestedManyWithoutUserInput
    referralUsesGained?: ReferralUseCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    avatar?: string | null
    bio?: string | null
    createdAt?: Date | string
    points?: number
    referralCode?: string | null
    referredById?: string | null
    lastLogin?: Date | string | null
    referrals?: UserUncheckedCreateNestedManyWithoutReferredByInput
    teacherProfile?: TeacherProfileUncheckedCreateNestedOneWithoutUserInput
    availability?: UserAvailabilityUncheckedCreateNestedManyWithoutUserInput
    pointsTransactions?: PointsTransactionUncheckedCreateNestedManyWithoutUserInput
    courses?: CourseUncheckedCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    savedCourses?: SavedCourseUncheckedCreateNestedManyWithoutUserInput
    likedCourses?: LikedCourseUncheckedCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressUncheckedCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutUserInput
    assignmentSubs?: AssignmentSubmissionUncheckedCreateNestedManyWithoutUserInput
    courseReviews?: CourseReviewUncheckedCreateNestedManyWithoutUserInput
    tutoringSessions?: TutoringSessionUncheckedCreateNestedManyWithoutTeacherInput
    tutoringRequests?: TutoringRequestUncheckedCreateNestedManyWithoutStudentInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUncheckedCreateNestedManyWithoutTeacherInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUncheckedCreateNestedManyWithoutStudentInput
    tutoringReviews?: TutoringReviewUncheckedCreateNestedManyWithoutStudentInput
    tutoringMessages?: TutoringMessageUncheckedCreateNestedManyWithoutSenderInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    conversationParts?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    subscriptionRecords?: UserSubscriptionUncheckedCreateNestedManyWithoutUserInput
    bundlesOwned?: UserBundleUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventUncheckedCreateNestedManyWithoutUserInput
    eventsAsTeacher?: CalendarEventUncheckedCreateNestedManyWithoutTeacherInput
    eventsAsStudent?: CalendarEventUncheckedCreateNestedManyWithoutStudentInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
    blogComments?: BlogCommentUncheckedCreateNestedManyWithoutUserInput
    submissionsGraded?: AssignmentSubmissionUncheckedCreateNestedManyWithoutGradedByInput
    referralCodesOwned?: ReferralCodeUncheckedCreateNestedManyWithoutUserInput
    referralUsesGained?: ReferralUseUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: IntFieldUpdateOperationsInput | number
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referredBy?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferredByNestedInput
    teacherProfile?: TeacherProfileUpdateOneWithoutUserNestedInput
    availability?: UserAvailabilityUpdateManyWithoutUserNestedInput
    pointsTransactions?: PointsTransactionUpdateManyWithoutUserNestedInput
    courses?: CourseUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    savedCourses?: SavedCourseUpdateManyWithoutUserNestedInput
    likedCourses?: LikedCourseUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutUserNestedInput
    assignmentSubs?: AssignmentSubmissionUpdateManyWithoutUserNestedInput
    courseReviews?: CourseReviewUpdateManyWithoutUserNestedInput
    tutoringSessions?: TutoringSessionUpdateManyWithoutTeacherNestedInput
    tutoringRequests?: TutoringRequestUpdateManyWithoutStudentNestedInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUpdateManyWithoutTeacherNestedInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUpdateManyWithoutStudentNestedInput
    tutoringReviews?: TutoringReviewUpdateManyWithoutStudentNestedInput
    tutoringMessages?: TutoringMessageUpdateManyWithoutSenderNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    conversationParts?: ConversationParticipantUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    attachments?: AttachmentUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    subscriptionRecords?: UserSubscriptionUpdateManyWithoutUserNestedInput
    bundlesOwned?: UserBundleUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUpdateManyWithoutUserNestedInput
    eventsAsTeacher?: CalendarEventUpdateManyWithoutTeacherNestedInput
    eventsAsStudent?: CalendarEventUpdateManyWithoutStudentNestedInput
    blogPosts?: BlogPostUpdateManyWithoutAuthorNestedInput
    blogComments?: BlogCommentUpdateManyWithoutUserNestedInput
    submissionsGraded?: AssignmentSubmissionUpdateManyWithoutGradedByNestedInput
    referralCodesOwned?: ReferralCodeUpdateManyWithoutUserNestedInput
    referralUsesGained?: ReferralUseUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: IntFieldUpdateOperationsInput | number
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referrals?: UserUncheckedUpdateManyWithoutReferredByNestedInput
    teacherProfile?: TeacherProfileUncheckedUpdateOneWithoutUserNestedInput
    availability?: UserAvailabilityUncheckedUpdateManyWithoutUserNestedInput
    pointsTransactions?: PointsTransactionUncheckedUpdateManyWithoutUserNestedInput
    courses?: CourseUncheckedUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    savedCourses?: SavedCourseUncheckedUpdateManyWithoutUserNestedInput
    likedCourses?: LikedCourseUncheckedUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUncheckedUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    assignmentSubs?: AssignmentSubmissionUncheckedUpdateManyWithoutUserNestedInput
    courseReviews?: CourseReviewUncheckedUpdateManyWithoutUserNestedInput
    tutoringSessions?: TutoringSessionUncheckedUpdateManyWithoutTeacherNestedInput
    tutoringRequests?: TutoringRequestUncheckedUpdateManyWithoutStudentNestedInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUncheckedUpdateManyWithoutTeacherNestedInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUncheckedUpdateManyWithoutStudentNestedInput
    tutoringReviews?: TutoringReviewUncheckedUpdateManyWithoutStudentNestedInput
    tutoringMessages?: TutoringMessageUncheckedUpdateManyWithoutSenderNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    conversationParts?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    subscriptionRecords?: UserSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    bundlesOwned?: UserBundleUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUncheckedUpdateManyWithoutUserNestedInput
    eventsAsTeacher?: CalendarEventUncheckedUpdateManyWithoutTeacherNestedInput
    eventsAsStudent?: CalendarEventUncheckedUpdateManyWithoutStudentNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
    blogComments?: BlogCommentUncheckedUpdateManyWithoutUserNestedInput
    submissionsGraded?: AssignmentSubmissionUncheckedUpdateManyWithoutGradedByNestedInput
    referralCodesOwned?: ReferralCodeUncheckedUpdateManyWithoutUserNestedInput
    referralUsesGained?: ReferralUseUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    avatar?: string | null
    bio?: string | null
    createdAt?: Date | string
    points?: number
    referralCode?: string | null
    referredById?: string | null
    lastLogin?: Date | string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: IntFieldUpdateOperationsInput | number
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: IntFieldUpdateOperationsInput | number
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TeacherProfileCreateInput = {
    specialization?: TeacherProfileCreatespecializationInput | string[]
    rating?: Decimal | DecimalJsLike | number | string | null
    students?: number
    education?: string | null
    experience?: string | null
    certificates?: TeacherProfileCreatecertificatesInput | string[]
    user: UserCreateNestedOneWithoutTeacherProfileInput
  }

  export type TeacherProfileUncheckedCreateInput = {
    userId: string
    specialization?: TeacherProfileCreatespecializationInput | string[]
    rating?: Decimal | DecimalJsLike | number | string | null
    students?: number
    education?: string | null
    experience?: string | null
    certificates?: TeacherProfileCreatecertificatesInput | string[]
  }

  export type TeacherProfileUpdateInput = {
    specialization?: TeacherProfileUpdatespecializationInput | string[]
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    students?: IntFieldUpdateOperationsInput | number
    education?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    certificates?: TeacherProfileUpdatecertificatesInput | string[]
    user?: UserUpdateOneRequiredWithoutTeacherProfileNestedInput
  }

  export type TeacherProfileUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    specialization?: TeacherProfileUpdatespecializationInput | string[]
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    students?: IntFieldUpdateOperationsInput | number
    education?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    certificates?: TeacherProfileUpdatecertificatesInput | string[]
  }

  export type TeacherProfileCreateManyInput = {
    userId: string
    specialization?: TeacherProfileCreatespecializationInput | string[]
    rating?: Decimal | DecimalJsLike | number | string | null
    students?: number
    education?: string | null
    experience?: string | null
    certificates?: TeacherProfileCreatecertificatesInput | string[]
  }

  export type TeacherProfileUpdateManyMutationInput = {
    specialization?: TeacherProfileUpdatespecializationInput | string[]
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    students?: IntFieldUpdateOperationsInput | number
    education?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    certificates?: TeacherProfileUpdatecertificatesInput | string[]
  }

  export type TeacherProfileUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    specialization?: TeacherProfileUpdatespecializationInput | string[]
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    students?: IntFieldUpdateOperationsInput | number
    education?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    certificates?: TeacherProfileUpdatecertificatesInput | string[]
  }

  export type UserAvailabilityCreateInput = {
    id?: string
    dayOfWeek: number
    startTime: Date | string
    endTime: Date | string
    user: UserCreateNestedOneWithoutAvailabilityInput
  }

  export type UserAvailabilityUncheckedCreateInput = {
    id?: string
    userId: string
    dayOfWeek: number
    startTime: Date | string
    endTime: Date | string
  }

  export type UserAvailabilityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAvailabilityNestedInput
  }

  export type UserAvailabilityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAvailabilityCreateManyInput = {
    id?: string
    userId: string
    dayOfWeek: number
    startTime: Date | string
    endTime: Date | string
  }

  export type UserAvailabilityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAvailabilityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PointsTransactionCreateInput = {
    id?: string
    amount: number
    type: $Enums.PointsTxnType
    description?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutPointsTransactionsInput
  }

  export type PointsTransactionUncheckedCreateInput = {
    id?: string
    userId: string
    amount: number
    type: $Enums.PointsTxnType
    description?: string | null
    createdAt?: Date | string
  }

  export type PointsTransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    type?: EnumPointsTxnTypeFieldUpdateOperationsInput | $Enums.PointsTxnType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPointsTransactionsNestedInput
  }

  export type PointsTransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    type?: EnumPointsTxnTypeFieldUpdateOperationsInput | $Enums.PointsTxnType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PointsTransactionCreateManyInput = {
    id?: string
    userId: string
    amount: number
    type: $Enums.PointsTxnType
    description?: string | null
    createdAt?: Date | string
  }

  export type PointsTransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    type?: EnumPointsTxnTypeFieldUpdateOperationsInput | $Enums.PointsTxnType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PointsTransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    type?: EnumPointsTxnTypeFieldUpdateOperationsInput | $Enums.PointsTxnType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PointsPackageCreateInput = {
    id?: string
    name: string
    description?: string | null
    points: number
    price: Decimal | DecimalJsLike | number | string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PointsPackageUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    points: number
    price: Decimal | DecimalJsLike | number | string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PointsPackageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PointsPackageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PointsPackageCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    points: number
    price: Decimal | DecimalJsLike | number | string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PointsPackageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PointsPackageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseCreateInput = {
    id?: string
    title: string
    description?: string | null
    subject: string
    image?: string | null
    price: Decimal | DecimalJsLike | number | string
    pointsPrice: number
    students?: number
    rating?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.CourseStatus
    featured?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teacher: UserCreateNestedOneWithoutCoursesInput
    topics?: TopicCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentCreateNestedManyWithoutCourseInput
    savedBy?: SavedCourseCreateNestedManyWithoutCourseInput
    likedBy?: LikedCourseCreateNestedManyWithoutCourseInput
    reviews?: CourseReviewCreateNestedManyWithoutCourseInput
    lessons?: LessonCreateNestedManyWithoutCourseInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutCourseInput
    certificates?: CertificateCreateNestedManyWithoutCourseInput
    bundleCourses?: BundleCourseCreateNestedManyWithoutCourseInput
    calendarEvents?: CalendarEventCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    subject: string
    image?: string | null
    price: Decimal | DecimalJsLike | number | string
    pointsPrice: number
    teacherId: string
    students?: number
    rating?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.CourseStatus
    featured?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    topics?: TopicUncheckedCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutCourseInput
    savedBy?: SavedCourseUncheckedCreateNestedManyWithoutCourseInput
    likedBy?: LikedCourseUncheckedCreateNestedManyWithoutCourseInput
    reviews?: CourseReviewUncheckedCreateNestedManyWithoutCourseInput
    lessons?: LessonUncheckedCreateNestedManyWithoutCourseInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutCourseInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutCourseInput
    bundleCourses?: BundleCourseUncheckedCreateNestedManyWithoutCourseInput
    calendarEvents?: CalendarEventUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pointsPrice?: IntFieldUpdateOperationsInput | number
    students?: IntFieldUpdateOperationsInput | number
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumCourseStatusFieldUpdateOperationsInput | $Enums.CourseStatus
    featured?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher?: UserUpdateOneRequiredWithoutCoursesNestedInput
    topics?: TopicUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUpdateManyWithoutCourseNestedInput
    savedBy?: SavedCourseUpdateManyWithoutCourseNestedInput
    likedBy?: LikedCourseUpdateManyWithoutCourseNestedInput
    reviews?: CourseReviewUpdateManyWithoutCourseNestedInput
    lessons?: LessonUpdateManyWithoutCourseNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutCourseNestedInput
    certificates?: CertificateUpdateManyWithoutCourseNestedInput
    bundleCourses?: BundleCourseUpdateManyWithoutCourseNestedInput
    calendarEvents?: CalendarEventUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pointsPrice?: IntFieldUpdateOperationsInput | number
    teacherId?: StringFieldUpdateOperationsInput | string
    students?: IntFieldUpdateOperationsInput | number
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumCourseStatusFieldUpdateOperationsInput | $Enums.CourseStatus
    featured?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    topics?: TopicUncheckedUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutCourseNestedInput
    savedBy?: SavedCourseUncheckedUpdateManyWithoutCourseNestedInput
    likedBy?: LikedCourseUncheckedUpdateManyWithoutCourseNestedInput
    reviews?: CourseReviewUncheckedUpdateManyWithoutCourseNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutCourseNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutCourseNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutCourseNestedInput
    bundleCourses?: BundleCourseUncheckedUpdateManyWithoutCourseNestedInput
    calendarEvents?: CalendarEventUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type CourseCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    subject: string
    image?: string | null
    price: Decimal | DecimalJsLike | number | string
    pointsPrice: number
    teacherId: string
    students?: number
    rating?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.CourseStatus
    featured?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CourseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pointsPrice?: IntFieldUpdateOperationsInput | number
    students?: IntFieldUpdateOperationsInput | number
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumCourseStatusFieldUpdateOperationsInput | $Enums.CourseStatus
    featured?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pointsPrice?: IntFieldUpdateOperationsInput | number
    teacherId?: StringFieldUpdateOperationsInput | string
    students?: IntFieldUpdateOperationsInput | number
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumCourseStatusFieldUpdateOperationsInput | $Enums.CourseStatus
    featured?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TopicCreateInput = {
    id?: string
    title: string
    description?: string | null
    orderIndex: number
    course: CourseCreateNestedOneWithoutTopicsInput
    lessons?: LessonCreateNestedManyWithoutTopicInput
  }

  export type TopicUncheckedCreateInput = {
    id?: string
    courseId: string
    title: string
    description?: string | null
    orderIndex: number
    lessons?: LessonUncheckedCreateNestedManyWithoutTopicInput
  }

  export type TopicUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    orderIndex?: IntFieldUpdateOperationsInput | number
    course?: CourseUpdateOneRequiredWithoutTopicsNestedInput
    lessons?: LessonUpdateManyWithoutTopicNestedInput
  }

  export type TopicUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    orderIndex?: IntFieldUpdateOperationsInput | number
    lessons?: LessonUncheckedUpdateManyWithoutTopicNestedInput
  }

  export type TopicCreateManyInput = {
    id?: string
    courseId: string
    title: string
    description?: string | null
    orderIndex: number
  }

  export type TopicUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    orderIndex?: IntFieldUpdateOperationsInput | number
  }

  export type TopicUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    orderIndex?: IntFieldUpdateOperationsInput | number
  }

  export type LessonCreateInput = {
    id?: string
    title: string
    description?: string | null
    videoUrl?: string | null
    content?: string | null
    duration?: number | null
    orderIndex: number
    type: $Enums.LessonType
    topic: TopicCreateNestedOneWithoutLessonsInput
    quiz?: QuizCreateNestedOneWithoutLessonInput
    assignment?: AssignmentCreateNestedOneWithoutLessonInput
    progress?: LessonProgressCreateNestedManyWithoutLessonInput
    calendarEvents?: CalendarEventCreateNestedManyWithoutLessonInput
    course?: CourseCreateNestedOneWithoutLessonsInput
  }

  export type LessonUncheckedCreateInput = {
    id?: string
    topicId: string
    title: string
    description?: string | null
    videoUrl?: string | null
    content?: string | null
    duration?: number | null
    orderIndex: number
    type: $Enums.LessonType
    courseId?: string | null
    quiz?: QuizUncheckedCreateNestedOneWithoutLessonInput
    assignment?: AssignmentUncheckedCreateNestedOneWithoutLessonInput
    progress?: LessonProgressUncheckedCreateNestedManyWithoutLessonInput
    calendarEvents?: CalendarEventUncheckedCreateNestedManyWithoutLessonInput
  }

  export type LessonUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    orderIndex?: IntFieldUpdateOperationsInput | number
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    topic?: TopicUpdateOneRequiredWithoutLessonsNestedInput
    quiz?: QuizUpdateOneWithoutLessonNestedInput
    assignment?: AssignmentUpdateOneWithoutLessonNestedInput
    progress?: LessonProgressUpdateManyWithoutLessonNestedInput
    calendarEvents?: CalendarEventUpdateManyWithoutLessonNestedInput
    course?: CourseUpdateOneWithoutLessonsNestedInput
  }

  export type LessonUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    orderIndex?: IntFieldUpdateOperationsInput | number
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    quiz?: QuizUncheckedUpdateOneWithoutLessonNestedInput
    assignment?: AssignmentUncheckedUpdateOneWithoutLessonNestedInput
    progress?: LessonProgressUncheckedUpdateManyWithoutLessonNestedInput
    calendarEvents?: CalendarEventUncheckedUpdateManyWithoutLessonNestedInput
  }

  export type LessonCreateManyInput = {
    id?: string
    topicId: string
    title: string
    description?: string | null
    videoUrl?: string | null
    content?: string | null
    duration?: number | null
    orderIndex: number
    type: $Enums.LessonType
    courseId?: string | null
  }

  export type LessonUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    orderIndex?: IntFieldUpdateOperationsInput | number
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
  }

  export type LessonUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    orderIndex?: IntFieldUpdateOperationsInput | number
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QuizCreateInput = {
    id?: string
    title: string
    description?: string | null
    timeLimit?: number | null
    lesson: LessonCreateNestedOneWithoutQuizInput
    questions?: QuestionCreateNestedManyWithoutQuizInput
    attempts?: QuizAttemptCreateNestedManyWithoutQuizInput
  }

  export type QuizUncheckedCreateInput = {
    id?: string
    lessonId: string
    title: string
    description?: string | null
    timeLimit?: number | null
    questions?: QuestionUncheckedCreateNestedManyWithoutQuizInput
    attempts?: QuizAttemptUncheckedCreateNestedManyWithoutQuizInput
  }

  export type QuizUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    lesson?: LessonUpdateOneRequiredWithoutQuizNestedInput
    questions?: QuestionUpdateManyWithoutQuizNestedInput
    attempts?: QuizAttemptUpdateManyWithoutQuizNestedInput
  }

  export type QuizUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lessonId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    questions?: QuestionUncheckedUpdateManyWithoutQuizNestedInput
    attempts?: QuizAttemptUncheckedUpdateManyWithoutQuizNestedInput
  }

  export type QuizCreateManyInput = {
    id?: string
    lessonId: string
    title: string
    description?: string | null
    timeLimit?: number | null
  }

  export type QuizUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type QuizUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    lessonId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type QuestionCreateInput = {
    id?: string
    questionText: string
    type: $Enums.QuestionType
    options: JsonNullValueInput | InputJsonValue
    correctOptions?: QuestionCreatecorrectOptionsInput | number[]
    orderIndex?: number | null
    quiz: QuizCreateNestedOneWithoutQuestionsInput
  }

  export type QuestionUncheckedCreateInput = {
    id?: string
    quizId: string
    questionText: string
    type: $Enums.QuestionType
    options: JsonNullValueInput | InputJsonValue
    correctOptions?: QuestionCreatecorrectOptionsInput | number[]
    orderIndex?: number | null
  }

  export type QuestionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionText?: StringFieldUpdateOperationsInput | string
    type?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    options?: JsonNullValueInput | InputJsonValue
    correctOptions?: QuestionUpdatecorrectOptionsInput | number[]
    orderIndex?: NullableIntFieldUpdateOperationsInput | number | null
    quiz?: QuizUpdateOneRequiredWithoutQuestionsNestedInput
  }

  export type QuestionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quizId?: StringFieldUpdateOperationsInput | string
    questionText?: StringFieldUpdateOperationsInput | string
    type?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    options?: JsonNullValueInput | InputJsonValue
    correctOptions?: QuestionUpdatecorrectOptionsInput | number[]
    orderIndex?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type QuestionCreateManyInput = {
    id?: string
    quizId: string
    questionText: string
    type: $Enums.QuestionType
    options: JsonNullValueInput | InputJsonValue
    correctOptions?: QuestionCreatecorrectOptionsInput | number[]
    orderIndex?: number | null
  }

  export type QuestionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionText?: StringFieldUpdateOperationsInput | string
    type?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    options?: JsonNullValueInput | InputJsonValue
    correctOptions?: QuestionUpdatecorrectOptionsInput | number[]
    orderIndex?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type QuestionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    quizId?: StringFieldUpdateOperationsInput | string
    questionText?: StringFieldUpdateOperationsInput | string
    type?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    options?: JsonNullValueInput | InputJsonValue
    correctOptions?: QuestionUpdatecorrectOptionsInput | number[]
    orderIndex?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AssignmentCreateInput = {
    id?: string
    title: string
    description?: string | null
    dueDate?: Date | string | null
    maxScore: number
    allowFileUpload?: boolean
    allowedFileTypes?: AssignmentCreateallowedFileTypesInput | string[]
    unitTests?: NullableJsonNullValueInput | InputJsonValue
    lesson: LessonCreateNestedOneWithoutAssignmentInput
    submissions?: AssignmentSubmissionCreateNestedManyWithoutAssignmentInput
  }

  export type AssignmentUncheckedCreateInput = {
    id?: string
    lessonId: string
    title: string
    description?: string | null
    dueDate?: Date | string | null
    maxScore: number
    allowFileUpload?: boolean
    allowedFileTypes?: AssignmentCreateallowedFileTypesInput | string[]
    unitTests?: NullableJsonNullValueInput | InputJsonValue
    submissions?: AssignmentSubmissionUncheckedCreateNestedManyWithoutAssignmentInput
  }

  export type AssignmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxScore?: IntFieldUpdateOperationsInput | number
    allowFileUpload?: BoolFieldUpdateOperationsInput | boolean
    allowedFileTypes?: AssignmentUpdateallowedFileTypesInput | string[]
    unitTests?: NullableJsonNullValueInput | InputJsonValue
    lesson?: LessonUpdateOneRequiredWithoutAssignmentNestedInput
    submissions?: AssignmentSubmissionUpdateManyWithoutAssignmentNestedInput
  }

  export type AssignmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lessonId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxScore?: IntFieldUpdateOperationsInput | number
    allowFileUpload?: BoolFieldUpdateOperationsInput | boolean
    allowedFileTypes?: AssignmentUpdateallowedFileTypesInput | string[]
    unitTests?: NullableJsonNullValueInput | InputJsonValue
    submissions?: AssignmentSubmissionUncheckedUpdateManyWithoutAssignmentNestedInput
  }

  export type AssignmentCreateManyInput = {
    id?: string
    lessonId: string
    title: string
    description?: string | null
    dueDate?: Date | string | null
    maxScore: number
    allowFileUpload?: boolean
    allowedFileTypes?: AssignmentCreateallowedFileTypesInput | string[]
    unitTests?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AssignmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxScore?: IntFieldUpdateOperationsInput | number
    allowFileUpload?: BoolFieldUpdateOperationsInput | boolean
    allowedFileTypes?: AssignmentUpdateallowedFileTypesInput | string[]
    unitTests?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AssignmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    lessonId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxScore?: IntFieldUpdateOperationsInput | number
    allowFileUpload?: BoolFieldUpdateOperationsInput | boolean
    allowedFileTypes?: AssignmentUpdateallowedFileTypesInput | string[]
    unitTests?: NullableJsonNullValueInput | InputJsonValue
  }

  export type EnrollmentCreateInput = {
    id?: string
    enrolledAt?: Date | string
    completed?: boolean
    completedAt?: Date | string | null
    status?: string
    user: UserCreateNestedOneWithoutEnrollmentsInput
    course: CourseCreateNestedOneWithoutEnrollmentsInput
  }

  export type EnrollmentUncheckedCreateInput = {
    id?: string
    userId: string
    courseId: string
    enrolledAt?: Date | string
    completed?: boolean
    completedAt?: Date | string | null
    status?: string
  }

  export type EnrollmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutEnrollmentsNestedInput
    course?: CourseUpdateOneRequiredWithoutEnrollmentsNestedInput
  }

  export type EnrollmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type EnrollmentCreateManyInput = {
    id?: string
    userId: string
    courseId: string
    enrolledAt?: Date | string
    completed?: boolean
    completedAt?: Date | string | null
    status?: string
  }

  export type EnrollmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type EnrollmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type SavedCourseCreateInput = {
    id?: string
    savedAt?: Date | string
    user: UserCreateNestedOneWithoutSavedCoursesInput
    course: CourseCreateNestedOneWithoutSavedByInput
  }

  export type SavedCourseUncheckedCreateInput = {
    id?: string
    userId: string
    courseId: string
    savedAt?: Date | string
  }

  export type SavedCourseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    savedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSavedCoursesNestedInput
    course?: CourseUpdateOneRequiredWithoutSavedByNestedInput
  }

  export type SavedCourseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    savedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SavedCourseCreateManyInput = {
    id?: string
    userId: string
    courseId: string
    savedAt?: Date | string
  }

  export type SavedCourseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    savedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SavedCourseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    savedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikedCourseCreateInput = {
    id?: string
    likedAt?: Date | string
    user: UserCreateNestedOneWithoutLikedCoursesInput
    course: CourseCreateNestedOneWithoutLikedByInput
  }

  export type LikedCourseUncheckedCreateInput = {
    id?: string
    userId: string
    courseId: string
    likedAt?: Date | string
  }

  export type LikedCourseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    likedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLikedCoursesNestedInput
    course?: CourseUpdateOneRequiredWithoutLikedByNestedInput
  }

  export type LikedCourseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    likedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikedCourseCreateManyInput = {
    id?: string
    userId: string
    courseId: string
    likedAt?: Date | string
  }

  export type LikedCourseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    likedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikedCourseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    likedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LessonProgressCreateInput = {
    id?: string
    completed?: boolean
    completedAt?: Date | string | null
    lastPosition?: number
    user: UserCreateNestedOneWithoutLessonProgressInput
    lesson: LessonCreateNestedOneWithoutProgressInput
  }

  export type LessonProgressUncheckedCreateInput = {
    id?: string
    userId: string
    lessonId: string
    completed?: boolean
    completedAt?: Date | string | null
    lastPosition?: number
  }

  export type LessonProgressUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPosition?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutLessonProgressNestedInput
    lesson?: LessonUpdateOneRequiredWithoutProgressNestedInput
  }

  export type LessonProgressUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    lessonId?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPosition?: IntFieldUpdateOperationsInput | number
  }

  export type LessonProgressCreateManyInput = {
    id?: string
    userId: string
    lessonId: string
    completed?: boolean
    completedAt?: Date | string | null
    lastPosition?: number
  }

  export type LessonProgressUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPosition?: IntFieldUpdateOperationsInput | number
  }

  export type LessonProgressUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    lessonId?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPosition?: IntFieldUpdateOperationsInput | number
  }

  export type QuizAttemptCreateInput = {
    id?: string
    score: number
    duration?: number | null
    completedAt?: Date | string
    answers: JsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutQuizAttemptsInput
    quiz: QuizCreateNestedOneWithoutAttemptsInput
    course?: CourseCreateNestedOneWithoutQuizAttemptsInput
  }

  export type QuizAttemptUncheckedCreateInput = {
    id?: string
    userId: string
    quizId: string
    score: number
    duration?: number | null
    completedAt?: Date | string
    answers: JsonNullValueInput | InputJsonValue
    courseId?: string | null
  }

  export type QuizAttemptUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answers?: JsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutQuizAttemptsNestedInput
    quiz?: QuizUpdateOneRequiredWithoutAttemptsNestedInput
    course?: CourseUpdateOneWithoutQuizAttemptsNestedInput
  }

  export type QuizAttemptUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    quizId?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answers?: JsonNullValueInput | InputJsonValue
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QuizAttemptCreateManyInput = {
    id?: string
    userId: string
    quizId: string
    score: number
    duration?: number | null
    completedAt?: Date | string
    answers: JsonNullValueInput | InputJsonValue
    courseId?: string | null
  }

  export type QuizAttemptUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answers?: JsonNullValueInput | InputJsonValue
  }

  export type QuizAttemptUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    quizId?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answers?: JsonNullValueInput | InputJsonValue
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AssignmentSubmissionCreateInput = {
    id?: string
    content?: string | null
    fileUrls?: AssignmentSubmissionCreatefileUrlsInput | string[]
    submittedAt?: Date | string
    score?: number | null
    feedback?: string | null
    gradedAt?: Date | string | null
    user: UserCreateNestedOneWithoutAssignmentSubsInput
    assignment: AssignmentCreateNestedOneWithoutSubmissionsInput
    gradedBy?: UserCreateNestedOneWithoutSubmissionsGradedInput
  }

  export type AssignmentSubmissionUncheckedCreateInput = {
    id?: string
    userId: string
    assignmentId: string
    content?: string | null
    fileUrls?: AssignmentSubmissionCreatefileUrlsInput | string[]
    submittedAt?: Date | string
    score?: number | null
    feedback?: string | null
    gradedAt?: Date | string | null
    gradedById?: string | null
  }

  export type AssignmentSubmissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrls?: AssignmentSubmissionUpdatefileUrlsInput | string[]
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    score?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    gradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutAssignmentSubsNestedInput
    assignment?: AssignmentUpdateOneRequiredWithoutSubmissionsNestedInput
    gradedBy?: UserUpdateOneWithoutSubmissionsGradedNestedInput
  }

  export type AssignmentSubmissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    assignmentId?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrls?: AssignmentSubmissionUpdatefileUrlsInput | string[]
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    score?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    gradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gradedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AssignmentSubmissionCreateManyInput = {
    id?: string
    userId: string
    assignmentId: string
    content?: string | null
    fileUrls?: AssignmentSubmissionCreatefileUrlsInput | string[]
    submittedAt?: Date | string
    score?: number | null
    feedback?: string | null
    gradedAt?: Date | string | null
    gradedById?: string | null
  }

  export type AssignmentSubmissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrls?: AssignmentSubmissionUpdatefileUrlsInput | string[]
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    score?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    gradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AssignmentSubmissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    assignmentId?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrls?: AssignmentSubmissionUpdatefileUrlsInput | string[]
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    score?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    gradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gradedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CourseReviewCreateInput = {
    id?: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutCourseReviewsInput
    course: CourseCreateNestedOneWithoutReviewsInput
  }

  export type CourseReviewUncheckedCreateInput = {
    id?: string
    userId: string
    courseId: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
  }

  export type CourseReviewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCourseReviewsNestedInput
    course?: CourseUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type CourseReviewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseReviewCreateManyInput = {
    id?: string
    userId: string
    courseId: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
  }

  export type CourseReviewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseReviewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TutoringSessionCreateInput = {
    id?: string
    subject: string
    description?: string | null
    pricePerHour: Decimal | DecimalJsLike | number | string
    locationType: $Enums.TutoringLocationType
    status?: $Enums.TutoringStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    maxStudents?: number
    prerequisites?: TutoringSessionCreateprerequisitesInput | string[]
    level?: string | null
    tags?: TutoringSessionCreatetagsInput | string[]
    featured?: boolean
    teacher: UserCreateNestedOneWithoutTutoringSessionsInput
    availability?: TutoringAvailabilityCreateNestedManyWithoutSessionInput
    requests?: TutoringRequestCreateNestedManyWithoutSessionInput
    appointments?: TutoringAppointmentCreateNestedManyWithoutSessionInput
    reviews?: TutoringReviewCreateNestedManyWithoutSessionInput
    certificates?: CertificateCreateNestedManyWithoutTutoringInput
  }

  export type TutoringSessionUncheckedCreateInput = {
    id?: string
    teacherId: string
    subject: string
    description?: string | null
    pricePerHour: Decimal | DecimalJsLike | number | string
    locationType: $Enums.TutoringLocationType
    status?: $Enums.TutoringStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    maxStudents?: number
    prerequisites?: TutoringSessionCreateprerequisitesInput | string[]
    level?: string | null
    tags?: TutoringSessionCreatetagsInput | string[]
    featured?: boolean
    availability?: TutoringAvailabilityUncheckedCreateNestedManyWithoutSessionInput
    requests?: TutoringRequestUncheckedCreateNestedManyWithoutSessionInput
    appointments?: TutoringAppointmentUncheckedCreateNestedManyWithoutSessionInput
    reviews?: TutoringReviewUncheckedCreateNestedManyWithoutSessionInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutTutoringInput
  }

  export type TutoringSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pricePerHour?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    locationType?: EnumTutoringLocationTypeFieldUpdateOperationsInput | $Enums.TutoringLocationType
    status?: EnumTutoringStatusFieldUpdateOperationsInput | $Enums.TutoringStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maxStudents?: IntFieldUpdateOperationsInput | number
    prerequisites?: TutoringSessionUpdateprerequisitesInput | string[]
    level?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: TutoringSessionUpdatetagsInput | string[]
    featured?: BoolFieldUpdateOperationsInput | boolean
    teacher?: UserUpdateOneRequiredWithoutTutoringSessionsNestedInput
    availability?: TutoringAvailabilityUpdateManyWithoutSessionNestedInput
    requests?: TutoringRequestUpdateManyWithoutSessionNestedInput
    appointments?: TutoringAppointmentUpdateManyWithoutSessionNestedInput
    reviews?: TutoringReviewUpdateManyWithoutSessionNestedInput
    certificates?: CertificateUpdateManyWithoutTutoringNestedInput
  }

  export type TutoringSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pricePerHour?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    locationType?: EnumTutoringLocationTypeFieldUpdateOperationsInput | $Enums.TutoringLocationType
    status?: EnumTutoringStatusFieldUpdateOperationsInput | $Enums.TutoringStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maxStudents?: IntFieldUpdateOperationsInput | number
    prerequisites?: TutoringSessionUpdateprerequisitesInput | string[]
    level?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: TutoringSessionUpdatetagsInput | string[]
    featured?: BoolFieldUpdateOperationsInput | boolean
    availability?: TutoringAvailabilityUncheckedUpdateManyWithoutSessionNestedInput
    requests?: TutoringRequestUncheckedUpdateManyWithoutSessionNestedInput
    appointments?: TutoringAppointmentUncheckedUpdateManyWithoutSessionNestedInput
    reviews?: TutoringReviewUncheckedUpdateManyWithoutSessionNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutTutoringNestedInput
  }

  export type TutoringSessionCreateManyInput = {
    id?: string
    teacherId: string
    subject: string
    description?: string | null
    pricePerHour: Decimal | DecimalJsLike | number | string
    locationType: $Enums.TutoringLocationType
    status?: $Enums.TutoringStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    maxStudents?: number
    prerequisites?: TutoringSessionCreateprerequisitesInput | string[]
    level?: string | null
    tags?: TutoringSessionCreatetagsInput | string[]
    featured?: boolean
  }

  export type TutoringSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pricePerHour?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    locationType?: EnumTutoringLocationTypeFieldUpdateOperationsInput | $Enums.TutoringLocationType
    status?: EnumTutoringStatusFieldUpdateOperationsInput | $Enums.TutoringStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maxStudents?: IntFieldUpdateOperationsInput | number
    prerequisites?: TutoringSessionUpdateprerequisitesInput | string[]
    level?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: TutoringSessionUpdatetagsInput | string[]
    featured?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TutoringSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pricePerHour?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    locationType?: EnumTutoringLocationTypeFieldUpdateOperationsInput | $Enums.TutoringLocationType
    status?: EnumTutoringStatusFieldUpdateOperationsInput | $Enums.TutoringStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maxStudents?: IntFieldUpdateOperationsInput | number
    prerequisites?: TutoringSessionUpdateprerequisitesInput | string[]
    level?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: TutoringSessionUpdatetagsInput | string[]
    featured?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TutoringAvailabilityCreateInput = {
    id?: string
    dayOfWeek: number
    startTime: Date | string
    endTime: Date | string
    session: TutoringSessionCreateNestedOneWithoutAvailabilityInput
  }

  export type TutoringAvailabilityUncheckedCreateInput = {
    id?: string
    sessionId: string
    dayOfWeek: number
    startTime: Date | string
    endTime: Date | string
  }

  export type TutoringAvailabilityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: TutoringSessionUpdateOneRequiredWithoutAvailabilityNestedInput
  }

  export type TutoringAvailabilityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TutoringAvailabilityCreateManyInput = {
    id?: string
    sessionId: string
    dayOfWeek: number
    startTime: Date | string
    endTime: Date | string
  }

  export type TutoringAvailabilityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TutoringAvailabilityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TutoringRequestCreateInput = {
    id?: string
    message?: string | null
    preferredDates?: TutoringRequestCreatepreferredDatesInput | Date[] | string[]
    status?: $Enums.TutoringRequestStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    session: TutoringSessionCreateNestedOneWithoutRequestsInput
    student: UserCreateNestedOneWithoutTutoringRequestsInput
    appointment?: TutoringAppointmentCreateNestedOneWithoutRequestInput
    messages?: TutoringMessageCreateNestedManyWithoutRequestInput
  }

  export type TutoringRequestUncheckedCreateInput = {
    id?: string
    sessionId: string
    studentId: string
    message?: string | null
    preferredDates?: TutoringRequestCreatepreferredDatesInput | Date[] | string[]
    status?: $Enums.TutoringRequestStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    appointment?: TutoringAppointmentUncheckedCreateNestedOneWithoutRequestInput
    messages?: TutoringMessageUncheckedCreateNestedManyWithoutRequestInput
  }

  export type TutoringRequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    preferredDates?: TutoringRequestUpdatepreferredDatesInput | Date[] | string[]
    status?: EnumTutoringRequestStatusFieldUpdateOperationsInput | $Enums.TutoringRequestStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: TutoringSessionUpdateOneRequiredWithoutRequestsNestedInput
    student?: UserUpdateOneRequiredWithoutTutoringRequestsNestedInput
    appointment?: TutoringAppointmentUpdateOneWithoutRequestNestedInput
    messages?: TutoringMessageUpdateManyWithoutRequestNestedInput
  }

  export type TutoringRequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    preferredDates?: TutoringRequestUpdatepreferredDatesInput | Date[] | string[]
    status?: EnumTutoringRequestStatusFieldUpdateOperationsInput | $Enums.TutoringRequestStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: TutoringAppointmentUncheckedUpdateOneWithoutRequestNestedInput
    messages?: TutoringMessageUncheckedUpdateManyWithoutRequestNestedInput
  }

  export type TutoringRequestCreateManyInput = {
    id?: string
    sessionId: string
    studentId: string
    message?: string | null
    preferredDates?: TutoringRequestCreatepreferredDatesInput | Date[] | string[]
    status?: $Enums.TutoringRequestStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TutoringRequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    preferredDates?: TutoringRequestUpdatepreferredDatesInput | Date[] | string[]
    status?: EnumTutoringRequestStatusFieldUpdateOperationsInput | $Enums.TutoringRequestStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TutoringRequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    preferredDates?: TutoringRequestUpdatepreferredDatesInput | Date[] | string[]
    status?: EnumTutoringRequestStatusFieldUpdateOperationsInput | $Enums.TutoringRequestStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TutoringAppointmentCreateInput = {
    id?: string
    scheduledAt: Date | string
    duration: number
    notes?: string | null
    meetingLink?: string | null
    status?: $Enums.AppointmentStatus
    price: Decimal | DecimalJsLike | number | string
    request: TutoringRequestCreateNestedOneWithoutAppointmentInput
    session: TutoringSessionCreateNestedOneWithoutAppointmentsInput
    teacher: UserCreateNestedOneWithoutTutoringAppointmentsAsTeacherInput
    student: UserCreateNestedOneWithoutTutoringAppointmentsAsStudentInput
  }

  export type TutoringAppointmentUncheckedCreateInput = {
    id?: string
    requestId: string
    sessionId: string
    scheduledAt: Date | string
    duration: number
    notes?: string | null
    meetingLink?: string | null
    status?: $Enums.AppointmentStatus
    price: Decimal | DecimalJsLike | number | string
    teacherId: string
    studentId: string
  }

  export type TutoringAppointmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    request?: TutoringRequestUpdateOneRequiredWithoutAppointmentNestedInput
    session?: TutoringSessionUpdateOneRequiredWithoutAppointmentsNestedInput
    teacher?: UserUpdateOneRequiredWithoutTutoringAppointmentsAsTeacherNestedInput
    student?: UserUpdateOneRequiredWithoutTutoringAppointmentsAsStudentNestedInput
  }

  export type TutoringAppointmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    teacherId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
  }

  export type TutoringAppointmentCreateManyInput = {
    id?: string
    requestId: string
    sessionId: string
    scheduledAt: Date | string
    duration: number
    notes?: string | null
    meetingLink?: string | null
    status?: $Enums.AppointmentStatus
    price: Decimal | DecimalJsLike | number | string
    teacherId: string
    studentId: string
  }

  export type TutoringAppointmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type TutoringAppointmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    teacherId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
  }

  export type TutoringReviewCreateInput = {
    id?: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
    session: TutoringSessionCreateNestedOneWithoutReviewsInput
    student: UserCreateNestedOneWithoutTutoringReviewsInput
  }

  export type TutoringReviewUncheckedCreateInput = {
    id?: string
    sessionId: string
    studentId: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
  }

  export type TutoringReviewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: TutoringSessionUpdateOneRequiredWithoutReviewsNestedInput
    student?: UserUpdateOneRequiredWithoutTutoringReviewsNestedInput
  }

  export type TutoringReviewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TutoringReviewCreateManyInput = {
    id?: string
    sessionId: string
    studentId: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
  }

  export type TutoringReviewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TutoringReviewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TutoringMessageCreateInput = {
    id?: string
    message: string
    read?: boolean
    createdAt?: Date | string
    request: TutoringRequestCreateNestedOneWithoutMessagesInput
    sender: UserCreateNestedOneWithoutTutoringMessagesInput
  }

  export type TutoringMessageUncheckedCreateInput = {
    id?: string
    requestId: string
    senderId: string
    message: string
    read?: boolean
    createdAt?: Date | string
  }

  export type TutoringMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    request?: TutoringRequestUpdateOneRequiredWithoutMessagesNestedInput
    sender?: UserUpdateOneRequiredWithoutTutoringMessagesNestedInput
  }

  export type TutoringMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TutoringMessageCreateManyInput = {
    id?: string
    requestId: string
    senderId: string
    message: string
    read?: boolean
    createdAt?: Date | string
  }

  export type TutoringMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TutoringMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AchievementCreateInput = {
    id?: string
    name: string
    description?: string | null
    pointsRewarded: number
    icon?: string | null
    category: $Enums.AchievementCategory
    users?: UserAchievementCreateNestedManyWithoutAchievementInput
  }

  export type AchievementUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    pointsRewarded: number
    icon?: string | null
    category: $Enums.AchievementCategory
    users?: UserAchievementUncheckedCreateNestedManyWithoutAchievementInput
  }

  export type AchievementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pointsRewarded?: IntFieldUpdateOperationsInput | number
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumAchievementCategoryFieldUpdateOperationsInput | $Enums.AchievementCategory
    users?: UserAchievementUpdateManyWithoutAchievementNestedInput
  }

  export type AchievementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pointsRewarded?: IntFieldUpdateOperationsInput | number
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumAchievementCategoryFieldUpdateOperationsInput | $Enums.AchievementCategory
    users?: UserAchievementUncheckedUpdateManyWithoutAchievementNestedInput
  }

  export type AchievementCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    pointsRewarded: number
    icon?: string | null
    category: $Enums.AchievementCategory
  }

  export type AchievementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pointsRewarded?: IntFieldUpdateOperationsInput | number
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumAchievementCategoryFieldUpdateOperationsInput | $Enums.AchievementCategory
  }

  export type AchievementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pointsRewarded?: IntFieldUpdateOperationsInput | number
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumAchievementCategoryFieldUpdateOperationsInput | $Enums.AchievementCategory
  }

  export type UserAchievementCreateInput = {
    id?: string
    completed?: boolean
    completedAt?: Date | string | null
    progress?: number
    user: UserCreateNestedOneWithoutAchievementsInput
    achievement: AchievementCreateNestedOneWithoutUsersInput
  }

  export type UserAchievementUncheckedCreateInput = {
    id?: string
    userId: string
    achievementId: string
    completed?: boolean
    completedAt?: Date | string | null
    progress?: number
  }

  export type UserAchievementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutAchievementsNestedInput
    achievement?: AchievementUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserAchievementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
  }

  export type UserAchievementCreateManyInput = {
    id?: string
    userId: string
    achievementId: string
    completed?: boolean
    completedAt?: Date | string | null
    progress?: number
  }

  export type UserAchievementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
  }

  export type UserAchievementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
  }

  export type BadgeCreateInput = {
    id?: string
    name: string
    description?: string | null
    imageUrl?: string | null
    type: $Enums.BadgeType
    category?: string | null
    certificates?: CertificateCreateNestedManyWithoutBadgeInput
  }

  export type BadgeUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    imageUrl?: string | null
    type: $Enums.BadgeType
    category?: string | null
    certificates?: CertificateUncheckedCreateNestedManyWithoutBadgeInput
  }

  export type BadgeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumBadgeTypeFieldUpdateOperationsInput | $Enums.BadgeType
    category?: NullableStringFieldUpdateOperationsInput | string | null
    certificates?: CertificateUpdateManyWithoutBadgeNestedInput
  }

  export type BadgeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumBadgeTypeFieldUpdateOperationsInput | $Enums.BadgeType
    category?: NullableStringFieldUpdateOperationsInput | string | null
    certificates?: CertificateUncheckedUpdateManyWithoutBadgeNestedInput
  }

  export type BadgeCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    imageUrl?: string | null
    type: $Enums.BadgeType
    category?: string | null
  }

  export type BadgeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumBadgeTypeFieldUpdateOperationsInput | $Enums.BadgeType
    category?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BadgeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumBadgeTypeFieldUpdateOperationsInput | $Enums.BadgeType
    category?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CertificateCreateInput = {
    id?: string
    title: string
    issueDate?: Date | string
    type: string
    courseName?: string | null
    tutoringSubject?: string | null
    teacherId?: string | null
    teacherName?: string | null
    customMessage?: string | null
    imageUrl?: string | null
    user: UserCreateNestedOneWithoutCertificatesInput
    course?: CourseCreateNestedOneWithoutCertificatesInput
    tutoring?: TutoringSessionCreateNestedOneWithoutCertificatesInput
    badge?: BadgeCreateNestedOneWithoutCertificatesInput
  }

  export type CertificateUncheckedCreateInput = {
    id?: string
    userId: string
    title: string
    issueDate?: Date | string
    type: string
    courseId?: string | null
    courseName?: string | null
    tutoringId?: string | null
    tutoringSubject?: string | null
    teacherId?: string | null
    teacherName?: string | null
    customMessage?: string | null
    imageUrl?: string | null
    badgeId?: string | null
  }

  export type CertificateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    courseName?: NullableStringFieldUpdateOperationsInput | string | null
    tutoringSubject?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    teacherName?: NullableStringFieldUpdateOperationsInput | string | null
    customMessage?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutCertificatesNestedInput
    course?: CourseUpdateOneWithoutCertificatesNestedInput
    tutoring?: TutoringSessionUpdateOneWithoutCertificatesNestedInput
    badge?: BadgeUpdateOneWithoutCertificatesNestedInput
  }

  export type CertificateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    courseName?: NullableStringFieldUpdateOperationsInput | string | null
    tutoringId?: NullableStringFieldUpdateOperationsInput | string | null
    tutoringSubject?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    teacherName?: NullableStringFieldUpdateOperationsInput | string | null
    customMessage?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    badgeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CertificateCreateManyInput = {
    id?: string
    userId: string
    title: string
    issueDate?: Date | string
    type: string
    courseId?: string | null
    courseName?: string | null
    tutoringId?: string | null
    tutoringSubject?: string | null
    teacherId?: string | null
    teacherName?: string | null
    customMessage?: string | null
    imageUrl?: string | null
    badgeId?: string | null
  }

  export type CertificateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    courseName?: NullableStringFieldUpdateOperationsInput | string | null
    tutoringSubject?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    teacherName?: NullableStringFieldUpdateOperationsInput | string | null
    customMessage?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CertificateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    courseName?: NullableStringFieldUpdateOperationsInput | string | null
    tutoringId?: NullableStringFieldUpdateOperationsInput | string | null
    tutoringSubject?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    teacherName?: NullableStringFieldUpdateOperationsInput | string | null
    customMessage?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    badgeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ConversationCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: ConversationParticipantCreateNestedManyWithoutConversationInput
    messages?: MessageCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: ConversationParticipantUncheckedCreateNestedManyWithoutConversationInput
    messages?: MessageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: ConversationParticipantUpdateManyWithoutConversationNestedInput
    messages?: MessageUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: ConversationParticipantUncheckedUpdateManyWithoutConversationNestedInput
    messages?: MessageUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ConversationCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConversationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationParticipantCreateInput = {
    conversation: ConversationCreateNestedOneWithoutParticipantsInput
    user: UserCreateNestedOneWithoutConversationPartsInput
  }

  export type ConversationParticipantUncheckedCreateInput = {
    conversationId: string
    userId: string
  }

  export type ConversationParticipantUpdateInput = {
    conversation?: ConversationUpdateOneRequiredWithoutParticipantsNestedInput
    user?: UserUpdateOneRequiredWithoutConversationPartsNestedInput
  }

  export type ConversationParticipantUncheckedUpdateInput = {
    conversationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type ConversationParticipantCreateManyInput = {
    conversationId: string
    userId: string
  }

  export type ConversationParticipantUpdateManyMutationInput = {

  }

  export type ConversationParticipantUncheckedUpdateManyInput = {
    conversationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type MessageCreateInput = {
    id?: string
    content: string
    timestamp?: Date | string
    read?: boolean
    conversation: ConversationCreateNestedOneWithoutMessagesInput
    sender: UserCreateNestedOneWithoutSentMessagesInput
    attachments?: AttachmentCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateInput = {
    id?: string
    conversationId: string
    senderId: string
    content: string
    timestamp?: Date | string
    read?: boolean
    attachments?: AttachmentUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: BoolFieldUpdateOperationsInput | boolean
    conversation?: ConversationUpdateOneRequiredWithoutMessagesNestedInput
    sender?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
    attachments?: AttachmentUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: BoolFieldUpdateOperationsInput | boolean
    attachments?: AttachmentUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageCreateManyInput = {
    id?: string
    conversationId: string
    senderId: string
    content: string
    timestamp?: Date | string
    read?: boolean
  }

  export type MessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AttachmentCreateInput = {
    id?: string
    fileName: string
    fileUrl: string
    fileType: string
    fileSize: number
    message: MessageCreateNestedOneWithoutAttachmentsInput
    user?: UserCreateNestedOneWithoutAttachmentsInput
  }

  export type AttachmentUncheckedCreateInput = {
    id?: string
    messageId: string
    userId?: string | null
    fileName: string
    fileUrl: string
    fileType: string
    fileSize: number
  }

  export type AttachmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    message?: MessageUpdateOneRequiredWithoutAttachmentsNestedInput
    user?: UserUpdateOneWithoutAttachmentsNestedInput
  }

  export type AttachmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
  }

  export type AttachmentCreateManyInput = {
    id?: string
    messageId: string
    userId?: string | null
    fileName: string
    fileUrl: string
    fileType: string
    fileSize: number
  }

  export type AttachmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
  }

  export type AttachmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
  }

  export type NotificationCreateInput = {
    id?: string
    title: string
    message: string
    read?: boolean
    type: $Enums.NotificationType
    link?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    userId: string
    title: string
    message: string
    read?: boolean
    type: $Enums.NotificationType
    link?: string | null
    createdAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    link?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    link?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    userId: string
    title: string
    message: string
    read?: boolean
    type: $Enums.NotificationType
    link?: string | null
    createdAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    link?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    link?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionPlanCreateInput = {
    id?: string
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    period: $Enums.SubscriptionPeriod
    featuredBenefit?: string | null
    benefits?: SubscriptionPlanCreatebenefitsInput | string[]
    isPopular?: boolean
    users?: UserSubscriptionCreateNestedManyWithoutPlanInput
  }

  export type SubscriptionPlanUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    period: $Enums.SubscriptionPeriod
    featuredBenefit?: string | null
    benefits?: SubscriptionPlanCreatebenefitsInput | string[]
    isPopular?: boolean
    users?: UserSubscriptionUncheckedCreateNestedManyWithoutPlanInput
  }

  export type SubscriptionPlanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    period?: EnumSubscriptionPeriodFieldUpdateOperationsInput | $Enums.SubscriptionPeriod
    featuredBenefit?: NullableStringFieldUpdateOperationsInput | string | null
    benefits?: SubscriptionPlanUpdatebenefitsInput | string[]
    isPopular?: BoolFieldUpdateOperationsInput | boolean
    users?: UserSubscriptionUpdateManyWithoutPlanNestedInput
  }

  export type SubscriptionPlanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    period?: EnumSubscriptionPeriodFieldUpdateOperationsInput | $Enums.SubscriptionPeriod
    featuredBenefit?: NullableStringFieldUpdateOperationsInput | string | null
    benefits?: SubscriptionPlanUpdatebenefitsInput | string[]
    isPopular?: BoolFieldUpdateOperationsInput | boolean
    users?: UserSubscriptionUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type SubscriptionPlanCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    period: $Enums.SubscriptionPeriod
    featuredBenefit?: string | null
    benefits?: SubscriptionPlanCreatebenefitsInput | string[]
    isPopular?: boolean
  }

  export type SubscriptionPlanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    period?: EnumSubscriptionPeriodFieldUpdateOperationsInput | $Enums.SubscriptionPeriod
    featuredBenefit?: NullableStringFieldUpdateOperationsInput | string | null
    benefits?: SubscriptionPlanUpdatebenefitsInput | string[]
    isPopular?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SubscriptionPlanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    period?: EnumSubscriptionPeriodFieldUpdateOperationsInput | $Enums.SubscriptionPeriod
    featuredBenefit?: NullableStringFieldUpdateOperationsInput | string | null
    benefits?: SubscriptionPlanUpdatebenefitsInput | string[]
    isPopular?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CourseBundleCreateInput = {
    id?: string
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    originalPrice: Decimal | DecimalJsLike | number | string
    discount: number
    featuredBenefit?: string | null
    benefits?: CourseBundleCreatebenefitsInput | string[]
    imageUrl?: string | null
    courses?: BundleCourseCreateNestedManyWithoutBundleInput
    owners?: UserBundleCreateNestedManyWithoutBundleInput
  }

  export type CourseBundleUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    originalPrice: Decimal | DecimalJsLike | number | string
    discount: number
    featuredBenefit?: string | null
    benefits?: CourseBundleCreatebenefitsInput | string[]
    imageUrl?: string | null
    courses?: BundleCourseUncheckedCreateNestedManyWithoutBundleInput
    owners?: UserBundleUncheckedCreateNestedManyWithoutBundleInput
  }

  export type CourseBundleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    originalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: IntFieldUpdateOperationsInput | number
    featuredBenefit?: NullableStringFieldUpdateOperationsInput | string | null
    benefits?: CourseBundleUpdatebenefitsInput | string[]
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    courses?: BundleCourseUpdateManyWithoutBundleNestedInput
    owners?: UserBundleUpdateManyWithoutBundleNestedInput
  }

  export type CourseBundleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    originalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: IntFieldUpdateOperationsInput | number
    featuredBenefit?: NullableStringFieldUpdateOperationsInput | string | null
    benefits?: CourseBundleUpdatebenefitsInput | string[]
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    courses?: BundleCourseUncheckedUpdateManyWithoutBundleNestedInput
    owners?: UserBundleUncheckedUpdateManyWithoutBundleNestedInput
  }

  export type CourseBundleCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    originalPrice: Decimal | DecimalJsLike | number | string
    discount: number
    featuredBenefit?: string | null
    benefits?: CourseBundleCreatebenefitsInput | string[]
    imageUrl?: string | null
  }

  export type CourseBundleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    originalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: IntFieldUpdateOperationsInput | number
    featuredBenefit?: NullableStringFieldUpdateOperationsInput | string | null
    benefits?: CourseBundleUpdatebenefitsInput | string[]
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CourseBundleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    originalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: IntFieldUpdateOperationsInput | number
    featuredBenefit?: NullableStringFieldUpdateOperationsInput | string | null
    benefits?: CourseBundleUpdatebenefitsInput | string[]
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BundleCourseCreateInput = {
    bundle: CourseBundleCreateNestedOneWithoutCoursesInput
    course: CourseCreateNestedOneWithoutBundleCoursesInput
  }

  export type BundleCourseUncheckedCreateInput = {
    bundleId: string
    courseId: string
  }

  export type BundleCourseUpdateInput = {
    bundle?: CourseBundleUpdateOneRequiredWithoutCoursesNestedInput
    course?: CourseUpdateOneRequiredWithoutBundleCoursesNestedInput
  }

  export type BundleCourseUncheckedUpdateInput = {
    bundleId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
  }

  export type BundleCourseCreateManyInput = {
    bundleId: string
    courseId: string
  }

  export type BundleCourseUpdateManyMutationInput = {

  }

  export type BundleCourseUncheckedUpdateManyInput = {
    bundleId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
  }

  export type UserSubscriptionCreateInput = {
    id?: string
    startDate?: Date | string
    endDate: Date | string
    isActive?: boolean
    autoRenew?: boolean
    paymentMethod?: string | null
    lastPaymentDate?: Date | string | null
    user: UserCreateNestedOneWithoutSubscriptionRecordsInput
    plan: SubscriptionPlanCreateNestedOneWithoutUsersInput
  }

  export type UserSubscriptionUncheckedCreateInput = {
    id?: string
    userId: string
    planId: string
    startDate?: Date | string
    endDate: Date | string
    isActive?: boolean
    autoRenew?: boolean
    paymentMethod?: string | null
    lastPaymentDate?: Date | string | null
  }

  export type UserSubscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutSubscriptionRecordsNestedInput
    plan?: SubscriptionPlanUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserSubscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserSubscriptionCreateManyInput = {
    id?: string
    userId: string
    planId: string
    startDate?: Date | string
    endDate: Date | string
    isActive?: boolean
    autoRenew?: boolean
    paymentMethod?: string | null
    lastPaymentDate?: Date | string | null
  }

  export type UserSubscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserSubscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserBundleCreateInput = {
    id?: string
    purchaseDate?: Date | string
    user: UserCreateNestedOneWithoutBundlesOwnedInput
    bundle: CourseBundleCreateNestedOneWithoutOwnersInput
  }

  export type UserBundleUncheckedCreateInput = {
    id?: string
    userId: string
    bundleId: string
    purchaseDate?: Date | string
  }

  export type UserBundleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBundlesOwnedNestedInput
    bundle?: CourseBundleUpdateOneRequiredWithoutOwnersNestedInput
  }

  export type UserBundleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bundleId?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBundleCreateManyInput = {
    id?: string
    userId: string
    bundleId: string
    purchaseDate?: Date | string
  }

  export type UserBundleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBundleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bundleId?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    paymentMethod?: string | null
    status: $Enums.PaymentStatus
    referenceType: $Enums.PaymentReferenceType
    referenceId?: string | null
    transactionId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: string
    userId: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    paymentMethod?: string | null
    status: $Enums.PaymentStatus
    referenceType: $Enums.PaymentReferenceType
    referenceId?: string | null
    transactionId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    referenceType?: EnumPaymentReferenceTypeFieldUpdateOperationsInput | $Enums.PaymentReferenceType
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    referenceType?: EnumPaymentReferenceTypeFieldUpdateOperationsInput | $Enums.PaymentReferenceType
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManyInput = {
    id?: string
    userId: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    paymentMethod?: string | null
    status: $Enums.PaymentStatus
    referenceType: $Enums.PaymentReferenceType
    referenceId?: string | null
    transactionId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    referenceType?: EnumPaymentReferenceTypeFieldUpdateOperationsInput | $Enums.PaymentReferenceType
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    referenceType?: EnumPaymentReferenceTypeFieldUpdateOperationsInput | $Enums.PaymentReferenceType
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarEventCreateInput = {
    id?: string
    title: string
    description?: string | null
    type: string
    startTime: Date | string
    endTime?: Date | string | null
    location?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutCalendarEventsInput
    course?: CourseCreateNestedOneWithoutCalendarEventsInput
    lesson?: LessonCreateNestedOneWithoutCalendarEventsInput
    teacher?: UserCreateNestedOneWithoutEventsAsTeacherInput
    student?: UserCreateNestedOneWithoutEventsAsStudentInput
  }

  export type CalendarEventUncheckedCreateInput = {
    id?: string
    userId: string
    title: string
    description?: string | null
    type: string
    startTime: Date | string
    endTime?: Date | string | null
    courseId?: string | null
    lessonId?: string | null
    teacherId?: string | null
    studentId?: string | null
    location?: string | null
    createdAt?: Date | string
  }

  export type CalendarEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCalendarEventsNestedInput
    course?: CourseUpdateOneWithoutCalendarEventsNestedInput
    lesson?: LessonUpdateOneWithoutCalendarEventsNestedInput
    teacher?: UserUpdateOneWithoutEventsAsTeacherNestedInput
    student?: UserUpdateOneWithoutEventsAsStudentNestedInput
  }

  export type CalendarEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    lessonId?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarEventCreateManyInput = {
    id?: string
    userId: string
    title: string
    description?: string | null
    type: string
    startTime: Date | string
    endTime?: Date | string | null
    courseId?: string | null
    lessonId?: string | null
    teacherId?: string | null
    studentId?: string | null
    location?: string | null
    createdAt?: Date | string
  }

  export type CalendarEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    lessonId?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogPostCreateInput = {
    id?: string
    title: string
    excerpt?: string | null
    content: string
    image?: string | null
    published?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    readTime?: number | null
    author: UserCreateNestedOneWithoutBlogPostsInput
    categories?: PostCategoryCreateNestedManyWithoutPostInput
    tags?: PostTagCreateNestedManyWithoutPostInput
    comments?: BlogCommentCreateNestedManyWithoutPostInput
  }

  export type BlogPostUncheckedCreateInput = {
    id?: string
    title: string
    excerpt?: string | null
    content: string
    image?: string | null
    authorId: string
    published?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    readTime?: number | null
    categories?: PostCategoryUncheckedCreateNestedManyWithoutPostInput
    tags?: PostTagUncheckedCreateNestedManyWithoutPostInput
    comments?: BlogCommentUncheckedCreateNestedManyWithoutPostInput
  }

  export type BlogPostUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readTime?: NullableIntFieldUpdateOperationsInput | number | null
    author?: UserUpdateOneRequiredWithoutBlogPostsNestedInput
    categories?: PostCategoryUpdateManyWithoutPostNestedInput
    tags?: PostTagUpdateManyWithoutPostNestedInput
    comments?: BlogCommentUpdateManyWithoutPostNestedInput
  }

  export type BlogPostUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readTime?: NullableIntFieldUpdateOperationsInput | number | null
    categories?: PostCategoryUncheckedUpdateManyWithoutPostNestedInput
    tags?: PostTagUncheckedUpdateManyWithoutPostNestedInput
    comments?: BlogCommentUncheckedUpdateManyWithoutPostNestedInput
  }

  export type BlogPostCreateManyInput = {
    id?: string
    title: string
    excerpt?: string | null
    content: string
    image?: string | null
    authorId: string
    published?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    readTime?: number | null
  }

  export type BlogPostUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readTime?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BlogPostUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readTime?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CategoryCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    posts?: PostCategoryCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    posts?: PostCategoryUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    posts?: PostCategoryUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    posts?: PostCategoryUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryCreateManyInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
  }

  export type CategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PostCategoryCreateInput = {
    post: BlogPostCreateNestedOneWithoutCategoriesInput
    category: CategoryCreateNestedOneWithoutPostsInput
  }

  export type PostCategoryUncheckedCreateInput = {
    postId: string
    categoryId: string
  }

  export type PostCategoryUpdateInput = {
    post?: BlogPostUpdateOneRequiredWithoutCategoriesNestedInput
    category?: CategoryUpdateOneRequiredWithoutPostsNestedInput
  }

  export type PostCategoryUncheckedUpdateInput = {
    postId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
  }

  export type PostCategoryCreateManyInput = {
    postId: string
    categoryId: string
  }

  export type PostCategoryUpdateManyMutationInput = {

  }

  export type PostCategoryUncheckedUpdateManyInput = {
    postId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
  }

  export type TagCreateInput = {
    id?: string
    name: string
    slug: string
    posts?: PostTagCreateNestedManyWithoutTagInput
  }

  export type TagUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    posts?: PostTagUncheckedCreateNestedManyWithoutTagInput
  }

  export type TagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    posts?: PostTagUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    posts?: PostTagUncheckedUpdateManyWithoutTagNestedInput
  }

  export type TagCreateManyInput = {
    id?: string
    name: string
    slug: string
  }

  export type TagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type TagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type PostTagCreateInput = {
    post: BlogPostCreateNestedOneWithoutTagsInput
    tag: TagCreateNestedOneWithoutPostsInput
  }

  export type PostTagUncheckedCreateInput = {
    postId: string
    tagId: string
  }

  export type PostTagUpdateInput = {
    post?: BlogPostUpdateOneRequiredWithoutTagsNestedInput
    tag?: TagUpdateOneRequiredWithoutPostsNestedInput
  }

  export type PostTagUncheckedUpdateInput = {
    postId?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type PostTagCreateManyInput = {
    postId: string
    tagId: string
  }

  export type PostTagUpdateManyMutationInput = {

  }

  export type PostTagUncheckedUpdateManyInput = {
    postId?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type BlogCommentCreateInput = {
    id?: string
    content: string
    createdAt?: Date | string
    post: BlogPostCreateNestedOneWithoutCommentsInput
    user: UserCreateNestedOneWithoutBlogCommentsInput
    parent?: BlogCommentCreateNestedOneWithoutRepliesInput
    replies?: BlogCommentCreateNestedManyWithoutParentInput
  }

  export type BlogCommentUncheckedCreateInput = {
    id?: string
    postId: string
    userId: string
    content: string
    createdAt?: Date | string
    parentId?: string | null
    replies?: BlogCommentUncheckedCreateNestedManyWithoutParentInput
  }

  export type BlogCommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: BlogPostUpdateOneRequiredWithoutCommentsNestedInput
    user?: UserUpdateOneRequiredWithoutBlogCommentsNestedInput
    parent?: BlogCommentUpdateOneWithoutRepliesNestedInput
    replies?: BlogCommentUpdateManyWithoutParentNestedInput
  }

  export type BlogCommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    replies?: BlogCommentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type BlogCommentCreateManyInput = {
    id?: string
    postId: string
    userId: string
    content: string
    createdAt?: Date | string
    parentId?: string | null
  }

  export type BlogCommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogCommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReferralCodeCreateInput = {
    id?: string
    code: string
    isActive?: boolean
    usageLimit?: number | null
    maxUses?: number | null
    pointsReward?: number
    isUserCode?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutReferralCodesOwnedInput
    uses?: ReferralUseCreateNestedManyWithoutReferralCodeInput
  }

  export type ReferralCodeUncheckedCreateInput = {
    id?: string
    code: string
    userId: string
    isActive?: boolean
    usageLimit?: number | null
    maxUses?: number | null
    pointsReward?: number
    isUserCode?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    uses?: ReferralUseUncheckedCreateNestedManyWithoutReferralCodeInput
  }

  export type ReferralCodeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    pointsReward?: IntFieldUpdateOperationsInput | number
    isUserCode?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutReferralCodesOwnedNestedInput
    uses?: ReferralUseUpdateManyWithoutReferralCodeNestedInput
  }

  export type ReferralCodeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    pointsReward?: IntFieldUpdateOperationsInput | number
    isUserCode?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uses?: ReferralUseUncheckedUpdateManyWithoutReferralCodeNestedInput
  }

  export type ReferralCodeCreateManyInput = {
    id?: string
    code: string
    userId: string
    isActive?: boolean
    usageLimit?: number | null
    maxUses?: number | null
    pointsReward?: number
    isUserCode?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReferralCodeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    pointsReward?: IntFieldUpdateOperationsInput | number
    isUserCode?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralCodeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    pointsReward?: IntFieldUpdateOperationsInput | number
    isUserCode?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralUseCreateInput = {
    id?: string
    pointsAwarded?: number
    createdAt?: Date | string
    referralCode: ReferralCodeCreateNestedOneWithoutUsesInput
    user: UserCreateNestedOneWithoutReferralUsesGainedInput
  }

  export type ReferralUseUncheckedCreateInput = {
    id?: string
    referralCodeId: string
    userId: string
    pointsAwarded?: number
    createdAt?: Date | string
  }

  export type ReferralUseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    pointsAwarded?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: ReferralCodeUpdateOneRequiredWithoutUsesNestedInput
    user?: UserUpdateOneRequiredWithoutReferralUsesGainedNestedInput
  }

  export type ReferralUseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    referralCodeId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    pointsAwarded?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralUseCreateManyInput = {
    id?: string
    referralCodeId: string
    userId: string
    pointsAwarded?: number
    createdAt?: Date | string
  }

  export type ReferralUseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    pointsAwarded?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralUseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    referralCodeId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    pointsAwarded?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type TeacherProfileNullableRelationFilter = {
    is?: TeacherProfileWhereInput | null
    isNot?: TeacherProfileWhereInput | null
  }

  export type UserAvailabilityListRelationFilter = {
    every?: UserAvailabilityWhereInput
    some?: UserAvailabilityWhereInput
    none?: UserAvailabilityWhereInput
  }

  export type PointsTransactionListRelationFilter = {
    every?: PointsTransactionWhereInput
    some?: PointsTransactionWhereInput
    none?: PointsTransactionWhereInput
  }

  export type CourseListRelationFilter = {
    every?: CourseWhereInput
    some?: CourseWhereInput
    none?: CourseWhereInput
  }

  export type EnrollmentListRelationFilter = {
    every?: EnrollmentWhereInput
    some?: EnrollmentWhereInput
    none?: EnrollmentWhereInput
  }

  export type SavedCourseListRelationFilter = {
    every?: SavedCourseWhereInput
    some?: SavedCourseWhereInput
    none?: SavedCourseWhereInput
  }

  export type LikedCourseListRelationFilter = {
    every?: LikedCourseWhereInput
    some?: LikedCourseWhereInput
    none?: LikedCourseWhereInput
  }

  export type LessonProgressListRelationFilter = {
    every?: LessonProgressWhereInput
    some?: LessonProgressWhereInput
    none?: LessonProgressWhereInput
  }

  export type QuizAttemptListRelationFilter = {
    every?: QuizAttemptWhereInput
    some?: QuizAttemptWhereInput
    none?: QuizAttemptWhereInput
  }

  export type AssignmentSubmissionListRelationFilter = {
    every?: AssignmentSubmissionWhereInput
    some?: AssignmentSubmissionWhereInput
    none?: AssignmentSubmissionWhereInput
  }

  export type CourseReviewListRelationFilter = {
    every?: CourseReviewWhereInput
    some?: CourseReviewWhereInput
    none?: CourseReviewWhereInput
  }

  export type TutoringSessionListRelationFilter = {
    every?: TutoringSessionWhereInput
    some?: TutoringSessionWhereInput
    none?: TutoringSessionWhereInput
  }

  export type TutoringRequestListRelationFilter = {
    every?: TutoringRequestWhereInput
    some?: TutoringRequestWhereInput
    none?: TutoringRequestWhereInput
  }

  export type TutoringAppointmentListRelationFilter = {
    every?: TutoringAppointmentWhereInput
    some?: TutoringAppointmentWhereInput
    none?: TutoringAppointmentWhereInput
  }

  export type TutoringReviewListRelationFilter = {
    every?: TutoringReviewWhereInput
    some?: TutoringReviewWhereInput
    none?: TutoringReviewWhereInput
  }

  export type TutoringMessageListRelationFilter = {
    every?: TutoringMessageWhereInput
    some?: TutoringMessageWhereInput
    none?: TutoringMessageWhereInput
  }

  export type UserAchievementListRelationFilter = {
    every?: UserAchievementWhereInput
    some?: UserAchievementWhereInput
    none?: UserAchievementWhereInput
  }

  export type CertificateListRelationFilter = {
    every?: CertificateWhereInput
    some?: CertificateWhereInput
    none?: CertificateWhereInput
  }

  export type ConversationParticipantListRelationFilter = {
    every?: ConversationParticipantWhereInput
    some?: ConversationParticipantWhereInput
    none?: ConversationParticipantWhereInput
  }

  export type MessageListRelationFilter = {
    every?: MessageWhereInput
    some?: MessageWhereInput
    none?: MessageWhereInput
  }

  export type AttachmentListRelationFilter = {
    every?: AttachmentWhereInput
    some?: AttachmentWhereInput
    none?: AttachmentWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type UserSubscriptionListRelationFilter = {
    every?: UserSubscriptionWhereInput
    some?: UserSubscriptionWhereInput
    none?: UserSubscriptionWhereInput
  }

  export type UserBundleListRelationFilter = {
    every?: UserBundleWhereInput
    some?: UserBundleWhereInput
    none?: UserBundleWhereInput
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type CalendarEventListRelationFilter = {
    every?: CalendarEventWhereInput
    some?: CalendarEventWhereInput
    none?: CalendarEventWhereInput
  }

  export type BlogPostListRelationFilter = {
    every?: BlogPostWhereInput
    some?: BlogPostWhereInput
    none?: BlogPostWhereInput
  }

  export type BlogCommentListRelationFilter = {
    every?: BlogCommentWhereInput
    some?: BlogCommentWhereInput
    none?: BlogCommentWhereInput
  }

  export type ReferralCodeListRelationFilter = {
    every?: ReferralCodeWhereInput
    some?: ReferralCodeWhereInput
    none?: ReferralCodeWhereInput
  }

  export type ReferralUseListRelationFilter = {
    every?: ReferralUseWhereInput
    some?: ReferralUseWhereInput
    none?: ReferralUseWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserAvailabilityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PointsTransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EnrollmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SavedCourseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LikedCourseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LessonProgressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuizAttemptOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AssignmentSubmissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourseReviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TutoringSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TutoringRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TutoringAppointmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TutoringReviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TutoringMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserAchievementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CertificateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConversationParticipantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AttachmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserSubscriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserBundleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CalendarEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BlogPostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BlogCommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReferralCodeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReferralUseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    avatar?: SortOrder
    bio?: SortOrder
    createdAt?: SortOrder
    points?: SortOrder
    referralCode?: SortOrder
    referredById?: SortOrder
    lastLogin?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    points?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    avatar?: SortOrder
    bio?: SortOrder
    createdAt?: SortOrder
    points?: SortOrder
    referralCode?: SortOrder
    referredById?: SortOrder
    lastLogin?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    avatar?: SortOrder
    bio?: SortOrder
    createdAt?: SortOrder
    points?: SortOrder
    referralCode?: SortOrder
    referredById?: SortOrder
    lastLogin?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    points?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type TeacherProfileCountOrderByAggregateInput = {
    userId?: SortOrder
    specialization?: SortOrder
    rating?: SortOrder
    students?: SortOrder
    education?: SortOrder
    experience?: SortOrder
    certificates?: SortOrder
  }

  export type TeacherProfileAvgOrderByAggregateInput = {
    rating?: SortOrder
    students?: SortOrder
  }

  export type TeacherProfileMaxOrderByAggregateInput = {
    userId?: SortOrder
    rating?: SortOrder
    students?: SortOrder
    education?: SortOrder
    experience?: SortOrder
  }

  export type TeacherProfileMinOrderByAggregateInput = {
    userId?: SortOrder
    rating?: SortOrder
    students?: SortOrder
    education?: SortOrder
    experience?: SortOrder
  }

  export type TeacherProfileSumOrderByAggregateInput = {
    rating?: SortOrder
    students?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type UserAvailabilityUserIdDayOfWeekStartTimeCompoundUniqueInput = {
    userId: string
    dayOfWeek: number
    startTime: Date | string
  }

  export type UserAvailabilityCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
  }

  export type UserAvailabilityAvgOrderByAggregateInput = {
    dayOfWeek?: SortOrder
  }

  export type UserAvailabilityMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
  }

  export type UserAvailabilityMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
  }

  export type UserAvailabilitySumOrderByAggregateInput = {
    dayOfWeek?: SortOrder
  }

  export type EnumPointsTxnTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PointsTxnType | EnumPointsTxnTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PointsTxnType[] | ListEnumPointsTxnTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PointsTxnType[] | ListEnumPointsTxnTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPointsTxnTypeFilter<$PrismaModel> | $Enums.PointsTxnType
  }

  export type PointsTransactionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type PointsTransactionAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PointsTransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type PointsTransactionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type PointsTransactionSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumPointsTxnTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PointsTxnType | EnumPointsTxnTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PointsTxnType[] | ListEnumPointsTxnTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PointsTxnType[] | ListEnumPointsTxnTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPointsTxnTypeWithAggregatesFilter<$PrismaModel> | $Enums.PointsTxnType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPointsTxnTypeFilter<$PrismaModel>
    _max?: NestedEnumPointsTxnTypeFilter<$PrismaModel>
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type PointsPackageCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    points?: SortOrder
    price?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PointsPackageAvgOrderByAggregateInput = {
    points?: SortOrder
    price?: SortOrder
  }

  export type PointsPackageMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    points?: SortOrder
    price?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PointsPackageMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    points?: SortOrder
    price?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PointsPackageSumOrderByAggregateInput = {
    points?: SortOrder
    price?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumCourseStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CourseStatus | EnumCourseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CourseStatus[] | ListEnumCourseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CourseStatus[] | ListEnumCourseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCourseStatusFilter<$PrismaModel> | $Enums.CourseStatus
  }

  export type TopicListRelationFilter = {
    every?: TopicWhereInput
    some?: TopicWhereInput
    none?: TopicWhereInput
  }

  export type LessonListRelationFilter = {
    every?: LessonWhereInput
    some?: LessonWhereInput
    none?: LessonWhereInput
  }

  export type BundleCourseListRelationFilter = {
    every?: BundleCourseWhereInput
    some?: BundleCourseWhereInput
    none?: BundleCourseWhereInput
  }

  export type TopicOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LessonOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BundleCourseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourseCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    subject?: SortOrder
    image?: SortOrder
    price?: SortOrder
    pointsPrice?: SortOrder
    teacherId?: SortOrder
    students?: SortOrder
    rating?: SortOrder
    status?: SortOrder
    featured?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CourseAvgOrderByAggregateInput = {
    price?: SortOrder
    pointsPrice?: SortOrder
    students?: SortOrder
    rating?: SortOrder
  }

  export type CourseMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    subject?: SortOrder
    image?: SortOrder
    price?: SortOrder
    pointsPrice?: SortOrder
    teacherId?: SortOrder
    students?: SortOrder
    rating?: SortOrder
    status?: SortOrder
    featured?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CourseMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    subject?: SortOrder
    image?: SortOrder
    price?: SortOrder
    pointsPrice?: SortOrder
    teacherId?: SortOrder
    students?: SortOrder
    rating?: SortOrder
    status?: SortOrder
    featured?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CourseSumOrderByAggregateInput = {
    price?: SortOrder
    pointsPrice?: SortOrder
    students?: SortOrder
    rating?: SortOrder
  }

  export type EnumCourseStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CourseStatus | EnumCourseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CourseStatus[] | ListEnumCourseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CourseStatus[] | ListEnumCourseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCourseStatusWithAggregatesFilter<$PrismaModel> | $Enums.CourseStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCourseStatusFilter<$PrismaModel>
    _max?: NestedEnumCourseStatusFilter<$PrismaModel>
  }

  export type CourseRelationFilter = {
    is?: CourseWhereInput
    isNot?: CourseWhereInput
  }

  export type TopicCourseIdOrderIndexCompoundUniqueInput = {
    courseId: string
    orderIndex: number
  }

  export type TopicCountOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    orderIndex?: SortOrder
  }

  export type TopicAvgOrderByAggregateInput = {
    orderIndex?: SortOrder
  }

  export type TopicMaxOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    orderIndex?: SortOrder
  }

  export type TopicMinOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    orderIndex?: SortOrder
  }

  export type TopicSumOrderByAggregateInput = {
    orderIndex?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type EnumLessonTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LessonType | EnumLessonTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LessonType[] | ListEnumLessonTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LessonType[] | ListEnumLessonTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLessonTypeFilter<$PrismaModel> | $Enums.LessonType
  }

  export type TopicRelationFilter = {
    is?: TopicWhereInput
    isNot?: TopicWhereInput
  }

  export type QuizNullableRelationFilter = {
    is?: QuizWhereInput | null
    isNot?: QuizWhereInput | null
  }

  export type AssignmentNullableRelationFilter = {
    is?: AssignmentWhereInput | null
    isNot?: AssignmentWhereInput | null
  }

  export type CourseNullableRelationFilter = {
    is?: CourseWhereInput | null
    isNot?: CourseWhereInput | null
  }

  export type LessonTopicIdOrderIndexCompoundUniqueInput = {
    topicId: string
    orderIndex: number
  }

  export type LessonCountOrderByAggregateInput = {
    id?: SortOrder
    topicId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    videoUrl?: SortOrder
    content?: SortOrder
    duration?: SortOrder
    orderIndex?: SortOrder
    type?: SortOrder
    courseId?: SortOrder
  }

  export type LessonAvgOrderByAggregateInput = {
    duration?: SortOrder
    orderIndex?: SortOrder
  }

  export type LessonMaxOrderByAggregateInput = {
    id?: SortOrder
    topicId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    videoUrl?: SortOrder
    content?: SortOrder
    duration?: SortOrder
    orderIndex?: SortOrder
    type?: SortOrder
    courseId?: SortOrder
  }

  export type LessonMinOrderByAggregateInput = {
    id?: SortOrder
    topicId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    videoUrl?: SortOrder
    content?: SortOrder
    duration?: SortOrder
    orderIndex?: SortOrder
    type?: SortOrder
    courseId?: SortOrder
  }

  export type LessonSumOrderByAggregateInput = {
    duration?: SortOrder
    orderIndex?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumLessonTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LessonType | EnumLessonTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LessonType[] | ListEnumLessonTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LessonType[] | ListEnumLessonTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLessonTypeWithAggregatesFilter<$PrismaModel> | $Enums.LessonType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLessonTypeFilter<$PrismaModel>
    _max?: NestedEnumLessonTypeFilter<$PrismaModel>
  }

  export type LessonRelationFilter = {
    is?: LessonWhereInput
    isNot?: LessonWhereInput
  }

  export type QuestionListRelationFilter = {
    every?: QuestionWhereInput
    some?: QuestionWhereInput
    none?: QuestionWhereInput
  }

  export type QuestionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuizCountOrderByAggregateInput = {
    id?: SortOrder
    lessonId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    timeLimit?: SortOrder
  }

  export type QuizAvgOrderByAggregateInput = {
    timeLimit?: SortOrder
  }

  export type QuizMaxOrderByAggregateInput = {
    id?: SortOrder
    lessonId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    timeLimit?: SortOrder
  }

  export type QuizMinOrderByAggregateInput = {
    id?: SortOrder
    lessonId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    timeLimit?: SortOrder
  }

  export type QuizSumOrderByAggregateInput = {
    timeLimit?: SortOrder
  }

  export type EnumQuestionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestionType | EnumQuestionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumQuestionTypeFilter<$PrismaModel> | $Enums.QuestionType
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type IntNullableListFilter<$PrismaModel = never> = {
    equals?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    has?: number | IntFieldRefInput<$PrismaModel> | null
    hasEvery?: number[] | ListIntFieldRefInput<$PrismaModel>
    hasSome?: number[] | ListIntFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type QuizRelationFilter = {
    is?: QuizWhereInput
    isNot?: QuizWhereInput
  }

  export type QuestionCountOrderByAggregateInput = {
    id?: SortOrder
    quizId?: SortOrder
    questionText?: SortOrder
    type?: SortOrder
    options?: SortOrder
    correctOptions?: SortOrder
    orderIndex?: SortOrder
  }

  export type QuestionAvgOrderByAggregateInput = {
    correctOptions?: SortOrder
    orderIndex?: SortOrder
  }

  export type QuestionMaxOrderByAggregateInput = {
    id?: SortOrder
    quizId?: SortOrder
    questionText?: SortOrder
    type?: SortOrder
    orderIndex?: SortOrder
  }

  export type QuestionMinOrderByAggregateInput = {
    id?: SortOrder
    quizId?: SortOrder
    questionText?: SortOrder
    type?: SortOrder
    orderIndex?: SortOrder
  }

  export type QuestionSumOrderByAggregateInput = {
    correctOptions?: SortOrder
    orderIndex?: SortOrder
  }

  export type EnumQuestionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestionType | EnumQuestionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumQuestionTypeWithAggregatesFilter<$PrismaModel> | $Enums.QuestionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQuestionTypeFilter<$PrismaModel>
    _max?: NestedEnumQuestionTypeFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type AssignmentCountOrderByAggregateInput = {
    id?: SortOrder
    lessonId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    dueDate?: SortOrder
    maxScore?: SortOrder
    allowFileUpload?: SortOrder
    allowedFileTypes?: SortOrder
    unitTests?: SortOrder
  }

  export type AssignmentAvgOrderByAggregateInput = {
    maxScore?: SortOrder
  }

  export type AssignmentMaxOrderByAggregateInput = {
    id?: SortOrder
    lessonId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    dueDate?: SortOrder
    maxScore?: SortOrder
    allowFileUpload?: SortOrder
  }

  export type AssignmentMinOrderByAggregateInput = {
    id?: SortOrder
    lessonId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    dueDate?: SortOrder
    maxScore?: SortOrder
    allowFileUpload?: SortOrder
  }

  export type AssignmentSumOrderByAggregateInput = {
    maxScore?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnrollmentUserIdCourseIdCompoundUniqueInput = {
    userId: string
    courseId: string
  }

  export type EnrollmentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    enrolledAt?: SortOrder
    completed?: SortOrder
    completedAt?: SortOrder
    status?: SortOrder
  }

  export type EnrollmentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    enrolledAt?: SortOrder
    completed?: SortOrder
    completedAt?: SortOrder
    status?: SortOrder
  }

  export type EnrollmentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    enrolledAt?: SortOrder
    completed?: SortOrder
    completedAt?: SortOrder
    status?: SortOrder
  }

  export type SavedCourseUserIdCourseIdCompoundUniqueInput = {
    userId: string
    courseId: string
  }

  export type SavedCourseCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    savedAt?: SortOrder
  }

  export type SavedCourseMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    savedAt?: SortOrder
  }

  export type SavedCourseMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    savedAt?: SortOrder
  }

  export type LikedCourseUserIdCourseIdCompoundUniqueInput = {
    userId: string
    courseId: string
  }

  export type LikedCourseCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    likedAt?: SortOrder
  }

  export type LikedCourseMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    likedAt?: SortOrder
  }

  export type LikedCourseMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    likedAt?: SortOrder
  }

  export type LessonProgressUserIdLessonIdCompoundUniqueInput = {
    userId: string
    lessonId: string
  }

  export type LessonProgressCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    lessonId?: SortOrder
    completed?: SortOrder
    completedAt?: SortOrder
    lastPosition?: SortOrder
  }

  export type LessonProgressAvgOrderByAggregateInput = {
    lastPosition?: SortOrder
  }

  export type LessonProgressMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    lessonId?: SortOrder
    completed?: SortOrder
    completedAt?: SortOrder
    lastPosition?: SortOrder
  }

  export type LessonProgressMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    lessonId?: SortOrder
    completed?: SortOrder
    completedAt?: SortOrder
    lastPosition?: SortOrder
  }

  export type LessonProgressSumOrderByAggregateInput = {
    lastPosition?: SortOrder
  }

  export type QuizAttemptCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    quizId?: SortOrder
    score?: SortOrder
    duration?: SortOrder
    completedAt?: SortOrder
    answers?: SortOrder
    courseId?: SortOrder
  }

  export type QuizAttemptAvgOrderByAggregateInput = {
    score?: SortOrder
    duration?: SortOrder
  }

  export type QuizAttemptMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    quizId?: SortOrder
    score?: SortOrder
    duration?: SortOrder
    completedAt?: SortOrder
    courseId?: SortOrder
  }

  export type QuizAttemptMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    quizId?: SortOrder
    score?: SortOrder
    duration?: SortOrder
    completedAt?: SortOrder
    courseId?: SortOrder
  }

  export type QuizAttemptSumOrderByAggregateInput = {
    score?: SortOrder
    duration?: SortOrder
  }

  export type AssignmentRelationFilter = {
    is?: AssignmentWhereInput
    isNot?: AssignmentWhereInput
  }

  export type AssignmentSubmissionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    assignmentId?: SortOrder
    content?: SortOrder
    fileUrls?: SortOrder
    submittedAt?: SortOrder
    score?: SortOrder
    feedback?: SortOrder
    gradedAt?: SortOrder
    gradedById?: SortOrder
  }

  export type AssignmentSubmissionAvgOrderByAggregateInput = {
    score?: SortOrder
  }

  export type AssignmentSubmissionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    assignmentId?: SortOrder
    content?: SortOrder
    submittedAt?: SortOrder
    score?: SortOrder
    feedback?: SortOrder
    gradedAt?: SortOrder
    gradedById?: SortOrder
  }

  export type AssignmentSubmissionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    assignmentId?: SortOrder
    content?: SortOrder
    submittedAt?: SortOrder
    score?: SortOrder
    feedback?: SortOrder
    gradedAt?: SortOrder
    gradedById?: SortOrder
  }

  export type AssignmentSubmissionSumOrderByAggregateInput = {
    score?: SortOrder
  }

  export type CourseReviewUserIdCourseIdCompoundUniqueInput = {
    userId: string
    courseId: string
  }

  export type CourseReviewCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
  }

  export type CourseReviewAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type CourseReviewMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
  }

  export type CourseReviewMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
  }

  export type CourseReviewSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type EnumTutoringLocationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TutoringLocationType | EnumTutoringLocationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TutoringLocationType[] | ListEnumTutoringLocationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TutoringLocationType[] | ListEnumTutoringLocationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTutoringLocationTypeFilter<$PrismaModel> | $Enums.TutoringLocationType
  }

  export type EnumTutoringStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TutoringStatus | EnumTutoringStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TutoringStatus[] | ListEnumTutoringStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TutoringStatus[] | ListEnumTutoringStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTutoringStatusFilter<$PrismaModel> | $Enums.TutoringStatus
  }

  export type TutoringAvailabilityListRelationFilter = {
    every?: TutoringAvailabilityWhereInput
    some?: TutoringAvailabilityWhereInput
    none?: TutoringAvailabilityWhereInput
  }

  export type TutoringAvailabilityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TutoringSessionCountOrderByAggregateInput = {
    id?: SortOrder
    teacherId?: SortOrder
    subject?: SortOrder
    description?: SortOrder
    pricePerHour?: SortOrder
    locationType?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    maxStudents?: SortOrder
    prerequisites?: SortOrder
    level?: SortOrder
    tags?: SortOrder
    featured?: SortOrder
  }

  export type TutoringSessionAvgOrderByAggregateInput = {
    pricePerHour?: SortOrder
    maxStudents?: SortOrder
  }

  export type TutoringSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    teacherId?: SortOrder
    subject?: SortOrder
    description?: SortOrder
    pricePerHour?: SortOrder
    locationType?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    maxStudents?: SortOrder
    level?: SortOrder
    featured?: SortOrder
  }

  export type TutoringSessionMinOrderByAggregateInput = {
    id?: SortOrder
    teacherId?: SortOrder
    subject?: SortOrder
    description?: SortOrder
    pricePerHour?: SortOrder
    locationType?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    maxStudents?: SortOrder
    level?: SortOrder
    featured?: SortOrder
  }

  export type TutoringSessionSumOrderByAggregateInput = {
    pricePerHour?: SortOrder
    maxStudents?: SortOrder
  }

  export type EnumTutoringLocationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TutoringLocationType | EnumTutoringLocationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TutoringLocationType[] | ListEnumTutoringLocationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TutoringLocationType[] | ListEnumTutoringLocationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTutoringLocationTypeWithAggregatesFilter<$PrismaModel> | $Enums.TutoringLocationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTutoringLocationTypeFilter<$PrismaModel>
    _max?: NestedEnumTutoringLocationTypeFilter<$PrismaModel>
  }

  export type EnumTutoringStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TutoringStatus | EnumTutoringStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TutoringStatus[] | ListEnumTutoringStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TutoringStatus[] | ListEnumTutoringStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTutoringStatusWithAggregatesFilter<$PrismaModel> | $Enums.TutoringStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTutoringStatusFilter<$PrismaModel>
    _max?: NestedEnumTutoringStatusFilter<$PrismaModel>
  }

  export type TutoringSessionRelationFilter = {
    is?: TutoringSessionWhereInput
    isNot?: TutoringSessionWhereInput
  }

  export type TutoringAvailabilityCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
  }

  export type TutoringAvailabilityAvgOrderByAggregateInput = {
    dayOfWeek?: SortOrder
  }

  export type TutoringAvailabilityMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
  }

  export type TutoringAvailabilityMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
  }

  export type TutoringAvailabilitySumOrderByAggregateInput = {
    dayOfWeek?: SortOrder
  }

  export type DateTimeNullableListFilter<$PrismaModel = never> = {
    equals?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    has?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    hasEvery?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    hasSome?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type EnumTutoringRequestStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TutoringRequestStatus | EnumTutoringRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TutoringRequestStatus[] | ListEnumTutoringRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TutoringRequestStatus[] | ListEnumTutoringRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTutoringRequestStatusFilter<$PrismaModel> | $Enums.TutoringRequestStatus
  }

  export type TutoringAppointmentNullableRelationFilter = {
    is?: TutoringAppointmentWhereInput | null
    isNot?: TutoringAppointmentWhereInput | null
  }

  export type TutoringRequestCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    studentId?: SortOrder
    message?: SortOrder
    preferredDates?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TutoringRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    studentId?: SortOrder
    message?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TutoringRequestMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    studentId?: SortOrder
    message?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumTutoringRequestStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TutoringRequestStatus | EnumTutoringRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TutoringRequestStatus[] | ListEnumTutoringRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TutoringRequestStatus[] | ListEnumTutoringRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTutoringRequestStatusWithAggregatesFilter<$PrismaModel> | $Enums.TutoringRequestStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTutoringRequestStatusFilter<$PrismaModel>
    _max?: NestedEnumTutoringRequestStatusFilter<$PrismaModel>
  }

  export type EnumAppointmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AppointmentStatus | EnumAppointmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAppointmentStatusFilter<$PrismaModel> | $Enums.AppointmentStatus
  }

  export type TutoringRequestRelationFilter = {
    is?: TutoringRequestWhereInput
    isNot?: TutoringRequestWhereInput
  }

  export type TutoringAppointmentCountOrderByAggregateInput = {
    id?: SortOrder
    requestId?: SortOrder
    sessionId?: SortOrder
    scheduledAt?: SortOrder
    duration?: SortOrder
    notes?: SortOrder
    meetingLink?: SortOrder
    status?: SortOrder
    price?: SortOrder
    teacherId?: SortOrder
    studentId?: SortOrder
  }

  export type TutoringAppointmentAvgOrderByAggregateInput = {
    duration?: SortOrder
    price?: SortOrder
  }

  export type TutoringAppointmentMaxOrderByAggregateInput = {
    id?: SortOrder
    requestId?: SortOrder
    sessionId?: SortOrder
    scheduledAt?: SortOrder
    duration?: SortOrder
    notes?: SortOrder
    meetingLink?: SortOrder
    status?: SortOrder
    price?: SortOrder
    teacherId?: SortOrder
    studentId?: SortOrder
  }

  export type TutoringAppointmentMinOrderByAggregateInput = {
    id?: SortOrder
    requestId?: SortOrder
    sessionId?: SortOrder
    scheduledAt?: SortOrder
    duration?: SortOrder
    notes?: SortOrder
    meetingLink?: SortOrder
    status?: SortOrder
    price?: SortOrder
    teacherId?: SortOrder
    studentId?: SortOrder
  }

  export type TutoringAppointmentSumOrderByAggregateInput = {
    duration?: SortOrder
    price?: SortOrder
  }

  export type EnumAppointmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AppointmentStatus | EnumAppointmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAppointmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.AppointmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAppointmentStatusFilter<$PrismaModel>
    _max?: NestedEnumAppointmentStatusFilter<$PrismaModel>
  }

  export type TutoringReviewStudentIdSessionIdCompoundUniqueInput = {
    studentId: string
    sessionId: string
  }

  export type TutoringReviewCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    studentId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
  }

  export type TutoringReviewAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type TutoringReviewMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    studentId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
  }

  export type TutoringReviewMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    studentId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
  }

  export type TutoringReviewSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type TutoringMessageCountOrderByAggregateInput = {
    id?: SortOrder
    requestId?: SortOrder
    senderId?: SortOrder
    message?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type TutoringMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    requestId?: SortOrder
    senderId?: SortOrder
    message?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type TutoringMessageMinOrderByAggregateInput = {
    id?: SortOrder
    requestId?: SortOrder
    senderId?: SortOrder
    message?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumAchievementCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.AchievementCategory | EnumAchievementCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.AchievementCategory[] | ListEnumAchievementCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.AchievementCategory[] | ListEnumAchievementCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumAchievementCategoryFilter<$PrismaModel> | $Enums.AchievementCategory
  }

  export type AchievementCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    pointsRewarded?: SortOrder
    icon?: SortOrder
    category?: SortOrder
  }

  export type AchievementAvgOrderByAggregateInput = {
    pointsRewarded?: SortOrder
  }

  export type AchievementMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    pointsRewarded?: SortOrder
    icon?: SortOrder
    category?: SortOrder
  }

  export type AchievementMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    pointsRewarded?: SortOrder
    icon?: SortOrder
    category?: SortOrder
  }

  export type AchievementSumOrderByAggregateInput = {
    pointsRewarded?: SortOrder
  }

  export type EnumAchievementCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AchievementCategory | EnumAchievementCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.AchievementCategory[] | ListEnumAchievementCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.AchievementCategory[] | ListEnumAchievementCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumAchievementCategoryWithAggregatesFilter<$PrismaModel> | $Enums.AchievementCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAchievementCategoryFilter<$PrismaModel>
    _max?: NestedEnumAchievementCategoryFilter<$PrismaModel>
  }

  export type AchievementRelationFilter = {
    is?: AchievementWhereInput
    isNot?: AchievementWhereInput
  }

  export type UserAchievementUserIdAchievementIdCompoundUniqueInput = {
    userId: string
    achievementId: string
  }

  export type UserAchievementCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    achievementId?: SortOrder
    completed?: SortOrder
    completedAt?: SortOrder
    progress?: SortOrder
  }

  export type UserAchievementAvgOrderByAggregateInput = {
    progress?: SortOrder
  }

  export type UserAchievementMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    achievementId?: SortOrder
    completed?: SortOrder
    completedAt?: SortOrder
    progress?: SortOrder
  }

  export type UserAchievementMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    achievementId?: SortOrder
    completed?: SortOrder
    completedAt?: SortOrder
    progress?: SortOrder
  }

  export type UserAchievementSumOrderByAggregateInput = {
    progress?: SortOrder
  }

  export type EnumBadgeTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.BadgeType | EnumBadgeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BadgeType[] | ListEnumBadgeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BadgeType[] | ListEnumBadgeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBadgeTypeFilter<$PrismaModel> | $Enums.BadgeType
  }

  export type BadgeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    type?: SortOrder
    category?: SortOrder
  }

  export type BadgeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    type?: SortOrder
    category?: SortOrder
  }

  export type BadgeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    type?: SortOrder
    category?: SortOrder
  }

  export type EnumBadgeTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BadgeType | EnumBadgeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BadgeType[] | ListEnumBadgeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BadgeType[] | ListEnumBadgeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBadgeTypeWithAggregatesFilter<$PrismaModel> | $Enums.BadgeType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBadgeTypeFilter<$PrismaModel>
    _max?: NestedEnumBadgeTypeFilter<$PrismaModel>
  }

  export type TutoringSessionNullableRelationFilter = {
    is?: TutoringSessionWhereInput | null
    isNot?: TutoringSessionWhereInput | null
  }

  export type BadgeNullableRelationFilter = {
    is?: BadgeWhereInput | null
    isNot?: BadgeWhereInput | null
  }

  export type CertificateCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    issueDate?: SortOrder
    type?: SortOrder
    courseId?: SortOrder
    courseName?: SortOrder
    tutoringId?: SortOrder
    tutoringSubject?: SortOrder
    teacherId?: SortOrder
    teacherName?: SortOrder
    customMessage?: SortOrder
    imageUrl?: SortOrder
    badgeId?: SortOrder
  }

  export type CertificateMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    issueDate?: SortOrder
    type?: SortOrder
    courseId?: SortOrder
    courseName?: SortOrder
    tutoringId?: SortOrder
    tutoringSubject?: SortOrder
    teacherId?: SortOrder
    teacherName?: SortOrder
    customMessage?: SortOrder
    imageUrl?: SortOrder
    badgeId?: SortOrder
  }

  export type CertificateMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    issueDate?: SortOrder
    type?: SortOrder
    courseId?: SortOrder
    courseName?: SortOrder
    tutoringId?: SortOrder
    tutoringSubject?: SortOrder
    teacherId?: SortOrder
    teacherName?: SortOrder
    customMessage?: SortOrder
    imageUrl?: SortOrder
    badgeId?: SortOrder
  }

  export type ConversationCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConversationMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConversationMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConversationRelationFilter = {
    is?: ConversationWhereInput
    isNot?: ConversationWhereInput
  }

  export type ConversationParticipantConversationIdUserIdCompoundUniqueInput = {
    conversationId: string
    userId: string
  }

  export type ConversationParticipantCountOrderByAggregateInput = {
    conversationId?: SortOrder
    userId?: SortOrder
  }

  export type ConversationParticipantMaxOrderByAggregateInput = {
    conversationId?: SortOrder
    userId?: SortOrder
  }

  export type ConversationParticipantMinOrderByAggregateInput = {
    conversationId?: SortOrder
    userId?: SortOrder
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    timestamp?: SortOrder
    read?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    timestamp?: SortOrder
    read?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    timestamp?: SortOrder
    read?: SortOrder
  }

  export type MessageRelationFilter = {
    is?: MessageWhereInput
    isNot?: MessageWhereInput
  }

  export type AttachmentCountOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    fileName?: SortOrder
    fileUrl?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
  }

  export type AttachmentAvgOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type AttachmentMaxOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    fileName?: SortOrder
    fileUrl?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
  }

  export type AttachmentMinOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    fileName?: SortOrder
    fileUrl?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
  }

  export type AttachmentSumOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type EnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    read?: SortOrder
    type?: SortOrder
    link?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    read?: SortOrder
    type?: SortOrder
    link?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    read?: SortOrder
    type?: SortOrder
    link?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type EnumSubscriptionPeriodFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionPeriod | EnumSubscriptionPeriodFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionPeriod[] | ListEnumSubscriptionPeriodFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionPeriod[] | ListEnumSubscriptionPeriodFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionPeriodFilter<$PrismaModel> | $Enums.SubscriptionPeriod
  }

  export type SubscriptionPlanCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    period?: SortOrder
    featuredBenefit?: SortOrder
    benefits?: SortOrder
    isPopular?: SortOrder
  }

  export type SubscriptionPlanAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type SubscriptionPlanMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    period?: SortOrder
    featuredBenefit?: SortOrder
    isPopular?: SortOrder
  }

  export type SubscriptionPlanMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    period?: SortOrder
    featuredBenefit?: SortOrder
    isPopular?: SortOrder
  }

  export type SubscriptionPlanSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type EnumSubscriptionPeriodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionPeriod | EnumSubscriptionPeriodFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionPeriod[] | ListEnumSubscriptionPeriodFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionPeriod[] | ListEnumSubscriptionPeriodFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionPeriodWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionPeriod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionPeriodFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionPeriodFilter<$PrismaModel>
  }

  export type CourseBundleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    originalPrice?: SortOrder
    discount?: SortOrder
    featuredBenefit?: SortOrder
    benefits?: SortOrder
    imageUrl?: SortOrder
  }

  export type CourseBundleAvgOrderByAggregateInput = {
    price?: SortOrder
    originalPrice?: SortOrder
    discount?: SortOrder
  }

  export type CourseBundleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    originalPrice?: SortOrder
    discount?: SortOrder
    featuredBenefit?: SortOrder
    imageUrl?: SortOrder
  }

  export type CourseBundleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    originalPrice?: SortOrder
    discount?: SortOrder
    featuredBenefit?: SortOrder
    imageUrl?: SortOrder
  }

  export type CourseBundleSumOrderByAggregateInput = {
    price?: SortOrder
    originalPrice?: SortOrder
    discount?: SortOrder
  }

  export type CourseBundleRelationFilter = {
    is?: CourseBundleWhereInput
    isNot?: CourseBundleWhereInput
  }

  export type BundleCourseBundleIdCourseIdCompoundUniqueInput = {
    bundleId: string
    courseId: string
  }

  export type BundleCourseCountOrderByAggregateInput = {
    bundleId?: SortOrder
    courseId?: SortOrder
  }

  export type BundleCourseMaxOrderByAggregateInput = {
    bundleId?: SortOrder
    courseId?: SortOrder
  }

  export type BundleCourseMinOrderByAggregateInput = {
    bundleId?: SortOrder
    courseId?: SortOrder
  }

  export type SubscriptionPlanRelationFilter = {
    is?: SubscriptionPlanWhereInput
    isNot?: SubscriptionPlanWhereInput
  }

  export type UserSubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    planId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    autoRenew?: SortOrder
    paymentMethod?: SortOrder
    lastPaymentDate?: SortOrder
  }

  export type UserSubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    planId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    autoRenew?: SortOrder
    paymentMethod?: SortOrder
    lastPaymentDate?: SortOrder
  }

  export type UserSubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    planId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    autoRenew?: SortOrder
    paymentMethod?: SortOrder
    lastPaymentDate?: SortOrder
  }

  export type UserBundleCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    bundleId?: SortOrder
    purchaseDate?: SortOrder
  }

  export type UserBundleMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    bundleId?: SortOrder
    purchaseDate?: SortOrder
  }

  export type UserBundleMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    bundleId?: SortOrder
    purchaseDate?: SortOrder
  }

  export type EnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type EnumPaymentReferenceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentReferenceType | EnumPaymentReferenceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentReferenceType[] | ListEnumPaymentReferenceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentReferenceType[] | ListEnumPaymentReferenceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentReferenceTypeFilter<$PrismaModel> | $Enums.PaymentReferenceType
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    paymentMethod?: SortOrder
    status?: SortOrder
    referenceType?: SortOrder
    referenceId?: SortOrder
    transactionId?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    paymentMethod?: SortOrder
    status?: SortOrder
    referenceType?: SortOrder
    referenceId?: SortOrder
    transactionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    paymentMethod?: SortOrder
    status?: SortOrder
    referenceType?: SortOrder
    referenceId?: SortOrder
    transactionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type EnumPaymentReferenceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentReferenceType | EnumPaymentReferenceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentReferenceType[] | ListEnumPaymentReferenceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentReferenceType[] | ListEnumPaymentReferenceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentReferenceTypeWithAggregatesFilter<$PrismaModel> | $Enums.PaymentReferenceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentReferenceTypeFilter<$PrismaModel>
    _max?: NestedEnumPaymentReferenceTypeFilter<$PrismaModel>
  }

  export type LessonNullableRelationFilter = {
    is?: LessonWhereInput | null
    isNot?: LessonWhereInput | null
  }

  export type CalendarEventCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    courseId?: SortOrder
    lessonId?: SortOrder
    teacherId?: SortOrder
    studentId?: SortOrder
    location?: SortOrder
    createdAt?: SortOrder
  }

  export type CalendarEventMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    courseId?: SortOrder
    lessonId?: SortOrder
    teacherId?: SortOrder
    studentId?: SortOrder
    location?: SortOrder
    createdAt?: SortOrder
  }

  export type CalendarEventMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    courseId?: SortOrder
    lessonId?: SortOrder
    teacherId?: SortOrder
    studentId?: SortOrder
    location?: SortOrder
    createdAt?: SortOrder
  }

  export type PostCategoryListRelationFilter = {
    every?: PostCategoryWhereInput
    some?: PostCategoryWhereInput
    none?: PostCategoryWhereInput
  }

  export type PostTagListRelationFilter = {
    every?: PostTagWhereInput
    some?: PostTagWhereInput
    none?: PostTagWhereInput
  }

  export type PostCategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostTagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BlogPostCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    excerpt?: SortOrder
    content?: SortOrder
    image?: SortOrder
    authorId?: SortOrder
    published?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    readTime?: SortOrder
  }

  export type BlogPostAvgOrderByAggregateInput = {
    readTime?: SortOrder
  }

  export type BlogPostMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    excerpt?: SortOrder
    content?: SortOrder
    image?: SortOrder
    authorId?: SortOrder
    published?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    readTime?: SortOrder
  }

  export type BlogPostMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    excerpt?: SortOrder
    content?: SortOrder
    image?: SortOrder
    authorId?: SortOrder
    published?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    readTime?: SortOrder
  }

  export type BlogPostSumOrderByAggregateInput = {
    readTime?: SortOrder
  }

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
  }

  export type BlogPostRelationFilter = {
    is?: BlogPostWhereInput
    isNot?: BlogPostWhereInput
  }

  export type CategoryRelationFilter = {
    is?: CategoryWhereInput
    isNot?: CategoryWhereInput
  }

  export type PostCategoryPostIdCategoryIdCompoundUniqueInput = {
    postId: string
    categoryId: string
  }

  export type PostCategoryCountOrderByAggregateInput = {
    postId?: SortOrder
    categoryId?: SortOrder
  }

  export type PostCategoryMaxOrderByAggregateInput = {
    postId?: SortOrder
    categoryId?: SortOrder
  }

  export type PostCategoryMinOrderByAggregateInput = {
    postId?: SortOrder
    categoryId?: SortOrder
  }

  export type TagCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
  }

  export type TagMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
  }

  export type TagMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
  }

  export type TagRelationFilter = {
    is?: TagWhereInput
    isNot?: TagWhereInput
  }

  export type PostTagPostIdTagIdCompoundUniqueInput = {
    postId: string
    tagId: string
  }

  export type PostTagCountOrderByAggregateInput = {
    postId?: SortOrder
    tagId?: SortOrder
  }

  export type PostTagMaxOrderByAggregateInput = {
    postId?: SortOrder
    tagId?: SortOrder
  }

  export type PostTagMinOrderByAggregateInput = {
    postId?: SortOrder
    tagId?: SortOrder
  }

  export type BlogCommentNullableRelationFilter = {
    is?: BlogCommentWhereInput | null
    isNot?: BlogCommentWhereInput | null
  }

  export type BlogCommentCountOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    parentId?: SortOrder
  }

  export type BlogCommentMaxOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    parentId?: SortOrder
  }

  export type BlogCommentMinOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    parentId?: SortOrder
  }

  export type ReferralCodeCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    userId?: SortOrder
    isActive?: SortOrder
    usageLimit?: SortOrder
    maxUses?: SortOrder
    pointsReward?: SortOrder
    isUserCode?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReferralCodeAvgOrderByAggregateInput = {
    usageLimit?: SortOrder
    maxUses?: SortOrder
    pointsReward?: SortOrder
  }

  export type ReferralCodeMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    userId?: SortOrder
    isActive?: SortOrder
    usageLimit?: SortOrder
    maxUses?: SortOrder
    pointsReward?: SortOrder
    isUserCode?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReferralCodeMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    userId?: SortOrder
    isActive?: SortOrder
    usageLimit?: SortOrder
    maxUses?: SortOrder
    pointsReward?: SortOrder
    isUserCode?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReferralCodeSumOrderByAggregateInput = {
    usageLimit?: SortOrder
    maxUses?: SortOrder
    pointsReward?: SortOrder
  }

  export type ReferralCodeRelationFilter = {
    is?: ReferralCodeWhereInput
    isNot?: ReferralCodeWhereInput
  }

  export type ReferralUseReferralCodeIdUserIdCompoundUniqueInput = {
    referralCodeId: string
    userId: string
  }

  export type ReferralUseCountOrderByAggregateInput = {
    id?: SortOrder
    referralCodeId?: SortOrder
    userId?: SortOrder
    pointsAwarded?: SortOrder
    createdAt?: SortOrder
  }

  export type ReferralUseAvgOrderByAggregateInput = {
    pointsAwarded?: SortOrder
  }

  export type ReferralUseMaxOrderByAggregateInput = {
    id?: SortOrder
    referralCodeId?: SortOrder
    userId?: SortOrder
    pointsAwarded?: SortOrder
    createdAt?: SortOrder
  }

  export type ReferralUseMinOrderByAggregateInput = {
    id?: SortOrder
    referralCodeId?: SortOrder
    userId?: SortOrder
    pointsAwarded?: SortOrder
    createdAt?: SortOrder
  }

  export type ReferralUseSumOrderByAggregateInput = {
    pointsAwarded?: SortOrder
  }

  export type UserCreateNestedOneWithoutReferralsInput = {
    create?: XOR<UserCreateWithoutReferralsInput, UserUncheckedCreateWithoutReferralsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReferralsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutReferredByInput = {
    create?: XOR<UserCreateWithoutReferredByInput, UserUncheckedCreateWithoutReferredByInput> | UserCreateWithoutReferredByInput[] | UserUncheckedCreateWithoutReferredByInput[]
    connectOrCreate?: UserCreateOrConnectWithoutReferredByInput | UserCreateOrConnectWithoutReferredByInput[]
    createMany?: UserCreateManyReferredByInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type TeacherProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<TeacherProfileCreateWithoutUserInput, TeacherProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: TeacherProfileCreateOrConnectWithoutUserInput
    connect?: TeacherProfileWhereUniqueInput
  }

  export type UserAvailabilityCreateNestedManyWithoutUserInput = {
    create?: XOR<UserAvailabilityCreateWithoutUserInput, UserAvailabilityUncheckedCreateWithoutUserInput> | UserAvailabilityCreateWithoutUserInput[] | UserAvailabilityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAvailabilityCreateOrConnectWithoutUserInput | UserAvailabilityCreateOrConnectWithoutUserInput[]
    createMany?: UserAvailabilityCreateManyUserInputEnvelope
    connect?: UserAvailabilityWhereUniqueInput | UserAvailabilityWhereUniqueInput[]
  }

  export type PointsTransactionCreateNestedManyWithoutUserInput = {
    create?: XOR<PointsTransactionCreateWithoutUserInput, PointsTransactionUncheckedCreateWithoutUserInput> | PointsTransactionCreateWithoutUserInput[] | PointsTransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PointsTransactionCreateOrConnectWithoutUserInput | PointsTransactionCreateOrConnectWithoutUserInput[]
    createMany?: PointsTransactionCreateManyUserInputEnvelope
    connect?: PointsTransactionWhereUniqueInput | PointsTransactionWhereUniqueInput[]
  }

  export type CourseCreateNestedManyWithoutTeacherInput = {
    create?: XOR<CourseCreateWithoutTeacherInput, CourseUncheckedCreateWithoutTeacherInput> | CourseCreateWithoutTeacherInput[] | CourseUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutTeacherInput | CourseCreateOrConnectWithoutTeacherInput[]
    createMany?: CourseCreateManyTeacherInputEnvelope
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
  }

  export type EnrollmentCreateNestedManyWithoutUserInput = {
    create?: XOR<EnrollmentCreateWithoutUserInput, EnrollmentUncheckedCreateWithoutUserInput> | EnrollmentCreateWithoutUserInput[] | EnrollmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutUserInput | EnrollmentCreateOrConnectWithoutUserInput[]
    createMany?: EnrollmentCreateManyUserInputEnvelope
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
  }

  export type SavedCourseCreateNestedManyWithoutUserInput = {
    create?: XOR<SavedCourseCreateWithoutUserInput, SavedCourseUncheckedCreateWithoutUserInput> | SavedCourseCreateWithoutUserInput[] | SavedCourseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SavedCourseCreateOrConnectWithoutUserInput | SavedCourseCreateOrConnectWithoutUserInput[]
    createMany?: SavedCourseCreateManyUserInputEnvelope
    connect?: SavedCourseWhereUniqueInput | SavedCourseWhereUniqueInput[]
  }

  export type LikedCourseCreateNestedManyWithoutUserInput = {
    create?: XOR<LikedCourseCreateWithoutUserInput, LikedCourseUncheckedCreateWithoutUserInput> | LikedCourseCreateWithoutUserInput[] | LikedCourseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LikedCourseCreateOrConnectWithoutUserInput | LikedCourseCreateOrConnectWithoutUserInput[]
    createMany?: LikedCourseCreateManyUserInputEnvelope
    connect?: LikedCourseWhereUniqueInput | LikedCourseWhereUniqueInput[]
  }

  export type LessonProgressCreateNestedManyWithoutUserInput = {
    create?: XOR<LessonProgressCreateWithoutUserInput, LessonProgressUncheckedCreateWithoutUserInput> | LessonProgressCreateWithoutUserInput[] | LessonProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LessonProgressCreateOrConnectWithoutUserInput | LessonProgressCreateOrConnectWithoutUserInput[]
    createMany?: LessonProgressCreateManyUserInputEnvelope
    connect?: LessonProgressWhereUniqueInput | LessonProgressWhereUniqueInput[]
  }

  export type QuizAttemptCreateNestedManyWithoutUserInput = {
    create?: XOR<QuizAttemptCreateWithoutUserInput, QuizAttemptUncheckedCreateWithoutUserInput> | QuizAttemptCreateWithoutUserInput[] | QuizAttemptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: QuizAttemptCreateOrConnectWithoutUserInput | QuizAttemptCreateOrConnectWithoutUserInput[]
    createMany?: QuizAttemptCreateManyUserInputEnvelope
    connect?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
  }

  export type AssignmentSubmissionCreateNestedManyWithoutUserInput = {
    create?: XOR<AssignmentSubmissionCreateWithoutUserInput, AssignmentSubmissionUncheckedCreateWithoutUserInput> | AssignmentSubmissionCreateWithoutUserInput[] | AssignmentSubmissionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AssignmentSubmissionCreateOrConnectWithoutUserInput | AssignmentSubmissionCreateOrConnectWithoutUserInput[]
    createMany?: AssignmentSubmissionCreateManyUserInputEnvelope
    connect?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
  }

  export type CourseReviewCreateNestedManyWithoutUserInput = {
    create?: XOR<CourseReviewCreateWithoutUserInput, CourseReviewUncheckedCreateWithoutUserInput> | CourseReviewCreateWithoutUserInput[] | CourseReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CourseReviewCreateOrConnectWithoutUserInput | CourseReviewCreateOrConnectWithoutUserInput[]
    createMany?: CourseReviewCreateManyUserInputEnvelope
    connect?: CourseReviewWhereUniqueInput | CourseReviewWhereUniqueInput[]
  }

  export type TutoringSessionCreateNestedManyWithoutTeacherInput = {
    create?: XOR<TutoringSessionCreateWithoutTeacherInput, TutoringSessionUncheckedCreateWithoutTeacherInput> | TutoringSessionCreateWithoutTeacherInput[] | TutoringSessionUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TutoringSessionCreateOrConnectWithoutTeacherInput | TutoringSessionCreateOrConnectWithoutTeacherInput[]
    createMany?: TutoringSessionCreateManyTeacherInputEnvelope
    connect?: TutoringSessionWhereUniqueInput | TutoringSessionWhereUniqueInput[]
  }

  export type TutoringRequestCreateNestedManyWithoutStudentInput = {
    create?: XOR<TutoringRequestCreateWithoutStudentInput, TutoringRequestUncheckedCreateWithoutStudentInput> | TutoringRequestCreateWithoutStudentInput[] | TutoringRequestUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: TutoringRequestCreateOrConnectWithoutStudentInput | TutoringRequestCreateOrConnectWithoutStudentInput[]
    createMany?: TutoringRequestCreateManyStudentInputEnvelope
    connect?: TutoringRequestWhereUniqueInput | TutoringRequestWhereUniqueInput[]
  }

  export type TutoringAppointmentCreateNestedManyWithoutTeacherInput = {
    create?: XOR<TutoringAppointmentCreateWithoutTeacherInput, TutoringAppointmentUncheckedCreateWithoutTeacherInput> | TutoringAppointmentCreateWithoutTeacherInput[] | TutoringAppointmentUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TutoringAppointmentCreateOrConnectWithoutTeacherInput | TutoringAppointmentCreateOrConnectWithoutTeacherInput[]
    createMany?: TutoringAppointmentCreateManyTeacherInputEnvelope
    connect?: TutoringAppointmentWhereUniqueInput | TutoringAppointmentWhereUniqueInput[]
  }

  export type TutoringAppointmentCreateNestedManyWithoutStudentInput = {
    create?: XOR<TutoringAppointmentCreateWithoutStudentInput, TutoringAppointmentUncheckedCreateWithoutStudentInput> | TutoringAppointmentCreateWithoutStudentInput[] | TutoringAppointmentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: TutoringAppointmentCreateOrConnectWithoutStudentInput | TutoringAppointmentCreateOrConnectWithoutStudentInput[]
    createMany?: TutoringAppointmentCreateManyStudentInputEnvelope
    connect?: TutoringAppointmentWhereUniqueInput | TutoringAppointmentWhereUniqueInput[]
  }

  export type TutoringReviewCreateNestedManyWithoutStudentInput = {
    create?: XOR<TutoringReviewCreateWithoutStudentInput, TutoringReviewUncheckedCreateWithoutStudentInput> | TutoringReviewCreateWithoutStudentInput[] | TutoringReviewUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: TutoringReviewCreateOrConnectWithoutStudentInput | TutoringReviewCreateOrConnectWithoutStudentInput[]
    createMany?: TutoringReviewCreateManyStudentInputEnvelope
    connect?: TutoringReviewWhereUniqueInput | TutoringReviewWhereUniqueInput[]
  }

  export type TutoringMessageCreateNestedManyWithoutSenderInput = {
    create?: XOR<TutoringMessageCreateWithoutSenderInput, TutoringMessageUncheckedCreateWithoutSenderInput> | TutoringMessageCreateWithoutSenderInput[] | TutoringMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: TutoringMessageCreateOrConnectWithoutSenderInput | TutoringMessageCreateOrConnectWithoutSenderInput[]
    createMany?: TutoringMessageCreateManySenderInputEnvelope
    connect?: TutoringMessageWhereUniqueInput | TutoringMessageWhereUniqueInput[]
  }

  export type UserAchievementCreateNestedManyWithoutUserInput = {
    create?: XOR<UserAchievementCreateWithoutUserInput, UserAchievementUncheckedCreateWithoutUserInput> | UserAchievementCreateWithoutUserInput[] | UserAchievementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutUserInput | UserAchievementCreateOrConnectWithoutUserInput[]
    createMany?: UserAchievementCreateManyUserInputEnvelope
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
  }

  export type CertificateCreateNestedManyWithoutUserInput = {
    create?: XOR<CertificateCreateWithoutUserInput, CertificateUncheckedCreateWithoutUserInput> | CertificateCreateWithoutUserInput[] | CertificateUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutUserInput | CertificateCreateOrConnectWithoutUserInput[]
    createMany?: CertificateCreateManyUserInputEnvelope
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
  }

  export type ConversationParticipantCreateNestedManyWithoutUserInput = {
    create?: XOR<ConversationParticipantCreateWithoutUserInput, ConversationParticipantUncheckedCreateWithoutUserInput> | ConversationParticipantCreateWithoutUserInput[] | ConversationParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConversationParticipantCreateOrConnectWithoutUserInput | ConversationParticipantCreateOrConnectWithoutUserInput[]
    createMany?: ConversationParticipantCreateManyUserInputEnvelope
    connect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type AttachmentCreateNestedManyWithoutUserInput = {
    create?: XOR<AttachmentCreateWithoutUserInput, AttachmentUncheckedCreateWithoutUserInput> | AttachmentCreateWithoutUserInput[] | AttachmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutUserInput | AttachmentCreateOrConnectWithoutUserInput[]
    createMany?: AttachmentCreateManyUserInputEnvelope
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type UserSubscriptionCreateNestedManyWithoutUserInput = {
    create?: XOR<UserSubscriptionCreateWithoutUserInput, UserSubscriptionUncheckedCreateWithoutUserInput> | UserSubscriptionCreateWithoutUserInput[] | UserSubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSubscriptionCreateOrConnectWithoutUserInput | UserSubscriptionCreateOrConnectWithoutUserInput[]
    createMany?: UserSubscriptionCreateManyUserInputEnvelope
    connect?: UserSubscriptionWhereUniqueInput | UserSubscriptionWhereUniqueInput[]
  }

  export type UserBundleCreateNestedManyWithoutUserInput = {
    create?: XOR<UserBundleCreateWithoutUserInput, UserBundleUncheckedCreateWithoutUserInput> | UserBundleCreateWithoutUserInput[] | UserBundleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserBundleCreateOrConnectWithoutUserInput | UserBundleCreateOrConnectWithoutUserInput[]
    createMany?: UserBundleCreateManyUserInputEnvelope
    connect?: UserBundleWhereUniqueInput | UserBundleWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutUserInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type CalendarEventCreateNestedManyWithoutUserInput = {
    create?: XOR<CalendarEventCreateWithoutUserInput, CalendarEventUncheckedCreateWithoutUserInput> | CalendarEventCreateWithoutUserInput[] | CalendarEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CalendarEventCreateOrConnectWithoutUserInput | CalendarEventCreateOrConnectWithoutUserInput[]
    createMany?: CalendarEventCreateManyUserInputEnvelope
    connect?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
  }

  export type CalendarEventCreateNestedManyWithoutTeacherInput = {
    create?: XOR<CalendarEventCreateWithoutTeacherInput, CalendarEventUncheckedCreateWithoutTeacherInput> | CalendarEventCreateWithoutTeacherInput[] | CalendarEventUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: CalendarEventCreateOrConnectWithoutTeacherInput | CalendarEventCreateOrConnectWithoutTeacherInput[]
    createMany?: CalendarEventCreateManyTeacherInputEnvelope
    connect?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
  }

  export type CalendarEventCreateNestedManyWithoutStudentInput = {
    create?: XOR<CalendarEventCreateWithoutStudentInput, CalendarEventUncheckedCreateWithoutStudentInput> | CalendarEventCreateWithoutStudentInput[] | CalendarEventUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: CalendarEventCreateOrConnectWithoutStudentInput | CalendarEventCreateOrConnectWithoutStudentInput[]
    createMany?: CalendarEventCreateManyStudentInputEnvelope
    connect?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
  }

  export type BlogPostCreateNestedManyWithoutAuthorInput = {
    create?: XOR<BlogPostCreateWithoutAuthorInput, BlogPostUncheckedCreateWithoutAuthorInput> | BlogPostCreateWithoutAuthorInput[] | BlogPostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: BlogPostCreateOrConnectWithoutAuthorInput | BlogPostCreateOrConnectWithoutAuthorInput[]
    createMany?: BlogPostCreateManyAuthorInputEnvelope
    connect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
  }

  export type BlogCommentCreateNestedManyWithoutUserInput = {
    create?: XOR<BlogCommentCreateWithoutUserInput, BlogCommentUncheckedCreateWithoutUserInput> | BlogCommentCreateWithoutUserInput[] | BlogCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BlogCommentCreateOrConnectWithoutUserInput | BlogCommentCreateOrConnectWithoutUserInput[]
    createMany?: BlogCommentCreateManyUserInputEnvelope
    connect?: BlogCommentWhereUniqueInput | BlogCommentWhereUniqueInput[]
  }

  export type AssignmentSubmissionCreateNestedManyWithoutGradedByInput = {
    create?: XOR<AssignmentSubmissionCreateWithoutGradedByInput, AssignmentSubmissionUncheckedCreateWithoutGradedByInput> | AssignmentSubmissionCreateWithoutGradedByInput[] | AssignmentSubmissionUncheckedCreateWithoutGradedByInput[]
    connectOrCreate?: AssignmentSubmissionCreateOrConnectWithoutGradedByInput | AssignmentSubmissionCreateOrConnectWithoutGradedByInput[]
    createMany?: AssignmentSubmissionCreateManyGradedByInputEnvelope
    connect?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
  }

  export type ReferralCodeCreateNestedManyWithoutUserInput = {
    create?: XOR<ReferralCodeCreateWithoutUserInput, ReferralCodeUncheckedCreateWithoutUserInput> | ReferralCodeCreateWithoutUserInput[] | ReferralCodeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReferralCodeCreateOrConnectWithoutUserInput | ReferralCodeCreateOrConnectWithoutUserInput[]
    createMany?: ReferralCodeCreateManyUserInputEnvelope
    connect?: ReferralCodeWhereUniqueInput | ReferralCodeWhereUniqueInput[]
  }

  export type ReferralUseCreateNestedManyWithoutUserInput = {
    create?: XOR<ReferralUseCreateWithoutUserInput, ReferralUseUncheckedCreateWithoutUserInput> | ReferralUseCreateWithoutUserInput[] | ReferralUseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReferralUseCreateOrConnectWithoutUserInput | ReferralUseCreateOrConnectWithoutUserInput[]
    createMany?: ReferralUseCreateManyUserInputEnvelope
    connect?: ReferralUseWhereUniqueInput | ReferralUseWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutReferredByInput = {
    create?: XOR<UserCreateWithoutReferredByInput, UserUncheckedCreateWithoutReferredByInput> | UserCreateWithoutReferredByInput[] | UserUncheckedCreateWithoutReferredByInput[]
    connectOrCreate?: UserCreateOrConnectWithoutReferredByInput | UserCreateOrConnectWithoutReferredByInput[]
    createMany?: UserCreateManyReferredByInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type TeacherProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<TeacherProfileCreateWithoutUserInput, TeacherProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: TeacherProfileCreateOrConnectWithoutUserInput
    connect?: TeacherProfileWhereUniqueInput
  }

  export type UserAvailabilityUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserAvailabilityCreateWithoutUserInput, UserAvailabilityUncheckedCreateWithoutUserInput> | UserAvailabilityCreateWithoutUserInput[] | UserAvailabilityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAvailabilityCreateOrConnectWithoutUserInput | UserAvailabilityCreateOrConnectWithoutUserInput[]
    createMany?: UserAvailabilityCreateManyUserInputEnvelope
    connect?: UserAvailabilityWhereUniqueInput | UserAvailabilityWhereUniqueInput[]
  }

  export type PointsTransactionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PointsTransactionCreateWithoutUserInput, PointsTransactionUncheckedCreateWithoutUserInput> | PointsTransactionCreateWithoutUserInput[] | PointsTransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PointsTransactionCreateOrConnectWithoutUserInput | PointsTransactionCreateOrConnectWithoutUserInput[]
    createMany?: PointsTransactionCreateManyUserInputEnvelope
    connect?: PointsTransactionWhereUniqueInput | PointsTransactionWhereUniqueInput[]
  }

  export type CourseUncheckedCreateNestedManyWithoutTeacherInput = {
    create?: XOR<CourseCreateWithoutTeacherInput, CourseUncheckedCreateWithoutTeacherInput> | CourseCreateWithoutTeacherInput[] | CourseUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutTeacherInput | CourseCreateOrConnectWithoutTeacherInput[]
    createMany?: CourseCreateManyTeacherInputEnvelope
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
  }

  export type EnrollmentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<EnrollmentCreateWithoutUserInput, EnrollmentUncheckedCreateWithoutUserInput> | EnrollmentCreateWithoutUserInput[] | EnrollmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutUserInput | EnrollmentCreateOrConnectWithoutUserInput[]
    createMany?: EnrollmentCreateManyUserInputEnvelope
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
  }

  export type SavedCourseUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SavedCourseCreateWithoutUserInput, SavedCourseUncheckedCreateWithoutUserInput> | SavedCourseCreateWithoutUserInput[] | SavedCourseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SavedCourseCreateOrConnectWithoutUserInput | SavedCourseCreateOrConnectWithoutUserInput[]
    createMany?: SavedCourseCreateManyUserInputEnvelope
    connect?: SavedCourseWhereUniqueInput | SavedCourseWhereUniqueInput[]
  }

  export type LikedCourseUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LikedCourseCreateWithoutUserInput, LikedCourseUncheckedCreateWithoutUserInput> | LikedCourseCreateWithoutUserInput[] | LikedCourseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LikedCourseCreateOrConnectWithoutUserInput | LikedCourseCreateOrConnectWithoutUserInput[]
    createMany?: LikedCourseCreateManyUserInputEnvelope
    connect?: LikedCourseWhereUniqueInput | LikedCourseWhereUniqueInput[]
  }

  export type LessonProgressUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LessonProgressCreateWithoutUserInput, LessonProgressUncheckedCreateWithoutUserInput> | LessonProgressCreateWithoutUserInput[] | LessonProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LessonProgressCreateOrConnectWithoutUserInput | LessonProgressCreateOrConnectWithoutUserInput[]
    createMany?: LessonProgressCreateManyUserInputEnvelope
    connect?: LessonProgressWhereUniqueInput | LessonProgressWhereUniqueInput[]
  }

  export type QuizAttemptUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<QuizAttemptCreateWithoutUserInput, QuizAttemptUncheckedCreateWithoutUserInput> | QuizAttemptCreateWithoutUserInput[] | QuizAttemptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: QuizAttemptCreateOrConnectWithoutUserInput | QuizAttemptCreateOrConnectWithoutUserInput[]
    createMany?: QuizAttemptCreateManyUserInputEnvelope
    connect?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
  }

  export type AssignmentSubmissionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AssignmentSubmissionCreateWithoutUserInput, AssignmentSubmissionUncheckedCreateWithoutUserInput> | AssignmentSubmissionCreateWithoutUserInput[] | AssignmentSubmissionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AssignmentSubmissionCreateOrConnectWithoutUserInput | AssignmentSubmissionCreateOrConnectWithoutUserInput[]
    createMany?: AssignmentSubmissionCreateManyUserInputEnvelope
    connect?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
  }

  export type CourseReviewUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CourseReviewCreateWithoutUserInput, CourseReviewUncheckedCreateWithoutUserInput> | CourseReviewCreateWithoutUserInput[] | CourseReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CourseReviewCreateOrConnectWithoutUserInput | CourseReviewCreateOrConnectWithoutUserInput[]
    createMany?: CourseReviewCreateManyUserInputEnvelope
    connect?: CourseReviewWhereUniqueInput | CourseReviewWhereUniqueInput[]
  }

  export type TutoringSessionUncheckedCreateNestedManyWithoutTeacherInput = {
    create?: XOR<TutoringSessionCreateWithoutTeacherInput, TutoringSessionUncheckedCreateWithoutTeacherInput> | TutoringSessionCreateWithoutTeacherInput[] | TutoringSessionUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TutoringSessionCreateOrConnectWithoutTeacherInput | TutoringSessionCreateOrConnectWithoutTeacherInput[]
    createMany?: TutoringSessionCreateManyTeacherInputEnvelope
    connect?: TutoringSessionWhereUniqueInput | TutoringSessionWhereUniqueInput[]
  }

  export type TutoringRequestUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<TutoringRequestCreateWithoutStudentInput, TutoringRequestUncheckedCreateWithoutStudentInput> | TutoringRequestCreateWithoutStudentInput[] | TutoringRequestUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: TutoringRequestCreateOrConnectWithoutStudentInput | TutoringRequestCreateOrConnectWithoutStudentInput[]
    createMany?: TutoringRequestCreateManyStudentInputEnvelope
    connect?: TutoringRequestWhereUniqueInput | TutoringRequestWhereUniqueInput[]
  }

  export type TutoringAppointmentUncheckedCreateNestedManyWithoutTeacherInput = {
    create?: XOR<TutoringAppointmentCreateWithoutTeacherInput, TutoringAppointmentUncheckedCreateWithoutTeacherInput> | TutoringAppointmentCreateWithoutTeacherInput[] | TutoringAppointmentUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TutoringAppointmentCreateOrConnectWithoutTeacherInput | TutoringAppointmentCreateOrConnectWithoutTeacherInput[]
    createMany?: TutoringAppointmentCreateManyTeacherInputEnvelope
    connect?: TutoringAppointmentWhereUniqueInput | TutoringAppointmentWhereUniqueInput[]
  }

  export type TutoringAppointmentUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<TutoringAppointmentCreateWithoutStudentInput, TutoringAppointmentUncheckedCreateWithoutStudentInput> | TutoringAppointmentCreateWithoutStudentInput[] | TutoringAppointmentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: TutoringAppointmentCreateOrConnectWithoutStudentInput | TutoringAppointmentCreateOrConnectWithoutStudentInput[]
    createMany?: TutoringAppointmentCreateManyStudentInputEnvelope
    connect?: TutoringAppointmentWhereUniqueInput | TutoringAppointmentWhereUniqueInput[]
  }

  export type TutoringReviewUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<TutoringReviewCreateWithoutStudentInput, TutoringReviewUncheckedCreateWithoutStudentInput> | TutoringReviewCreateWithoutStudentInput[] | TutoringReviewUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: TutoringReviewCreateOrConnectWithoutStudentInput | TutoringReviewCreateOrConnectWithoutStudentInput[]
    createMany?: TutoringReviewCreateManyStudentInputEnvelope
    connect?: TutoringReviewWhereUniqueInput | TutoringReviewWhereUniqueInput[]
  }

  export type TutoringMessageUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<TutoringMessageCreateWithoutSenderInput, TutoringMessageUncheckedCreateWithoutSenderInput> | TutoringMessageCreateWithoutSenderInput[] | TutoringMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: TutoringMessageCreateOrConnectWithoutSenderInput | TutoringMessageCreateOrConnectWithoutSenderInput[]
    createMany?: TutoringMessageCreateManySenderInputEnvelope
    connect?: TutoringMessageWhereUniqueInput | TutoringMessageWhereUniqueInput[]
  }

  export type UserAchievementUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserAchievementCreateWithoutUserInput, UserAchievementUncheckedCreateWithoutUserInput> | UserAchievementCreateWithoutUserInput[] | UserAchievementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutUserInput | UserAchievementCreateOrConnectWithoutUserInput[]
    createMany?: UserAchievementCreateManyUserInputEnvelope
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
  }

  export type CertificateUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CertificateCreateWithoutUserInput, CertificateUncheckedCreateWithoutUserInput> | CertificateCreateWithoutUserInput[] | CertificateUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutUserInput | CertificateCreateOrConnectWithoutUserInput[]
    createMany?: CertificateCreateManyUserInputEnvelope
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
  }

  export type ConversationParticipantUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ConversationParticipantCreateWithoutUserInput, ConversationParticipantUncheckedCreateWithoutUserInput> | ConversationParticipantCreateWithoutUserInput[] | ConversationParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConversationParticipantCreateOrConnectWithoutUserInput | ConversationParticipantCreateOrConnectWithoutUserInput[]
    createMany?: ConversationParticipantCreateManyUserInputEnvelope
    connect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type AttachmentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AttachmentCreateWithoutUserInput, AttachmentUncheckedCreateWithoutUserInput> | AttachmentCreateWithoutUserInput[] | AttachmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutUserInput | AttachmentCreateOrConnectWithoutUserInput[]
    createMany?: AttachmentCreateManyUserInputEnvelope
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type UserSubscriptionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserSubscriptionCreateWithoutUserInput, UserSubscriptionUncheckedCreateWithoutUserInput> | UserSubscriptionCreateWithoutUserInput[] | UserSubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSubscriptionCreateOrConnectWithoutUserInput | UserSubscriptionCreateOrConnectWithoutUserInput[]
    createMany?: UserSubscriptionCreateManyUserInputEnvelope
    connect?: UserSubscriptionWhereUniqueInput | UserSubscriptionWhereUniqueInput[]
  }

  export type UserBundleUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserBundleCreateWithoutUserInput, UserBundleUncheckedCreateWithoutUserInput> | UserBundleCreateWithoutUserInput[] | UserBundleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserBundleCreateOrConnectWithoutUserInput | UserBundleCreateOrConnectWithoutUserInput[]
    createMany?: UserBundleCreateManyUserInputEnvelope
    connect?: UserBundleWhereUniqueInput | UserBundleWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type CalendarEventUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CalendarEventCreateWithoutUserInput, CalendarEventUncheckedCreateWithoutUserInput> | CalendarEventCreateWithoutUserInput[] | CalendarEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CalendarEventCreateOrConnectWithoutUserInput | CalendarEventCreateOrConnectWithoutUserInput[]
    createMany?: CalendarEventCreateManyUserInputEnvelope
    connect?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
  }

  export type CalendarEventUncheckedCreateNestedManyWithoutTeacherInput = {
    create?: XOR<CalendarEventCreateWithoutTeacherInput, CalendarEventUncheckedCreateWithoutTeacherInput> | CalendarEventCreateWithoutTeacherInput[] | CalendarEventUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: CalendarEventCreateOrConnectWithoutTeacherInput | CalendarEventCreateOrConnectWithoutTeacherInput[]
    createMany?: CalendarEventCreateManyTeacherInputEnvelope
    connect?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
  }

  export type CalendarEventUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<CalendarEventCreateWithoutStudentInput, CalendarEventUncheckedCreateWithoutStudentInput> | CalendarEventCreateWithoutStudentInput[] | CalendarEventUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: CalendarEventCreateOrConnectWithoutStudentInput | CalendarEventCreateOrConnectWithoutStudentInput[]
    createMany?: CalendarEventCreateManyStudentInputEnvelope
    connect?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
  }

  export type BlogPostUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<BlogPostCreateWithoutAuthorInput, BlogPostUncheckedCreateWithoutAuthorInput> | BlogPostCreateWithoutAuthorInput[] | BlogPostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: BlogPostCreateOrConnectWithoutAuthorInput | BlogPostCreateOrConnectWithoutAuthorInput[]
    createMany?: BlogPostCreateManyAuthorInputEnvelope
    connect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
  }

  export type BlogCommentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BlogCommentCreateWithoutUserInput, BlogCommentUncheckedCreateWithoutUserInput> | BlogCommentCreateWithoutUserInput[] | BlogCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BlogCommentCreateOrConnectWithoutUserInput | BlogCommentCreateOrConnectWithoutUserInput[]
    createMany?: BlogCommentCreateManyUserInputEnvelope
    connect?: BlogCommentWhereUniqueInput | BlogCommentWhereUniqueInput[]
  }

  export type AssignmentSubmissionUncheckedCreateNestedManyWithoutGradedByInput = {
    create?: XOR<AssignmentSubmissionCreateWithoutGradedByInput, AssignmentSubmissionUncheckedCreateWithoutGradedByInput> | AssignmentSubmissionCreateWithoutGradedByInput[] | AssignmentSubmissionUncheckedCreateWithoutGradedByInput[]
    connectOrCreate?: AssignmentSubmissionCreateOrConnectWithoutGradedByInput | AssignmentSubmissionCreateOrConnectWithoutGradedByInput[]
    createMany?: AssignmentSubmissionCreateManyGradedByInputEnvelope
    connect?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
  }

  export type ReferralCodeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ReferralCodeCreateWithoutUserInput, ReferralCodeUncheckedCreateWithoutUserInput> | ReferralCodeCreateWithoutUserInput[] | ReferralCodeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReferralCodeCreateOrConnectWithoutUserInput | ReferralCodeCreateOrConnectWithoutUserInput[]
    createMany?: ReferralCodeCreateManyUserInputEnvelope
    connect?: ReferralCodeWhereUniqueInput | ReferralCodeWhereUniqueInput[]
  }

  export type ReferralUseUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ReferralUseCreateWithoutUserInput, ReferralUseUncheckedCreateWithoutUserInput> | ReferralUseCreateWithoutUserInput[] | ReferralUseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReferralUseCreateOrConnectWithoutUserInput | ReferralUseCreateOrConnectWithoutUserInput[]
    createMany?: ReferralUseCreateManyUserInputEnvelope
    connect?: ReferralUseWhereUniqueInput | ReferralUseWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserUpdateOneWithoutReferralsNestedInput = {
    create?: XOR<UserCreateWithoutReferralsInput, UserUncheckedCreateWithoutReferralsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReferralsInput
    upsert?: UserUpsertWithoutReferralsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReferralsInput, UserUpdateWithoutReferralsInput>, UserUncheckedUpdateWithoutReferralsInput>
  }

  export type UserUpdateManyWithoutReferredByNestedInput = {
    create?: XOR<UserCreateWithoutReferredByInput, UserUncheckedCreateWithoutReferredByInput> | UserCreateWithoutReferredByInput[] | UserUncheckedCreateWithoutReferredByInput[]
    connectOrCreate?: UserCreateOrConnectWithoutReferredByInput | UserCreateOrConnectWithoutReferredByInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutReferredByInput | UserUpsertWithWhereUniqueWithoutReferredByInput[]
    createMany?: UserCreateManyReferredByInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutReferredByInput | UserUpdateWithWhereUniqueWithoutReferredByInput[]
    updateMany?: UserUpdateManyWithWhereWithoutReferredByInput | UserUpdateManyWithWhereWithoutReferredByInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type TeacherProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<TeacherProfileCreateWithoutUserInput, TeacherProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: TeacherProfileCreateOrConnectWithoutUserInput
    upsert?: TeacherProfileUpsertWithoutUserInput
    disconnect?: TeacherProfileWhereInput | boolean
    delete?: TeacherProfileWhereInput | boolean
    connect?: TeacherProfileWhereUniqueInput
    update?: XOR<XOR<TeacherProfileUpdateToOneWithWhereWithoutUserInput, TeacherProfileUpdateWithoutUserInput>, TeacherProfileUncheckedUpdateWithoutUserInput>
  }

  export type UserAvailabilityUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserAvailabilityCreateWithoutUserInput, UserAvailabilityUncheckedCreateWithoutUserInput> | UserAvailabilityCreateWithoutUserInput[] | UserAvailabilityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAvailabilityCreateOrConnectWithoutUserInput | UserAvailabilityCreateOrConnectWithoutUserInput[]
    upsert?: UserAvailabilityUpsertWithWhereUniqueWithoutUserInput | UserAvailabilityUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserAvailabilityCreateManyUserInputEnvelope
    set?: UserAvailabilityWhereUniqueInput | UserAvailabilityWhereUniqueInput[]
    disconnect?: UserAvailabilityWhereUniqueInput | UserAvailabilityWhereUniqueInput[]
    delete?: UserAvailabilityWhereUniqueInput | UserAvailabilityWhereUniqueInput[]
    connect?: UserAvailabilityWhereUniqueInput | UserAvailabilityWhereUniqueInput[]
    update?: UserAvailabilityUpdateWithWhereUniqueWithoutUserInput | UserAvailabilityUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserAvailabilityUpdateManyWithWhereWithoutUserInput | UserAvailabilityUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserAvailabilityScalarWhereInput | UserAvailabilityScalarWhereInput[]
  }

  export type PointsTransactionUpdateManyWithoutUserNestedInput = {
    create?: XOR<PointsTransactionCreateWithoutUserInput, PointsTransactionUncheckedCreateWithoutUserInput> | PointsTransactionCreateWithoutUserInput[] | PointsTransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PointsTransactionCreateOrConnectWithoutUserInput | PointsTransactionCreateOrConnectWithoutUserInput[]
    upsert?: PointsTransactionUpsertWithWhereUniqueWithoutUserInput | PointsTransactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PointsTransactionCreateManyUserInputEnvelope
    set?: PointsTransactionWhereUniqueInput | PointsTransactionWhereUniqueInput[]
    disconnect?: PointsTransactionWhereUniqueInput | PointsTransactionWhereUniqueInput[]
    delete?: PointsTransactionWhereUniqueInput | PointsTransactionWhereUniqueInput[]
    connect?: PointsTransactionWhereUniqueInput | PointsTransactionWhereUniqueInput[]
    update?: PointsTransactionUpdateWithWhereUniqueWithoutUserInput | PointsTransactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PointsTransactionUpdateManyWithWhereWithoutUserInput | PointsTransactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PointsTransactionScalarWhereInput | PointsTransactionScalarWhereInput[]
  }

  export type CourseUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<CourseCreateWithoutTeacherInput, CourseUncheckedCreateWithoutTeacherInput> | CourseCreateWithoutTeacherInput[] | CourseUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutTeacherInput | CourseCreateOrConnectWithoutTeacherInput[]
    upsert?: CourseUpsertWithWhereUniqueWithoutTeacherInput | CourseUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: CourseCreateManyTeacherInputEnvelope
    set?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    disconnect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    delete?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    update?: CourseUpdateWithWhereUniqueWithoutTeacherInput | CourseUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: CourseUpdateManyWithWhereWithoutTeacherInput | CourseUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: CourseScalarWhereInput | CourseScalarWhereInput[]
  }

  export type EnrollmentUpdateManyWithoutUserNestedInput = {
    create?: XOR<EnrollmentCreateWithoutUserInput, EnrollmentUncheckedCreateWithoutUserInput> | EnrollmentCreateWithoutUserInput[] | EnrollmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutUserInput | EnrollmentCreateOrConnectWithoutUserInput[]
    upsert?: EnrollmentUpsertWithWhereUniqueWithoutUserInput | EnrollmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EnrollmentCreateManyUserInputEnvelope
    set?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    disconnect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    delete?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    update?: EnrollmentUpdateWithWhereUniqueWithoutUserInput | EnrollmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EnrollmentUpdateManyWithWhereWithoutUserInput | EnrollmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EnrollmentScalarWhereInput | EnrollmentScalarWhereInput[]
  }

  export type SavedCourseUpdateManyWithoutUserNestedInput = {
    create?: XOR<SavedCourseCreateWithoutUserInput, SavedCourseUncheckedCreateWithoutUserInput> | SavedCourseCreateWithoutUserInput[] | SavedCourseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SavedCourseCreateOrConnectWithoutUserInput | SavedCourseCreateOrConnectWithoutUserInput[]
    upsert?: SavedCourseUpsertWithWhereUniqueWithoutUserInput | SavedCourseUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SavedCourseCreateManyUserInputEnvelope
    set?: SavedCourseWhereUniqueInput | SavedCourseWhereUniqueInput[]
    disconnect?: SavedCourseWhereUniqueInput | SavedCourseWhereUniqueInput[]
    delete?: SavedCourseWhereUniqueInput | SavedCourseWhereUniqueInput[]
    connect?: SavedCourseWhereUniqueInput | SavedCourseWhereUniqueInput[]
    update?: SavedCourseUpdateWithWhereUniqueWithoutUserInput | SavedCourseUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SavedCourseUpdateManyWithWhereWithoutUserInput | SavedCourseUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SavedCourseScalarWhereInput | SavedCourseScalarWhereInput[]
  }

  export type LikedCourseUpdateManyWithoutUserNestedInput = {
    create?: XOR<LikedCourseCreateWithoutUserInput, LikedCourseUncheckedCreateWithoutUserInput> | LikedCourseCreateWithoutUserInput[] | LikedCourseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LikedCourseCreateOrConnectWithoutUserInput | LikedCourseCreateOrConnectWithoutUserInput[]
    upsert?: LikedCourseUpsertWithWhereUniqueWithoutUserInput | LikedCourseUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LikedCourseCreateManyUserInputEnvelope
    set?: LikedCourseWhereUniqueInput | LikedCourseWhereUniqueInput[]
    disconnect?: LikedCourseWhereUniqueInput | LikedCourseWhereUniqueInput[]
    delete?: LikedCourseWhereUniqueInput | LikedCourseWhereUniqueInput[]
    connect?: LikedCourseWhereUniqueInput | LikedCourseWhereUniqueInput[]
    update?: LikedCourseUpdateWithWhereUniqueWithoutUserInput | LikedCourseUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LikedCourseUpdateManyWithWhereWithoutUserInput | LikedCourseUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LikedCourseScalarWhereInput | LikedCourseScalarWhereInput[]
  }

  export type LessonProgressUpdateManyWithoutUserNestedInput = {
    create?: XOR<LessonProgressCreateWithoutUserInput, LessonProgressUncheckedCreateWithoutUserInput> | LessonProgressCreateWithoutUserInput[] | LessonProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LessonProgressCreateOrConnectWithoutUserInput | LessonProgressCreateOrConnectWithoutUserInput[]
    upsert?: LessonProgressUpsertWithWhereUniqueWithoutUserInput | LessonProgressUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LessonProgressCreateManyUserInputEnvelope
    set?: LessonProgressWhereUniqueInput | LessonProgressWhereUniqueInput[]
    disconnect?: LessonProgressWhereUniqueInput | LessonProgressWhereUniqueInput[]
    delete?: LessonProgressWhereUniqueInput | LessonProgressWhereUniqueInput[]
    connect?: LessonProgressWhereUniqueInput | LessonProgressWhereUniqueInput[]
    update?: LessonProgressUpdateWithWhereUniqueWithoutUserInput | LessonProgressUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LessonProgressUpdateManyWithWhereWithoutUserInput | LessonProgressUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LessonProgressScalarWhereInput | LessonProgressScalarWhereInput[]
  }

  export type QuizAttemptUpdateManyWithoutUserNestedInput = {
    create?: XOR<QuizAttemptCreateWithoutUserInput, QuizAttemptUncheckedCreateWithoutUserInput> | QuizAttemptCreateWithoutUserInput[] | QuizAttemptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: QuizAttemptCreateOrConnectWithoutUserInput | QuizAttemptCreateOrConnectWithoutUserInput[]
    upsert?: QuizAttemptUpsertWithWhereUniqueWithoutUserInput | QuizAttemptUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: QuizAttemptCreateManyUserInputEnvelope
    set?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    disconnect?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    delete?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    connect?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    update?: QuizAttemptUpdateWithWhereUniqueWithoutUserInput | QuizAttemptUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: QuizAttemptUpdateManyWithWhereWithoutUserInput | QuizAttemptUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: QuizAttemptScalarWhereInput | QuizAttemptScalarWhereInput[]
  }

  export type AssignmentSubmissionUpdateManyWithoutUserNestedInput = {
    create?: XOR<AssignmentSubmissionCreateWithoutUserInput, AssignmentSubmissionUncheckedCreateWithoutUserInput> | AssignmentSubmissionCreateWithoutUserInput[] | AssignmentSubmissionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AssignmentSubmissionCreateOrConnectWithoutUserInput | AssignmentSubmissionCreateOrConnectWithoutUserInput[]
    upsert?: AssignmentSubmissionUpsertWithWhereUniqueWithoutUserInput | AssignmentSubmissionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AssignmentSubmissionCreateManyUserInputEnvelope
    set?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
    disconnect?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
    delete?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
    connect?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
    update?: AssignmentSubmissionUpdateWithWhereUniqueWithoutUserInput | AssignmentSubmissionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AssignmentSubmissionUpdateManyWithWhereWithoutUserInput | AssignmentSubmissionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AssignmentSubmissionScalarWhereInput | AssignmentSubmissionScalarWhereInput[]
  }

  export type CourseReviewUpdateManyWithoutUserNestedInput = {
    create?: XOR<CourseReviewCreateWithoutUserInput, CourseReviewUncheckedCreateWithoutUserInput> | CourseReviewCreateWithoutUserInput[] | CourseReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CourseReviewCreateOrConnectWithoutUserInput | CourseReviewCreateOrConnectWithoutUserInput[]
    upsert?: CourseReviewUpsertWithWhereUniqueWithoutUserInput | CourseReviewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CourseReviewCreateManyUserInputEnvelope
    set?: CourseReviewWhereUniqueInput | CourseReviewWhereUniqueInput[]
    disconnect?: CourseReviewWhereUniqueInput | CourseReviewWhereUniqueInput[]
    delete?: CourseReviewWhereUniqueInput | CourseReviewWhereUniqueInput[]
    connect?: CourseReviewWhereUniqueInput | CourseReviewWhereUniqueInput[]
    update?: CourseReviewUpdateWithWhereUniqueWithoutUserInput | CourseReviewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CourseReviewUpdateManyWithWhereWithoutUserInput | CourseReviewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CourseReviewScalarWhereInput | CourseReviewScalarWhereInput[]
  }

  export type TutoringSessionUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<TutoringSessionCreateWithoutTeacherInput, TutoringSessionUncheckedCreateWithoutTeacherInput> | TutoringSessionCreateWithoutTeacherInput[] | TutoringSessionUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TutoringSessionCreateOrConnectWithoutTeacherInput | TutoringSessionCreateOrConnectWithoutTeacherInput[]
    upsert?: TutoringSessionUpsertWithWhereUniqueWithoutTeacherInput | TutoringSessionUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: TutoringSessionCreateManyTeacherInputEnvelope
    set?: TutoringSessionWhereUniqueInput | TutoringSessionWhereUniqueInput[]
    disconnect?: TutoringSessionWhereUniqueInput | TutoringSessionWhereUniqueInput[]
    delete?: TutoringSessionWhereUniqueInput | TutoringSessionWhereUniqueInput[]
    connect?: TutoringSessionWhereUniqueInput | TutoringSessionWhereUniqueInput[]
    update?: TutoringSessionUpdateWithWhereUniqueWithoutTeacherInput | TutoringSessionUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: TutoringSessionUpdateManyWithWhereWithoutTeacherInput | TutoringSessionUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: TutoringSessionScalarWhereInput | TutoringSessionScalarWhereInput[]
  }

  export type TutoringRequestUpdateManyWithoutStudentNestedInput = {
    create?: XOR<TutoringRequestCreateWithoutStudentInput, TutoringRequestUncheckedCreateWithoutStudentInput> | TutoringRequestCreateWithoutStudentInput[] | TutoringRequestUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: TutoringRequestCreateOrConnectWithoutStudentInput | TutoringRequestCreateOrConnectWithoutStudentInput[]
    upsert?: TutoringRequestUpsertWithWhereUniqueWithoutStudentInput | TutoringRequestUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: TutoringRequestCreateManyStudentInputEnvelope
    set?: TutoringRequestWhereUniqueInput | TutoringRequestWhereUniqueInput[]
    disconnect?: TutoringRequestWhereUniqueInput | TutoringRequestWhereUniqueInput[]
    delete?: TutoringRequestWhereUniqueInput | TutoringRequestWhereUniqueInput[]
    connect?: TutoringRequestWhereUniqueInput | TutoringRequestWhereUniqueInput[]
    update?: TutoringRequestUpdateWithWhereUniqueWithoutStudentInput | TutoringRequestUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: TutoringRequestUpdateManyWithWhereWithoutStudentInput | TutoringRequestUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: TutoringRequestScalarWhereInput | TutoringRequestScalarWhereInput[]
  }

  export type TutoringAppointmentUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<TutoringAppointmentCreateWithoutTeacherInput, TutoringAppointmentUncheckedCreateWithoutTeacherInput> | TutoringAppointmentCreateWithoutTeacherInput[] | TutoringAppointmentUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TutoringAppointmentCreateOrConnectWithoutTeacherInput | TutoringAppointmentCreateOrConnectWithoutTeacherInput[]
    upsert?: TutoringAppointmentUpsertWithWhereUniqueWithoutTeacherInput | TutoringAppointmentUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: TutoringAppointmentCreateManyTeacherInputEnvelope
    set?: TutoringAppointmentWhereUniqueInput | TutoringAppointmentWhereUniqueInput[]
    disconnect?: TutoringAppointmentWhereUniqueInput | TutoringAppointmentWhereUniqueInput[]
    delete?: TutoringAppointmentWhereUniqueInput | TutoringAppointmentWhereUniqueInput[]
    connect?: TutoringAppointmentWhereUniqueInput | TutoringAppointmentWhereUniqueInput[]
    update?: TutoringAppointmentUpdateWithWhereUniqueWithoutTeacherInput | TutoringAppointmentUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: TutoringAppointmentUpdateManyWithWhereWithoutTeacherInput | TutoringAppointmentUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: TutoringAppointmentScalarWhereInput | TutoringAppointmentScalarWhereInput[]
  }

  export type TutoringAppointmentUpdateManyWithoutStudentNestedInput = {
    create?: XOR<TutoringAppointmentCreateWithoutStudentInput, TutoringAppointmentUncheckedCreateWithoutStudentInput> | TutoringAppointmentCreateWithoutStudentInput[] | TutoringAppointmentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: TutoringAppointmentCreateOrConnectWithoutStudentInput | TutoringAppointmentCreateOrConnectWithoutStudentInput[]
    upsert?: TutoringAppointmentUpsertWithWhereUniqueWithoutStudentInput | TutoringAppointmentUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: TutoringAppointmentCreateManyStudentInputEnvelope
    set?: TutoringAppointmentWhereUniqueInput | TutoringAppointmentWhereUniqueInput[]
    disconnect?: TutoringAppointmentWhereUniqueInput | TutoringAppointmentWhereUniqueInput[]
    delete?: TutoringAppointmentWhereUniqueInput | TutoringAppointmentWhereUniqueInput[]
    connect?: TutoringAppointmentWhereUniqueInput | TutoringAppointmentWhereUniqueInput[]
    update?: TutoringAppointmentUpdateWithWhereUniqueWithoutStudentInput | TutoringAppointmentUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: TutoringAppointmentUpdateManyWithWhereWithoutStudentInput | TutoringAppointmentUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: TutoringAppointmentScalarWhereInput | TutoringAppointmentScalarWhereInput[]
  }

  export type TutoringReviewUpdateManyWithoutStudentNestedInput = {
    create?: XOR<TutoringReviewCreateWithoutStudentInput, TutoringReviewUncheckedCreateWithoutStudentInput> | TutoringReviewCreateWithoutStudentInput[] | TutoringReviewUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: TutoringReviewCreateOrConnectWithoutStudentInput | TutoringReviewCreateOrConnectWithoutStudentInput[]
    upsert?: TutoringReviewUpsertWithWhereUniqueWithoutStudentInput | TutoringReviewUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: TutoringReviewCreateManyStudentInputEnvelope
    set?: TutoringReviewWhereUniqueInput | TutoringReviewWhereUniqueInput[]
    disconnect?: TutoringReviewWhereUniqueInput | TutoringReviewWhereUniqueInput[]
    delete?: TutoringReviewWhereUniqueInput | TutoringReviewWhereUniqueInput[]
    connect?: TutoringReviewWhereUniqueInput | TutoringReviewWhereUniqueInput[]
    update?: TutoringReviewUpdateWithWhereUniqueWithoutStudentInput | TutoringReviewUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: TutoringReviewUpdateManyWithWhereWithoutStudentInput | TutoringReviewUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: TutoringReviewScalarWhereInput | TutoringReviewScalarWhereInput[]
  }

  export type TutoringMessageUpdateManyWithoutSenderNestedInput = {
    create?: XOR<TutoringMessageCreateWithoutSenderInput, TutoringMessageUncheckedCreateWithoutSenderInput> | TutoringMessageCreateWithoutSenderInput[] | TutoringMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: TutoringMessageCreateOrConnectWithoutSenderInput | TutoringMessageCreateOrConnectWithoutSenderInput[]
    upsert?: TutoringMessageUpsertWithWhereUniqueWithoutSenderInput | TutoringMessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: TutoringMessageCreateManySenderInputEnvelope
    set?: TutoringMessageWhereUniqueInput | TutoringMessageWhereUniqueInput[]
    disconnect?: TutoringMessageWhereUniqueInput | TutoringMessageWhereUniqueInput[]
    delete?: TutoringMessageWhereUniqueInput | TutoringMessageWhereUniqueInput[]
    connect?: TutoringMessageWhereUniqueInput | TutoringMessageWhereUniqueInput[]
    update?: TutoringMessageUpdateWithWhereUniqueWithoutSenderInput | TutoringMessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: TutoringMessageUpdateManyWithWhereWithoutSenderInput | TutoringMessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: TutoringMessageScalarWhereInput | TutoringMessageScalarWhereInput[]
  }

  export type UserAchievementUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserAchievementCreateWithoutUserInput, UserAchievementUncheckedCreateWithoutUserInput> | UserAchievementCreateWithoutUserInput[] | UserAchievementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutUserInput | UserAchievementCreateOrConnectWithoutUserInput[]
    upsert?: UserAchievementUpsertWithWhereUniqueWithoutUserInput | UserAchievementUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserAchievementCreateManyUserInputEnvelope
    set?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    disconnect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    delete?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    update?: UserAchievementUpdateWithWhereUniqueWithoutUserInput | UserAchievementUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserAchievementUpdateManyWithWhereWithoutUserInput | UserAchievementUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserAchievementScalarWhereInput | UserAchievementScalarWhereInput[]
  }

  export type CertificateUpdateManyWithoutUserNestedInput = {
    create?: XOR<CertificateCreateWithoutUserInput, CertificateUncheckedCreateWithoutUserInput> | CertificateCreateWithoutUserInput[] | CertificateUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutUserInput | CertificateCreateOrConnectWithoutUserInput[]
    upsert?: CertificateUpsertWithWhereUniqueWithoutUserInput | CertificateUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CertificateCreateManyUserInputEnvelope
    set?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    disconnect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    delete?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    update?: CertificateUpdateWithWhereUniqueWithoutUserInput | CertificateUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CertificateUpdateManyWithWhereWithoutUserInput | CertificateUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CertificateScalarWhereInput | CertificateScalarWhereInput[]
  }

  export type ConversationParticipantUpdateManyWithoutUserNestedInput = {
    create?: XOR<ConversationParticipantCreateWithoutUserInput, ConversationParticipantUncheckedCreateWithoutUserInput> | ConversationParticipantCreateWithoutUserInput[] | ConversationParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConversationParticipantCreateOrConnectWithoutUserInput | ConversationParticipantCreateOrConnectWithoutUserInput[]
    upsert?: ConversationParticipantUpsertWithWhereUniqueWithoutUserInput | ConversationParticipantUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ConversationParticipantCreateManyUserInputEnvelope
    set?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    disconnect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    delete?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    connect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    update?: ConversationParticipantUpdateWithWhereUniqueWithoutUserInput | ConversationParticipantUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ConversationParticipantUpdateManyWithWhereWithoutUserInput | ConversationParticipantUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ConversationParticipantScalarWhereInput | ConversationParticipantScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type AttachmentUpdateManyWithoutUserNestedInput = {
    create?: XOR<AttachmentCreateWithoutUserInput, AttachmentUncheckedCreateWithoutUserInput> | AttachmentCreateWithoutUserInput[] | AttachmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutUserInput | AttachmentCreateOrConnectWithoutUserInput[]
    upsert?: AttachmentUpsertWithWhereUniqueWithoutUserInput | AttachmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AttachmentCreateManyUserInputEnvelope
    set?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    disconnect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    delete?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    update?: AttachmentUpdateWithWhereUniqueWithoutUserInput | AttachmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AttachmentUpdateManyWithWhereWithoutUserInput | AttachmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type UserSubscriptionUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserSubscriptionCreateWithoutUserInput, UserSubscriptionUncheckedCreateWithoutUserInput> | UserSubscriptionCreateWithoutUserInput[] | UserSubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSubscriptionCreateOrConnectWithoutUserInput | UserSubscriptionCreateOrConnectWithoutUserInput[]
    upsert?: UserSubscriptionUpsertWithWhereUniqueWithoutUserInput | UserSubscriptionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserSubscriptionCreateManyUserInputEnvelope
    set?: UserSubscriptionWhereUniqueInput | UserSubscriptionWhereUniqueInput[]
    disconnect?: UserSubscriptionWhereUniqueInput | UserSubscriptionWhereUniqueInput[]
    delete?: UserSubscriptionWhereUniqueInput | UserSubscriptionWhereUniqueInput[]
    connect?: UserSubscriptionWhereUniqueInput | UserSubscriptionWhereUniqueInput[]
    update?: UserSubscriptionUpdateWithWhereUniqueWithoutUserInput | UserSubscriptionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserSubscriptionUpdateManyWithWhereWithoutUserInput | UserSubscriptionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserSubscriptionScalarWhereInput | UserSubscriptionScalarWhereInput[]
  }

  export type UserBundleUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserBundleCreateWithoutUserInput, UserBundleUncheckedCreateWithoutUserInput> | UserBundleCreateWithoutUserInput[] | UserBundleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserBundleCreateOrConnectWithoutUserInput | UserBundleCreateOrConnectWithoutUserInput[]
    upsert?: UserBundleUpsertWithWhereUniqueWithoutUserInput | UserBundleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserBundleCreateManyUserInputEnvelope
    set?: UserBundleWhereUniqueInput | UserBundleWhereUniqueInput[]
    disconnect?: UserBundleWhereUniqueInput | UserBundleWhereUniqueInput[]
    delete?: UserBundleWhereUniqueInput | UserBundleWhereUniqueInput[]
    connect?: UserBundleWhereUniqueInput | UserBundleWhereUniqueInput[]
    update?: UserBundleUpdateWithWhereUniqueWithoutUserInput | UserBundleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserBundleUpdateManyWithWhereWithoutUserInput | UserBundleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserBundleScalarWhereInput | UserBundleScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutUserNestedInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutUserInput | PaymentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutUserInput | PaymentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutUserInput | PaymentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type CalendarEventUpdateManyWithoutUserNestedInput = {
    create?: XOR<CalendarEventCreateWithoutUserInput, CalendarEventUncheckedCreateWithoutUserInput> | CalendarEventCreateWithoutUserInput[] | CalendarEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CalendarEventCreateOrConnectWithoutUserInput | CalendarEventCreateOrConnectWithoutUserInput[]
    upsert?: CalendarEventUpsertWithWhereUniqueWithoutUserInput | CalendarEventUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CalendarEventCreateManyUserInputEnvelope
    set?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    disconnect?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    delete?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    connect?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    update?: CalendarEventUpdateWithWhereUniqueWithoutUserInput | CalendarEventUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CalendarEventUpdateManyWithWhereWithoutUserInput | CalendarEventUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CalendarEventScalarWhereInput | CalendarEventScalarWhereInput[]
  }

  export type CalendarEventUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<CalendarEventCreateWithoutTeacherInput, CalendarEventUncheckedCreateWithoutTeacherInput> | CalendarEventCreateWithoutTeacherInput[] | CalendarEventUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: CalendarEventCreateOrConnectWithoutTeacherInput | CalendarEventCreateOrConnectWithoutTeacherInput[]
    upsert?: CalendarEventUpsertWithWhereUniqueWithoutTeacherInput | CalendarEventUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: CalendarEventCreateManyTeacherInputEnvelope
    set?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    disconnect?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    delete?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    connect?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    update?: CalendarEventUpdateWithWhereUniqueWithoutTeacherInput | CalendarEventUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: CalendarEventUpdateManyWithWhereWithoutTeacherInput | CalendarEventUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: CalendarEventScalarWhereInput | CalendarEventScalarWhereInput[]
  }

  export type CalendarEventUpdateManyWithoutStudentNestedInput = {
    create?: XOR<CalendarEventCreateWithoutStudentInput, CalendarEventUncheckedCreateWithoutStudentInput> | CalendarEventCreateWithoutStudentInput[] | CalendarEventUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: CalendarEventCreateOrConnectWithoutStudentInput | CalendarEventCreateOrConnectWithoutStudentInput[]
    upsert?: CalendarEventUpsertWithWhereUniqueWithoutStudentInput | CalendarEventUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: CalendarEventCreateManyStudentInputEnvelope
    set?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    disconnect?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    delete?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    connect?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    update?: CalendarEventUpdateWithWhereUniqueWithoutStudentInput | CalendarEventUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: CalendarEventUpdateManyWithWhereWithoutStudentInput | CalendarEventUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: CalendarEventScalarWhereInput | CalendarEventScalarWhereInput[]
  }

  export type BlogPostUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<BlogPostCreateWithoutAuthorInput, BlogPostUncheckedCreateWithoutAuthorInput> | BlogPostCreateWithoutAuthorInput[] | BlogPostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: BlogPostCreateOrConnectWithoutAuthorInput | BlogPostCreateOrConnectWithoutAuthorInput[]
    upsert?: BlogPostUpsertWithWhereUniqueWithoutAuthorInput | BlogPostUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: BlogPostCreateManyAuthorInputEnvelope
    set?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    disconnect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    delete?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    connect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    update?: BlogPostUpdateWithWhereUniqueWithoutAuthorInput | BlogPostUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: BlogPostUpdateManyWithWhereWithoutAuthorInput | BlogPostUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: BlogPostScalarWhereInput | BlogPostScalarWhereInput[]
  }

  export type BlogCommentUpdateManyWithoutUserNestedInput = {
    create?: XOR<BlogCommentCreateWithoutUserInput, BlogCommentUncheckedCreateWithoutUserInput> | BlogCommentCreateWithoutUserInput[] | BlogCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BlogCommentCreateOrConnectWithoutUserInput | BlogCommentCreateOrConnectWithoutUserInput[]
    upsert?: BlogCommentUpsertWithWhereUniqueWithoutUserInput | BlogCommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BlogCommentCreateManyUserInputEnvelope
    set?: BlogCommentWhereUniqueInput | BlogCommentWhereUniqueInput[]
    disconnect?: BlogCommentWhereUniqueInput | BlogCommentWhereUniqueInput[]
    delete?: BlogCommentWhereUniqueInput | BlogCommentWhereUniqueInput[]
    connect?: BlogCommentWhereUniqueInput | BlogCommentWhereUniqueInput[]
    update?: BlogCommentUpdateWithWhereUniqueWithoutUserInput | BlogCommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BlogCommentUpdateManyWithWhereWithoutUserInput | BlogCommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BlogCommentScalarWhereInput | BlogCommentScalarWhereInput[]
  }

  export type AssignmentSubmissionUpdateManyWithoutGradedByNestedInput = {
    create?: XOR<AssignmentSubmissionCreateWithoutGradedByInput, AssignmentSubmissionUncheckedCreateWithoutGradedByInput> | AssignmentSubmissionCreateWithoutGradedByInput[] | AssignmentSubmissionUncheckedCreateWithoutGradedByInput[]
    connectOrCreate?: AssignmentSubmissionCreateOrConnectWithoutGradedByInput | AssignmentSubmissionCreateOrConnectWithoutGradedByInput[]
    upsert?: AssignmentSubmissionUpsertWithWhereUniqueWithoutGradedByInput | AssignmentSubmissionUpsertWithWhereUniqueWithoutGradedByInput[]
    createMany?: AssignmentSubmissionCreateManyGradedByInputEnvelope
    set?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
    disconnect?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
    delete?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
    connect?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
    update?: AssignmentSubmissionUpdateWithWhereUniqueWithoutGradedByInput | AssignmentSubmissionUpdateWithWhereUniqueWithoutGradedByInput[]
    updateMany?: AssignmentSubmissionUpdateManyWithWhereWithoutGradedByInput | AssignmentSubmissionUpdateManyWithWhereWithoutGradedByInput[]
    deleteMany?: AssignmentSubmissionScalarWhereInput | AssignmentSubmissionScalarWhereInput[]
  }

  export type ReferralCodeUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReferralCodeCreateWithoutUserInput, ReferralCodeUncheckedCreateWithoutUserInput> | ReferralCodeCreateWithoutUserInput[] | ReferralCodeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReferralCodeCreateOrConnectWithoutUserInput | ReferralCodeCreateOrConnectWithoutUserInput[]
    upsert?: ReferralCodeUpsertWithWhereUniqueWithoutUserInput | ReferralCodeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReferralCodeCreateManyUserInputEnvelope
    set?: ReferralCodeWhereUniqueInput | ReferralCodeWhereUniqueInput[]
    disconnect?: ReferralCodeWhereUniqueInput | ReferralCodeWhereUniqueInput[]
    delete?: ReferralCodeWhereUniqueInput | ReferralCodeWhereUniqueInput[]
    connect?: ReferralCodeWhereUniqueInput | ReferralCodeWhereUniqueInput[]
    update?: ReferralCodeUpdateWithWhereUniqueWithoutUserInput | ReferralCodeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReferralCodeUpdateManyWithWhereWithoutUserInput | ReferralCodeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReferralCodeScalarWhereInput | ReferralCodeScalarWhereInput[]
  }

  export type ReferralUseUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReferralUseCreateWithoutUserInput, ReferralUseUncheckedCreateWithoutUserInput> | ReferralUseCreateWithoutUserInput[] | ReferralUseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReferralUseCreateOrConnectWithoutUserInput | ReferralUseCreateOrConnectWithoutUserInput[]
    upsert?: ReferralUseUpsertWithWhereUniqueWithoutUserInput | ReferralUseUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReferralUseCreateManyUserInputEnvelope
    set?: ReferralUseWhereUniqueInput | ReferralUseWhereUniqueInput[]
    disconnect?: ReferralUseWhereUniqueInput | ReferralUseWhereUniqueInput[]
    delete?: ReferralUseWhereUniqueInput | ReferralUseWhereUniqueInput[]
    connect?: ReferralUseWhereUniqueInput | ReferralUseWhereUniqueInput[]
    update?: ReferralUseUpdateWithWhereUniqueWithoutUserInput | ReferralUseUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReferralUseUpdateManyWithWhereWithoutUserInput | ReferralUseUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReferralUseScalarWhereInput | ReferralUseScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutReferredByNestedInput = {
    create?: XOR<UserCreateWithoutReferredByInput, UserUncheckedCreateWithoutReferredByInput> | UserCreateWithoutReferredByInput[] | UserUncheckedCreateWithoutReferredByInput[]
    connectOrCreate?: UserCreateOrConnectWithoutReferredByInput | UserCreateOrConnectWithoutReferredByInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutReferredByInput | UserUpsertWithWhereUniqueWithoutReferredByInput[]
    createMany?: UserCreateManyReferredByInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutReferredByInput | UserUpdateWithWhereUniqueWithoutReferredByInput[]
    updateMany?: UserUpdateManyWithWhereWithoutReferredByInput | UserUpdateManyWithWhereWithoutReferredByInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type TeacherProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<TeacherProfileCreateWithoutUserInput, TeacherProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: TeacherProfileCreateOrConnectWithoutUserInput
    upsert?: TeacherProfileUpsertWithoutUserInput
    disconnect?: TeacherProfileWhereInput | boolean
    delete?: TeacherProfileWhereInput | boolean
    connect?: TeacherProfileWhereUniqueInput
    update?: XOR<XOR<TeacherProfileUpdateToOneWithWhereWithoutUserInput, TeacherProfileUpdateWithoutUserInput>, TeacherProfileUncheckedUpdateWithoutUserInput>
  }

  export type UserAvailabilityUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserAvailabilityCreateWithoutUserInput, UserAvailabilityUncheckedCreateWithoutUserInput> | UserAvailabilityCreateWithoutUserInput[] | UserAvailabilityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAvailabilityCreateOrConnectWithoutUserInput | UserAvailabilityCreateOrConnectWithoutUserInput[]
    upsert?: UserAvailabilityUpsertWithWhereUniqueWithoutUserInput | UserAvailabilityUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserAvailabilityCreateManyUserInputEnvelope
    set?: UserAvailabilityWhereUniqueInput | UserAvailabilityWhereUniqueInput[]
    disconnect?: UserAvailabilityWhereUniqueInput | UserAvailabilityWhereUniqueInput[]
    delete?: UserAvailabilityWhereUniqueInput | UserAvailabilityWhereUniqueInput[]
    connect?: UserAvailabilityWhereUniqueInput | UserAvailabilityWhereUniqueInput[]
    update?: UserAvailabilityUpdateWithWhereUniqueWithoutUserInput | UserAvailabilityUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserAvailabilityUpdateManyWithWhereWithoutUserInput | UserAvailabilityUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserAvailabilityScalarWhereInput | UserAvailabilityScalarWhereInput[]
  }

  export type PointsTransactionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PointsTransactionCreateWithoutUserInput, PointsTransactionUncheckedCreateWithoutUserInput> | PointsTransactionCreateWithoutUserInput[] | PointsTransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PointsTransactionCreateOrConnectWithoutUserInput | PointsTransactionCreateOrConnectWithoutUserInput[]
    upsert?: PointsTransactionUpsertWithWhereUniqueWithoutUserInput | PointsTransactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PointsTransactionCreateManyUserInputEnvelope
    set?: PointsTransactionWhereUniqueInput | PointsTransactionWhereUniqueInput[]
    disconnect?: PointsTransactionWhereUniqueInput | PointsTransactionWhereUniqueInput[]
    delete?: PointsTransactionWhereUniqueInput | PointsTransactionWhereUniqueInput[]
    connect?: PointsTransactionWhereUniqueInput | PointsTransactionWhereUniqueInput[]
    update?: PointsTransactionUpdateWithWhereUniqueWithoutUserInput | PointsTransactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PointsTransactionUpdateManyWithWhereWithoutUserInput | PointsTransactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PointsTransactionScalarWhereInput | PointsTransactionScalarWhereInput[]
  }

  export type CourseUncheckedUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<CourseCreateWithoutTeacherInput, CourseUncheckedCreateWithoutTeacherInput> | CourseCreateWithoutTeacherInput[] | CourseUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutTeacherInput | CourseCreateOrConnectWithoutTeacherInput[]
    upsert?: CourseUpsertWithWhereUniqueWithoutTeacherInput | CourseUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: CourseCreateManyTeacherInputEnvelope
    set?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    disconnect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    delete?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    update?: CourseUpdateWithWhereUniqueWithoutTeacherInput | CourseUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: CourseUpdateManyWithWhereWithoutTeacherInput | CourseUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: CourseScalarWhereInput | CourseScalarWhereInput[]
  }

  export type EnrollmentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<EnrollmentCreateWithoutUserInput, EnrollmentUncheckedCreateWithoutUserInput> | EnrollmentCreateWithoutUserInput[] | EnrollmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutUserInput | EnrollmentCreateOrConnectWithoutUserInput[]
    upsert?: EnrollmentUpsertWithWhereUniqueWithoutUserInput | EnrollmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EnrollmentCreateManyUserInputEnvelope
    set?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    disconnect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    delete?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    update?: EnrollmentUpdateWithWhereUniqueWithoutUserInput | EnrollmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EnrollmentUpdateManyWithWhereWithoutUserInput | EnrollmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EnrollmentScalarWhereInput | EnrollmentScalarWhereInput[]
  }

  export type SavedCourseUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SavedCourseCreateWithoutUserInput, SavedCourseUncheckedCreateWithoutUserInput> | SavedCourseCreateWithoutUserInput[] | SavedCourseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SavedCourseCreateOrConnectWithoutUserInput | SavedCourseCreateOrConnectWithoutUserInput[]
    upsert?: SavedCourseUpsertWithWhereUniqueWithoutUserInput | SavedCourseUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SavedCourseCreateManyUserInputEnvelope
    set?: SavedCourseWhereUniqueInput | SavedCourseWhereUniqueInput[]
    disconnect?: SavedCourseWhereUniqueInput | SavedCourseWhereUniqueInput[]
    delete?: SavedCourseWhereUniqueInput | SavedCourseWhereUniqueInput[]
    connect?: SavedCourseWhereUniqueInput | SavedCourseWhereUniqueInput[]
    update?: SavedCourseUpdateWithWhereUniqueWithoutUserInput | SavedCourseUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SavedCourseUpdateManyWithWhereWithoutUserInput | SavedCourseUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SavedCourseScalarWhereInput | SavedCourseScalarWhereInput[]
  }

  export type LikedCourseUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LikedCourseCreateWithoutUserInput, LikedCourseUncheckedCreateWithoutUserInput> | LikedCourseCreateWithoutUserInput[] | LikedCourseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LikedCourseCreateOrConnectWithoutUserInput | LikedCourseCreateOrConnectWithoutUserInput[]
    upsert?: LikedCourseUpsertWithWhereUniqueWithoutUserInput | LikedCourseUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LikedCourseCreateManyUserInputEnvelope
    set?: LikedCourseWhereUniqueInput | LikedCourseWhereUniqueInput[]
    disconnect?: LikedCourseWhereUniqueInput | LikedCourseWhereUniqueInput[]
    delete?: LikedCourseWhereUniqueInput | LikedCourseWhereUniqueInput[]
    connect?: LikedCourseWhereUniqueInput | LikedCourseWhereUniqueInput[]
    update?: LikedCourseUpdateWithWhereUniqueWithoutUserInput | LikedCourseUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LikedCourseUpdateManyWithWhereWithoutUserInput | LikedCourseUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LikedCourseScalarWhereInput | LikedCourseScalarWhereInput[]
  }

  export type LessonProgressUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LessonProgressCreateWithoutUserInput, LessonProgressUncheckedCreateWithoutUserInput> | LessonProgressCreateWithoutUserInput[] | LessonProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LessonProgressCreateOrConnectWithoutUserInput | LessonProgressCreateOrConnectWithoutUserInput[]
    upsert?: LessonProgressUpsertWithWhereUniqueWithoutUserInput | LessonProgressUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LessonProgressCreateManyUserInputEnvelope
    set?: LessonProgressWhereUniqueInput | LessonProgressWhereUniqueInput[]
    disconnect?: LessonProgressWhereUniqueInput | LessonProgressWhereUniqueInput[]
    delete?: LessonProgressWhereUniqueInput | LessonProgressWhereUniqueInput[]
    connect?: LessonProgressWhereUniqueInput | LessonProgressWhereUniqueInput[]
    update?: LessonProgressUpdateWithWhereUniqueWithoutUserInput | LessonProgressUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LessonProgressUpdateManyWithWhereWithoutUserInput | LessonProgressUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LessonProgressScalarWhereInput | LessonProgressScalarWhereInput[]
  }

  export type QuizAttemptUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<QuizAttemptCreateWithoutUserInput, QuizAttemptUncheckedCreateWithoutUserInput> | QuizAttemptCreateWithoutUserInput[] | QuizAttemptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: QuizAttemptCreateOrConnectWithoutUserInput | QuizAttemptCreateOrConnectWithoutUserInput[]
    upsert?: QuizAttemptUpsertWithWhereUniqueWithoutUserInput | QuizAttemptUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: QuizAttemptCreateManyUserInputEnvelope
    set?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    disconnect?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    delete?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    connect?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    update?: QuizAttemptUpdateWithWhereUniqueWithoutUserInput | QuizAttemptUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: QuizAttemptUpdateManyWithWhereWithoutUserInput | QuizAttemptUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: QuizAttemptScalarWhereInput | QuizAttemptScalarWhereInput[]
  }

  export type AssignmentSubmissionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AssignmentSubmissionCreateWithoutUserInput, AssignmentSubmissionUncheckedCreateWithoutUserInput> | AssignmentSubmissionCreateWithoutUserInput[] | AssignmentSubmissionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AssignmentSubmissionCreateOrConnectWithoutUserInput | AssignmentSubmissionCreateOrConnectWithoutUserInput[]
    upsert?: AssignmentSubmissionUpsertWithWhereUniqueWithoutUserInput | AssignmentSubmissionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AssignmentSubmissionCreateManyUserInputEnvelope
    set?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
    disconnect?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
    delete?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
    connect?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
    update?: AssignmentSubmissionUpdateWithWhereUniqueWithoutUserInput | AssignmentSubmissionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AssignmentSubmissionUpdateManyWithWhereWithoutUserInput | AssignmentSubmissionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AssignmentSubmissionScalarWhereInput | AssignmentSubmissionScalarWhereInput[]
  }

  export type CourseReviewUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CourseReviewCreateWithoutUserInput, CourseReviewUncheckedCreateWithoutUserInput> | CourseReviewCreateWithoutUserInput[] | CourseReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CourseReviewCreateOrConnectWithoutUserInput | CourseReviewCreateOrConnectWithoutUserInput[]
    upsert?: CourseReviewUpsertWithWhereUniqueWithoutUserInput | CourseReviewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CourseReviewCreateManyUserInputEnvelope
    set?: CourseReviewWhereUniqueInput | CourseReviewWhereUniqueInput[]
    disconnect?: CourseReviewWhereUniqueInput | CourseReviewWhereUniqueInput[]
    delete?: CourseReviewWhereUniqueInput | CourseReviewWhereUniqueInput[]
    connect?: CourseReviewWhereUniqueInput | CourseReviewWhereUniqueInput[]
    update?: CourseReviewUpdateWithWhereUniqueWithoutUserInput | CourseReviewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CourseReviewUpdateManyWithWhereWithoutUserInput | CourseReviewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CourseReviewScalarWhereInput | CourseReviewScalarWhereInput[]
  }

  export type TutoringSessionUncheckedUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<TutoringSessionCreateWithoutTeacherInput, TutoringSessionUncheckedCreateWithoutTeacherInput> | TutoringSessionCreateWithoutTeacherInput[] | TutoringSessionUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TutoringSessionCreateOrConnectWithoutTeacherInput | TutoringSessionCreateOrConnectWithoutTeacherInput[]
    upsert?: TutoringSessionUpsertWithWhereUniqueWithoutTeacherInput | TutoringSessionUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: TutoringSessionCreateManyTeacherInputEnvelope
    set?: TutoringSessionWhereUniqueInput | TutoringSessionWhereUniqueInput[]
    disconnect?: TutoringSessionWhereUniqueInput | TutoringSessionWhereUniqueInput[]
    delete?: TutoringSessionWhereUniqueInput | TutoringSessionWhereUniqueInput[]
    connect?: TutoringSessionWhereUniqueInput | TutoringSessionWhereUniqueInput[]
    update?: TutoringSessionUpdateWithWhereUniqueWithoutTeacherInput | TutoringSessionUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: TutoringSessionUpdateManyWithWhereWithoutTeacherInput | TutoringSessionUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: TutoringSessionScalarWhereInput | TutoringSessionScalarWhereInput[]
  }

  export type TutoringRequestUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<TutoringRequestCreateWithoutStudentInput, TutoringRequestUncheckedCreateWithoutStudentInput> | TutoringRequestCreateWithoutStudentInput[] | TutoringRequestUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: TutoringRequestCreateOrConnectWithoutStudentInput | TutoringRequestCreateOrConnectWithoutStudentInput[]
    upsert?: TutoringRequestUpsertWithWhereUniqueWithoutStudentInput | TutoringRequestUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: TutoringRequestCreateManyStudentInputEnvelope
    set?: TutoringRequestWhereUniqueInput | TutoringRequestWhereUniqueInput[]
    disconnect?: TutoringRequestWhereUniqueInput | TutoringRequestWhereUniqueInput[]
    delete?: TutoringRequestWhereUniqueInput | TutoringRequestWhereUniqueInput[]
    connect?: TutoringRequestWhereUniqueInput | TutoringRequestWhereUniqueInput[]
    update?: TutoringRequestUpdateWithWhereUniqueWithoutStudentInput | TutoringRequestUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: TutoringRequestUpdateManyWithWhereWithoutStudentInput | TutoringRequestUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: TutoringRequestScalarWhereInput | TutoringRequestScalarWhereInput[]
  }

  export type TutoringAppointmentUncheckedUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<TutoringAppointmentCreateWithoutTeacherInput, TutoringAppointmentUncheckedCreateWithoutTeacherInput> | TutoringAppointmentCreateWithoutTeacherInput[] | TutoringAppointmentUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TutoringAppointmentCreateOrConnectWithoutTeacherInput | TutoringAppointmentCreateOrConnectWithoutTeacherInput[]
    upsert?: TutoringAppointmentUpsertWithWhereUniqueWithoutTeacherInput | TutoringAppointmentUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: TutoringAppointmentCreateManyTeacherInputEnvelope
    set?: TutoringAppointmentWhereUniqueInput | TutoringAppointmentWhereUniqueInput[]
    disconnect?: TutoringAppointmentWhereUniqueInput | TutoringAppointmentWhereUniqueInput[]
    delete?: TutoringAppointmentWhereUniqueInput | TutoringAppointmentWhereUniqueInput[]
    connect?: TutoringAppointmentWhereUniqueInput | TutoringAppointmentWhereUniqueInput[]
    update?: TutoringAppointmentUpdateWithWhereUniqueWithoutTeacherInput | TutoringAppointmentUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: TutoringAppointmentUpdateManyWithWhereWithoutTeacherInput | TutoringAppointmentUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: TutoringAppointmentScalarWhereInput | TutoringAppointmentScalarWhereInput[]
  }

  export type TutoringAppointmentUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<TutoringAppointmentCreateWithoutStudentInput, TutoringAppointmentUncheckedCreateWithoutStudentInput> | TutoringAppointmentCreateWithoutStudentInput[] | TutoringAppointmentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: TutoringAppointmentCreateOrConnectWithoutStudentInput | TutoringAppointmentCreateOrConnectWithoutStudentInput[]
    upsert?: TutoringAppointmentUpsertWithWhereUniqueWithoutStudentInput | TutoringAppointmentUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: TutoringAppointmentCreateManyStudentInputEnvelope
    set?: TutoringAppointmentWhereUniqueInput | TutoringAppointmentWhereUniqueInput[]
    disconnect?: TutoringAppointmentWhereUniqueInput | TutoringAppointmentWhereUniqueInput[]
    delete?: TutoringAppointmentWhereUniqueInput | TutoringAppointmentWhereUniqueInput[]
    connect?: TutoringAppointmentWhereUniqueInput | TutoringAppointmentWhereUniqueInput[]
    update?: TutoringAppointmentUpdateWithWhereUniqueWithoutStudentInput | TutoringAppointmentUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: TutoringAppointmentUpdateManyWithWhereWithoutStudentInput | TutoringAppointmentUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: TutoringAppointmentScalarWhereInput | TutoringAppointmentScalarWhereInput[]
  }

  export type TutoringReviewUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<TutoringReviewCreateWithoutStudentInput, TutoringReviewUncheckedCreateWithoutStudentInput> | TutoringReviewCreateWithoutStudentInput[] | TutoringReviewUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: TutoringReviewCreateOrConnectWithoutStudentInput | TutoringReviewCreateOrConnectWithoutStudentInput[]
    upsert?: TutoringReviewUpsertWithWhereUniqueWithoutStudentInput | TutoringReviewUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: TutoringReviewCreateManyStudentInputEnvelope
    set?: TutoringReviewWhereUniqueInput | TutoringReviewWhereUniqueInput[]
    disconnect?: TutoringReviewWhereUniqueInput | TutoringReviewWhereUniqueInput[]
    delete?: TutoringReviewWhereUniqueInput | TutoringReviewWhereUniqueInput[]
    connect?: TutoringReviewWhereUniqueInput | TutoringReviewWhereUniqueInput[]
    update?: TutoringReviewUpdateWithWhereUniqueWithoutStudentInput | TutoringReviewUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: TutoringReviewUpdateManyWithWhereWithoutStudentInput | TutoringReviewUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: TutoringReviewScalarWhereInput | TutoringReviewScalarWhereInput[]
  }

  export type TutoringMessageUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<TutoringMessageCreateWithoutSenderInput, TutoringMessageUncheckedCreateWithoutSenderInput> | TutoringMessageCreateWithoutSenderInput[] | TutoringMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: TutoringMessageCreateOrConnectWithoutSenderInput | TutoringMessageCreateOrConnectWithoutSenderInput[]
    upsert?: TutoringMessageUpsertWithWhereUniqueWithoutSenderInput | TutoringMessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: TutoringMessageCreateManySenderInputEnvelope
    set?: TutoringMessageWhereUniqueInput | TutoringMessageWhereUniqueInput[]
    disconnect?: TutoringMessageWhereUniqueInput | TutoringMessageWhereUniqueInput[]
    delete?: TutoringMessageWhereUniqueInput | TutoringMessageWhereUniqueInput[]
    connect?: TutoringMessageWhereUniqueInput | TutoringMessageWhereUniqueInput[]
    update?: TutoringMessageUpdateWithWhereUniqueWithoutSenderInput | TutoringMessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: TutoringMessageUpdateManyWithWhereWithoutSenderInput | TutoringMessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: TutoringMessageScalarWhereInput | TutoringMessageScalarWhereInput[]
  }

  export type UserAchievementUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserAchievementCreateWithoutUserInput, UserAchievementUncheckedCreateWithoutUserInput> | UserAchievementCreateWithoutUserInput[] | UserAchievementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutUserInput | UserAchievementCreateOrConnectWithoutUserInput[]
    upsert?: UserAchievementUpsertWithWhereUniqueWithoutUserInput | UserAchievementUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserAchievementCreateManyUserInputEnvelope
    set?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    disconnect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    delete?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    update?: UserAchievementUpdateWithWhereUniqueWithoutUserInput | UserAchievementUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserAchievementUpdateManyWithWhereWithoutUserInput | UserAchievementUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserAchievementScalarWhereInput | UserAchievementScalarWhereInput[]
  }

  export type CertificateUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CertificateCreateWithoutUserInput, CertificateUncheckedCreateWithoutUserInput> | CertificateCreateWithoutUserInput[] | CertificateUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutUserInput | CertificateCreateOrConnectWithoutUserInput[]
    upsert?: CertificateUpsertWithWhereUniqueWithoutUserInput | CertificateUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CertificateCreateManyUserInputEnvelope
    set?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    disconnect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    delete?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    update?: CertificateUpdateWithWhereUniqueWithoutUserInput | CertificateUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CertificateUpdateManyWithWhereWithoutUserInput | CertificateUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CertificateScalarWhereInput | CertificateScalarWhereInput[]
  }

  export type ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ConversationParticipantCreateWithoutUserInput, ConversationParticipantUncheckedCreateWithoutUserInput> | ConversationParticipantCreateWithoutUserInput[] | ConversationParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConversationParticipantCreateOrConnectWithoutUserInput | ConversationParticipantCreateOrConnectWithoutUserInput[]
    upsert?: ConversationParticipantUpsertWithWhereUniqueWithoutUserInput | ConversationParticipantUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ConversationParticipantCreateManyUserInputEnvelope
    set?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    disconnect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    delete?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    connect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    update?: ConversationParticipantUpdateWithWhereUniqueWithoutUserInput | ConversationParticipantUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ConversationParticipantUpdateManyWithWhereWithoutUserInput | ConversationParticipantUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ConversationParticipantScalarWhereInput | ConversationParticipantScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type AttachmentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AttachmentCreateWithoutUserInput, AttachmentUncheckedCreateWithoutUserInput> | AttachmentCreateWithoutUserInput[] | AttachmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutUserInput | AttachmentCreateOrConnectWithoutUserInput[]
    upsert?: AttachmentUpsertWithWhereUniqueWithoutUserInput | AttachmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AttachmentCreateManyUserInputEnvelope
    set?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    disconnect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    delete?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    update?: AttachmentUpdateWithWhereUniqueWithoutUserInput | AttachmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AttachmentUpdateManyWithWhereWithoutUserInput | AttachmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type UserSubscriptionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserSubscriptionCreateWithoutUserInput, UserSubscriptionUncheckedCreateWithoutUserInput> | UserSubscriptionCreateWithoutUserInput[] | UserSubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSubscriptionCreateOrConnectWithoutUserInput | UserSubscriptionCreateOrConnectWithoutUserInput[]
    upsert?: UserSubscriptionUpsertWithWhereUniqueWithoutUserInput | UserSubscriptionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserSubscriptionCreateManyUserInputEnvelope
    set?: UserSubscriptionWhereUniqueInput | UserSubscriptionWhereUniqueInput[]
    disconnect?: UserSubscriptionWhereUniqueInput | UserSubscriptionWhereUniqueInput[]
    delete?: UserSubscriptionWhereUniqueInput | UserSubscriptionWhereUniqueInput[]
    connect?: UserSubscriptionWhereUniqueInput | UserSubscriptionWhereUniqueInput[]
    update?: UserSubscriptionUpdateWithWhereUniqueWithoutUserInput | UserSubscriptionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserSubscriptionUpdateManyWithWhereWithoutUserInput | UserSubscriptionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserSubscriptionScalarWhereInput | UserSubscriptionScalarWhereInput[]
  }

  export type UserBundleUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserBundleCreateWithoutUserInput, UserBundleUncheckedCreateWithoutUserInput> | UserBundleCreateWithoutUserInput[] | UserBundleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserBundleCreateOrConnectWithoutUserInput | UserBundleCreateOrConnectWithoutUserInput[]
    upsert?: UserBundleUpsertWithWhereUniqueWithoutUserInput | UserBundleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserBundleCreateManyUserInputEnvelope
    set?: UserBundleWhereUniqueInput | UserBundleWhereUniqueInput[]
    disconnect?: UserBundleWhereUniqueInput | UserBundleWhereUniqueInput[]
    delete?: UserBundleWhereUniqueInput | UserBundleWhereUniqueInput[]
    connect?: UserBundleWhereUniqueInput | UserBundleWhereUniqueInput[]
    update?: UserBundleUpdateWithWhereUniqueWithoutUserInput | UserBundleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserBundleUpdateManyWithWhereWithoutUserInput | UserBundleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserBundleScalarWhereInput | UserBundleScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutUserInput | PaymentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutUserInput | PaymentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutUserInput | PaymentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type CalendarEventUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CalendarEventCreateWithoutUserInput, CalendarEventUncheckedCreateWithoutUserInput> | CalendarEventCreateWithoutUserInput[] | CalendarEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CalendarEventCreateOrConnectWithoutUserInput | CalendarEventCreateOrConnectWithoutUserInput[]
    upsert?: CalendarEventUpsertWithWhereUniqueWithoutUserInput | CalendarEventUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CalendarEventCreateManyUserInputEnvelope
    set?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    disconnect?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    delete?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    connect?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    update?: CalendarEventUpdateWithWhereUniqueWithoutUserInput | CalendarEventUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CalendarEventUpdateManyWithWhereWithoutUserInput | CalendarEventUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CalendarEventScalarWhereInput | CalendarEventScalarWhereInput[]
  }

  export type CalendarEventUncheckedUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<CalendarEventCreateWithoutTeacherInput, CalendarEventUncheckedCreateWithoutTeacherInput> | CalendarEventCreateWithoutTeacherInput[] | CalendarEventUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: CalendarEventCreateOrConnectWithoutTeacherInput | CalendarEventCreateOrConnectWithoutTeacherInput[]
    upsert?: CalendarEventUpsertWithWhereUniqueWithoutTeacherInput | CalendarEventUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: CalendarEventCreateManyTeacherInputEnvelope
    set?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    disconnect?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    delete?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    connect?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    update?: CalendarEventUpdateWithWhereUniqueWithoutTeacherInput | CalendarEventUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: CalendarEventUpdateManyWithWhereWithoutTeacherInput | CalendarEventUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: CalendarEventScalarWhereInput | CalendarEventScalarWhereInput[]
  }

  export type CalendarEventUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<CalendarEventCreateWithoutStudentInput, CalendarEventUncheckedCreateWithoutStudentInput> | CalendarEventCreateWithoutStudentInput[] | CalendarEventUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: CalendarEventCreateOrConnectWithoutStudentInput | CalendarEventCreateOrConnectWithoutStudentInput[]
    upsert?: CalendarEventUpsertWithWhereUniqueWithoutStudentInput | CalendarEventUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: CalendarEventCreateManyStudentInputEnvelope
    set?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    disconnect?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    delete?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    connect?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    update?: CalendarEventUpdateWithWhereUniqueWithoutStudentInput | CalendarEventUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: CalendarEventUpdateManyWithWhereWithoutStudentInput | CalendarEventUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: CalendarEventScalarWhereInput | CalendarEventScalarWhereInput[]
  }

  export type BlogPostUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<BlogPostCreateWithoutAuthorInput, BlogPostUncheckedCreateWithoutAuthorInput> | BlogPostCreateWithoutAuthorInput[] | BlogPostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: BlogPostCreateOrConnectWithoutAuthorInput | BlogPostCreateOrConnectWithoutAuthorInput[]
    upsert?: BlogPostUpsertWithWhereUniqueWithoutAuthorInput | BlogPostUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: BlogPostCreateManyAuthorInputEnvelope
    set?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    disconnect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    delete?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    connect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    update?: BlogPostUpdateWithWhereUniqueWithoutAuthorInput | BlogPostUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: BlogPostUpdateManyWithWhereWithoutAuthorInput | BlogPostUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: BlogPostScalarWhereInput | BlogPostScalarWhereInput[]
  }

  export type BlogCommentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BlogCommentCreateWithoutUserInput, BlogCommentUncheckedCreateWithoutUserInput> | BlogCommentCreateWithoutUserInput[] | BlogCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BlogCommentCreateOrConnectWithoutUserInput | BlogCommentCreateOrConnectWithoutUserInput[]
    upsert?: BlogCommentUpsertWithWhereUniqueWithoutUserInput | BlogCommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BlogCommentCreateManyUserInputEnvelope
    set?: BlogCommentWhereUniqueInput | BlogCommentWhereUniqueInput[]
    disconnect?: BlogCommentWhereUniqueInput | BlogCommentWhereUniqueInput[]
    delete?: BlogCommentWhereUniqueInput | BlogCommentWhereUniqueInput[]
    connect?: BlogCommentWhereUniqueInput | BlogCommentWhereUniqueInput[]
    update?: BlogCommentUpdateWithWhereUniqueWithoutUserInput | BlogCommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BlogCommentUpdateManyWithWhereWithoutUserInput | BlogCommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BlogCommentScalarWhereInput | BlogCommentScalarWhereInput[]
  }

  export type AssignmentSubmissionUncheckedUpdateManyWithoutGradedByNestedInput = {
    create?: XOR<AssignmentSubmissionCreateWithoutGradedByInput, AssignmentSubmissionUncheckedCreateWithoutGradedByInput> | AssignmentSubmissionCreateWithoutGradedByInput[] | AssignmentSubmissionUncheckedCreateWithoutGradedByInput[]
    connectOrCreate?: AssignmentSubmissionCreateOrConnectWithoutGradedByInput | AssignmentSubmissionCreateOrConnectWithoutGradedByInput[]
    upsert?: AssignmentSubmissionUpsertWithWhereUniqueWithoutGradedByInput | AssignmentSubmissionUpsertWithWhereUniqueWithoutGradedByInput[]
    createMany?: AssignmentSubmissionCreateManyGradedByInputEnvelope
    set?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
    disconnect?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
    delete?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
    connect?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
    update?: AssignmentSubmissionUpdateWithWhereUniqueWithoutGradedByInput | AssignmentSubmissionUpdateWithWhereUniqueWithoutGradedByInput[]
    updateMany?: AssignmentSubmissionUpdateManyWithWhereWithoutGradedByInput | AssignmentSubmissionUpdateManyWithWhereWithoutGradedByInput[]
    deleteMany?: AssignmentSubmissionScalarWhereInput | AssignmentSubmissionScalarWhereInput[]
  }

  export type ReferralCodeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReferralCodeCreateWithoutUserInput, ReferralCodeUncheckedCreateWithoutUserInput> | ReferralCodeCreateWithoutUserInput[] | ReferralCodeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReferralCodeCreateOrConnectWithoutUserInput | ReferralCodeCreateOrConnectWithoutUserInput[]
    upsert?: ReferralCodeUpsertWithWhereUniqueWithoutUserInput | ReferralCodeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReferralCodeCreateManyUserInputEnvelope
    set?: ReferralCodeWhereUniqueInput | ReferralCodeWhereUniqueInput[]
    disconnect?: ReferralCodeWhereUniqueInput | ReferralCodeWhereUniqueInput[]
    delete?: ReferralCodeWhereUniqueInput | ReferralCodeWhereUniqueInput[]
    connect?: ReferralCodeWhereUniqueInput | ReferralCodeWhereUniqueInput[]
    update?: ReferralCodeUpdateWithWhereUniqueWithoutUserInput | ReferralCodeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReferralCodeUpdateManyWithWhereWithoutUserInput | ReferralCodeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReferralCodeScalarWhereInput | ReferralCodeScalarWhereInput[]
  }

  export type ReferralUseUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReferralUseCreateWithoutUserInput, ReferralUseUncheckedCreateWithoutUserInput> | ReferralUseCreateWithoutUserInput[] | ReferralUseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReferralUseCreateOrConnectWithoutUserInput | ReferralUseCreateOrConnectWithoutUserInput[]
    upsert?: ReferralUseUpsertWithWhereUniqueWithoutUserInput | ReferralUseUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReferralUseCreateManyUserInputEnvelope
    set?: ReferralUseWhereUniqueInput | ReferralUseWhereUniqueInput[]
    disconnect?: ReferralUseWhereUniqueInput | ReferralUseWhereUniqueInput[]
    delete?: ReferralUseWhereUniqueInput | ReferralUseWhereUniqueInput[]
    connect?: ReferralUseWhereUniqueInput | ReferralUseWhereUniqueInput[]
    update?: ReferralUseUpdateWithWhereUniqueWithoutUserInput | ReferralUseUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReferralUseUpdateManyWithWhereWithoutUserInput | ReferralUseUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReferralUseScalarWhereInput | ReferralUseScalarWhereInput[]
  }

  export type TeacherProfileCreatespecializationInput = {
    set: string[]
  }

  export type TeacherProfileCreatecertificatesInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutTeacherProfileInput = {
    create?: XOR<UserCreateWithoutTeacherProfileInput, UserUncheckedCreateWithoutTeacherProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeacherProfileInput
    connect?: UserWhereUniqueInput
  }

  export type TeacherProfileUpdatespecializationInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type TeacherProfileUpdatecertificatesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutTeacherProfileNestedInput = {
    create?: XOR<UserCreateWithoutTeacherProfileInput, UserUncheckedCreateWithoutTeacherProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeacherProfileInput
    upsert?: UserUpsertWithoutTeacherProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTeacherProfileInput, UserUpdateWithoutTeacherProfileInput>, UserUncheckedUpdateWithoutTeacherProfileInput>
  }

  export type UserCreateNestedOneWithoutAvailabilityInput = {
    create?: XOR<UserCreateWithoutAvailabilityInput, UserUncheckedCreateWithoutAvailabilityInput>
    connectOrCreate?: UserCreateOrConnectWithoutAvailabilityInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAvailabilityNestedInput = {
    create?: XOR<UserCreateWithoutAvailabilityInput, UserUncheckedCreateWithoutAvailabilityInput>
    connectOrCreate?: UserCreateOrConnectWithoutAvailabilityInput
    upsert?: UserUpsertWithoutAvailabilityInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAvailabilityInput, UserUpdateWithoutAvailabilityInput>, UserUncheckedUpdateWithoutAvailabilityInput>
  }

  export type UserCreateNestedOneWithoutPointsTransactionsInput = {
    create?: XOR<UserCreateWithoutPointsTransactionsInput, UserUncheckedCreateWithoutPointsTransactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPointsTransactionsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumPointsTxnTypeFieldUpdateOperationsInput = {
    set?: $Enums.PointsTxnType
  }

  export type UserUpdateOneRequiredWithoutPointsTransactionsNestedInput = {
    create?: XOR<UserCreateWithoutPointsTransactionsInput, UserUncheckedCreateWithoutPointsTransactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPointsTransactionsInput
    upsert?: UserUpsertWithoutPointsTransactionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPointsTransactionsInput, UserUpdateWithoutPointsTransactionsInput>, UserUncheckedUpdateWithoutPointsTransactionsInput>
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserCreateNestedOneWithoutCoursesInput = {
    create?: XOR<UserCreateWithoutCoursesInput, UserUncheckedCreateWithoutCoursesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCoursesInput
    connect?: UserWhereUniqueInput
  }

  export type TopicCreateNestedManyWithoutCourseInput = {
    create?: XOR<TopicCreateWithoutCourseInput, TopicUncheckedCreateWithoutCourseInput> | TopicCreateWithoutCourseInput[] | TopicUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: TopicCreateOrConnectWithoutCourseInput | TopicCreateOrConnectWithoutCourseInput[]
    createMany?: TopicCreateManyCourseInputEnvelope
    connect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
  }

  export type EnrollmentCreateNestedManyWithoutCourseInput = {
    create?: XOR<EnrollmentCreateWithoutCourseInput, EnrollmentUncheckedCreateWithoutCourseInput> | EnrollmentCreateWithoutCourseInput[] | EnrollmentUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutCourseInput | EnrollmentCreateOrConnectWithoutCourseInput[]
    createMany?: EnrollmentCreateManyCourseInputEnvelope
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
  }

  export type SavedCourseCreateNestedManyWithoutCourseInput = {
    create?: XOR<SavedCourseCreateWithoutCourseInput, SavedCourseUncheckedCreateWithoutCourseInput> | SavedCourseCreateWithoutCourseInput[] | SavedCourseUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: SavedCourseCreateOrConnectWithoutCourseInput | SavedCourseCreateOrConnectWithoutCourseInput[]
    createMany?: SavedCourseCreateManyCourseInputEnvelope
    connect?: SavedCourseWhereUniqueInput | SavedCourseWhereUniqueInput[]
  }

  export type LikedCourseCreateNestedManyWithoutCourseInput = {
    create?: XOR<LikedCourseCreateWithoutCourseInput, LikedCourseUncheckedCreateWithoutCourseInput> | LikedCourseCreateWithoutCourseInput[] | LikedCourseUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: LikedCourseCreateOrConnectWithoutCourseInput | LikedCourseCreateOrConnectWithoutCourseInput[]
    createMany?: LikedCourseCreateManyCourseInputEnvelope
    connect?: LikedCourseWhereUniqueInput | LikedCourseWhereUniqueInput[]
  }

  export type CourseReviewCreateNestedManyWithoutCourseInput = {
    create?: XOR<CourseReviewCreateWithoutCourseInput, CourseReviewUncheckedCreateWithoutCourseInput> | CourseReviewCreateWithoutCourseInput[] | CourseReviewUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseReviewCreateOrConnectWithoutCourseInput | CourseReviewCreateOrConnectWithoutCourseInput[]
    createMany?: CourseReviewCreateManyCourseInputEnvelope
    connect?: CourseReviewWhereUniqueInput | CourseReviewWhereUniqueInput[]
  }

  export type LessonCreateNestedManyWithoutCourseInput = {
    create?: XOR<LessonCreateWithoutCourseInput, LessonUncheckedCreateWithoutCourseInput> | LessonCreateWithoutCourseInput[] | LessonUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutCourseInput | LessonCreateOrConnectWithoutCourseInput[]
    createMany?: LessonCreateManyCourseInputEnvelope
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
  }

  export type QuizAttemptCreateNestedManyWithoutCourseInput = {
    create?: XOR<QuizAttemptCreateWithoutCourseInput, QuizAttemptUncheckedCreateWithoutCourseInput> | QuizAttemptCreateWithoutCourseInput[] | QuizAttemptUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: QuizAttemptCreateOrConnectWithoutCourseInput | QuizAttemptCreateOrConnectWithoutCourseInput[]
    createMany?: QuizAttemptCreateManyCourseInputEnvelope
    connect?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
  }

  export type CertificateCreateNestedManyWithoutCourseInput = {
    create?: XOR<CertificateCreateWithoutCourseInput, CertificateUncheckedCreateWithoutCourseInput> | CertificateCreateWithoutCourseInput[] | CertificateUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutCourseInput | CertificateCreateOrConnectWithoutCourseInput[]
    createMany?: CertificateCreateManyCourseInputEnvelope
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
  }

  export type BundleCourseCreateNestedManyWithoutCourseInput = {
    create?: XOR<BundleCourseCreateWithoutCourseInput, BundleCourseUncheckedCreateWithoutCourseInput> | BundleCourseCreateWithoutCourseInput[] | BundleCourseUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: BundleCourseCreateOrConnectWithoutCourseInput | BundleCourseCreateOrConnectWithoutCourseInput[]
    createMany?: BundleCourseCreateManyCourseInputEnvelope
    connect?: BundleCourseWhereUniqueInput | BundleCourseWhereUniqueInput[]
  }

  export type CalendarEventCreateNestedManyWithoutCourseInput = {
    create?: XOR<CalendarEventCreateWithoutCourseInput, CalendarEventUncheckedCreateWithoutCourseInput> | CalendarEventCreateWithoutCourseInput[] | CalendarEventUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CalendarEventCreateOrConnectWithoutCourseInput | CalendarEventCreateOrConnectWithoutCourseInput[]
    createMany?: CalendarEventCreateManyCourseInputEnvelope
    connect?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
  }

  export type TopicUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<TopicCreateWithoutCourseInput, TopicUncheckedCreateWithoutCourseInput> | TopicCreateWithoutCourseInput[] | TopicUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: TopicCreateOrConnectWithoutCourseInput | TopicCreateOrConnectWithoutCourseInput[]
    createMany?: TopicCreateManyCourseInputEnvelope
    connect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
  }

  export type EnrollmentUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<EnrollmentCreateWithoutCourseInput, EnrollmentUncheckedCreateWithoutCourseInput> | EnrollmentCreateWithoutCourseInput[] | EnrollmentUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutCourseInput | EnrollmentCreateOrConnectWithoutCourseInput[]
    createMany?: EnrollmentCreateManyCourseInputEnvelope
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
  }

  export type SavedCourseUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<SavedCourseCreateWithoutCourseInput, SavedCourseUncheckedCreateWithoutCourseInput> | SavedCourseCreateWithoutCourseInput[] | SavedCourseUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: SavedCourseCreateOrConnectWithoutCourseInput | SavedCourseCreateOrConnectWithoutCourseInput[]
    createMany?: SavedCourseCreateManyCourseInputEnvelope
    connect?: SavedCourseWhereUniqueInput | SavedCourseWhereUniqueInput[]
  }

  export type LikedCourseUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<LikedCourseCreateWithoutCourseInput, LikedCourseUncheckedCreateWithoutCourseInput> | LikedCourseCreateWithoutCourseInput[] | LikedCourseUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: LikedCourseCreateOrConnectWithoutCourseInput | LikedCourseCreateOrConnectWithoutCourseInput[]
    createMany?: LikedCourseCreateManyCourseInputEnvelope
    connect?: LikedCourseWhereUniqueInput | LikedCourseWhereUniqueInput[]
  }

  export type CourseReviewUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<CourseReviewCreateWithoutCourseInput, CourseReviewUncheckedCreateWithoutCourseInput> | CourseReviewCreateWithoutCourseInput[] | CourseReviewUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseReviewCreateOrConnectWithoutCourseInput | CourseReviewCreateOrConnectWithoutCourseInput[]
    createMany?: CourseReviewCreateManyCourseInputEnvelope
    connect?: CourseReviewWhereUniqueInput | CourseReviewWhereUniqueInput[]
  }

  export type LessonUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<LessonCreateWithoutCourseInput, LessonUncheckedCreateWithoutCourseInput> | LessonCreateWithoutCourseInput[] | LessonUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutCourseInput | LessonCreateOrConnectWithoutCourseInput[]
    createMany?: LessonCreateManyCourseInputEnvelope
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
  }

  export type QuizAttemptUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<QuizAttemptCreateWithoutCourseInput, QuizAttemptUncheckedCreateWithoutCourseInput> | QuizAttemptCreateWithoutCourseInput[] | QuizAttemptUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: QuizAttemptCreateOrConnectWithoutCourseInput | QuizAttemptCreateOrConnectWithoutCourseInput[]
    createMany?: QuizAttemptCreateManyCourseInputEnvelope
    connect?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
  }

  export type CertificateUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<CertificateCreateWithoutCourseInput, CertificateUncheckedCreateWithoutCourseInput> | CertificateCreateWithoutCourseInput[] | CertificateUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutCourseInput | CertificateCreateOrConnectWithoutCourseInput[]
    createMany?: CertificateCreateManyCourseInputEnvelope
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
  }

  export type BundleCourseUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<BundleCourseCreateWithoutCourseInput, BundleCourseUncheckedCreateWithoutCourseInput> | BundleCourseCreateWithoutCourseInput[] | BundleCourseUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: BundleCourseCreateOrConnectWithoutCourseInput | BundleCourseCreateOrConnectWithoutCourseInput[]
    createMany?: BundleCourseCreateManyCourseInputEnvelope
    connect?: BundleCourseWhereUniqueInput | BundleCourseWhereUniqueInput[]
  }

  export type CalendarEventUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<CalendarEventCreateWithoutCourseInput, CalendarEventUncheckedCreateWithoutCourseInput> | CalendarEventCreateWithoutCourseInput[] | CalendarEventUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CalendarEventCreateOrConnectWithoutCourseInput | CalendarEventCreateOrConnectWithoutCourseInput[]
    createMany?: CalendarEventCreateManyCourseInputEnvelope
    connect?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
  }

  export type EnumCourseStatusFieldUpdateOperationsInput = {
    set?: $Enums.CourseStatus
  }

  export type UserUpdateOneRequiredWithoutCoursesNestedInput = {
    create?: XOR<UserCreateWithoutCoursesInput, UserUncheckedCreateWithoutCoursesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCoursesInput
    upsert?: UserUpsertWithoutCoursesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCoursesInput, UserUpdateWithoutCoursesInput>, UserUncheckedUpdateWithoutCoursesInput>
  }

  export type TopicUpdateManyWithoutCourseNestedInput = {
    create?: XOR<TopicCreateWithoutCourseInput, TopicUncheckedCreateWithoutCourseInput> | TopicCreateWithoutCourseInput[] | TopicUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: TopicCreateOrConnectWithoutCourseInput | TopicCreateOrConnectWithoutCourseInput[]
    upsert?: TopicUpsertWithWhereUniqueWithoutCourseInput | TopicUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: TopicCreateManyCourseInputEnvelope
    set?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    disconnect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    delete?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    connect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    update?: TopicUpdateWithWhereUniqueWithoutCourseInput | TopicUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: TopicUpdateManyWithWhereWithoutCourseInput | TopicUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: TopicScalarWhereInput | TopicScalarWhereInput[]
  }

  export type EnrollmentUpdateManyWithoutCourseNestedInput = {
    create?: XOR<EnrollmentCreateWithoutCourseInput, EnrollmentUncheckedCreateWithoutCourseInput> | EnrollmentCreateWithoutCourseInput[] | EnrollmentUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutCourseInput | EnrollmentCreateOrConnectWithoutCourseInput[]
    upsert?: EnrollmentUpsertWithWhereUniqueWithoutCourseInput | EnrollmentUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: EnrollmentCreateManyCourseInputEnvelope
    set?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    disconnect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    delete?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    update?: EnrollmentUpdateWithWhereUniqueWithoutCourseInput | EnrollmentUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: EnrollmentUpdateManyWithWhereWithoutCourseInput | EnrollmentUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: EnrollmentScalarWhereInput | EnrollmentScalarWhereInput[]
  }

  export type SavedCourseUpdateManyWithoutCourseNestedInput = {
    create?: XOR<SavedCourseCreateWithoutCourseInput, SavedCourseUncheckedCreateWithoutCourseInput> | SavedCourseCreateWithoutCourseInput[] | SavedCourseUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: SavedCourseCreateOrConnectWithoutCourseInput | SavedCourseCreateOrConnectWithoutCourseInput[]
    upsert?: SavedCourseUpsertWithWhereUniqueWithoutCourseInput | SavedCourseUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: SavedCourseCreateManyCourseInputEnvelope
    set?: SavedCourseWhereUniqueInput | SavedCourseWhereUniqueInput[]
    disconnect?: SavedCourseWhereUniqueInput | SavedCourseWhereUniqueInput[]
    delete?: SavedCourseWhereUniqueInput | SavedCourseWhereUniqueInput[]
    connect?: SavedCourseWhereUniqueInput | SavedCourseWhereUniqueInput[]
    update?: SavedCourseUpdateWithWhereUniqueWithoutCourseInput | SavedCourseUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: SavedCourseUpdateManyWithWhereWithoutCourseInput | SavedCourseUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: SavedCourseScalarWhereInput | SavedCourseScalarWhereInput[]
  }

  export type LikedCourseUpdateManyWithoutCourseNestedInput = {
    create?: XOR<LikedCourseCreateWithoutCourseInput, LikedCourseUncheckedCreateWithoutCourseInput> | LikedCourseCreateWithoutCourseInput[] | LikedCourseUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: LikedCourseCreateOrConnectWithoutCourseInput | LikedCourseCreateOrConnectWithoutCourseInput[]
    upsert?: LikedCourseUpsertWithWhereUniqueWithoutCourseInput | LikedCourseUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: LikedCourseCreateManyCourseInputEnvelope
    set?: LikedCourseWhereUniqueInput | LikedCourseWhereUniqueInput[]
    disconnect?: LikedCourseWhereUniqueInput | LikedCourseWhereUniqueInput[]
    delete?: LikedCourseWhereUniqueInput | LikedCourseWhereUniqueInput[]
    connect?: LikedCourseWhereUniqueInput | LikedCourseWhereUniqueInput[]
    update?: LikedCourseUpdateWithWhereUniqueWithoutCourseInput | LikedCourseUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: LikedCourseUpdateManyWithWhereWithoutCourseInput | LikedCourseUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: LikedCourseScalarWhereInput | LikedCourseScalarWhereInput[]
  }

  export type CourseReviewUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CourseReviewCreateWithoutCourseInput, CourseReviewUncheckedCreateWithoutCourseInput> | CourseReviewCreateWithoutCourseInput[] | CourseReviewUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseReviewCreateOrConnectWithoutCourseInput | CourseReviewCreateOrConnectWithoutCourseInput[]
    upsert?: CourseReviewUpsertWithWhereUniqueWithoutCourseInput | CourseReviewUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CourseReviewCreateManyCourseInputEnvelope
    set?: CourseReviewWhereUniqueInput | CourseReviewWhereUniqueInput[]
    disconnect?: CourseReviewWhereUniqueInput | CourseReviewWhereUniqueInput[]
    delete?: CourseReviewWhereUniqueInput | CourseReviewWhereUniqueInput[]
    connect?: CourseReviewWhereUniqueInput | CourseReviewWhereUniqueInput[]
    update?: CourseReviewUpdateWithWhereUniqueWithoutCourseInput | CourseReviewUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CourseReviewUpdateManyWithWhereWithoutCourseInput | CourseReviewUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CourseReviewScalarWhereInput | CourseReviewScalarWhereInput[]
  }

  export type LessonUpdateManyWithoutCourseNestedInput = {
    create?: XOR<LessonCreateWithoutCourseInput, LessonUncheckedCreateWithoutCourseInput> | LessonCreateWithoutCourseInput[] | LessonUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutCourseInput | LessonCreateOrConnectWithoutCourseInput[]
    upsert?: LessonUpsertWithWhereUniqueWithoutCourseInput | LessonUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: LessonCreateManyCourseInputEnvelope
    set?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    disconnect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    delete?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    update?: LessonUpdateWithWhereUniqueWithoutCourseInput | LessonUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: LessonUpdateManyWithWhereWithoutCourseInput | LessonUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: LessonScalarWhereInput | LessonScalarWhereInput[]
  }

  export type QuizAttemptUpdateManyWithoutCourseNestedInput = {
    create?: XOR<QuizAttemptCreateWithoutCourseInput, QuizAttemptUncheckedCreateWithoutCourseInput> | QuizAttemptCreateWithoutCourseInput[] | QuizAttemptUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: QuizAttemptCreateOrConnectWithoutCourseInput | QuizAttemptCreateOrConnectWithoutCourseInput[]
    upsert?: QuizAttemptUpsertWithWhereUniqueWithoutCourseInput | QuizAttemptUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: QuizAttemptCreateManyCourseInputEnvelope
    set?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    disconnect?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    delete?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    connect?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    update?: QuizAttemptUpdateWithWhereUniqueWithoutCourseInput | QuizAttemptUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: QuizAttemptUpdateManyWithWhereWithoutCourseInput | QuizAttemptUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: QuizAttemptScalarWhereInput | QuizAttemptScalarWhereInput[]
  }

  export type CertificateUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CertificateCreateWithoutCourseInput, CertificateUncheckedCreateWithoutCourseInput> | CertificateCreateWithoutCourseInput[] | CertificateUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutCourseInput | CertificateCreateOrConnectWithoutCourseInput[]
    upsert?: CertificateUpsertWithWhereUniqueWithoutCourseInput | CertificateUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CertificateCreateManyCourseInputEnvelope
    set?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    disconnect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    delete?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    update?: CertificateUpdateWithWhereUniqueWithoutCourseInput | CertificateUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CertificateUpdateManyWithWhereWithoutCourseInput | CertificateUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CertificateScalarWhereInput | CertificateScalarWhereInput[]
  }

  export type BundleCourseUpdateManyWithoutCourseNestedInput = {
    create?: XOR<BundleCourseCreateWithoutCourseInput, BundleCourseUncheckedCreateWithoutCourseInput> | BundleCourseCreateWithoutCourseInput[] | BundleCourseUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: BundleCourseCreateOrConnectWithoutCourseInput | BundleCourseCreateOrConnectWithoutCourseInput[]
    upsert?: BundleCourseUpsertWithWhereUniqueWithoutCourseInput | BundleCourseUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: BundleCourseCreateManyCourseInputEnvelope
    set?: BundleCourseWhereUniqueInput | BundleCourseWhereUniqueInput[]
    disconnect?: BundleCourseWhereUniqueInput | BundleCourseWhereUniqueInput[]
    delete?: BundleCourseWhereUniqueInput | BundleCourseWhereUniqueInput[]
    connect?: BundleCourseWhereUniqueInput | BundleCourseWhereUniqueInput[]
    update?: BundleCourseUpdateWithWhereUniqueWithoutCourseInput | BundleCourseUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: BundleCourseUpdateManyWithWhereWithoutCourseInput | BundleCourseUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: BundleCourseScalarWhereInput | BundleCourseScalarWhereInput[]
  }

  export type CalendarEventUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CalendarEventCreateWithoutCourseInput, CalendarEventUncheckedCreateWithoutCourseInput> | CalendarEventCreateWithoutCourseInput[] | CalendarEventUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CalendarEventCreateOrConnectWithoutCourseInput | CalendarEventCreateOrConnectWithoutCourseInput[]
    upsert?: CalendarEventUpsertWithWhereUniqueWithoutCourseInput | CalendarEventUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CalendarEventCreateManyCourseInputEnvelope
    set?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    disconnect?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    delete?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    connect?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    update?: CalendarEventUpdateWithWhereUniqueWithoutCourseInput | CalendarEventUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CalendarEventUpdateManyWithWhereWithoutCourseInput | CalendarEventUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CalendarEventScalarWhereInput | CalendarEventScalarWhereInput[]
  }

  export type TopicUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<TopicCreateWithoutCourseInput, TopicUncheckedCreateWithoutCourseInput> | TopicCreateWithoutCourseInput[] | TopicUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: TopicCreateOrConnectWithoutCourseInput | TopicCreateOrConnectWithoutCourseInput[]
    upsert?: TopicUpsertWithWhereUniqueWithoutCourseInput | TopicUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: TopicCreateManyCourseInputEnvelope
    set?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    disconnect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    delete?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    connect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    update?: TopicUpdateWithWhereUniqueWithoutCourseInput | TopicUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: TopicUpdateManyWithWhereWithoutCourseInput | TopicUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: TopicScalarWhereInput | TopicScalarWhereInput[]
  }

  export type EnrollmentUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<EnrollmentCreateWithoutCourseInput, EnrollmentUncheckedCreateWithoutCourseInput> | EnrollmentCreateWithoutCourseInput[] | EnrollmentUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutCourseInput | EnrollmentCreateOrConnectWithoutCourseInput[]
    upsert?: EnrollmentUpsertWithWhereUniqueWithoutCourseInput | EnrollmentUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: EnrollmentCreateManyCourseInputEnvelope
    set?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    disconnect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    delete?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    update?: EnrollmentUpdateWithWhereUniqueWithoutCourseInput | EnrollmentUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: EnrollmentUpdateManyWithWhereWithoutCourseInput | EnrollmentUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: EnrollmentScalarWhereInput | EnrollmentScalarWhereInput[]
  }

  export type SavedCourseUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<SavedCourseCreateWithoutCourseInput, SavedCourseUncheckedCreateWithoutCourseInput> | SavedCourseCreateWithoutCourseInput[] | SavedCourseUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: SavedCourseCreateOrConnectWithoutCourseInput | SavedCourseCreateOrConnectWithoutCourseInput[]
    upsert?: SavedCourseUpsertWithWhereUniqueWithoutCourseInput | SavedCourseUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: SavedCourseCreateManyCourseInputEnvelope
    set?: SavedCourseWhereUniqueInput | SavedCourseWhereUniqueInput[]
    disconnect?: SavedCourseWhereUniqueInput | SavedCourseWhereUniqueInput[]
    delete?: SavedCourseWhereUniqueInput | SavedCourseWhereUniqueInput[]
    connect?: SavedCourseWhereUniqueInput | SavedCourseWhereUniqueInput[]
    update?: SavedCourseUpdateWithWhereUniqueWithoutCourseInput | SavedCourseUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: SavedCourseUpdateManyWithWhereWithoutCourseInput | SavedCourseUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: SavedCourseScalarWhereInput | SavedCourseScalarWhereInput[]
  }

  export type LikedCourseUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<LikedCourseCreateWithoutCourseInput, LikedCourseUncheckedCreateWithoutCourseInput> | LikedCourseCreateWithoutCourseInput[] | LikedCourseUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: LikedCourseCreateOrConnectWithoutCourseInput | LikedCourseCreateOrConnectWithoutCourseInput[]
    upsert?: LikedCourseUpsertWithWhereUniqueWithoutCourseInput | LikedCourseUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: LikedCourseCreateManyCourseInputEnvelope
    set?: LikedCourseWhereUniqueInput | LikedCourseWhereUniqueInput[]
    disconnect?: LikedCourseWhereUniqueInput | LikedCourseWhereUniqueInput[]
    delete?: LikedCourseWhereUniqueInput | LikedCourseWhereUniqueInput[]
    connect?: LikedCourseWhereUniqueInput | LikedCourseWhereUniqueInput[]
    update?: LikedCourseUpdateWithWhereUniqueWithoutCourseInput | LikedCourseUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: LikedCourseUpdateManyWithWhereWithoutCourseInput | LikedCourseUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: LikedCourseScalarWhereInput | LikedCourseScalarWhereInput[]
  }

  export type CourseReviewUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CourseReviewCreateWithoutCourseInput, CourseReviewUncheckedCreateWithoutCourseInput> | CourseReviewCreateWithoutCourseInput[] | CourseReviewUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseReviewCreateOrConnectWithoutCourseInput | CourseReviewCreateOrConnectWithoutCourseInput[]
    upsert?: CourseReviewUpsertWithWhereUniqueWithoutCourseInput | CourseReviewUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CourseReviewCreateManyCourseInputEnvelope
    set?: CourseReviewWhereUniqueInput | CourseReviewWhereUniqueInput[]
    disconnect?: CourseReviewWhereUniqueInput | CourseReviewWhereUniqueInput[]
    delete?: CourseReviewWhereUniqueInput | CourseReviewWhereUniqueInput[]
    connect?: CourseReviewWhereUniqueInput | CourseReviewWhereUniqueInput[]
    update?: CourseReviewUpdateWithWhereUniqueWithoutCourseInput | CourseReviewUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CourseReviewUpdateManyWithWhereWithoutCourseInput | CourseReviewUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CourseReviewScalarWhereInput | CourseReviewScalarWhereInput[]
  }

  export type LessonUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<LessonCreateWithoutCourseInput, LessonUncheckedCreateWithoutCourseInput> | LessonCreateWithoutCourseInput[] | LessonUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutCourseInput | LessonCreateOrConnectWithoutCourseInput[]
    upsert?: LessonUpsertWithWhereUniqueWithoutCourseInput | LessonUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: LessonCreateManyCourseInputEnvelope
    set?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    disconnect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    delete?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    update?: LessonUpdateWithWhereUniqueWithoutCourseInput | LessonUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: LessonUpdateManyWithWhereWithoutCourseInput | LessonUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: LessonScalarWhereInput | LessonScalarWhereInput[]
  }

  export type QuizAttemptUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<QuizAttemptCreateWithoutCourseInput, QuizAttemptUncheckedCreateWithoutCourseInput> | QuizAttemptCreateWithoutCourseInput[] | QuizAttemptUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: QuizAttemptCreateOrConnectWithoutCourseInput | QuizAttemptCreateOrConnectWithoutCourseInput[]
    upsert?: QuizAttemptUpsertWithWhereUniqueWithoutCourseInput | QuizAttemptUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: QuizAttemptCreateManyCourseInputEnvelope
    set?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    disconnect?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    delete?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    connect?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    update?: QuizAttemptUpdateWithWhereUniqueWithoutCourseInput | QuizAttemptUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: QuizAttemptUpdateManyWithWhereWithoutCourseInput | QuizAttemptUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: QuizAttemptScalarWhereInput | QuizAttemptScalarWhereInput[]
  }

  export type CertificateUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CertificateCreateWithoutCourseInput, CertificateUncheckedCreateWithoutCourseInput> | CertificateCreateWithoutCourseInput[] | CertificateUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutCourseInput | CertificateCreateOrConnectWithoutCourseInput[]
    upsert?: CertificateUpsertWithWhereUniqueWithoutCourseInput | CertificateUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CertificateCreateManyCourseInputEnvelope
    set?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    disconnect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    delete?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    update?: CertificateUpdateWithWhereUniqueWithoutCourseInput | CertificateUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CertificateUpdateManyWithWhereWithoutCourseInput | CertificateUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CertificateScalarWhereInput | CertificateScalarWhereInput[]
  }

  export type BundleCourseUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<BundleCourseCreateWithoutCourseInput, BundleCourseUncheckedCreateWithoutCourseInput> | BundleCourseCreateWithoutCourseInput[] | BundleCourseUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: BundleCourseCreateOrConnectWithoutCourseInput | BundleCourseCreateOrConnectWithoutCourseInput[]
    upsert?: BundleCourseUpsertWithWhereUniqueWithoutCourseInput | BundleCourseUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: BundleCourseCreateManyCourseInputEnvelope
    set?: BundleCourseWhereUniqueInput | BundleCourseWhereUniqueInput[]
    disconnect?: BundleCourseWhereUniqueInput | BundleCourseWhereUniqueInput[]
    delete?: BundleCourseWhereUniqueInput | BundleCourseWhereUniqueInput[]
    connect?: BundleCourseWhereUniqueInput | BundleCourseWhereUniqueInput[]
    update?: BundleCourseUpdateWithWhereUniqueWithoutCourseInput | BundleCourseUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: BundleCourseUpdateManyWithWhereWithoutCourseInput | BundleCourseUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: BundleCourseScalarWhereInput | BundleCourseScalarWhereInput[]
  }

  export type CalendarEventUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CalendarEventCreateWithoutCourseInput, CalendarEventUncheckedCreateWithoutCourseInput> | CalendarEventCreateWithoutCourseInput[] | CalendarEventUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CalendarEventCreateOrConnectWithoutCourseInput | CalendarEventCreateOrConnectWithoutCourseInput[]
    upsert?: CalendarEventUpsertWithWhereUniqueWithoutCourseInput | CalendarEventUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CalendarEventCreateManyCourseInputEnvelope
    set?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    disconnect?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    delete?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    connect?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    update?: CalendarEventUpdateWithWhereUniqueWithoutCourseInput | CalendarEventUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CalendarEventUpdateManyWithWhereWithoutCourseInput | CalendarEventUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CalendarEventScalarWhereInput | CalendarEventScalarWhereInput[]
  }

  export type CourseCreateNestedOneWithoutTopicsInput = {
    create?: XOR<CourseCreateWithoutTopicsInput, CourseUncheckedCreateWithoutTopicsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutTopicsInput
    connect?: CourseWhereUniqueInput
  }

  export type LessonCreateNestedManyWithoutTopicInput = {
    create?: XOR<LessonCreateWithoutTopicInput, LessonUncheckedCreateWithoutTopicInput> | LessonCreateWithoutTopicInput[] | LessonUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutTopicInput | LessonCreateOrConnectWithoutTopicInput[]
    createMany?: LessonCreateManyTopicInputEnvelope
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
  }

  export type LessonUncheckedCreateNestedManyWithoutTopicInput = {
    create?: XOR<LessonCreateWithoutTopicInput, LessonUncheckedCreateWithoutTopicInput> | LessonCreateWithoutTopicInput[] | LessonUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutTopicInput | LessonCreateOrConnectWithoutTopicInput[]
    createMany?: LessonCreateManyTopicInputEnvelope
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
  }

  export type CourseUpdateOneRequiredWithoutTopicsNestedInput = {
    create?: XOR<CourseCreateWithoutTopicsInput, CourseUncheckedCreateWithoutTopicsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutTopicsInput
    upsert?: CourseUpsertWithoutTopicsInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutTopicsInput, CourseUpdateWithoutTopicsInput>, CourseUncheckedUpdateWithoutTopicsInput>
  }

  export type LessonUpdateManyWithoutTopicNestedInput = {
    create?: XOR<LessonCreateWithoutTopicInput, LessonUncheckedCreateWithoutTopicInput> | LessonCreateWithoutTopicInput[] | LessonUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutTopicInput | LessonCreateOrConnectWithoutTopicInput[]
    upsert?: LessonUpsertWithWhereUniqueWithoutTopicInput | LessonUpsertWithWhereUniqueWithoutTopicInput[]
    createMany?: LessonCreateManyTopicInputEnvelope
    set?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    disconnect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    delete?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    update?: LessonUpdateWithWhereUniqueWithoutTopicInput | LessonUpdateWithWhereUniqueWithoutTopicInput[]
    updateMany?: LessonUpdateManyWithWhereWithoutTopicInput | LessonUpdateManyWithWhereWithoutTopicInput[]
    deleteMany?: LessonScalarWhereInput | LessonScalarWhereInput[]
  }

  export type LessonUncheckedUpdateManyWithoutTopicNestedInput = {
    create?: XOR<LessonCreateWithoutTopicInput, LessonUncheckedCreateWithoutTopicInput> | LessonCreateWithoutTopicInput[] | LessonUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutTopicInput | LessonCreateOrConnectWithoutTopicInput[]
    upsert?: LessonUpsertWithWhereUniqueWithoutTopicInput | LessonUpsertWithWhereUniqueWithoutTopicInput[]
    createMany?: LessonCreateManyTopicInputEnvelope
    set?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    disconnect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    delete?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    update?: LessonUpdateWithWhereUniqueWithoutTopicInput | LessonUpdateWithWhereUniqueWithoutTopicInput[]
    updateMany?: LessonUpdateManyWithWhereWithoutTopicInput | LessonUpdateManyWithWhereWithoutTopicInput[]
    deleteMany?: LessonScalarWhereInput | LessonScalarWhereInput[]
  }

  export type TopicCreateNestedOneWithoutLessonsInput = {
    create?: XOR<TopicCreateWithoutLessonsInput, TopicUncheckedCreateWithoutLessonsInput>
    connectOrCreate?: TopicCreateOrConnectWithoutLessonsInput
    connect?: TopicWhereUniqueInput
  }

  export type QuizCreateNestedOneWithoutLessonInput = {
    create?: XOR<QuizCreateWithoutLessonInput, QuizUncheckedCreateWithoutLessonInput>
    connectOrCreate?: QuizCreateOrConnectWithoutLessonInput
    connect?: QuizWhereUniqueInput
  }

  export type AssignmentCreateNestedOneWithoutLessonInput = {
    create?: XOR<AssignmentCreateWithoutLessonInput, AssignmentUncheckedCreateWithoutLessonInput>
    connectOrCreate?: AssignmentCreateOrConnectWithoutLessonInput
    connect?: AssignmentWhereUniqueInput
  }

  export type LessonProgressCreateNestedManyWithoutLessonInput = {
    create?: XOR<LessonProgressCreateWithoutLessonInput, LessonProgressUncheckedCreateWithoutLessonInput> | LessonProgressCreateWithoutLessonInput[] | LessonProgressUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: LessonProgressCreateOrConnectWithoutLessonInput | LessonProgressCreateOrConnectWithoutLessonInput[]
    createMany?: LessonProgressCreateManyLessonInputEnvelope
    connect?: LessonProgressWhereUniqueInput | LessonProgressWhereUniqueInput[]
  }

  export type CalendarEventCreateNestedManyWithoutLessonInput = {
    create?: XOR<CalendarEventCreateWithoutLessonInput, CalendarEventUncheckedCreateWithoutLessonInput> | CalendarEventCreateWithoutLessonInput[] | CalendarEventUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: CalendarEventCreateOrConnectWithoutLessonInput | CalendarEventCreateOrConnectWithoutLessonInput[]
    createMany?: CalendarEventCreateManyLessonInputEnvelope
    connect?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
  }

  export type CourseCreateNestedOneWithoutLessonsInput = {
    create?: XOR<CourseCreateWithoutLessonsInput, CourseUncheckedCreateWithoutLessonsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutLessonsInput
    connect?: CourseWhereUniqueInput
  }

  export type QuizUncheckedCreateNestedOneWithoutLessonInput = {
    create?: XOR<QuizCreateWithoutLessonInput, QuizUncheckedCreateWithoutLessonInput>
    connectOrCreate?: QuizCreateOrConnectWithoutLessonInput
    connect?: QuizWhereUniqueInput
  }

  export type AssignmentUncheckedCreateNestedOneWithoutLessonInput = {
    create?: XOR<AssignmentCreateWithoutLessonInput, AssignmentUncheckedCreateWithoutLessonInput>
    connectOrCreate?: AssignmentCreateOrConnectWithoutLessonInput
    connect?: AssignmentWhereUniqueInput
  }

  export type LessonProgressUncheckedCreateNestedManyWithoutLessonInput = {
    create?: XOR<LessonProgressCreateWithoutLessonInput, LessonProgressUncheckedCreateWithoutLessonInput> | LessonProgressCreateWithoutLessonInput[] | LessonProgressUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: LessonProgressCreateOrConnectWithoutLessonInput | LessonProgressCreateOrConnectWithoutLessonInput[]
    createMany?: LessonProgressCreateManyLessonInputEnvelope
    connect?: LessonProgressWhereUniqueInput | LessonProgressWhereUniqueInput[]
  }

  export type CalendarEventUncheckedCreateNestedManyWithoutLessonInput = {
    create?: XOR<CalendarEventCreateWithoutLessonInput, CalendarEventUncheckedCreateWithoutLessonInput> | CalendarEventCreateWithoutLessonInput[] | CalendarEventUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: CalendarEventCreateOrConnectWithoutLessonInput | CalendarEventCreateOrConnectWithoutLessonInput[]
    createMany?: CalendarEventCreateManyLessonInputEnvelope
    connect?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumLessonTypeFieldUpdateOperationsInput = {
    set?: $Enums.LessonType
  }

  export type TopicUpdateOneRequiredWithoutLessonsNestedInput = {
    create?: XOR<TopicCreateWithoutLessonsInput, TopicUncheckedCreateWithoutLessonsInput>
    connectOrCreate?: TopicCreateOrConnectWithoutLessonsInput
    upsert?: TopicUpsertWithoutLessonsInput
    connect?: TopicWhereUniqueInput
    update?: XOR<XOR<TopicUpdateToOneWithWhereWithoutLessonsInput, TopicUpdateWithoutLessonsInput>, TopicUncheckedUpdateWithoutLessonsInput>
  }

  export type QuizUpdateOneWithoutLessonNestedInput = {
    create?: XOR<QuizCreateWithoutLessonInput, QuizUncheckedCreateWithoutLessonInput>
    connectOrCreate?: QuizCreateOrConnectWithoutLessonInput
    upsert?: QuizUpsertWithoutLessonInput
    disconnect?: QuizWhereInput | boolean
    delete?: QuizWhereInput | boolean
    connect?: QuizWhereUniqueInput
    update?: XOR<XOR<QuizUpdateToOneWithWhereWithoutLessonInput, QuizUpdateWithoutLessonInput>, QuizUncheckedUpdateWithoutLessonInput>
  }

  export type AssignmentUpdateOneWithoutLessonNestedInput = {
    create?: XOR<AssignmentCreateWithoutLessonInput, AssignmentUncheckedCreateWithoutLessonInput>
    connectOrCreate?: AssignmentCreateOrConnectWithoutLessonInput
    upsert?: AssignmentUpsertWithoutLessonInput
    disconnect?: AssignmentWhereInput | boolean
    delete?: AssignmentWhereInput | boolean
    connect?: AssignmentWhereUniqueInput
    update?: XOR<XOR<AssignmentUpdateToOneWithWhereWithoutLessonInput, AssignmentUpdateWithoutLessonInput>, AssignmentUncheckedUpdateWithoutLessonInput>
  }

  export type LessonProgressUpdateManyWithoutLessonNestedInput = {
    create?: XOR<LessonProgressCreateWithoutLessonInput, LessonProgressUncheckedCreateWithoutLessonInput> | LessonProgressCreateWithoutLessonInput[] | LessonProgressUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: LessonProgressCreateOrConnectWithoutLessonInput | LessonProgressCreateOrConnectWithoutLessonInput[]
    upsert?: LessonProgressUpsertWithWhereUniqueWithoutLessonInput | LessonProgressUpsertWithWhereUniqueWithoutLessonInput[]
    createMany?: LessonProgressCreateManyLessonInputEnvelope
    set?: LessonProgressWhereUniqueInput | LessonProgressWhereUniqueInput[]
    disconnect?: LessonProgressWhereUniqueInput | LessonProgressWhereUniqueInput[]
    delete?: LessonProgressWhereUniqueInput | LessonProgressWhereUniqueInput[]
    connect?: LessonProgressWhereUniqueInput | LessonProgressWhereUniqueInput[]
    update?: LessonProgressUpdateWithWhereUniqueWithoutLessonInput | LessonProgressUpdateWithWhereUniqueWithoutLessonInput[]
    updateMany?: LessonProgressUpdateManyWithWhereWithoutLessonInput | LessonProgressUpdateManyWithWhereWithoutLessonInput[]
    deleteMany?: LessonProgressScalarWhereInput | LessonProgressScalarWhereInput[]
  }

  export type CalendarEventUpdateManyWithoutLessonNestedInput = {
    create?: XOR<CalendarEventCreateWithoutLessonInput, CalendarEventUncheckedCreateWithoutLessonInput> | CalendarEventCreateWithoutLessonInput[] | CalendarEventUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: CalendarEventCreateOrConnectWithoutLessonInput | CalendarEventCreateOrConnectWithoutLessonInput[]
    upsert?: CalendarEventUpsertWithWhereUniqueWithoutLessonInput | CalendarEventUpsertWithWhereUniqueWithoutLessonInput[]
    createMany?: CalendarEventCreateManyLessonInputEnvelope
    set?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    disconnect?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    delete?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    connect?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    update?: CalendarEventUpdateWithWhereUniqueWithoutLessonInput | CalendarEventUpdateWithWhereUniqueWithoutLessonInput[]
    updateMany?: CalendarEventUpdateManyWithWhereWithoutLessonInput | CalendarEventUpdateManyWithWhereWithoutLessonInput[]
    deleteMany?: CalendarEventScalarWhereInput | CalendarEventScalarWhereInput[]
  }

  export type CourseUpdateOneWithoutLessonsNestedInput = {
    create?: XOR<CourseCreateWithoutLessonsInput, CourseUncheckedCreateWithoutLessonsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutLessonsInput
    upsert?: CourseUpsertWithoutLessonsInput
    disconnect?: CourseWhereInput | boolean
    delete?: CourseWhereInput | boolean
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutLessonsInput, CourseUpdateWithoutLessonsInput>, CourseUncheckedUpdateWithoutLessonsInput>
  }

  export type QuizUncheckedUpdateOneWithoutLessonNestedInput = {
    create?: XOR<QuizCreateWithoutLessonInput, QuizUncheckedCreateWithoutLessonInput>
    connectOrCreate?: QuizCreateOrConnectWithoutLessonInput
    upsert?: QuizUpsertWithoutLessonInput
    disconnect?: QuizWhereInput | boolean
    delete?: QuizWhereInput | boolean
    connect?: QuizWhereUniqueInput
    update?: XOR<XOR<QuizUpdateToOneWithWhereWithoutLessonInput, QuizUpdateWithoutLessonInput>, QuizUncheckedUpdateWithoutLessonInput>
  }

  export type AssignmentUncheckedUpdateOneWithoutLessonNestedInput = {
    create?: XOR<AssignmentCreateWithoutLessonInput, AssignmentUncheckedCreateWithoutLessonInput>
    connectOrCreate?: AssignmentCreateOrConnectWithoutLessonInput
    upsert?: AssignmentUpsertWithoutLessonInput
    disconnect?: AssignmentWhereInput | boolean
    delete?: AssignmentWhereInput | boolean
    connect?: AssignmentWhereUniqueInput
    update?: XOR<XOR<AssignmentUpdateToOneWithWhereWithoutLessonInput, AssignmentUpdateWithoutLessonInput>, AssignmentUncheckedUpdateWithoutLessonInput>
  }

  export type LessonProgressUncheckedUpdateManyWithoutLessonNestedInput = {
    create?: XOR<LessonProgressCreateWithoutLessonInput, LessonProgressUncheckedCreateWithoutLessonInput> | LessonProgressCreateWithoutLessonInput[] | LessonProgressUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: LessonProgressCreateOrConnectWithoutLessonInput | LessonProgressCreateOrConnectWithoutLessonInput[]
    upsert?: LessonProgressUpsertWithWhereUniqueWithoutLessonInput | LessonProgressUpsertWithWhereUniqueWithoutLessonInput[]
    createMany?: LessonProgressCreateManyLessonInputEnvelope
    set?: LessonProgressWhereUniqueInput | LessonProgressWhereUniqueInput[]
    disconnect?: LessonProgressWhereUniqueInput | LessonProgressWhereUniqueInput[]
    delete?: LessonProgressWhereUniqueInput | LessonProgressWhereUniqueInput[]
    connect?: LessonProgressWhereUniqueInput | LessonProgressWhereUniqueInput[]
    update?: LessonProgressUpdateWithWhereUniqueWithoutLessonInput | LessonProgressUpdateWithWhereUniqueWithoutLessonInput[]
    updateMany?: LessonProgressUpdateManyWithWhereWithoutLessonInput | LessonProgressUpdateManyWithWhereWithoutLessonInput[]
    deleteMany?: LessonProgressScalarWhereInput | LessonProgressScalarWhereInput[]
  }

  export type CalendarEventUncheckedUpdateManyWithoutLessonNestedInput = {
    create?: XOR<CalendarEventCreateWithoutLessonInput, CalendarEventUncheckedCreateWithoutLessonInput> | CalendarEventCreateWithoutLessonInput[] | CalendarEventUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: CalendarEventCreateOrConnectWithoutLessonInput | CalendarEventCreateOrConnectWithoutLessonInput[]
    upsert?: CalendarEventUpsertWithWhereUniqueWithoutLessonInput | CalendarEventUpsertWithWhereUniqueWithoutLessonInput[]
    createMany?: CalendarEventCreateManyLessonInputEnvelope
    set?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    disconnect?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    delete?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    connect?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    update?: CalendarEventUpdateWithWhereUniqueWithoutLessonInput | CalendarEventUpdateWithWhereUniqueWithoutLessonInput[]
    updateMany?: CalendarEventUpdateManyWithWhereWithoutLessonInput | CalendarEventUpdateManyWithWhereWithoutLessonInput[]
    deleteMany?: CalendarEventScalarWhereInput | CalendarEventScalarWhereInput[]
  }

  export type LessonCreateNestedOneWithoutQuizInput = {
    create?: XOR<LessonCreateWithoutQuizInput, LessonUncheckedCreateWithoutQuizInput>
    connectOrCreate?: LessonCreateOrConnectWithoutQuizInput
    connect?: LessonWhereUniqueInput
  }

  export type QuestionCreateNestedManyWithoutQuizInput = {
    create?: XOR<QuestionCreateWithoutQuizInput, QuestionUncheckedCreateWithoutQuizInput> | QuestionCreateWithoutQuizInput[] | QuestionUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: QuestionCreateOrConnectWithoutQuizInput | QuestionCreateOrConnectWithoutQuizInput[]
    createMany?: QuestionCreateManyQuizInputEnvelope
    connect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
  }

  export type QuizAttemptCreateNestedManyWithoutQuizInput = {
    create?: XOR<QuizAttemptCreateWithoutQuizInput, QuizAttemptUncheckedCreateWithoutQuizInput> | QuizAttemptCreateWithoutQuizInput[] | QuizAttemptUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: QuizAttemptCreateOrConnectWithoutQuizInput | QuizAttemptCreateOrConnectWithoutQuizInput[]
    createMany?: QuizAttemptCreateManyQuizInputEnvelope
    connect?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
  }

  export type QuestionUncheckedCreateNestedManyWithoutQuizInput = {
    create?: XOR<QuestionCreateWithoutQuizInput, QuestionUncheckedCreateWithoutQuizInput> | QuestionCreateWithoutQuizInput[] | QuestionUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: QuestionCreateOrConnectWithoutQuizInput | QuestionCreateOrConnectWithoutQuizInput[]
    createMany?: QuestionCreateManyQuizInputEnvelope
    connect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
  }

  export type QuizAttemptUncheckedCreateNestedManyWithoutQuizInput = {
    create?: XOR<QuizAttemptCreateWithoutQuizInput, QuizAttemptUncheckedCreateWithoutQuizInput> | QuizAttemptCreateWithoutQuizInput[] | QuizAttemptUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: QuizAttemptCreateOrConnectWithoutQuizInput | QuizAttemptCreateOrConnectWithoutQuizInput[]
    createMany?: QuizAttemptCreateManyQuizInputEnvelope
    connect?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
  }

  export type LessonUpdateOneRequiredWithoutQuizNestedInput = {
    create?: XOR<LessonCreateWithoutQuizInput, LessonUncheckedCreateWithoutQuizInput>
    connectOrCreate?: LessonCreateOrConnectWithoutQuizInput
    upsert?: LessonUpsertWithoutQuizInput
    connect?: LessonWhereUniqueInput
    update?: XOR<XOR<LessonUpdateToOneWithWhereWithoutQuizInput, LessonUpdateWithoutQuizInput>, LessonUncheckedUpdateWithoutQuizInput>
  }

  export type QuestionUpdateManyWithoutQuizNestedInput = {
    create?: XOR<QuestionCreateWithoutQuizInput, QuestionUncheckedCreateWithoutQuizInput> | QuestionCreateWithoutQuizInput[] | QuestionUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: QuestionCreateOrConnectWithoutQuizInput | QuestionCreateOrConnectWithoutQuizInput[]
    upsert?: QuestionUpsertWithWhereUniqueWithoutQuizInput | QuestionUpsertWithWhereUniqueWithoutQuizInput[]
    createMany?: QuestionCreateManyQuizInputEnvelope
    set?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    disconnect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    delete?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    connect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    update?: QuestionUpdateWithWhereUniqueWithoutQuizInput | QuestionUpdateWithWhereUniqueWithoutQuizInput[]
    updateMany?: QuestionUpdateManyWithWhereWithoutQuizInput | QuestionUpdateManyWithWhereWithoutQuizInput[]
    deleteMany?: QuestionScalarWhereInput | QuestionScalarWhereInput[]
  }

  export type QuizAttemptUpdateManyWithoutQuizNestedInput = {
    create?: XOR<QuizAttemptCreateWithoutQuizInput, QuizAttemptUncheckedCreateWithoutQuizInput> | QuizAttemptCreateWithoutQuizInput[] | QuizAttemptUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: QuizAttemptCreateOrConnectWithoutQuizInput | QuizAttemptCreateOrConnectWithoutQuizInput[]
    upsert?: QuizAttemptUpsertWithWhereUniqueWithoutQuizInput | QuizAttemptUpsertWithWhereUniqueWithoutQuizInput[]
    createMany?: QuizAttemptCreateManyQuizInputEnvelope
    set?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    disconnect?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    delete?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    connect?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    update?: QuizAttemptUpdateWithWhereUniqueWithoutQuizInput | QuizAttemptUpdateWithWhereUniqueWithoutQuizInput[]
    updateMany?: QuizAttemptUpdateManyWithWhereWithoutQuizInput | QuizAttemptUpdateManyWithWhereWithoutQuizInput[]
    deleteMany?: QuizAttemptScalarWhereInput | QuizAttemptScalarWhereInput[]
  }

  export type QuestionUncheckedUpdateManyWithoutQuizNestedInput = {
    create?: XOR<QuestionCreateWithoutQuizInput, QuestionUncheckedCreateWithoutQuizInput> | QuestionCreateWithoutQuizInput[] | QuestionUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: QuestionCreateOrConnectWithoutQuizInput | QuestionCreateOrConnectWithoutQuizInput[]
    upsert?: QuestionUpsertWithWhereUniqueWithoutQuizInput | QuestionUpsertWithWhereUniqueWithoutQuizInput[]
    createMany?: QuestionCreateManyQuizInputEnvelope
    set?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    disconnect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    delete?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    connect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    update?: QuestionUpdateWithWhereUniqueWithoutQuizInput | QuestionUpdateWithWhereUniqueWithoutQuizInput[]
    updateMany?: QuestionUpdateManyWithWhereWithoutQuizInput | QuestionUpdateManyWithWhereWithoutQuizInput[]
    deleteMany?: QuestionScalarWhereInput | QuestionScalarWhereInput[]
  }

  export type QuizAttemptUncheckedUpdateManyWithoutQuizNestedInput = {
    create?: XOR<QuizAttemptCreateWithoutQuizInput, QuizAttemptUncheckedCreateWithoutQuizInput> | QuizAttemptCreateWithoutQuizInput[] | QuizAttemptUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: QuizAttemptCreateOrConnectWithoutQuizInput | QuizAttemptCreateOrConnectWithoutQuizInput[]
    upsert?: QuizAttemptUpsertWithWhereUniqueWithoutQuizInput | QuizAttemptUpsertWithWhereUniqueWithoutQuizInput[]
    createMany?: QuizAttemptCreateManyQuizInputEnvelope
    set?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    disconnect?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    delete?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    connect?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    update?: QuizAttemptUpdateWithWhereUniqueWithoutQuizInput | QuizAttemptUpdateWithWhereUniqueWithoutQuizInput[]
    updateMany?: QuizAttemptUpdateManyWithWhereWithoutQuizInput | QuizAttemptUpdateManyWithWhereWithoutQuizInput[]
    deleteMany?: QuizAttemptScalarWhereInput | QuizAttemptScalarWhereInput[]
  }

  export type QuestionCreatecorrectOptionsInput = {
    set: number[]
  }

  export type QuizCreateNestedOneWithoutQuestionsInput = {
    create?: XOR<QuizCreateWithoutQuestionsInput, QuizUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: QuizCreateOrConnectWithoutQuestionsInput
    connect?: QuizWhereUniqueInput
  }

  export type EnumQuestionTypeFieldUpdateOperationsInput = {
    set?: $Enums.QuestionType
  }

  export type QuestionUpdatecorrectOptionsInput = {
    set?: number[]
    push?: number | number[]
  }

  export type QuizUpdateOneRequiredWithoutQuestionsNestedInput = {
    create?: XOR<QuizCreateWithoutQuestionsInput, QuizUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: QuizCreateOrConnectWithoutQuestionsInput
    upsert?: QuizUpsertWithoutQuestionsInput
    connect?: QuizWhereUniqueInput
    update?: XOR<XOR<QuizUpdateToOneWithWhereWithoutQuestionsInput, QuizUpdateWithoutQuestionsInput>, QuizUncheckedUpdateWithoutQuestionsInput>
  }

  export type AssignmentCreateallowedFileTypesInput = {
    set: string[]
  }

  export type LessonCreateNestedOneWithoutAssignmentInput = {
    create?: XOR<LessonCreateWithoutAssignmentInput, LessonUncheckedCreateWithoutAssignmentInput>
    connectOrCreate?: LessonCreateOrConnectWithoutAssignmentInput
    connect?: LessonWhereUniqueInput
  }

  export type AssignmentSubmissionCreateNestedManyWithoutAssignmentInput = {
    create?: XOR<AssignmentSubmissionCreateWithoutAssignmentInput, AssignmentSubmissionUncheckedCreateWithoutAssignmentInput> | AssignmentSubmissionCreateWithoutAssignmentInput[] | AssignmentSubmissionUncheckedCreateWithoutAssignmentInput[]
    connectOrCreate?: AssignmentSubmissionCreateOrConnectWithoutAssignmentInput | AssignmentSubmissionCreateOrConnectWithoutAssignmentInput[]
    createMany?: AssignmentSubmissionCreateManyAssignmentInputEnvelope
    connect?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
  }

  export type AssignmentSubmissionUncheckedCreateNestedManyWithoutAssignmentInput = {
    create?: XOR<AssignmentSubmissionCreateWithoutAssignmentInput, AssignmentSubmissionUncheckedCreateWithoutAssignmentInput> | AssignmentSubmissionCreateWithoutAssignmentInput[] | AssignmentSubmissionUncheckedCreateWithoutAssignmentInput[]
    connectOrCreate?: AssignmentSubmissionCreateOrConnectWithoutAssignmentInput | AssignmentSubmissionCreateOrConnectWithoutAssignmentInput[]
    createMany?: AssignmentSubmissionCreateManyAssignmentInputEnvelope
    connect?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
  }

  export type AssignmentUpdateallowedFileTypesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type LessonUpdateOneRequiredWithoutAssignmentNestedInput = {
    create?: XOR<LessonCreateWithoutAssignmentInput, LessonUncheckedCreateWithoutAssignmentInput>
    connectOrCreate?: LessonCreateOrConnectWithoutAssignmentInput
    upsert?: LessonUpsertWithoutAssignmentInput
    connect?: LessonWhereUniqueInput
    update?: XOR<XOR<LessonUpdateToOneWithWhereWithoutAssignmentInput, LessonUpdateWithoutAssignmentInput>, LessonUncheckedUpdateWithoutAssignmentInput>
  }

  export type AssignmentSubmissionUpdateManyWithoutAssignmentNestedInput = {
    create?: XOR<AssignmentSubmissionCreateWithoutAssignmentInput, AssignmentSubmissionUncheckedCreateWithoutAssignmentInput> | AssignmentSubmissionCreateWithoutAssignmentInput[] | AssignmentSubmissionUncheckedCreateWithoutAssignmentInput[]
    connectOrCreate?: AssignmentSubmissionCreateOrConnectWithoutAssignmentInput | AssignmentSubmissionCreateOrConnectWithoutAssignmentInput[]
    upsert?: AssignmentSubmissionUpsertWithWhereUniqueWithoutAssignmentInput | AssignmentSubmissionUpsertWithWhereUniqueWithoutAssignmentInput[]
    createMany?: AssignmentSubmissionCreateManyAssignmentInputEnvelope
    set?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
    disconnect?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
    delete?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
    connect?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
    update?: AssignmentSubmissionUpdateWithWhereUniqueWithoutAssignmentInput | AssignmentSubmissionUpdateWithWhereUniqueWithoutAssignmentInput[]
    updateMany?: AssignmentSubmissionUpdateManyWithWhereWithoutAssignmentInput | AssignmentSubmissionUpdateManyWithWhereWithoutAssignmentInput[]
    deleteMany?: AssignmentSubmissionScalarWhereInput | AssignmentSubmissionScalarWhereInput[]
  }

  export type AssignmentSubmissionUncheckedUpdateManyWithoutAssignmentNestedInput = {
    create?: XOR<AssignmentSubmissionCreateWithoutAssignmentInput, AssignmentSubmissionUncheckedCreateWithoutAssignmentInput> | AssignmentSubmissionCreateWithoutAssignmentInput[] | AssignmentSubmissionUncheckedCreateWithoutAssignmentInput[]
    connectOrCreate?: AssignmentSubmissionCreateOrConnectWithoutAssignmentInput | AssignmentSubmissionCreateOrConnectWithoutAssignmentInput[]
    upsert?: AssignmentSubmissionUpsertWithWhereUniqueWithoutAssignmentInput | AssignmentSubmissionUpsertWithWhereUniqueWithoutAssignmentInput[]
    createMany?: AssignmentSubmissionCreateManyAssignmentInputEnvelope
    set?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
    disconnect?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
    delete?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
    connect?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
    update?: AssignmentSubmissionUpdateWithWhereUniqueWithoutAssignmentInput | AssignmentSubmissionUpdateWithWhereUniqueWithoutAssignmentInput[]
    updateMany?: AssignmentSubmissionUpdateManyWithWhereWithoutAssignmentInput | AssignmentSubmissionUpdateManyWithWhereWithoutAssignmentInput[]
    deleteMany?: AssignmentSubmissionScalarWhereInput | AssignmentSubmissionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutEnrollmentsInput = {
    create?: XOR<UserCreateWithoutEnrollmentsInput, UserUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEnrollmentsInput
    connect?: UserWhereUniqueInput
  }

  export type CourseCreateNestedOneWithoutEnrollmentsInput = {
    create?: XOR<CourseCreateWithoutEnrollmentsInput, CourseUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutEnrollmentsInput
    connect?: CourseWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutEnrollmentsNestedInput = {
    create?: XOR<UserCreateWithoutEnrollmentsInput, UserUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEnrollmentsInput
    upsert?: UserUpsertWithoutEnrollmentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEnrollmentsInput, UserUpdateWithoutEnrollmentsInput>, UserUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type CourseUpdateOneRequiredWithoutEnrollmentsNestedInput = {
    create?: XOR<CourseCreateWithoutEnrollmentsInput, CourseUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutEnrollmentsInput
    upsert?: CourseUpsertWithoutEnrollmentsInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutEnrollmentsInput, CourseUpdateWithoutEnrollmentsInput>, CourseUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type UserCreateNestedOneWithoutSavedCoursesInput = {
    create?: XOR<UserCreateWithoutSavedCoursesInput, UserUncheckedCreateWithoutSavedCoursesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSavedCoursesInput
    connect?: UserWhereUniqueInput
  }

  export type CourseCreateNestedOneWithoutSavedByInput = {
    create?: XOR<CourseCreateWithoutSavedByInput, CourseUncheckedCreateWithoutSavedByInput>
    connectOrCreate?: CourseCreateOrConnectWithoutSavedByInput
    connect?: CourseWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSavedCoursesNestedInput = {
    create?: XOR<UserCreateWithoutSavedCoursesInput, UserUncheckedCreateWithoutSavedCoursesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSavedCoursesInput
    upsert?: UserUpsertWithoutSavedCoursesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSavedCoursesInput, UserUpdateWithoutSavedCoursesInput>, UserUncheckedUpdateWithoutSavedCoursesInput>
  }

  export type CourseUpdateOneRequiredWithoutSavedByNestedInput = {
    create?: XOR<CourseCreateWithoutSavedByInput, CourseUncheckedCreateWithoutSavedByInput>
    connectOrCreate?: CourseCreateOrConnectWithoutSavedByInput
    upsert?: CourseUpsertWithoutSavedByInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutSavedByInput, CourseUpdateWithoutSavedByInput>, CourseUncheckedUpdateWithoutSavedByInput>
  }

  export type UserCreateNestedOneWithoutLikedCoursesInput = {
    create?: XOR<UserCreateWithoutLikedCoursesInput, UserUncheckedCreateWithoutLikedCoursesInput>
    connectOrCreate?: UserCreateOrConnectWithoutLikedCoursesInput
    connect?: UserWhereUniqueInput
  }

  export type CourseCreateNestedOneWithoutLikedByInput = {
    create?: XOR<CourseCreateWithoutLikedByInput, CourseUncheckedCreateWithoutLikedByInput>
    connectOrCreate?: CourseCreateOrConnectWithoutLikedByInput
    connect?: CourseWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutLikedCoursesNestedInput = {
    create?: XOR<UserCreateWithoutLikedCoursesInput, UserUncheckedCreateWithoutLikedCoursesInput>
    connectOrCreate?: UserCreateOrConnectWithoutLikedCoursesInput
    upsert?: UserUpsertWithoutLikedCoursesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLikedCoursesInput, UserUpdateWithoutLikedCoursesInput>, UserUncheckedUpdateWithoutLikedCoursesInput>
  }

  export type CourseUpdateOneRequiredWithoutLikedByNestedInput = {
    create?: XOR<CourseCreateWithoutLikedByInput, CourseUncheckedCreateWithoutLikedByInput>
    connectOrCreate?: CourseCreateOrConnectWithoutLikedByInput
    upsert?: CourseUpsertWithoutLikedByInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutLikedByInput, CourseUpdateWithoutLikedByInput>, CourseUncheckedUpdateWithoutLikedByInput>
  }

  export type UserCreateNestedOneWithoutLessonProgressInput = {
    create?: XOR<UserCreateWithoutLessonProgressInput, UserUncheckedCreateWithoutLessonProgressInput>
    connectOrCreate?: UserCreateOrConnectWithoutLessonProgressInput
    connect?: UserWhereUniqueInput
  }

  export type LessonCreateNestedOneWithoutProgressInput = {
    create?: XOR<LessonCreateWithoutProgressInput, LessonUncheckedCreateWithoutProgressInput>
    connectOrCreate?: LessonCreateOrConnectWithoutProgressInput
    connect?: LessonWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutLessonProgressNestedInput = {
    create?: XOR<UserCreateWithoutLessonProgressInput, UserUncheckedCreateWithoutLessonProgressInput>
    connectOrCreate?: UserCreateOrConnectWithoutLessonProgressInput
    upsert?: UserUpsertWithoutLessonProgressInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLessonProgressInput, UserUpdateWithoutLessonProgressInput>, UserUncheckedUpdateWithoutLessonProgressInput>
  }

  export type LessonUpdateOneRequiredWithoutProgressNestedInput = {
    create?: XOR<LessonCreateWithoutProgressInput, LessonUncheckedCreateWithoutProgressInput>
    connectOrCreate?: LessonCreateOrConnectWithoutProgressInput
    upsert?: LessonUpsertWithoutProgressInput
    connect?: LessonWhereUniqueInput
    update?: XOR<XOR<LessonUpdateToOneWithWhereWithoutProgressInput, LessonUpdateWithoutProgressInput>, LessonUncheckedUpdateWithoutProgressInput>
  }

  export type UserCreateNestedOneWithoutQuizAttemptsInput = {
    create?: XOR<UserCreateWithoutQuizAttemptsInput, UserUncheckedCreateWithoutQuizAttemptsInput>
    connectOrCreate?: UserCreateOrConnectWithoutQuizAttemptsInput
    connect?: UserWhereUniqueInput
  }

  export type QuizCreateNestedOneWithoutAttemptsInput = {
    create?: XOR<QuizCreateWithoutAttemptsInput, QuizUncheckedCreateWithoutAttemptsInput>
    connectOrCreate?: QuizCreateOrConnectWithoutAttemptsInput
    connect?: QuizWhereUniqueInput
  }

  export type CourseCreateNestedOneWithoutQuizAttemptsInput = {
    create?: XOR<CourseCreateWithoutQuizAttemptsInput, CourseUncheckedCreateWithoutQuizAttemptsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutQuizAttemptsInput
    connect?: CourseWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutQuizAttemptsNestedInput = {
    create?: XOR<UserCreateWithoutQuizAttemptsInput, UserUncheckedCreateWithoutQuizAttemptsInput>
    connectOrCreate?: UserCreateOrConnectWithoutQuizAttemptsInput
    upsert?: UserUpsertWithoutQuizAttemptsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutQuizAttemptsInput, UserUpdateWithoutQuizAttemptsInput>, UserUncheckedUpdateWithoutQuizAttemptsInput>
  }

  export type QuizUpdateOneRequiredWithoutAttemptsNestedInput = {
    create?: XOR<QuizCreateWithoutAttemptsInput, QuizUncheckedCreateWithoutAttemptsInput>
    connectOrCreate?: QuizCreateOrConnectWithoutAttemptsInput
    upsert?: QuizUpsertWithoutAttemptsInput
    connect?: QuizWhereUniqueInput
    update?: XOR<XOR<QuizUpdateToOneWithWhereWithoutAttemptsInput, QuizUpdateWithoutAttemptsInput>, QuizUncheckedUpdateWithoutAttemptsInput>
  }

  export type CourseUpdateOneWithoutQuizAttemptsNestedInput = {
    create?: XOR<CourseCreateWithoutQuizAttemptsInput, CourseUncheckedCreateWithoutQuizAttemptsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutQuizAttemptsInput
    upsert?: CourseUpsertWithoutQuizAttemptsInput
    disconnect?: CourseWhereInput | boolean
    delete?: CourseWhereInput | boolean
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutQuizAttemptsInput, CourseUpdateWithoutQuizAttemptsInput>, CourseUncheckedUpdateWithoutQuizAttemptsInput>
  }

  export type AssignmentSubmissionCreatefileUrlsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutAssignmentSubsInput = {
    create?: XOR<UserCreateWithoutAssignmentSubsInput, UserUncheckedCreateWithoutAssignmentSubsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignmentSubsInput
    connect?: UserWhereUniqueInput
  }

  export type AssignmentCreateNestedOneWithoutSubmissionsInput = {
    create?: XOR<AssignmentCreateWithoutSubmissionsInput, AssignmentUncheckedCreateWithoutSubmissionsInput>
    connectOrCreate?: AssignmentCreateOrConnectWithoutSubmissionsInput
    connect?: AssignmentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSubmissionsGradedInput = {
    create?: XOR<UserCreateWithoutSubmissionsGradedInput, UserUncheckedCreateWithoutSubmissionsGradedInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubmissionsGradedInput
    connect?: UserWhereUniqueInput
  }

  export type AssignmentSubmissionUpdatefileUrlsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutAssignmentSubsNestedInput = {
    create?: XOR<UserCreateWithoutAssignmentSubsInput, UserUncheckedCreateWithoutAssignmentSubsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignmentSubsInput
    upsert?: UserUpsertWithoutAssignmentSubsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAssignmentSubsInput, UserUpdateWithoutAssignmentSubsInput>, UserUncheckedUpdateWithoutAssignmentSubsInput>
  }

  export type AssignmentUpdateOneRequiredWithoutSubmissionsNestedInput = {
    create?: XOR<AssignmentCreateWithoutSubmissionsInput, AssignmentUncheckedCreateWithoutSubmissionsInput>
    connectOrCreate?: AssignmentCreateOrConnectWithoutSubmissionsInput
    upsert?: AssignmentUpsertWithoutSubmissionsInput
    connect?: AssignmentWhereUniqueInput
    update?: XOR<XOR<AssignmentUpdateToOneWithWhereWithoutSubmissionsInput, AssignmentUpdateWithoutSubmissionsInput>, AssignmentUncheckedUpdateWithoutSubmissionsInput>
  }

  export type UserUpdateOneWithoutSubmissionsGradedNestedInput = {
    create?: XOR<UserCreateWithoutSubmissionsGradedInput, UserUncheckedCreateWithoutSubmissionsGradedInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubmissionsGradedInput
    upsert?: UserUpsertWithoutSubmissionsGradedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSubmissionsGradedInput, UserUpdateWithoutSubmissionsGradedInput>, UserUncheckedUpdateWithoutSubmissionsGradedInput>
  }

  export type UserCreateNestedOneWithoutCourseReviewsInput = {
    create?: XOR<UserCreateWithoutCourseReviewsInput, UserUncheckedCreateWithoutCourseReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCourseReviewsInput
    connect?: UserWhereUniqueInput
  }

  export type CourseCreateNestedOneWithoutReviewsInput = {
    create?: XOR<CourseCreateWithoutReviewsInput, CourseUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutReviewsInput
    connect?: CourseWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutCourseReviewsNestedInput = {
    create?: XOR<UserCreateWithoutCourseReviewsInput, UserUncheckedCreateWithoutCourseReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCourseReviewsInput
    upsert?: UserUpsertWithoutCourseReviewsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCourseReviewsInput, UserUpdateWithoutCourseReviewsInput>, UserUncheckedUpdateWithoutCourseReviewsInput>
  }

  export type CourseUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<CourseCreateWithoutReviewsInput, CourseUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutReviewsInput
    upsert?: CourseUpsertWithoutReviewsInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutReviewsInput, CourseUpdateWithoutReviewsInput>, CourseUncheckedUpdateWithoutReviewsInput>
  }

  export type TutoringSessionCreateprerequisitesInput = {
    set: string[]
  }

  export type TutoringSessionCreatetagsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutTutoringSessionsInput = {
    create?: XOR<UserCreateWithoutTutoringSessionsInput, UserUncheckedCreateWithoutTutoringSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTutoringSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type TutoringAvailabilityCreateNestedManyWithoutSessionInput = {
    create?: XOR<TutoringAvailabilityCreateWithoutSessionInput, TutoringAvailabilityUncheckedCreateWithoutSessionInput> | TutoringAvailabilityCreateWithoutSessionInput[] | TutoringAvailabilityUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: TutoringAvailabilityCreateOrConnectWithoutSessionInput | TutoringAvailabilityCreateOrConnectWithoutSessionInput[]
    createMany?: TutoringAvailabilityCreateManySessionInputEnvelope
    connect?: TutoringAvailabilityWhereUniqueInput | TutoringAvailabilityWhereUniqueInput[]
  }

  export type TutoringRequestCreateNestedManyWithoutSessionInput = {
    create?: XOR<TutoringRequestCreateWithoutSessionInput, TutoringRequestUncheckedCreateWithoutSessionInput> | TutoringRequestCreateWithoutSessionInput[] | TutoringRequestUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: TutoringRequestCreateOrConnectWithoutSessionInput | TutoringRequestCreateOrConnectWithoutSessionInput[]
    createMany?: TutoringRequestCreateManySessionInputEnvelope
    connect?: TutoringRequestWhereUniqueInput | TutoringRequestWhereUniqueInput[]
  }

  export type TutoringAppointmentCreateNestedManyWithoutSessionInput = {
    create?: XOR<TutoringAppointmentCreateWithoutSessionInput, TutoringAppointmentUncheckedCreateWithoutSessionInput> | TutoringAppointmentCreateWithoutSessionInput[] | TutoringAppointmentUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: TutoringAppointmentCreateOrConnectWithoutSessionInput | TutoringAppointmentCreateOrConnectWithoutSessionInput[]
    createMany?: TutoringAppointmentCreateManySessionInputEnvelope
    connect?: TutoringAppointmentWhereUniqueInput | TutoringAppointmentWhereUniqueInput[]
  }

  export type TutoringReviewCreateNestedManyWithoutSessionInput = {
    create?: XOR<TutoringReviewCreateWithoutSessionInput, TutoringReviewUncheckedCreateWithoutSessionInput> | TutoringReviewCreateWithoutSessionInput[] | TutoringReviewUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: TutoringReviewCreateOrConnectWithoutSessionInput | TutoringReviewCreateOrConnectWithoutSessionInput[]
    createMany?: TutoringReviewCreateManySessionInputEnvelope
    connect?: TutoringReviewWhereUniqueInput | TutoringReviewWhereUniqueInput[]
  }

  export type CertificateCreateNestedManyWithoutTutoringInput = {
    create?: XOR<CertificateCreateWithoutTutoringInput, CertificateUncheckedCreateWithoutTutoringInput> | CertificateCreateWithoutTutoringInput[] | CertificateUncheckedCreateWithoutTutoringInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutTutoringInput | CertificateCreateOrConnectWithoutTutoringInput[]
    createMany?: CertificateCreateManyTutoringInputEnvelope
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
  }

  export type TutoringAvailabilityUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<TutoringAvailabilityCreateWithoutSessionInput, TutoringAvailabilityUncheckedCreateWithoutSessionInput> | TutoringAvailabilityCreateWithoutSessionInput[] | TutoringAvailabilityUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: TutoringAvailabilityCreateOrConnectWithoutSessionInput | TutoringAvailabilityCreateOrConnectWithoutSessionInput[]
    createMany?: TutoringAvailabilityCreateManySessionInputEnvelope
    connect?: TutoringAvailabilityWhereUniqueInput | TutoringAvailabilityWhereUniqueInput[]
  }

  export type TutoringRequestUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<TutoringRequestCreateWithoutSessionInput, TutoringRequestUncheckedCreateWithoutSessionInput> | TutoringRequestCreateWithoutSessionInput[] | TutoringRequestUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: TutoringRequestCreateOrConnectWithoutSessionInput | TutoringRequestCreateOrConnectWithoutSessionInput[]
    createMany?: TutoringRequestCreateManySessionInputEnvelope
    connect?: TutoringRequestWhereUniqueInput | TutoringRequestWhereUniqueInput[]
  }

  export type TutoringAppointmentUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<TutoringAppointmentCreateWithoutSessionInput, TutoringAppointmentUncheckedCreateWithoutSessionInput> | TutoringAppointmentCreateWithoutSessionInput[] | TutoringAppointmentUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: TutoringAppointmentCreateOrConnectWithoutSessionInput | TutoringAppointmentCreateOrConnectWithoutSessionInput[]
    createMany?: TutoringAppointmentCreateManySessionInputEnvelope
    connect?: TutoringAppointmentWhereUniqueInput | TutoringAppointmentWhereUniqueInput[]
  }

  export type TutoringReviewUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<TutoringReviewCreateWithoutSessionInput, TutoringReviewUncheckedCreateWithoutSessionInput> | TutoringReviewCreateWithoutSessionInput[] | TutoringReviewUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: TutoringReviewCreateOrConnectWithoutSessionInput | TutoringReviewCreateOrConnectWithoutSessionInput[]
    createMany?: TutoringReviewCreateManySessionInputEnvelope
    connect?: TutoringReviewWhereUniqueInput | TutoringReviewWhereUniqueInput[]
  }

  export type CertificateUncheckedCreateNestedManyWithoutTutoringInput = {
    create?: XOR<CertificateCreateWithoutTutoringInput, CertificateUncheckedCreateWithoutTutoringInput> | CertificateCreateWithoutTutoringInput[] | CertificateUncheckedCreateWithoutTutoringInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutTutoringInput | CertificateCreateOrConnectWithoutTutoringInput[]
    createMany?: CertificateCreateManyTutoringInputEnvelope
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
  }

  export type EnumTutoringLocationTypeFieldUpdateOperationsInput = {
    set?: $Enums.TutoringLocationType
  }

  export type EnumTutoringStatusFieldUpdateOperationsInput = {
    set?: $Enums.TutoringStatus
  }

  export type TutoringSessionUpdateprerequisitesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type TutoringSessionUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutTutoringSessionsNestedInput = {
    create?: XOR<UserCreateWithoutTutoringSessionsInput, UserUncheckedCreateWithoutTutoringSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTutoringSessionsInput
    upsert?: UserUpsertWithoutTutoringSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTutoringSessionsInput, UserUpdateWithoutTutoringSessionsInput>, UserUncheckedUpdateWithoutTutoringSessionsInput>
  }

  export type TutoringAvailabilityUpdateManyWithoutSessionNestedInput = {
    create?: XOR<TutoringAvailabilityCreateWithoutSessionInput, TutoringAvailabilityUncheckedCreateWithoutSessionInput> | TutoringAvailabilityCreateWithoutSessionInput[] | TutoringAvailabilityUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: TutoringAvailabilityCreateOrConnectWithoutSessionInput | TutoringAvailabilityCreateOrConnectWithoutSessionInput[]
    upsert?: TutoringAvailabilityUpsertWithWhereUniqueWithoutSessionInput | TutoringAvailabilityUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: TutoringAvailabilityCreateManySessionInputEnvelope
    set?: TutoringAvailabilityWhereUniqueInput | TutoringAvailabilityWhereUniqueInput[]
    disconnect?: TutoringAvailabilityWhereUniqueInput | TutoringAvailabilityWhereUniqueInput[]
    delete?: TutoringAvailabilityWhereUniqueInput | TutoringAvailabilityWhereUniqueInput[]
    connect?: TutoringAvailabilityWhereUniqueInput | TutoringAvailabilityWhereUniqueInput[]
    update?: TutoringAvailabilityUpdateWithWhereUniqueWithoutSessionInput | TutoringAvailabilityUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: TutoringAvailabilityUpdateManyWithWhereWithoutSessionInput | TutoringAvailabilityUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: TutoringAvailabilityScalarWhereInput | TutoringAvailabilityScalarWhereInput[]
  }

  export type TutoringRequestUpdateManyWithoutSessionNestedInput = {
    create?: XOR<TutoringRequestCreateWithoutSessionInput, TutoringRequestUncheckedCreateWithoutSessionInput> | TutoringRequestCreateWithoutSessionInput[] | TutoringRequestUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: TutoringRequestCreateOrConnectWithoutSessionInput | TutoringRequestCreateOrConnectWithoutSessionInput[]
    upsert?: TutoringRequestUpsertWithWhereUniqueWithoutSessionInput | TutoringRequestUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: TutoringRequestCreateManySessionInputEnvelope
    set?: TutoringRequestWhereUniqueInput | TutoringRequestWhereUniqueInput[]
    disconnect?: TutoringRequestWhereUniqueInput | TutoringRequestWhereUniqueInput[]
    delete?: TutoringRequestWhereUniqueInput | TutoringRequestWhereUniqueInput[]
    connect?: TutoringRequestWhereUniqueInput | TutoringRequestWhereUniqueInput[]
    update?: TutoringRequestUpdateWithWhereUniqueWithoutSessionInput | TutoringRequestUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: TutoringRequestUpdateManyWithWhereWithoutSessionInput | TutoringRequestUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: TutoringRequestScalarWhereInput | TutoringRequestScalarWhereInput[]
  }

  export type TutoringAppointmentUpdateManyWithoutSessionNestedInput = {
    create?: XOR<TutoringAppointmentCreateWithoutSessionInput, TutoringAppointmentUncheckedCreateWithoutSessionInput> | TutoringAppointmentCreateWithoutSessionInput[] | TutoringAppointmentUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: TutoringAppointmentCreateOrConnectWithoutSessionInput | TutoringAppointmentCreateOrConnectWithoutSessionInput[]
    upsert?: TutoringAppointmentUpsertWithWhereUniqueWithoutSessionInput | TutoringAppointmentUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: TutoringAppointmentCreateManySessionInputEnvelope
    set?: TutoringAppointmentWhereUniqueInput | TutoringAppointmentWhereUniqueInput[]
    disconnect?: TutoringAppointmentWhereUniqueInput | TutoringAppointmentWhereUniqueInput[]
    delete?: TutoringAppointmentWhereUniqueInput | TutoringAppointmentWhereUniqueInput[]
    connect?: TutoringAppointmentWhereUniqueInput | TutoringAppointmentWhereUniqueInput[]
    update?: TutoringAppointmentUpdateWithWhereUniqueWithoutSessionInput | TutoringAppointmentUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: TutoringAppointmentUpdateManyWithWhereWithoutSessionInput | TutoringAppointmentUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: TutoringAppointmentScalarWhereInput | TutoringAppointmentScalarWhereInput[]
  }

  export type TutoringReviewUpdateManyWithoutSessionNestedInput = {
    create?: XOR<TutoringReviewCreateWithoutSessionInput, TutoringReviewUncheckedCreateWithoutSessionInput> | TutoringReviewCreateWithoutSessionInput[] | TutoringReviewUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: TutoringReviewCreateOrConnectWithoutSessionInput | TutoringReviewCreateOrConnectWithoutSessionInput[]
    upsert?: TutoringReviewUpsertWithWhereUniqueWithoutSessionInput | TutoringReviewUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: TutoringReviewCreateManySessionInputEnvelope
    set?: TutoringReviewWhereUniqueInput | TutoringReviewWhereUniqueInput[]
    disconnect?: TutoringReviewWhereUniqueInput | TutoringReviewWhereUniqueInput[]
    delete?: TutoringReviewWhereUniqueInput | TutoringReviewWhereUniqueInput[]
    connect?: TutoringReviewWhereUniqueInput | TutoringReviewWhereUniqueInput[]
    update?: TutoringReviewUpdateWithWhereUniqueWithoutSessionInput | TutoringReviewUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: TutoringReviewUpdateManyWithWhereWithoutSessionInput | TutoringReviewUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: TutoringReviewScalarWhereInput | TutoringReviewScalarWhereInput[]
  }

  export type CertificateUpdateManyWithoutTutoringNestedInput = {
    create?: XOR<CertificateCreateWithoutTutoringInput, CertificateUncheckedCreateWithoutTutoringInput> | CertificateCreateWithoutTutoringInput[] | CertificateUncheckedCreateWithoutTutoringInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutTutoringInput | CertificateCreateOrConnectWithoutTutoringInput[]
    upsert?: CertificateUpsertWithWhereUniqueWithoutTutoringInput | CertificateUpsertWithWhereUniqueWithoutTutoringInput[]
    createMany?: CertificateCreateManyTutoringInputEnvelope
    set?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    disconnect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    delete?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    update?: CertificateUpdateWithWhereUniqueWithoutTutoringInput | CertificateUpdateWithWhereUniqueWithoutTutoringInput[]
    updateMany?: CertificateUpdateManyWithWhereWithoutTutoringInput | CertificateUpdateManyWithWhereWithoutTutoringInput[]
    deleteMany?: CertificateScalarWhereInput | CertificateScalarWhereInput[]
  }

  export type TutoringAvailabilityUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<TutoringAvailabilityCreateWithoutSessionInput, TutoringAvailabilityUncheckedCreateWithoutSessionInput> | TutoringAvailabilityCreateWithoutSessionInput[] | TutoringAvailabilityUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: TutoringAvailabilityCreateOrConnectWithoutSessionInput | TutoringAvailabilityCreateOrConnectWithoutSessionInput[]
    upsert?: TutoringAvailabilityUpsertWithWhereUniqueWithoutSessionInput | TutoringAvailabilityUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: TutoringAvailabilityCreateManySessionInputEnvelope
    set?: TutoringAvailabilityWhereUniqueInput | TutoringAvailabilityWhereUniqueInput[]
    disconnect?: TutoringAvailabilityWhereUniqueInput | TutoringAvailabilityWhereUniqueInput[]
    delete?: TutoringAvailabilityWhereUniqueInput | TutoringAvailabilityWhereUniqueInput[]
    connect?: TutoringAvailabilityWhereUniqueInput | TutoringAvailabilityWhereUniqueInput[]
    update?: TutoringAvailabilityUpdateWithWhereUniqueWithoutSessionInput | TutoringAvailabilityUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: TutoringAvailabilityUpdateManyWithWhereWithoutSessionInput | TutoringAvailabilityUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: TutoringAvailabilityScalarWhereInput | TutoringAvailabilityScalarWhereInput[]
  }

  export type TutoringRequestUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<TutoringRequestCreateWithoutSessionInput, TutoringRequestUncheckedCreateWithoutSessionInput> | TutoringRequestCreateWithoutSessionInput[] | TutoringRequestUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: TutoringRequestCreateOrConnectWithoutSessionInput | TutoringRequestCreateOrConnectWithoutSessionInput[]
    upsert?: TutoringRequestUpsertWithWhereUniqueWithoutSessionInput | TutoringRequestUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: TutoringRequestCreateManySessionInputEnvelope
    set?: TutoringRequestWhereUniqueInput | TutoringRequestWhereUniqueInput[]
    disconnect?: TutoringRequestWhereUniqueInput | TutoringRequestWhereUniqueInput[]
    delete?: TutoringRequestWhereUniqueInput | TutoringRequestWhereUniqueInput[]
    connect?: TutoringRequestWhereUniqueInput | TutoringRequestWhereUniqueInput[]
    update?: TutoringRequestUpdateWithWhereUniqueWithoutSessionInput | TutoringRequestUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: TutoringRequestUpdateManyWithWhereWithoutSessionInput | TutoringRequestUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: TutoringRequestScalarWhereInput | TutoringRequestScalarWhereInput[]
  }

  export type TutoringAppointmentUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<TutoringAppointmentCreateWithoutSessionInput, TutoringAppointmentUncheckedCreateWithoutSessionInput> | TutoringAppointmentCreateWithoutSessionInput[] | TutoringAppointmentUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: TutoringAppointmentCreateOrConnectWithoutSessionInput | TutoringAppointmentCreateOrConnectWithoutSessionInput[]
    upsert?: TutoringAppointmentUpsertWithWhereUniqueWithoutSessionInput | TutoringAppointmentUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: TutoringAppointmentCreateManySessionInputEnvelope
    set?: TutoringAppointmentWhereUniqueInput | TutoringAppointmentWhereUniqueInput[]
    disconnect?: TutoringAppointmentWhereUniqueInput | TutoringAppointmentWhereUniqueInput[]
    delete?: TutoringAppointmentWhereUniqueInput | TutoringAppointmentWhereUniqueInput[]
    connect?: TutoringAppointmentWhereUniqueInput | TutoringAppointmentWhereUniqueInput[]
    update?: TutoringAppointmentUpdateWithWhereUniqueWithoutSessionInput | TutoringAppointmentUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: TutoringAppointmentUpdateManyWithWhereWithoutSessionInput | TutoringAppointmentUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: TutoringAppointmentScalarWhereInput | TutoringAppointmentScalarWhereInput[]
  }

  export type TutoringReviewUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<TutoringReviewCreateWithoutSessionInput, TutoringReviewUncheckedCreateWithoutSessionInput> | TutoringReviewCreateWithoutSessionInput[] | TutoringReviewUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: TutoringReviewCreateOrConnectWithoutSessionInput | TutoringReviewCreateOrConnectWithoutSessionInput[]
    upsert?: TutoringReviewUpsertWithWhereUniqueWithoutSessionInput | TutoringReviewUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: TutoringReviewCreateManySessionInputEnvelope
    set?: TutoringReviewWhereUniqueInput | TutoringReviewWhereUniqueInput[]
    disconnect?: TutoringReviewWhereUniqueInput | TutoringReviewWhereUniqueInput[]
    delete?: TutoringReviewWhereUniqueInput | TutoringReviewWhereUniqueInput[]
    connect?: TutoringReviewWhereUniqueInput | TutoringReviewWhereUniqueInput[]
    update?: TutoringReviewUpdateWithWhereUniqueWithoutSessionInput | TutoringReviewUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: TutoringReviewUpdateManyWithWhereWithoutSessionInput | TutoringReviewUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: TutoringReviewScalarWhereInput | TutoringReviewScalarWhereInput[]
  }

  export type CertificateUncheckedUpdateManyWithoutTutoringNestedInput = {
    create?: XOR<CertificateCreateWithoutTutoringInput, CertificateUncheckedCreateWithoutTutoringInput> | CertificateCreateWithoutTutoringInput[] | CertificateUncheckedCreateWithoutTutoringInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutTutoringInput | CertificateCreateOrConnectWithoutTutoringInput[]
    upsert?: CertificateUpsertWithWhereUniqueWithoutTutoringInput | CertificateUpsertWithWhereUniqueWithoutTutoringInput[]
    createMany?: CertificateCreateManyTutoringInputEnvelope
    set?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    disconnect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    delete?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    update?: CertificateUpdateWithWhereUniqueWithoutTutoringInput | CertificateUpdateWithWhereUniqueWithoutTutoringInput[]
    updateMany?: CertificateUpdateManyWithWhereWithoutTutoringInput | CertificateUpdateManyWithWhereWithoutTutoringInput[]
    deleteMany?: CertificateScalarWhereInput | CertificateScalarWhereInput[]
  }

  export type TutoringSessionCreateNestedOneWithoutAvailabilityInput = {
    create?: XOR<TutoringSessionCreateWithoutAvailabilityInput, TutoringSessionUncheckedCreateWithoutAvailabilityInput>
    connectOrCreate?: TutoringSessionCreateOrConnectWithoutAvailabilityInput
    connect?: TutoringSessionWhereUniqueInput
  }

  export type TutoringSessionUpdateOneRequiredWithoutAvailabilityNestedInput = {
    create?: XOR<TutoringSessionCreateWithoutAvailabilityInput, TutoringSessionUncheckedCreateWithoutAvailabilityInput>
    connectOrCreate?: TutoringSessionCreateOrConnectWithoutAvailabilityInput
    upsert?: TutoringSessionUpsertWithoutAvailabilityInput
    connect?: TutoringSessionWhereUniqueInput
    update?: XOR<XOR<TutoringSessionUpdateToOneWithWhereWithoutAvailabilityInput, TutoringSessionUpdateWithoutAvailabilityInput>, TutoringSessionUncheckedUpdateWithoutAvailabilityInput>
  }

  export type TutoringRequestCreatepreferredDatesInput = {
    set: Date[] | string[]
  }

  export type TutoringSessionCreateNestedOneWithoutRequestsInput = {
    create?: XOR<TutoringSessionCreateWithoutRequestsInput, TutoringSessionUncheckedCreateWithoutRequestsInput>
    connectOrCreate?: TutoringSessionCreateOrConnectWithoutRequestsInput
    connect?: TutoringSessionWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTutoringRequestsInput = {
    create?: XOR<UserCreateWithoutTutoringRequestsInput, UserUncheckedCreateWithoutTutoringRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTutoringRequestsInput
    connect?: UserWhereUniqueInput
  }

  export type TutoringAppointmentCreateNestedOneWithoutRequestInput = {
    create?: XOR<TutoringAppointmentCreateWithoutRequestInput, TutoringAppointmentUncheckedCreateWithoutRequestInput>
    connectOrCreate?: TutoringAppointmentCreateOrConnectWithoutRequestInput
    connect?: TutoringAppointmentWhereUniqueInput
  }

  export type TutoringMessageCreateNestedManyWithoutRequestInput = {
    create?: XOR<TutoringMessageCreateWithoutRequestInput, TutoringMessageUncheckedCreateWithoutRequestInput> | TutoringMessageCreateWithoutRequestInput[] | TutoringMessageUncheckedCreateWithoutRequestInput[]
    connectOrCreate?: TutoringMessageCreateOrConnectWithoutRequestInput | TutoringMessageCreateOrConnectWithoutRequestInput[]
    createMany?: TutoringMessageCreateManyRequestInputEnvelope
    connect?: TutoringMessageWhereUniqueInput | TutoringMessageWhereUniqueInput[]
  }

  export type TutoringAppointmentUncheckedCreateNestedOneWithoutRequestInput = {
    create?: XOR<TutoringAppointmentCreateWithoutRequestInput, TutoringAppointmentUncheckedCreateWithoutRequestInput>
    connectOrCreate?: TutoringAppointmentCreateOrConnectWithoutRequestInput
    connect?: TutoringAppointmentWhereUniqueInput
  }

  export type TutoringMessageUncheckedCreateNestedManyWithoutRequestInput = {
    create?: XOR<TutoringMessageCreateWithoutRequestInput, TutoringMessageUncheckedCreateWithoutRequestInput> | TutoringMessageCreateWithoutRequestInput[] | TutoringMessageUncheckedCreateWithoutRequestInput[]
    connectOrCreate?: TutoringMessageCreateOrConnectWithoutRequestInput | TutoringMessageCreateOrConnectWithoutRequestInput[]
    createMany?: TutoringMessageCreateManyRequestInputEnvelope
    connect?: TutoringMessageWhereUniqueInput | TutoringMessageWhereUniqueInput[]
  }

  export type TutoringRequestUpdatepreferredDatesInput = {
    set?: Date[] | string[]
    push?: Date | string | Date[] | string[]
  }

  export type EnumTutoringRequestStatusFieldUpdateOperationsInput = {
    set?: $Enums.TutoringRequestStatus
  }

  export type TutoringSessionUpdateOneRequiredWithoutRequestsNestedInput = {
    create?: XOR<TutoringSessionCreateWithoutRequestsInput, TutoringSessionUncheckedCreateWithoutRequestsInput>
    connectOrCreate?: TutoringSessionCreateOrConnectWithoutRequestsInput
    upsert?: TutoringSessionUpsertWithoutRequestsInput
    connect?: TutoringSessionWhereUniqueInput
    update?: XOR<XOR<TutoringSessionUpdateToOneWithWhereWithoutRequestsInput, TutoringSessionUpdateWithoutRequestsInput>, TutoringSessionUncheckedUpdateWithoutRequestsInput>
  }

  export type UserUpdateOneRequiredWithoutTutoringRequestsNestedInput = {
    create?: XOR<UserCreateWithoutTutoringRequestsInput, UserUncheckedCreateWithoutTutoringRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTutoringRequestsInput
    upsert?: UserUpsertWithoutTutoringRequestsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTutoringRequestsInput, UserUpdateWithoutTutoringRequestsInput>, UserUncheckedUpdateWithoutTutoringRequestsInput>
  }

  export type TutoringAppointmentUpdateOneWithoutRequestNestedInput = {
    create?: XOR<TutoringAppointmentCreateWithoutRequestInput, TutoringAppointmentUncheckedCreateWithoutRequestInput>
    connectOrCreate?: TutoringAppointmentCreateOrConnectWithoutRequestInput
    upsert?: TutoringAppointmentUpsertWithoutRequestInput
    disconnect?: TutoringAppointmentWhereInput | boolean
    delete?: TutoringAppointmentWhereInput | boolean
    connect?: TutoringAppointmentWhereUniqueInput
    update?: XOR<XOR<TutoringAppointmentUpdateToOneWithWhereWithoutRequestInput, TutoringAppointmentUpdateWithoutRequestInput>, TutoringAppointmentUncheckedUpdateWithoutRequestInput>
  }

  export type TutoringMessageUpdateManyWithoutRequestNestedInput = {
    create?: XOR<TutoringMessageCreateWithoutRequestInput, TutoringMessageUncheckedCreateWithoutRequestInput> | TutoringMessageCreateWithoutRequestInput[] | TutoringMessageUncheckedCreateWithoutRequestInput[]
    connectOrCreate?: TutoringMessageCreateOrConnectWithoutRequestInput | TutoringMessageCreateOrConnectWithoutRequestInput[]
    upsert?: TutoringMessageUpsertWithWhereUniqueWithoutRequestInput | TutoringMessageUpsertWithWhereUniqueWithoutRequestInput[]
    createMany?: TutoringMessageCreateManyRequestInputEnvelope
    set?: TutoringMessageWhereUniqueInput | TutoringMessageWhereUniqueInput[]
    disconnect?: TutoringMessageWhereUniqueInput | TutoringMessageWhereUniqueInput[]
    delete?: TutoringMessageWhereUniqueInput | TutoringMessageWhereUniqueInput[]
    connect?: TutoringMessageWhereUniqueInput | TutoringMessageWhereUniqueInput[]
    update?: TutoringMessageUpdateWithWhereUniqueWithoutRequestInput | TutoringMessageUpdateWithWhereUniqueWithoutRequestInput[]
    updateMany?: TutoringMessageUpdateManyWithWhereWithoutRequestInput | TutoringMessageUpdateManyWithWhereWithoutRequestInput[]
    deleteMany?: TutoringMessageScalarWhereInput | TutoringMessageScalarWhereInput[]
  }

  export type TutoringAppointmentUncheckedUpdateOneWithoutRequestNestedInput = {
    create?: XOR<TutoringAppointmentCreateWithoutRequestInput, TutoringAppointmentUncheckedCreateWithoutRequestInput>
    connectOrCreate?: TutoringAppointmentCreateOrConnectWithoutRequestInput
    upsert?: TutoringAppointmentUpsertWithoutRequestInput
    disconnect?: TutoringAppointmentWhereInput | boolean
    delete?: TutoringAppointmentWhereInput | boolean
    connect?: TutoringAppointmentWhereUniqueInput
    update?: XOR<XOR<TutoringAppointmentUpdateToOneWithWhereWithoutRequestInput, TutoringAppointmentUpdateWithoutRequestInput>, TutoringAppointmentUncheckedUpdateWithoutRequestInput>
  }

  export type TutoringMessageUncheckedUpdateManyWithoutRequestNestedInput = {
    create?: XOR<TutoringMessageCreateWithoutRequestInput, TutoringMessageUncheckedCreateWithoutRequestInput> | TutoringMessageCreateWithoutRequestInput[] | TutoringMessageUncheckedCreateWithoutRequestInput[]
    connectOrCreate?: TutoringMessageCreateOrConnectWithoutRequestInput | TutoringMessageCreateOrConnectWithoutRequestInput[]
    upsert?: TutoringMessageUpsertWithWhereUniqueWithoutRequestInput | TutoringMessageUpsertWithWhereUniqueWithoutRequestInput[]
    createMany?: TutoringMessageCreateManyRequestInputEnvelope
    set?: TutoringMessageWhereUniqueInput | TutoringMessageWhereUniqueInput[]
    disconnect?: TutoringMessageWhereUniqueInput | TutoringMessageWhereUniqueInput[]
    delete?: TutoringMessageWhereUniqueInput | TutoringMessageWhereUniqueInput[]
    connect?: TutoringMessageWhereUniqueInput | TutoringMessageWhereUniqueInput[]
    update?: TutoringMessageUpdateWithWhereUniqueWithoutRequestInput | TutoringMessageUpdateWithWhereUniqueWithoutRequestInput[]
    updateMany?: TutoringMessageUpdateManyWithWhereWithoutRequestInput | TutoringMessageUpdateManyWithWhereWithoutRequestInput[]
    deleteMany?: TutoringMessageScalarWhereInput | TutoringMessageScalarWhereInput[]
  }

  export type TutoringRequestCreateNestedOneWithoutAppointmentInput = {
    create?: XOR<TutoringRequestCreateWithoutAppointmentInput, TutoringRequestUncheckedCreateWithoutAppointmentInput>
    connectOrCreate?: TutoringRequestCreateOrConnectWithoutAppointmentInput
    connect?: TutoringRequestWhereUniqueInput
  }

  export type TutoringSessionCreateNestedOneWithoutAppointmentsInput = {
    create?: XOR<TutoringSessionCreateWithoutAppointmentsInput, TutoringSessionUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: TutoringSessionCreateOrConnectWithoutAppointmentsInput
    connect?: TutoringSessionWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTutoringAppointmentsAsTeacherInput = {
    create?: XOR<UserCreateWithoutTutoringAppointmentsAsTeacherInput, UserUncheckedCreateWithoutTutoringAppointmentsAsTeacherInput>
    connectOrCreate?: UserCreateOrConnectWithoutTutoringAppointmentsAsTeacherInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTutoringAppointmentsAsStudentInput = {
    create?: XOR<UserCreateWithoutTutoringAppointmentsAsStudentInput, UserUncheckedCreateWithoutTutoringAppointmentsAsStudentInput>
    connectOrCreate?: UserCreateOrConnectWithoutTutoringAppointmentsAsStudentInput
    connect?: UserWhereUniqueInput
  }

  export type EnumAppointmentStatusFieldUpdateOperationsInput = {
    set?: $Enums.AppointmentStatus
  }

  export type TutoringRequestUpdateOneRequiredWithoutAppointmentNestedInput = {
    create?: XOR<TutoringRequestCreateWithoutAppointmentInput, TutoringRequestUncheckedCreateWithoutAppointmentInput>
    connectOrCreate?: TutoringRequestCreateOrConnectWithoutAppointmentInput
    upsert?: TutoringRequestUpsertWithoutAppointmentInput
    connect?: TutoringRequestWhereUniqueInput
    update?: XOR<XOR<TutoringRequestUpdateToOneWithWhereWithoutAppointmentInput, TutoringRequestUpdateWithoutAppointmentInput>, TutoringRequestUncheckedUpdateWithoutAppointmentInput>
  }

  export type TutoringSessionUpdateOneRequiredWithoutAppointmentsNestedInput = {
    create?: XOR<TutoringSessionCreateWithoutAppointmentsInput, TutoringSessionUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: TutoringSessionCreateOrConnectWithoutAppointmentsInput
    upsert?: TutoringSessionUpsertWithoutAppointmentsInput
    connect?: TutoringSessionWhereUniqueInput
    update?: XOR<XOR<TutoringSessionUpdateToOneWithWhereWithoutAppointmentsInput, TutoringSessionUpdateWithoutAppointmentsInput>, TutoringSessionUncheckedUpdateWithoutAppointmentsInput>
  }

  export type UserUpdateOneRequiredWithoutTutoringAppointmentsAsTeacherNestedInput = {
    create?: XOR<UserCreateWithoutTutoringAppointmentsAsTeacherInput, UserUncheckedCreateWithoutTutoringAppointmentsAsTeacherInput>
    connectOrCreate?: UserCreateOrConnectWithoutTutoringAppointmentsAsTeacherInput
    upsert?: UserUpsertWithoutTutoringAppointmentsAsTeacherInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTutoringAppointmentsAsTeacherInput, UserUpdateWithoutTutoringAppointmentsAsTeacherInput>, UserUncheckedUpdateWithoutTutoringAppointmentsAsTeacherInput>
  }

  export type UserUpdateOneRequiredWithoutTutoringAppointmentsAsStudentNestedInput = {
    create?: XOR<UserCreateWithoutTutoringAppointmentsAsStudentInput, UserUncheckedCreateWithoutTutoringAppointmentsAsStudentInput>
    connectOrCreate?: UserCreateOrConnectWithoutTutoringAppointmentsAsStudentInput
    upsert?: UserUpsertWithoutTutoringAppointmentsAsStudentInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTutoringAppointmentsAsStudentInput, UserUpdateWithoutTutoringAppointmentsAsStudentInput>, UserUncheckedUpdateWithoutTutoringAppointmentsAsStudentInput>
  }

  export type TutoringSessionCreateNestedOneWithoutReviewsInput = {
    create?: XOR<TutoringSessionCreateWithoutReviewsInput, TutoringSessionUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: TutoringSessionCreateOrConnectWithoutReviewsInput
    connect?: TutoringSessionWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTutoringReviewsInput = {
    create?: XOR<UserCreateWithoutTutoringReviewsInput, UserUncheckedCreateWithoutTutoringReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTutoringReviewsInput
    connect?: UserWhereUniqueInput
  }

  export type TutoringSessionUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<TutoringSessionCreateWithoutReviewsInput, TutoringSessionUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: TutoringSessionCreateOrConnectWithoutReviewsInput
    upsert?: TutoringSessionUpsertWithoutReviewsInput
    connect?: TutoringSessionWhereUniqueInput
    update?: XOR<XOR<TutoringSessionUpdateToOneWithWhereWithoutReviewsInput, TutoringSessionUpdateWithoutReviewsInput>, TutoringSessionUncheckedUpdateWithoutReviewsInput>
  }

  export type UserUpdateOneRequiredWithoutTutoringReviewsNestedInput = {
    create?: XOR<UserCreateWithoutTutoringReviewsInput, UserUncheckedCreateWithoutTutoringReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTutoringReviewsInput
    upsert?: UserUpsertWithoutTutoringReviewsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTutoringReviewsInput, UserUpdateWithoutTutoringReviewsInput>, UserUncheckedUpdateWithoutTutoringReviewsInput>
  }

  export type TutoringRequestCreateNestedOneWithoutMessagesInput = {
    create?: XOR<TutoringRequestCreateWithoutMessagesInput, TutoringRequestUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: TutoringRequestCreateOrConnectWithoutMessagesInput
    connect?: TutoringRequestWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTutoringMessagesInput = {
    create?: XOR<UserCreateWithoutTutoringMessagesInput, UserUncheckedCreateWithoutTutoringMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutTutoringMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type TutoringRequestUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<TutoringRequestCreateWithoutMessagesInput, TutoringRequestUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: TutoringRequestCreateOrConnectWithoutMessagesInput
    upsert?: TutoringRequestUpsertWithoutMessagesInput
    connect?: TutoringRequestWhereUniqueInput
    update?: XOR<XOR<TutoringRequestUpdateToOneWithWhereWithoutMessagesInput, TutoringRequestUpdateWithoutMessagesInput>, TutoringRequestUncheckedUpdateWithoutMessagesInput>
  }

  export type UserUpdateOneRequiredWithoutTutoringMessagesNestedInput = {
    create?: XOR<UserCreateWithoutTutoringMessagesInput, UserUncheckedCreateWithoutTutoringMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutTutoringMessagesInput
    upsert?: UserUpsertWithoutTutoringMessagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTutoringMessagesInput, UserUpdateWithoutTutoringMessagesInput>, UserUncheckedUpdateWithoutTutoringMessagesInput>
  }

  export type UserAchievementCreateNestedManyWithoutAchievementInput = {
    create?: XOR<UserAchievementCreateWithoutAchievementInput, UserAchievementUncheckedCreateWithoutAchievementInput> | UserAchievementCreateWithoutAchievementInput[] | UserAchievementUncheckedCreateWithoutAchievementInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutAchievementInput | UserAchievementCreateOrConnectWithoutAchievementInput[]
    createMany?: UserAchievementCreateManyAchievementInputEnvelope
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
  }

  export type UserAchievementUncheckedCreateNestedManyWithoutAchievementInput = {
    create?: XOR<UserAchievementCreateWithoutAchievementInput, UserAchievementUncheckedCreateWithoutAchievementInput> | UserAchievementCreateWithoutAchievementInput[] | UserAchievementUncheckedCreateWithoutAchievementInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutAchievementInput | UserAchievementCreateOrConnectWithoutAchievementInput[]
    createMany?: UserAchievementCreateManyAchievementInputEnvelope
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
  }

  export type EnumAchievementCategoryFieldUpdateOperationsInput = {
    set?: $Enums.AchievementCategory
  }

  export type UserAchievementUpdateManyWithoutAchievementNestedInput = {
    create?: XOR<UserAchievementCreateWithoutAchievementInput, UserAchievementUncheckedCreateWithoutAchievementInput> | UserAchievementCreateWithoutAchievementInput[] | UserAchievementUncheckedCreateWithoutAchievementInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutAchievementInput | UserAchievementCreateOrConnectWithoutAchievementInput[]
    upsert?: UserAchievementUpsertWithWhereUniqueWithoutAchievementInput | UserAchievementUpsertWithWhereUniqueWithoutAchievementInput[]
    createMany?: UserAchievementCreateManyAchievementInputEnvelope
    set?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    disconnect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    delete?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    update?: UserAchievementUpdateWithWhereUniqueWithoutAchievementInput | UserAchievementUpdateWithWhereUniqueWithoutAchievementInput[]
    updateMany?: UserAchievementUpdateManyWithWhereWithoutAchievementInput | UserAchievementUpdateManyWithWhereWithoutAchievementInput[]
    deleteMany?: UserAchievementScalarWhereInput | UserAchievementScalarWhereInput[]
  }

  export type UserAchievementUncheckedUpdateManyWithoutAchievementNestedInput = {
    create?: XOR<UserAchievementCreateWithoutAchievementInput, UserAchievementUncheckedCreateWithoutAchievementInput> | UserAchievementCreateWithoutAchievementInput[] | UserAchievementUncheckedCreateWithoutAchievementInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutAchievementInput | UserAchievementCreateOrConnectWithoutAchievementInput[]
    upsert?: UserAchievementUpsertWithWhereUniqueWithoutAchievementInput | UserAchievementUpsertWithWhereUniqueWithoutAchievementInput[]
    createMany?: UserAchievementCreateManyAchievementInputEnvelope
    set?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    disconnect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    delete?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    update?: UserAchievementUpdateWithWhereUniqueWithoutAchievementInput | UserAchievementUpdateWithWhereUniqueWithoutAchievementInput[]
    updateMany?: UserAchievementUpdateManyWithWhereWithoutAchievementInput | UserAchievementUpdateManyWithWhereWithoutAchievementInput[]
    deleteMany?: UserAchievementScalarWhereInput | UserAchievementScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAchievementsInput = {
    create?: XOR<UserCreateWithoutAchievementsInput, UserUncheckedCreateWithoutAchievementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAchievementsInput
    connect?: UserWhereUniqueInput
  }

  export type AchievementCreateNestedOneWithoutUsersInput = {
    create?: XOR<AchievementCreateWithoutUsersInput, AchievementUncheckedCreateWithoutUsersInput>
    connectOrCreate?: AchievementCreateOrConnectWithoutUsersInput
    connect?: AchievementWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAchievementsNestedInput = {
    create?: XOR<UserCreateWithoutAchievementsInput, UserUncheckedCreateWithoutAchievementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAchievementsInput
    upsert?: UserUpsertWithoutAchievementsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAchievementsInput, UserUpdateWithoutAchievementsInput>, UserUncheckedUpdateWithoutAchievementsInput>
  }

  export type AchievementUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<AchievementCreateWithoutUsersInput, AchievementUncheckedCreateWithoutUsersInput>
    connectOrCreate?: AchievementCreateOrConnectWithoutUsersInput
    upsert?: AchievementUpsertWithoutUsersInput
    connect?: AchievementWhereUniqueInput
    update?: XOR<XOR<AchievementUpdateToOneWithWhereWithoutUsersInput, AchievementUpdateWithoutUsersInput>, AchievementUncheckedUpdateWithoutUsersInput>
  }

  export type CertificateCreateNestedManyWithoutBadgeInput = {
    create?: XOR<CertificateCreateWithoutBadgeInput, CertificateUncheckedCreateWithoutBadgeInput> | CertificateCreateWithoutBadgeInput[] | CertificateUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutBadgeInput | CertificateCreateOrConnectWithoutBadgeInput[]
    createMany?: CertificateCreateManyBadgeInputEnvelope
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
  }

  export type CertificateUncheckedCreateNestedManyWithoutBadgeInput = {
    create?: XOR<CertificateCreateWithoutBadgeInput, CertificateUncheckedCreateWithoutBadgeInput> | CertificateCreateWithoutBadgeInput[] | CertificateUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutBadgeInput | CertificateCreateOrConnectWithoutBadgeInput[]
    createMany?: CertificateCreateManyBadgeInputEnvelope
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
  }

  export type EnumBadgeTypeFieldUpdateOperationsInput = {
    set?: $Enums.BadgeType
  }

  export type CertificateUpdateManyWithoutBadgeNestedInput = {
    create?: XOR<CertificateCreateWithoutBadgeInput, CertificateUncheckedCreateWithoutBadgeInput> | CertificateCreateWithoutBadgeInput[] | CertificateUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutBadgeInput | CertificateCreateOrConnectWithoutBadgeInput[]
    upsert?: CertificateUpsertWithWhereUniqueWithoutBadgeInput | CertificateUpsertWithWhereUniqueWithoutBadgeInput[]
    createMany?: CertificateCreateManyBadgeInputEnvelope
    set?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    disconnect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    delete?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    update?: CertificateUpdateWithWhereUniqueWithoutBadgeInput | CertificateUpdateWithWhereUniqueWithoutBadgeInput[]
    updateMany?: CertificateUpdateManyWithWhereWithoutBadgeInput | CertificateUpdateManyWithWhereWithoutBadgeInput[]
    deleteMany?: CertificateScalarWhereInput | CertificateScalarWhereInput[]
  }

  export type CertificateUncheckedUpdateManyWithoutBadgeNestedInput = {
    create?: XOR<CertificateCreateWithoutBadgeInput, CertificateUncheckedCreateWithoutBadgeInput> | CertificateCreateWithoutBadgeInput[] | CertificateUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutBadgeInput | CertificateCreateOrConnectWithoutBadgeInput[]
    upsert?: CertificateUpsertWithWhereUniqueWithoutBadgeInput | CertificateUpsertWithWhereUniqueWithoutBadgeInput[]
    createMany?: CertificateCreateManyBadgeInputEnvelope
    set?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    disconnect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    delete?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    update?: CertificateUpdateWithWhereUniqueWithoutBadgeInput | CertificateUpdateWithWhereUniqueWithoutBadgeInput[]
    updateMany?: CertificateUpdateManyWithWhereWithoutBadgeInput | CertificateUpdateManyWithWhereWithoutBadgeInput[]
    deleteMany?: CertificateScalarWhereInput | CertificateScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutCertificatesInput = {
    create?: XOR<UserCreateWithoutCertificatesInput, UserUncheckedCreateWithoutCertificatesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCertificatesInput
    connect?: UserWhereUniqueInput
  }

  export type CourseCreateNestedOneWithoutCertificatesInput = {
    create?: XOR<CourseCreateWithoutCertificatesInput, CourseUncheckedCreateWithoutCertificatesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutCertificatesInput
    connect?: CourseWhereUniqueInput
  }

  export type TutoringSessionCreateNestedOneWithoutCertificatesInput = {
    create?: XOR<TutoringSessionCreateWithoutCertificatesInput, TutoringSessionUncheckedCreateWithoutCertificatesInput>
    connectOrCreate?: TutoringSessionCreateOrConnectWithoutCertificatesInput
    connect?: TutoringSessionWhereUniqueInput
  }

  export type BadgeCreateNestedOneWithoutCertificatesInput = {
    create?: XOR<BadgeCreateWithoutCertificatesInput, BadgeUncheckedCreateWithoutCertificatesInput>
    connectOrCreate?: BadgeCreateOrConnectWithoutCertificatesInput
    connect?: BadgeWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutCertificatesNestedInput = {
    create?: XOR<UserCreateWithoutCertificatesInput, UserUncheckedCreateWithoutCertificatesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCertificatesInput
    upsert?: UserUpsertWithoutCertificatesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCertificatesInput, UserUpdateWithoutCertificatesInput>, UserUncheckedUpdateWithoutCertificatesInput>
  }

  export type CourseUpdateOneWithoutCertificatesNestedInput = {
    create?: XOR<CourseCreateWithoutCertificatesInput, CourseUncheckedCreateWithoutCertificatesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutCertificatesInput
    upsert?: CourseUpsertWithoutCertificatesInput
    disconnect?: CourseWhereInput | boolean
    delete?: CourseWhereInput | boolean
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutCertificatesInput, CourseUpdateWithoutCertificatesInput>, CourseUncheckedUpdateWithoutCertificatesInput>
  }

  export type TutoringSessionUpdateOneWithoutCertificatesNestedInput = {
    create?: XOR<TutoringSessionCreateWithoutCertificatesInput, TutoringSessionUncheckedCreateWithoutCertificatesInput>
    connectOrCreate?: TutoringSessionCreateOrConnectWithoutCertificatesInput
    upsert?: TutoringSessionUpsertWithoutCertificatesInput
    disconnect?: TutoringSessionWhereInput | boolean
    delete?: TutoringSessionWhereInput | boolean
    connect?: TutoringSessionWhereUniqueInput
    update?: XOR<XOR<TutoringSessionUpdateToOneWithWhereWithoutCertificatesInput, TutoringSessionUpdateWithoutCertificatesInput>, TutoringSessionUncheckedUpdateWithoutCertificatesInput>
  }

  export type BadgeUpdateOneWithoutCertificatesNestedInput = {
    create?: XOR<BadgeCreateWithoutCertificatesInput, BadgeUncheckedCreateWithoutCertificatesInput>
    connectOrCreate?: BadgeCreateOrConnectWithoutCertificatesInput
    upsert?: BadgeUpsertWithoutCertificatesInput
    disconnect?: BadgeWhereInput | boolean
    delete?: BadgeWhereInput | boolean
    connect?: BadgeWhereUniqueInput
    update?: XOR<XOR<BadgeUpdateToOneWithWhereWithoutCertificatesInput, BadgeUpdateWithoutCertificatesInput>, BadgeUncheckedUpdateWithoutCertificatesInput>
  }

  export type ConversationParticipantCreateNestedManyWithoutConversationInput = {
    create?: XOR<ConversationParticipantCreateWithoutConversationInput, ConversationParticipantUncheckedCreateWithoutConversationInput> | ConversationParticipantCreateWithoutConversationInput[] | ConversationParticipantUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ConversationParticipantCreateOrConnectWithoutConversationInput | ConversationParticipantCreateOrConnectWithoutConversationInput[]
    createMany?: ConversationParticipantCreateManyConversationInputEnvelope
    connect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutConversationInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ConversationParticipantUncheckedCreateNestedManyWithoutConversationInput = {
    create?: XOR<ConversationParticipantCreateWithoutConversationInput, ConversationParticipantUncheckedCreateWithoutConversationInput> | ConversationParticipantCreateWithoutConversationInput[] | ConversationParticipantUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ConversationParticipantCreateOrConnectWithoutConversationInput | ConversationParticipantCreateOrConnectWithoutConversationInput[]
    createMany?: ConversationParticipantCreateManyConversationInputEnvelope
    connect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutConversationInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ConversationParticipantUpdateManyWithoutConversationNestedInput = {
    create?: XOR<ConversationParticipantCreateWithoutConversationInput, ConversationParticipantUncheckedCreateWithoutConversationInput> | ConversationParticipantCreateWithoutConversationInput[] | ConversationParticipantUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ConversationParticipantCreateOrConnectWithoutConversationInput | ConversationParticipantCreateOrConnectWithoutConversationInput[]
    upsert?: ConversationParticipantUpsertWithWhereUniqueWithoutConversationInput | ConversationParticipantUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: ConversationParticipantCreateManyConversationInputEnvelope
    set?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    disconnect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    delete?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    connect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    update?: ConversationParticipantUpdateWithWhereUniqueWithoutConversationInput | ConversationParticipantUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: ConversationParticipantUpdateManyWithWhereWithoutConversationInput | ConversationParticipantUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: ConversationParticipantScalarWhereInput | ConversationParticipantScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutConversationNestedInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutConversationInput | MessageUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutConversationInput | MessageUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutConversationInput | MessageUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ConversationParticipantUncheckedUpdateManyWithoutConversationNestedInput = {
    create?: XOR<ConversationParticipantCreateWithoutConversationInput, ConversationParticipantUncheckedCreateWithoutConversationInput> | ConversationParticipantCreateWithoutConversationInput[] | ConversationParticipantUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ConversationParticipantCreateOrConnectWithoutConversationInput | ConversationParticipantCreateOrConnectWithoutConversationInput[]
    upsert?: ConversationParticipantUpsertWithWhereUniqueWithoutConversationInput | ConversationParticipantUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: ConversationParticipantCreateManyConversationInputEnvelope
    set?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    disconnect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    delete?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    connect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    update?: ConversationParticipantUpdateWithWhereUniqueWithoutConversationInput | ConversationParticipantUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: ConversationParticipantUpdateManyWithWhereWithoutConversationInput | ConversationParticipantUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: ConversationParticipantScalarWhereInput | ConversationParticipantScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutConversationNestedInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutConversationInput | MessageUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutConversationInput | MessageUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutConversationInput | MessageUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ConversationCreateNestedOneWithoutParticipantsInput = {
    create?: XOR<ConversationCreateWithoutParticipantsInput, ConversationUncheckedCreateWithoutParticipantsInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutParticipantsInput
    connect?: ConversationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutConversationPartsInput = {
    create?: XOR<UserCreateWithoutConversationPartsInput, UserUncheckedCreateWithoutConversationPartsInput>
    connectOrCreate?: UserCreateOrConnectWithoutConversationPartsInput
    connect?: UserWhereUniqueInput
  }

  export type ConversationUpdateOneRequiredWithoutParticipantsNestedInput = {
    create?: XOR<ConversationCreateWithoutParticipantsInput, ConversationUncheckedCreateWithoutParticipantsInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutParticipantsInput
    upsert?: ConversationUpsertWithoutParticipantsInput
    connect?: ConversationWhereUniqueInput
    update?: XOR<XOR<ConversationUpdateToOneWithWhereWithoutParticipantsInput, ConversationUpdateWithoutParticipantsInput>, ConversationUncheckedUpdateWithoutParticipantsInput>
  }

  export type UserUpdateOneRequiredWithoutConversationPartsNestedInput = {
    create?: XOR<UserCreateWithoutConversationPartsInput, UserUncheckedCreateWithoutConversationPartsInput>
    connectOrCreate?: UserCreateOrConnectWithoutConversationPartsInput
    upsert?: UserUpsertWithoutConversationPartsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutConversationPartsInput, UserUpdateWithoutConversationPartsInput>, UserUncheckedUpdateWithoutConversationPartsInput>
  }

  export type ConversationCreateNestedOneWithoutMessagesInput = {
    create?: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutMessagesInput
    connect?: ConversationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSentMessagesInput = {
    create?: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type AttachmentCreateNestedManyWithoutMessageInput = {
    create?: XOR<AttachmentCreateWithoutMessageInput, AttachmentUncheckedCreateWithoutMessageInput> | AttachmentCreateWithoutMessageInput[] | AttachmentUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutMessageInput | AttachmentCreateOrConnectWithoutMessageInput[]
    createMany?: AttachmentCreateManyMessageInputEnvelope
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
  }

  export type AttachmentUncheckedCreateNestedManyWithoutMessageInput = {
    create?: XOR<AttachmentCreateWithoutMessageInput, AttachmentUncheckedCreateWithoutMessageInput> | AttachmentCreateWithoutMessageInput[] | AttachmentUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutMessageInput | AttachmentCreateOrConnectWithoutMessageInput[]
    createMany?: AttachmentCreateManyMessageInputEnvelope
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
  }

  export type ConversationUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutMessagesInput
    upsert?: ConversationUpsertWithoutMessagesInput
    connect?: ConversationWhereUniqueInput
    update?: XOR<XOR<ConversationUpdateToOneWithWhereWithoutMessagesInput, ConversationUpdateWithoutMessagesInput>, ConversationUncheckedUpdateWithoutMessagesInput>
  }

  export type UserUpdateOneRequiredWithoutSentMessagesNestedInput = {
    create?: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentMessagesInput
    upsert?: UserUpsertWithoutSentMessagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSentMessagesInput, UserUpdateWithoutSentMessagesInput>, UserUncheckedUpdateWithoutSentMessagesInput>
  }

  export type AttachmentUpdateManyWithoutMessageNestedInput = {
    create?: XOR<AttachmentCreateWithoutMessageInput, AttachmentUncheckedCreateWithoutMessageInput> | AttachmentCreateWithoutMessageInput[] | AttachmentUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutMessageInput | AttachmentCreateOrConnectWithoutMessageInput[]
    upsert?: AttachmentUpsertWithWhereUniqueWithoutMessageInput | AttachmentUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: AttachmentCreateManyMessageInputEnvelope
    set?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    disconnect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    delete?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    update?: AttachmentUpdateWithWhereUniqueWithoutMessageInput | AttachmentUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: AttachmentUpdateManyWithWhereWithoutMessageInput | AttachmentUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
  }

  export type AttachmentUncheckedUpdateManyWithoutMessageNestedInput = {
    create?: XOR<AttachmentCreateWithoutMessageInput, AttachmentUncheckedCreateWithoutMessageInput> | AttachmentCreateWithoutMessageInput[] | AttachmentUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutMessageInput | AttachmentCreateOrConnectWithoutMessageInput[]
    upsert?: AttachmentUpsertWithWhereUniqueWithoutMessageInput | AttachmentUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: AttachmentCreateManyMessageInputEnvelope
    set?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    disconnect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    delete?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    update?: AttachmentUpdateWithWhereUniqueWithoutMessageInput | AttachmentUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: AttachmentUpdateManyWithWhereWithoutMessageInput | AttachmentUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
  }

  export type MessageCreateNestedOneWithoutAttachmentsInput = {
    create?: XOR<MessageCreateWithoutAttachmentsInput, MessageUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: MessageCreateOrConnectWithoutAttachmentsInput
    connect?: MessageWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAttachmentsInput = {
    create?: XOR<UserCreateWithoutAttachmentsInput, UserUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAttachmentsInput
    connect?: UserWhereUniqueInput
  }

  export type MessageUpdateOneRequiredWithoutAttachmentsNestedInput = {
    create?: XOR<MessageCreateWithoutAttachmentsInput, MessageUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: MessageCreateOrConnectWithoutAttachmentsInput
    upsert?: MessageUpsertWithoutAttachmentsInput
    connect?: MessageWhereUniqueInput
    update?: XOR<XOR<MessageUpdateToOneWithWhereWithoutAttachmentsInput, MessageUpdateWithoutAttachmentsInput>, MessageUncheckedUpdateWithoutAttachmentsInput>
  }

  export type UserUpdateOneWithoutAttachmentsNestedInput = {
    create?: XOR<UserCreateWithoutAttachmentsInput, UserUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAttachmentsInput
    upsert?: UserUpsertWithoutAttachmentsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAttachmentsInput, UserUpdateWithoutAttachmentsInput>, UserUncheckedUpdateWithoutAttachmentsInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumNotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationType
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type SubscriptionPlanCreatebenefitsInput = {
    set: string[]
  }

  export type UserSubscriptionCreateNestedManyWithoutPlanInput = {
    create?: XOR<UserSubscriptionCreateWithoutPlanInput, UserSubscriptionUncheckedCreateWithoutPlanInput> | UserSubscriptionCreateWithoutPlanInput[] | UserSubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: UserSubscriptionCreateOrConnectWithoutPlanInput | UserSubscriptionCreateOrConnectWithoutPlanInput[]
    createMany?: UserSubscriptionCreateManyPlanInputEnvelope
    connect?: UserSubscriptionWhereUniqueInput | UserSubscriptionWhereUniqueInput[]
  }

  export type UserSubscriptionUncheckedCreateNestedManyWithoutPlanInput = {
    create?: XOR<UserSubscriptionCreateWithoutPlanInput, UserSubscriptionUncheckedCreateWithoutPlanInput> | UserSubscriptionCreateWithoutPlanInput[] | UserSubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: UserSubscriptionCreateOrConnectWithoutPlanInput | UserSubscriptionCreateOrConnectWithoutPlanInput[]
    createMany?: UserSubscriptionCreateManyPlanInputEnvelope
    connect?: UserSubscriptionWhereUniqueInput | UserSubscriptionWhereUniqueInput[]
  }

  export type EnumSubscriptionPeriodFieldUpdateOperationsInput = {
    set?: $Enums.SubscriptionPeriod
  }

  export type SubscriptionPlanUpdatebenefitsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserSubscriptionUpdateManyWithoutPlanNestedInput = {
    create?: XOR<UserSubscriptionCreateWithoutPlanInput, UserSubscriptionUncheckedCreateWithoutPlanInput> | UserSubscriptionCreateWithoutPlanInput[] | UserSubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: UserSubscriptionCreateOrConnectWithoutPlanInput | UserSubscriptionCreateOrConnectWithoutPlanInput[]
    upsert?: UserSubscriptionUpsertWithWhereUniqueWithoutPlanInput | UserSubscriptionUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: UserSubscriptionCreateManyPlanInputEnvelope
    set?: UserSubscriptionWhereUniqueInput | UserSubscriptionWhereUniqueInput[]
    disconnect?: UserSubscriptionWhereUniqueInput | UserSubscriptionWhereUniqueInput[]
    delete?: UserSubscriptionWhereUniqueInput | UserSubscriptionWhereUniqueInput[]
    connect?: UserSubscriptionWhereUniqueInput | UserSubscriptionWhereUniqueInput[]
    update?: UserSubscriptionUpdateWithWhereUniqueWithoutPlanInput | UserSubscriptionUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: UserSubscriptionUpdateManyWithWhereWithoutPlanInput | UserSubscriptionUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: UserSubscriptionScalarWhereInput | UserSubscriptionScalarWhereInput[]
  }

  export type UserSubscriptionUncheckedUpdateManyWithoutPlanNestedInput = {
    create?: XOR<UserSubscriptionCreateWithoutPlanInput, UserSubscriptionUncheckedCreateWithoutPlanInput> | UserSubscriptionCreateWithoutPlanInput[] | UserSubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: UserSubscriptionCreateOrConnectWithoutPlanInput | UserSubscriptionCreateOrConnectWithoutPlanInput[]
    upsert?: UserSubscriptionUpsertWithWhereUniqueWithoutPlanInput | UserSubscriptionUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: UserSubscriptionCreateManyPlanInputEnvelope
    set?: UserSubscriptionWhereUniqueInput | UserSubscriptionWhereUniqueInput[]
    disconnect?: UserSubscriptionWhereUniqueInput | UserSubscriptionWhereUniqueInput[]
    delete?: UserSubscriptionWhereUniqueInput | UserSubscriptionWhereUniqueInput[]
    connect?: UserSubscriptionWhereUniqueInput | UserSubscriptionWhereUniqueInput[]
    update?: UserSubscriptionUpdateWithWhereUniqueWithoutPlanInput | UserSubscriptionUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: UserSubscriptionUpdateManyWithWhereWithoutPlanInput | UserSubscriptionUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: UserSubscriptionScalarWhereInput | UserSubscriptionScalarWhereInput[]
  }

  export type CourseBundleCreatebenefitsInput = {
    set: string[]
  }

  export type BundleCourseCreateNestedManyWithoutBundleInput = {
    create?: XOR<BundleCourseCreateWithoutBundleInput, BundleCourseUncheckedCreateWithoutBundleInput> | BundleCourseCreateWithoutBundleInput[] | BundleCourseUncheckedCreateWithoutBundleInput[]
    connectOrCreate?: BundleCourseCreateOrConnectWithoutBundleInput | BundleCourseCreateOrConnectWithoutBundleInput[]
    createMany?: BundleCourseCreateManyBundleInputEnvelope
    connect?: BundleCourseWhereUniqueInput | BundleCourseWhereUniqueInput[]
  }

  export type UserBundleCreateNestedManyWithoutBundleInput = {
    create?: XOR<UserBundleCreateWithoutBundleInput, UserBundleUncheckedCreateWithoutBundleInput> | UserBundleCreateWithoutBundleInput[] | UserBundleUncheckedCreateWithoutBundleInput[]
    connectOrCreate?: UserBundleCreateOrConnectWithoutBundleInput | UserBundleCreateOrConnectWithoutBundleInput[]
    createMany?: UserBundleCreateManyBundleInputEnvelope
    connect?: UserBundleWhereUniqueInput | UserBundleWhereUniqueInput[]
  }

  export type BundleCourseUncheckedCreateNestedManyWithoutBundleInput = {
    create?: XOR<BundleCourseCreateWithoutBundleInput, BundleCourseUncheckedCreateWithoutBundleInput> | BundleCourseCreateWithoutBundleInput[] | BundleCourseUncheckedCreateWithoutBundleInput[]
    connectOrCreate?: BundleCourseCreateOrConnectWithoutBundleInput | BundleCourseCreateOrConnectWithoutBundleInput[]
    createMany?: BundleCourseCreateManyBundleInputEnvelope
    connect?: BundleCourseWhereUniqueInput | BundleCourseWhereUniqueInput[]
  }

  export type UserBundleUncheckedCreateNestedManyWithoutBundleInput = {
    create?: XOR<UserBundleCreateWithoutBundleInput, UserBundleUncheckedCreateWithoutBundleInput> | UserBundleCreateWithoutBundleInput[] | UserBundleUncheckedCreateWithoutBundleInput[]
    connectOrCreate?: UserBundleCreateOrConnectWithoutBundleInput | UserBundleCreateOrConnectWithoutBundleInput[]
    createMany?: UserBundleCreateManyBundleInputEnvelope
    connect?: UserBundleWhereUniqueInput | UserBundleWhereUniqueInput[]
  }

  export type CourseBundleUpdatebenefitsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type BundleCourseUpdateManyWithoutBundleNestedInput = {
    create?: XOR<BundleCourseCreateWithoutBundleInput, BundleCourseUncheckedCreateWithoutBundleInput> | BundleCourseCreateWithoutBundleInput[] | BundleCourseUncheckedCreateWithoutBundleInput[]
    connectOrCreate?: BundleCourseCreateOrConnectWithoutBundleInput | BundleCourseCreateOrConnectWithoutBundleInput[]
    upsert?: BundleCourseUpsertWithWhereUniqueWithoutBundleInput | BundleCourseUpsertWithWhereUniqueWithoutBundleInput[]
    createMany?: BundleCourseCreateManyBundleInputEnvelope
    set?: BundleCourseWhereUniqueInput | BundleCourseWhereUniqueInput[]
    disconnect?: BundleCourseWhereUniqueInput | BundleCourseWhereUniqueInput[]
    delete?: BundleCourseWhereUniqueInput | BundleCourseWhereUniqueInput[]
    connect?: BundleCourseWhereUniqueInput | BundleCourseWhereUniqueInput[]
    update?: BundleCourseUpdateWithWhereUniqueWithoutBundleInput | BundleCourseUpdateWithWhereUniqueWithoutBundleInput[]
    updateMany?: BundleCourseUpdateManyWithWhereWithoutBundleInput | BundleCourseUpdateManyWithWhereWithoutBundleInput[]
    deleteMany?: BundleCourseScalarWhereInput | BundleCourseScalarWhereInput[]
  }

  export type UserBundleUpdateManyWithoutBundleNestedInput = {
    create?: XOR<UserBundleCreateWithoutBundleInput, UserBundleUncheckedCreateWithoutBundleInput> | UserBundleCreateWithoutBundleInput[] | UserBundleUncheckedCreateWithoutBundleInput[]
    connectOrCreate?: UserBundleCreateOrConnectWithoutBundleInput | UserBundleCreateOrConnectWithoutBundleInput[]
    upsert?: UserBundleUpsertWithWhereUniqueWithoutBundleInput | UserBundleUpsertWithWhereUniqueWithoutBundleInput[]
    createMany?: UserBundleCreateManyBundleInputEnvelope
    set?: UserBundleWhereUniqueInput | UserBundleWhereUniqueInput[]
    disconnect?: UserBundleWhereUniqueInput | UserBundleWhereUniqueInput[]
    delete?: UserBundleWhereUniqueInput | UserBundleWhereUniqueInput[]
    connect?: UserBundleWhereUniqueInput | UserBundleWhereUniqueInput[]
    update?: UserBundleUpdateWithWhereUniqueWithoutBundleInput | UserBundleUpdateWithWhereUniqueWithoutBundleInput[]
    updateMany?: UserBundleUpdateManyWithWhereWithoutBundleInput | UserBundleUpdateManyWithWhereWithoutBundleInput[]
    deleteMany?: UserBundleScalarWhereInput | UserBundleScalarWhereInput[]
  }

  export type BundleCourseUncheckedUpdateManyWithoutBundleNestedInput = {
    create?: XOR<BundleCourseCreateWithoutBundleInput, BundleCourseUncheckedCreateWithoutBundleInput> | BundleCourseCreateWithoutBundleInput[] | BundleCourseUncheckedCreateWithoutBundleInput[]
    connectOrCreate?: BundleCourseCreateOrConnectWithoutBundleInput | BundleCourseCreateOrConnectWithoutBundleInput[]
    upsert?: BundleCourseUpsertWithWhereUniqueWithoutBundleInput | BundleCourseUpsertWithWhereUniqueWithoutBundleInput[]
    createMany?: BundleCourseCreateManyBundleInputEnvelope
    set?: BundleCourseWhereUniqueInput | BundleCourseWhereUniqueInput[]
    disconnect?: BundleCourseWhereUniqueInput | BundleCourseWhereUniqueInput[]
    delete?: BundleCourseWhereUniqueInput | BundleCourseWhereUniqueInput[]
    connect?: BundleCourseWhereUniqueInput | BundleCourseWhereUniqueInput[]
    update?: BundleCourseUpdateWithWhereUniqueWithoutBundleInput | BundleCourseUpdateWithWhereUniqueWithoutBundleInput[]
    updateMany?: BundleCourseUpdateManyWithWhereWithoutBundleInput | BundleCourseUpdateManyWithWhereWithoutBundleInput[]
    deleteMany?: BundleCourseScalarWhereInput | BundleCourseScalarWhereInput[]
  }

  export type UserBundleUncheckedUpdateManyWithoutBundleNestedInput = {
    create?: XOR<UserBundleCreateWithoutBundleInput, UserBundleUncheckedCreateWithoutBundleInput> | UserBundleCreateWithoutBundleInput[] | UserBundleUncheckedCreateWithoutBundleInput[]
    connectOrCreate?: UserBundleCreateOrConnectWithoutBundleInput | UserBundleCreateOrConnectWithoutBundleInput[]
    upsert?: UserBundleUpsertWithWhereUniqueWithoutBundleInput | UserBundleUpsertWithWhereUniqueWithoutBundleInput[]
    createMany?: UserBundleCreateManyBundleInputEnvelope
    set?: UserBundleWhereUniqueInput | UserBundleWhereUniqueInput[]
    disconnect?: UserBundleWhereUniqueInput | UserBundleWhereUniqueInput[]
    delete?: UserBundleWhereUniqueInput | UserBundleWhereUniqueInput[]
    connect?: UserBundleWhereUniqueInput | UserBundleWhereUniqueInput[]
    update?: UserBundleUpdateWithWhereUniqueWithoutBundleInput | UserBundleUpdateWithWhereUniqueWithoutBundleInput[]
    updateMany?: UserBundleUpdateManyWithWhereWithoutBundleInput | UserBundleUpdateManyWithWhereWithoutBundleInput[]
    deleteMany?: UserBundleScalarWhereInput | UserBundleScalarWhereInput[]
  }

  export type CourseBundleCreateNestedOneWithoutCoursesInput = {
    create?: XOR<CourseBundleCreateWithoutCoursesInput, CourseBundleUncheckedCreateWithoutCoursesInput>
    connectOrCreate?: CourseBundleCreateOrConnectWithoutCoursesInput
    connect?: CourseBundleWhereUniqueInput
  }

  export type CourseCreateNestedOneWithoutBundleCoursesInput = {
    create?: XOR<CourseCreateWithoutBundleCoursesInput, CourseUncheckedCreateWithoutBundleCoursesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutBundleCoursesInput
    connect?: CourseWhereUniqueInput
  }

  export type CourseBundleUpdateOneRequiredWithoutCoursesNestedInput = {
    create?: XOR<CourseBundleCreateWithoutCoursesInput, CourseBundleUncheckedCreateWithoutCoursesInput>
    connectOrCreate?: CourseBundleCreateOrConnectWithoutCoursesInput
    upsert?: CourseBundleUpsertWithoutCoursesInput
    connect?: CourseBundleWhereUniqueInput
    update?: XOR<XOR<CourseBundleUpdateToOneWithWhereWithoutCoursesInput, CourseBundleUpdateWithoutCoursesInput>, CourseBundleUncheckedUpdateWithoutCoursesInput>
  }

  export type CourseUpdateOneRequiredWithoutBundleCoursesNestedInput = {
    create?: XOR<CourseCreateWithoutBundleCoursesInput, CourseUncheckedCreateWithoutBundleCoursesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutBundleCoursesInput
    upsert?: CourseUpsertWithoutBundleCoursesInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutBundleCoursesInput, CourseUpdateWithoutBundleCoursesInput>, CourseUncheckedUpdateWithoutBundleCoursesInput>
  }

  export type UserCreateNestedOneWithoutSubscriptionRecordsInput = {
    create?: XOR<UserCreateWithoutSubscriptionRecordsInput, UserUncheckedCreateWithoutSubscriptionRecordsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubscriptionRecordsInput
    connect?: UserWhereUniqueInput
  }

  export type SubscriptionPlanCreateNestedOneWithoutUsersInput = {
    create?: XOR<SubscriptionPlanCreateWithoutUsersInput, SubscriptionPlanUncheckedCreateWithoutUsersInput>
    connectOrCreate?: SubscriptionPlanCreateOrConnectWithoutUsersInput
    connect?: SubscriptionPlanWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSubscriptionRecordsNestedInput = {
    create?: XOR<UserCreateWithoutSubscriptionRecordsInput, UserUncheckedCreateWithoutSubscriptionRecordsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubscriptionRecordsInput
    upsert?: UserUpsertWithoutSubscriptionRecordsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSubscriptionRecordsInput, UserUpdateWithoutSubscriptionRecordsInput>, UserUncheckedUpdateWithoutSubscriptionRecordsInput>
  }

  export type SubscriptionPlanUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<SubscriptionPlanCreateWithoutUsersInput, SubscriptionPlanUncheckedCreateWithoutUsersInput>
    connectOrCreate?: SubscriptionPlanCreateOrConnectWithoutUsersInput
    upsert?: SubscriptionPlanUpsertWithoutUsersInput
    connect?: SubscriptionPlanWhereUniqueInput
    update?: XOR<XOR<SubscriptionPlanUpdateToOneWithWhereWithoutUsersInput, SubscriptionPlanUpdateWithoutUsersInput>, SubscriptionPlanUncheckedUpdateWithoutUsersInput>
  }

  export type UserCreateNestedOneWithoutBundlesOwnedInput = {
    create?: XOR<UserCreateWithoutBundlesOwnedInput, UserUncheckedCreateWithoutBundlesOwnedInput>
    connectOrCreate?: UserCreateOrConnectWithoutBundlesOwnedInput
    connect?: UserWhereUniqueInput
  }

  export type CourseBundleCreateNestedOneWithoutOwnersInput = {
    create?: XOR<CourseBundleCreateWithoutOwnersInput, CourseBundleUncheckedCreateWithoutOwnersInput>
    connectOrCreate?: CourseBundleCreateOrConnectWithoutOwnersInput
    connect?: CourseBundleWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutBundlesOwnedNestedInput = {
    create?: XOR<UserCreateWithoutBundlesOwnedInput, UserUncheckedCreateWithoutBundlesOwnedInput>
    connectOrCreate?: UserCreateOrConnectWithoutBundlesOwnedInput
    upsert?: UserUpsertWithoutBundlesOwnedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBundlesOwnedInput, UserUpdateWithoutBundlesOwnedInput>, UserUncheckedUpdateWithoutBundlesOwnedInput>
  }

  export type CourseBundleUpdateOneRequiredWithoutOwnersNestedInput = {
    create?: XOR<CourseBundleCreateWithoutOwnersInput, CourseBundleUncheckedCreateWithoutOwnersInput>
    connectOrCreate?: CourseBundleCreateOrConnectWithoutOwnersInput
    upsert?: CourseBundleUpsertWithoutOwnersInput
    connect?: CourseBundleWhereUniqueInput
    update?: XOR<XOR<CourseBundleUpdateToOneWithWhereWithoutOwnersInput, CourseBundleUpdateWithoutOwnersInput>, CourseBundleUncheckedUpdateWithoutOwnersInput>
  }

  export type UserCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumPaymentStatusFieldUpdateOperationsInput = {
    set?: $Enums.PaymentStatus
  }

  export type EnumPaymentReferenceTypeFieldUpdateOperationsInput = {
    set?: $Enums.PaymentReferenceType
  }

  export type UserUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentsInput
    upsert?: UserUpsertWithoutPaymentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPaymentsInput, UserUpdateWithoutPaymentsInput>, UserUncheckedUpdateWithoutPaymentsInput>
  }

  export type UserCreateNestedOneWithoutCalendarEventsInput = {
    create?: XOR<UserCreateWithoutCalendarEventsInput, UserUncheckedCreateWithoutCalendarEventsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCalendarEventsInput
    connect?: UserWhereUniqueInput
  }

  export type CourseCreateNestedOneWithoutCalendarEventsInput = {
    create?: XOR<CourseCreateWithoutCalendarEventsInput, CourseUncheckedCreateWithoutCalendarEventsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutCalendarEventsInput
    connect?: CourseWhereUniqueInput
  }

  export type LessonCreateNestedOneWithoutCalendarEventsInput = {
    create?: XOR<LessonCreateWithoutCalendarEventsInput, LessonUncheckedCreateWithoutCalendarEventsInput>
    connectOrCreate?: LessonCreateOrConnectWithoutCalendarEventsInput
    connect?: LessonWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutEventsAsTeacherInput = {
    create?: XOR<UserCreateWithoutEventsAsTeacherInput, UserUncheckedCreateWithoutEventsAsTeacherInput>
    connectOrCreate?: UserCreateOrConnectWithoutEventsAsTeacherInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutEventsAsStudentInput = {
    create?: XOR<UserCreateWithoutEventsAsStudentInput, UserUncheckedCreateWithoutEventsAsStudentInput>
    connectOrCreate?: UserCreateOrConnectWithoutEventsAsStudentInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutCalendarEventsNestedInput = {
    create?: XOR<UserCreateWithoutCalendarEventsInput, UserUncheckedCreateWithoutCalendarEventsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCalendarEventsInput
    upsert?: UserUpsertWithoutCalendarEventsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCalendarEventsInput, UserUpdateWithoutCalendarEventsInput>, UserUncheckedUpdateWithoutCalendarEventsInput>
  }

  export type CourseUpdateOneWithoutCalendarEventsNestedInput = {
    create?: XOR<CourseCreateWithoutCalendarEventsInput, CourseUncheckedCreateWithoutCalendarEventsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutCalendarEventsInput
    upsert?: CourseUpsertWithoutCalendarEventsInput
    disconnect?: CourseWhereInput | boolean
    delete?: CourseWhereInput | boolean
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutCalendarEventsInput, CourseUpdateWithoutCalendarEventsInput>, CourseUncheckedUpdateWithoutCalendarEventsInput>
  }

  export type LessonUpdateOneWithoutCalendarEventsNestedInput = {
    create?: XOR<LessonCreateWithoutCalendarEventsInput, LessonUncheckedCreateWithoutCalendarEventsInput>
    connectOrCreate?: LessonCreateOrConnectWithoutCalendarEventsInput
    upsert?: LessonUpsertWithoutCalendarEventsInput
    disconnect?: LessonWhereInput | boolean
    delete?: LessonWhereInput | boolean
    connect?: LessonWhereUniqueInput
    update?: XOR<XOR<LessonUpdateToOneWithWhereWithoutCalendarEventsInput, LessonUpdateWithoutCalendarEventsInput>, LessonUncheckedUpdateWithoutCalendarEventsInput>
  }

  export type UserUpdateOneWithoutEventsAsTeacherNestedInput = {
    create?: XOR<UserCreateWithoutEventsAsTeacherInput, UserUncheckedCreateWithoutEventsAsTeacherInput>
    connectOrCreate?: UserCreateOrConnectWithoutEventsAsTeacherInput
    upsert?: UserUpsertWithoutEventsAsTeacherInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEventsAsTeacherInput, UserUpdateWithoutEventsAsTeacherInput>, UserUncheckedUpdateWithoutEventsAsTeacherInput>
  }

  export type UserUpdateOneWithoutEventsAsStudentNestedInput = {
    create?: XOR<UserCreateWithoutEventsAsStudentInput, UserUncheckedCreateWithoutEventsAsStudentInput>
    connectOrCreate?: UserCreateOrConnectWithoutEventsAsStudentInput
    upsert?: UserUpsertWithoutEventsAsStudentInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEventsAsStudentInput, UserUpdateWithoutEventsAsStudentInput>, UserUncheckedUpdateWithoutEventsAsStudentInput>
  }

  export type UserCreateNestedOneWithoutBlogPostsInput = {
    create?: XOR<UserCreateWithoutBlogPostsInput, UserUncheckedCreateWithoutBlogPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBlogPostsInput
    connect?: UserWhereUniqueInput
  }

  export type PostCategoryCreateNestedManyWithoutPostInput = {
    create?: XOR<PostCategoryCreateWithoutPostInput, PostCategoryUncheckedCreateWithoutPostInput> | PostCategoryCreateWithoutPostInput[] | PostCategoryUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostCategoryCreateOrConnectWithoutPostInput | PostCategoryCreateOrConnectWithoutPostInput[]
    createMany?: PostCategoryCreateManyPostInputEnvelope
    connect?: PostCategoryWhereUniqueInput | PostCategoryWhereUniqueInput[]
  }

  export type PostTagCreateNestedManyWithoutPostInput = {
    create?: XOR<PostTagCreateWithoutPostInput, PostTagUncheckedCreateWithoutPostInput> | PostTagCreateWithoutPostInput[] | PostTagUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostTagCreateOrConnectWithoutPostInput | PostTagCreateOrConnectWithoutPostInput[]
    createMany?: PostTagCreateManyPostInputEnvelope
    connect?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
  }

  export type BlogCommentCreateNestedManyWithoutPostInput = {
    create?: XOR<BlogCommentCreateWithoutPostInput, BlogCommentUncheckedCreateWithoutPostInput> | BlogCommentCreateWithoutPostInput[] | BlogCommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: BlogCommentCreateOrConnectWithoutPostInput | BlogCommentCreateOrConnectWithoutPostInput[]
    createMany?: BlogCommentCreateManyPostInputEnvelope
    connect?: BlogCommentWhereUniqueInput | BlogCommentWhereUniqueInput[]
  }

  export type PostCategoryUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<PostCategoryCreateWithoutPostInput, PostCategoryUncheckedCreateWithoutPostInput> | PostCategoryCreateWithoutPostInput[] | PostCategoryUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostCategoryCreateOrConnectWithoutPostInput | PostCategoryCreateOrConnectWithoutPostInput[]
    createMany?: PostCategoryCreateManyPostInputEnvelope
    connect?: PostCategoryWhereUniqueInput | PostCategoryWhereUniqueInput[]
  }

  export type PostTagUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<PostTagCreateWithoutPostInput, PostTagUncheckedCreateWithoutPostInput> | PostTagCreateWithoutPostInput[] | PostTagUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostTagCreateOrConnectWithoutPostInput | PostTagCreateOrConnectWithoutPostInput[]
    createMany?: PostTagCreateManyPostInputEnvelope
    connect?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
  }

  export type BlogCommentUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<BlogCommentCreateWithoutPostInput, BlogCommentUncheckedCreateWithoutPostInput> | BlogCommentCreateWithoutPostInput[] | BlogCommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: BlogCommentCreateOrConnectWithoutPostInput | BlogCommentCreateOrConnectWithoutPostInput[]
    createMany?: BlogCommentCreateManyPostInputEnvelope
    connect?: BlogCommentWhereUniqueInput | BlogCommentWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutBlogPostsNestedInput = {
    create?: XOR<UserCreateWithoutBlogPostsInput, UserUncheckedCreateWithoutBlogPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBlogPostsInput
    upsert?: UserUpsertWithoutBlogPostsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBlogPostsInput, UserUpdateWithoutBlogPostsInput>, UserUncheckedUpdateWithoutBlogPostsInput>
  }

  export type PostCategoryUpdateManyWithoutPostNestedInput = {
    create?: XOR<PostCategoryCreateWithoutPostInput, PostCategoryUncheckedCreateWithoutPostInput> | PostCategoryCreateWithoutPostInput[] | PostCategoryUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostCategoryCreateOrConnectWithoutPostInput | PostCategoryCreateOrConnectWithoutPostInput[]
    upsert?: PostCategoryUpsertWithWhereUniqueWithoutPostInput | PostCategoryUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: PostCategoryCreateManyPostInputEnvelope
    set?: PostCategoryWhereUniqueInput | PostCategoryWhereUniqueInput[]
    disconnect?: PostCategoryWhereUniqueInput | PostCategoryWhereUniqueInput[]
    delete?: PostCategoryWhereUniqueInput | PostCategoryWhereUniqueInput[]
    connect?: PostCategoryWhereUniqueInput | PostCategoryWhereUniqueInput[]
    update?: PostCategoryUpdateWithWhereUniqueWithoutPostInput | PostCategoryUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: PostCategoryUpdateManyWithWhereWithoutPostInput | PostCategoryUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: PostCategoryScalarWhereInput | PostCategoryScalarWhereInput[]
  }

  export type PostTagUpdateManyWithoutPostNestedInput = {
    create?: XOR<PostTagCreateWithoutPostInput, PostTagUncheckedCreateWithoutPostInput> | PostTagCreateWithoutPostInput[] | PostTagUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostTagCreateOrConnectWithoutPostInput | PostTagCreateOrConnectWithoutPostInput[]
    upsert?: PostTagUpsertWithWhereUniqueWithoutPostInput | PostTagUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: PostTagCreateManyPostInputEnvelope
    set?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
    disconnect?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
    delete?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
    connect?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
    update?: PostTagUpdateWithWhereUniqueWithoutPostInput | PostTagUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: PostTagUpdateManyWithWhereWithoutPostInput | PostTagUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: PostTagScalarWhereInput | PostTagScalarWhereInput[]
  }

  export type BlogCommentUpdateManyWithoutPostNestedInput = {
    create?: XOR<BlogCommentCreateWithoutPostInput, BlogCommentUncheckedCreateWithoutPostInput> | BlogCommentCreateWithoutPostInput[] | BlogCommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: BlogCommentCreateOrConnectWithoutPostInput | BlogCommentCreateOrConnectWithoutPostInput[]
    upsert?: BlogCommentUpsertWithWhereUniqueWithoutPostInput | BlogCommentUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: BlogCommentCreateManyPostInputEnvelope
    set?: BlogCommentWhereUniqueInput | BlogCommentWhereUniqueInput[]
    disconnect?: BlogCommentWhereUniqueInput | BlogCommentWhereUniqueInput[]
    delete?: BlogCommentWhereUniqueInput | BlogCommentWhereUniqueInput[]
    connect?: BlogCommentWhereUniqueInput | BlogCommentWhereUniqueInput[]
    update?: BlogCommentUpdateWithWhereUniqueWithoutPostInput | BlogCommentUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: BlogCommentUpdateManyWithWhereWithoutPostInput | BlogCommentUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: BlogCommentScalarWhereInput | BlogCommentScalarWhereInput[]
  }

  export type PostCategoryUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<PostCategoryCreateWithoutPostInput, PostCategoryUncheckedCreateWithoutPostInput> | PostCategoryCreateWithoutPostInput[] | PostCategoryUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostCategoryCreateOrConnectWithoutPostInput | PostCategoryCreateOrConnectWithoutPostInput[]
    upsert?: PostCategoryUpsertWithWhereUniqueWithoutPostInput | PostCategoryUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: PostCategoryCreateManyPostInputEnvelope
    set?: PostCategoryWhereUniqueInput | PostCategoryWhereUniqueInput[]
    disconnect?: PostCategoryWhereUniqueInput | PostCategoryWhereUniqueInput[]
    delete?: PostCategoryWhereUniqueInput | PostCategoryWhereUniqueInput[]
    connect?: PostCategoryWhereUniqueInput | PostCategoryWhereUniqueInput[]
    update?: PostCategoryUpdateWithWhereUniqueWithoutPostInput | PostCategoryUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: PostCategoryUpdateManyWithWhereWithoutPostInput | PostCategoryUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: PostCategoryScalarWhereInput | PostCategoryScalarWhereInput[]
  }

  export type PostTagUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<PostTagCreateWithoutPostInput, PostTagUncheckedCreateWithoutPostInput> | PostTagCreateWithoutPostInput[] | PostTagUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostTagCreateOrConnectWithoutPostInput | PostTagCreateOrConnectWithoutPostInput[]
    upsert?: PostTagUpsertWithWhereUniqueWithoutPostInput | PostTagUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: PostTagCreateManyPostInputEnvelope
    set?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
    disconnect?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
    delete?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
    connect?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
    update?: PostTagUpdateWithWhereUniqueWithoutPostInput | PostTagUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: PostTagUpdateManyWithWhereWithoutPostInput | PostTagUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: PostTagScalarWhereInput | PostTagScalarWhereInput[]
  }

  export type BlogCommentUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<BlogCommentCreateWithoutPostInput, BlogCommentUncheckedCreateWithoutPostInput> | BlogCommentCreateWithoutPostInput[] | BlogCommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: BlogCommentCreateOrConnectWithoutPostInput | BlogCommentCreateOrConnectWithoutPostInput[]
    upsert?: BlogCommentUpsertWithWhereUniqueWithoutPostInput | BlogCommentUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: BlogCommentCreateManyPostInputEnvelope
    set?: BlogCommentWhereUniqueInput | BlogCommentWhereUniqueInput[]
    disconnect?: BlogCommentWhereUniqueInput | BlogCommentWhereUniqueInput[]
    delete?: BlogCommentWhereUniqueInput | BlogCommentWhereUniqueInput[]
    connect?: BlogCommentWhereUniqueInput | BlogCommentWhereUniqueInput[]
    update?: BlogCommentUpdateWithWhereUniqueWithoutPostInput | BlogCommentUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: BlogCommentUpdateManyWithWhereWithoutPostInput | BlogCommentUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: BlogCommentScalarWhereInput | BlogCommentScalarWhereInput[]
  }

  export type PostCategoryCreateNestedManyWithoutCategoryInput = {
    create?: XOR<PostCategoryCreateWithoutCategoryInput, PostCategoryUncheckedCreateWithoutCategoryInput> | PostCategoryCreateWithoutCategoryInput[] | PostCategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: PostCategoryCreateOrConnectWithoutCategoryInput | PostCategoryCreateOrConnectWithoutCategoryInput[]
    createMany?: PostCategoryCreateManyCategoryInputEnvelope
    connect?: PostCategoryWhereUniqueInput | PostCategoryWhereUniqueInput[]
  }

  export type PostCategoryUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<PostCategoryCreateWithoutCategoryInput, PostCategoryUncheckedCreateWithoutCategoryInput> | PostCategoryCreateWithoutCategoryInput[] | PostCategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: PostCategoryCreateOrConnectWithoutCategoryInput | PostCategoryCreateOrConnectWithoutCategoryInput[]
    createMany?: PostCategoryCreateManyCategoryInputEnvelope
    connect?: PostCategoryWhereUniqueInput | PostCategoryWhereUniqueInput[]
  }

  export type PostCategoryUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<PostCategoryCreateWithoutCategoryInput, PostCategoryUncheckedCreateWithoutCategoryInput> | PostCategoryCreateWithoutCategoryInput[] | PostCategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: PostCategoryCreateOrConnectWithoutCategoryInput | PostCategoryCreateOrConnectWithoutCategoryInput[]
    upsert?: PostCategoryUpsertWithWhereUniqueWithoutCategoryInput | PostCategoryUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: PostCategoryCreateManyCategoryInputEnvelope
    set?: PostCategoryWhereUniqueInput | PostCategoryWhereUniqueInput[]
    disconnect?: PostCategoryWhereUniqueInput | PostCategoryWhereUniqueInput[]
    delete?: PostCategoryWhereUniqueInput | PostCategoryWhereUniqueInput[]
    connect?: PostCategoryWhereUniqueInput | PostCategoryWhereUniqueInput[]
    update?: PostCategoryUpdateWithWhereUniqueWithoutCategoryInput | PostCategoryUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: PostCategoryUpdateManyWithWhereWithoutCategoryInput | PostCategoryUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: PostCategoryScalarWhereInput | PostCategoryScalarWhereInput[]
  }

  export type PostCategoryUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<PostCategoryCreateWithoutCategoryInput, PostCategoryUncheckedCreateWithoutCategoryInput> | PostCategoryCreateWithoutCategoryInput[] | PostCategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: PostCategoryCreateOrConnectWithoutCategoryInput | PostCategoryCreateOrConnectWithoutCategoryInput[]
    upsert?: PostCategoryUpsertWithWhereUniqueWithoutCategoryInput | PostCategoryUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: PostCategoryCreateManyCategoryInputEnvelope
    set?: PostCategoryWhereUniqueInput | PostCategoryWhereUniqueInput[]
    disconnect?: PostCategoryWhereUniqueInput | PostCategoryWhereUniqueInput[]
    delete?: PostCategoryWhereUniqueInput | PostCategoryWhereUniqueInput[]
    connect?: PostCategoryWhereUniqueInput | PostCategoryWhereUniqueInput[]
    update?: PostCategoryUpdateWithWhereUniqueWithoutCategoryInput | PostCategoryUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: PostCategoryUpdateManyWithWhereWithoutCategoryInput | PostCategoryUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: PostCategoryScalarWhereInput | PostCategoryScalarWhereInput[]
  }

  export type BlogPostCreateNestedOneWithoutCategoriesInput = {
    create?: XOR<BlogPostCreateWithoutCategoriesInput, BlogPostUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: BlogPostCreateOrConnectWithoutCategoriesInput
    connect?: BlogPostWhereUniqueInput
  }

  export type CategoryCreateNestedOneWithoutPostsInput = {
    create?: XOR<CategoryCreateWithoutPostsInput, CategoryUncheckedCreateWithoutPostsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutPostsInput
    connect?: CategoryWhereUniqueInput
  }

  export type BlogPostUpdateOneRequiredWithoutCategoriesNestedInput = {
    create?: XOR<BlogPostCreateWithoutCategoriesInput, BlogPostUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: BlogPostCreateOrConnectWithoutCategoriesInput
    upsert?: BlogPostUpsertWithoutCategoriesInput
    connect?: BlogPostWhereUniqueInput
    update?: XOR<XOR<BlogPostUpdateToOneWithWhereWithoutCategoriesInput, BlogPostUpdateWithoutCategoriesInput>, BlogPostUncheckedUpdateWithoutCategoriesInput>
  }

  export type CategoryUpdateOneRequiredWithoutPostsNestedInput = {
    create?: XOR<CategoryCreateWithoutPostsInput, CategoryUncheckedCreateWithoutPostsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutPostsInput
    upsert?: CategoryUpsertWithoutPostsInput
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutPostsInput, CategoryUpdateWithoutPostsInput>, CategoryUncheckedUpdateWithoutPostsInput>
  }

  export type PostTagCreateNestedManyWithoutTagInput = {
    create?: XOR<PostTagCreateWithoutTagInput, PostTagUncheckedCreateWithoutTagInput> | PostTagCreateWithoutTagInput[] | PostTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: PostTagCreateOrConnectWithoutTagInput | PostTagCreateOrConnectWithoutTagInput[]
    createMany?: PostTagCreateManyTagInputEnvelope
    connect?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
  }

  export type PostTagUncheckedCreateNestedManyWithoutTagInput = {
    create?: XOR<PostTagCreateWithoutTagInput, PostTagUncheckedCreateWithoutTagInput> | PostTagCreateWithoutTagInput[] | PostTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: PostTagCreateOrConnectWithoutTagInput | PostTagCreateOrConnectWithoutTagInput[]
    createMany?: PostTagCreateManyTagInputEnvelope
    connect?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
  }

  export type PostTagUpdateManyWithoutTagNestedInput = {
    create?: XOR<PostTagCreateWithoutTagInput, PostTagUncheckedCreateWithoutTagInput> | PostTagCreateWithoutTagInput[] | PostTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: PostTagCreateOrConnectWithoutTagInput | PostTagCreateOrConnectWithoutTagInput[]
    upsert?: PostTagUpsertWithWhereUniqueWithoutTagInput | PostTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: PostTagCreateManyTagInputEnvelope
    set?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
    disconnect?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
    delete?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
    connect?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
    update?: PostTagUpdateWithWhereUniqueWithoutTagInput | PostTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: PostTagUpdateManyWithWhereWithoutTagInput | PostTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: PostTagScalarWhereInput | PostTagScalarWhereInput[]
  }

  export type PostTagUncheckedUpdateManyWithoutTagNestedInput = {
    create?: XOR<PostTagCreateWithoutTagInput, PostTagUncheckedCreateWithoutTagInput> | PostTagCreateWithoutTagInput[] | PostTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: PostTagCreateOrConnectWithoutTagInput | PostTagCreateOrConnectWithoutTagInput[]
    upsert?: PostTagUpsertWithWhereUniqueWithoutTagInput | PostTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: PostTagCreateManyTagInputEnvelope
    set?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
    disconnect?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
    delete?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
    connect?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
    update?: PostTagUpdateWithWhereUniqueWithoutTagInput | PostTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: PostTagUpdateManyWithWhereWithoutTagInput | PostTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: PostTagScalarWhereInput | PostTagScalarWhereInput[]
  }

  export type BlogPostCreateNestedOneWithoutTagsInput = {
    create?: XOR<BlogPostCreateWithoutTagsInput, BlogPostUncheckedCreateWithoutTagsInput>
    connectOrCreate?: BlogPostCreateOrConnectWithoutTagsInput
    connect?: BlogPostWhereUniqueInput
  }

  export type TagCreateNestedOneWithoutPostsInput = {
    create?: XOR<TagCreateWithoutPostsInput, TagUncheckedCreateWithoutPostsInput>
    connectOrCreate?: TagCreateOrConnectWithoutPostsInput
    connect?: TagWhereUniqueInput
  }

  export type BlogPostUpdateOneRequiredWithoutTagsNestedInput = {
    create?: XOR<BlogPostCreateWithoutTagsInput, BlogPostUncheckedCreateWithoutTagsInput>
    connectOrCreate?: BlogPostCreateOrConnectWithoutTagsInput
    upsert?: BlogPostUpsertWithoutTagsInput
    connect?: BlogPostWhereUniqueInput
    update?: XOR<XOR<BlogPostUpdateToOneWithWhereWithoutTagsInput, BlogPostUpdateWithoutTagsInput>, BlogPostUncheckedUpdateWithoutTagsInput>
  }

  export type TagUpdateOneRequiredWithoutPostsNestedInput = {
    create?: XOR<TagCreateWithoutPostsInput, TagUncheckedCreateWithoutPostsInput>
    connectOrCreate?: TagCreateOrConnectWithoutPostsInput
    upsert?: TagUpsertWithoutPostsInput
    connect?: TagWhereUniqueInput
    update?: XOR<XOR<TagUpdateToOneWithWhereWithoutPostsInput, TagUpdateWithoutPostsInput>, TagUncheckedUpdateWithoutPostsInput>
  }

  export type BlogPostCreateNestedOneWithoutCommentsInput = {
    create?: XOR<BlogPostCreateWithoutCommentsInput, BlogPostUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: BlogPostCreateOrConnectWithoutCommentsInput
    connect?: BlogPostWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutBlogCommentsInput = {
    create?: XOR<UserCreateWithoutBlogCommentsInput, UserUncheckedCreateWithoutBlogCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBlogCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type BlogCommentCreateNestedOneWithoutRepliesInput = {
    create?: XOR<BlogCommentCreateWithoutRepliesInput, BlogCommentUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: BlogCommentCreateOrConnectWithoutRepliesInput
    connect?: BlogCommentWhereUniqueInput
  }

  export type BlogCommentCreateNestedManyWithoutParentInput = {
    create?: XOR<BlogCommentCreateWithoutParentInput, BlogCommentUncheckedCreateWithoutParentInput> | BlogCommentCreateWithoutParentInput[] | BlogCommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: BlogCommentCreateOrConnectWithoutParentInput | BlogCommentCreateOrConnectWithoutParentInput[]
    createMany?: BlogCommentCreateManyParentInputEnvelope
    connect?: BlogCommentWhereUniqueInput | BlogCommentWhereUniqueInput[]
  }

  export type BlogCommentUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<BlogCommentCreateWithoutParentInput, BlogCommentUncheckedCreateWithoutParentInput> | BlogCommentCreateWithoutParentInput[] | BlogCommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: BlogCommentCreateOrConnectWithoutParentInput | BlogCommentCreateOrConnectWithoutParentInput[]
    createMany?: BlogCommentCreateManyParentInputEnvelope
    connect?: BlogCommentWhereUniqueInput | BlogCommentWhereUniqueInput[]
  }

  export type BlogPostUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<BlogPostCreateWithoutCommentsInput, BlogPostUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: BlogPostCreateOrConnectWithoutCommentsInput
    upsert?: BlogPostUpsertWithoutCommentsInput
    connect?: BlogPostWhereUniqueInput
    update?: XOR<XOR<BlogPostUpdateToOneWithWhereWithoutCommentsInput, BlogPostUpdateWithoutCommentsInput>, BlogPostUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateOneRequiredWithoutBlogCommentsNestedInput = {
    create?: XOR<UserCreateWithoutBlogCommentsInput, UserUncheckedCreateWithoutBlogCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBlogCommentsInput
    upsert?: UserUpsertWithoutBlogCommentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBlogCommentsInput, UserUpdateWithoutBlogCommentsInput>, UserUncheckedUpdateWithoutBlogCommentsInput>
  }

  export type BlogCommentUpdateOneWithoutRepliesNestedInput = {
    create?: XOR<BlogCommentCreateWithoutRepliesInput, BlogCommentUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: BlogCommentCreateOrConnectWithoutRepliesInput
    upsert?: BlogCommentUpsertWithoutRepliesInput
    disconnect?: BlogCommentWhereInput | boolean
    delete?: BlogCommentWhereInput | boolean
    connect?: BlogCommentWhereUniqueInput
    update?: XOR<XOR<BlogCommentUpdateToOneWithWhereWithoutRepliesInput, BlogCommentUpdateWithoutRepliesInput>, BlogCommentUncheckedUpdateWithoutRepliesInput>
  }

  export type BlogCommentUpdateManyWithoutParentNestedInput = {
    create?: XOR<BlogCommentCreateWithoutParentInput, BlogCommentUncheckedCreateWithoutParentInput> | BlogCommentCreateWithoutParentInput[] | BlogCommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: BlogCommentCreateOrConnectWithoutParentInput | BlogCommentCreateOrConnectWithoutParentInput[]
    upsert?: BlogCommentUpsertWithWhereUniqueWithoutParentInput | BlogCommentUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: BlogCommentCreateManyParentInputEnvelope
    set?: BlogCommentWhereUniqueInput | BlogCommentWhereUniqueInput[]
    disconnect?: BlogCommentWhereUniqueInput | BlogCommentWhereUniqueInput[]
    delete?: BlogCommentWhereUniqueInput | BlogCommentWhereUniqueInput[]
    connect?: BlogCommentWhereUniqueInput | BlogCommentWhereUniqueInput[]
    update?: BlogCommentUpdateWithWhereUniqueWithoutParentInput | BlogCommentUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: BlogCommentUpdateManyWithWhereWithoutParentInput | BlogCommentUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: BlogCommentScalarWhereInput | BlogCommentScalarWhereInput[]
  }

  export type BlogCommentUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<BlogCommentCreateWithoutParentInput, BlogCommentUncheckedCreateWithoutParentInput> | BlogCommentCreateWithoutParentInput[] | BlogCommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: BlogCommentCreateOrConnectWithoutParentInput | BlogCommentCreateOrConnectWithoutParentInput[]
    upsert?: BlogCommentUpsertWithWhereUniqueWithoutParentInput | BlogCommentUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: BlogCommentCreateManyParentInputEnvelope
    set?: BlogCommentWhereUniqueInput | BlogCommentWhereUniqueInput[]
    disconnect?: BlogCommentWhereUniqueInput | BlogCommentWhereUniqueInput[]
    delete?: BlogCommentWhereUniqueInput | BlogCommentWhereUniqueInput[]
    connect?: BlogCommentWhereUniqueInput | BlogCommentWhereUniqueInput[]
    update?: BlogCommentUpdateWithWhereUniqueWithoutParentInput | BlogCommentUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: BlogCommentUpdateManyWithWhereWithoutParentInput | BlogCommentUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: BlogCommentScalarWhereInput | BlogCommentScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutReferralCodesOwnedInput = {
    create?: XOR<UserCreateWithoutReferralCodesOwnedInput, UserUncheckedCreateWithoutReferralCodesOwnedInput>
    connectOrCreate?: UserCreateOrConnectWithoutReferralCodesOwnedInput
    connect?: UserWhereUniqueInput
  }

  export type ReferralUseCreateNestedManyWithoutReferralCodeInput = {
    create?: XOR<ReferralUseCreateWithoutReferralCodeInput, ReferralUseUncheckedCreateWithoutReferralCodeInput> | ReferralUseCreateWithoutReferralCodeInput[] | ReferralUseUncheckedCreateWithoutReferralCodeInput[]
    connectOrCreate?: ReferralUseCreateOrConnectWithoutReferralCodeInput | ReferralUseCreateOrConnectWithoutReferralCodeInput[]
    createMany?: ReferralUseCreateManyReferralCodeInputEnvelope
    connect?: ReferralUseWhereUniqueInput | ReferralUseWhereUniqueInput[]
  }

  export type ReferralUseUncheckedCreateNestedManyWithoutReferralCodeInput = {
    create?: XOR<ReferralUseCreateWithoutReferralCodeInput, ReferralUseUncheckedCreateWithoutReferralCodeInput> | ReferralUseCreateWithoutReferralCodeInput[] | ReferralUseUncheckedCreateWithoutReferralCodeInput[]
    connectOrCreate?: ReferralUseCreateOrConnectWithoutReferralCodeInput | ReferralUseCreateOrConnectWithoutReferralCodeInput[]
    createMany?: ReferralUseCreateManyReferralCodeInputEnvelope
    connect?: ReferralUseWhereUniqueInput | ReferralUseWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutReferralCodesOwnedNestedInput = {
    create?: XOR<UserCreateWithoutReferralCodesOwnedInput, UserUncheckedCreateWithoutReferralCodesOwnedInput>
    connectOrCreate?: UserCreateOrConnectWithoutReferralCodesOwnedInput
    upsert?: UserUpsertWithoutReferralCodesOwnedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReferralCodesOwnedInput, UserUpdateWithoutReferralCodesOwnedInput>, UserUncheckedUpdateWithoutReferralCodesOwnedInput>
  }

  export type ReferralUseUpdateManyWithoutReferralCodeNestedInput = {
    create?: XOR<ReferralUseCreateWithoutReferralCodeInput, ReferralUseUncheckedCreateWithoutReferralCodeInput> | ReferralUseCreateWithoutReferralCodeInput[] | ReferralUseUncheckedCreateWithoutReferralCodeInput[]
    connectOrCreate?: ReferralUseCreateOrConnectWithoutReferralCodeInput | ReferralUseCreateOrConnectWithoutReferralCodeInput[]
    upsert?: ReferralUseUpsertWithWhereUniqueWithoutReferralCodeInput | ReferralUseUpsertWithWhereUniqueWithoutReferralCodeInput[]
    createMany?: ReferralUseCreateManyReferralCodeInputEnvelope
    set?: ReferralUseWhereUniqueInput | ReferralUseWhereUniqueInput[]
    disconnect?: ReferralUseWhereUniqueInput | ReferralUseWhereUniqueInput[]
    delete?: ReferralUseWhereUniqueInput | ReferralUseWhereUniqueInput[]
    connect?: ReferralUseWhereUniqueInput | ReferralUseWhereUniqueInput[]
    update?: ReferralUseUpdateWithWhereUniqueWithoutReferralCodeInput | ReferralUseUpdateWithWhereUniqueWithoutReferralCodeInput[]
    updateMany?: ReferralUseUpdateManyWithWhereWithoutReferralCodeInput | ReferralUseUpdateManyWithWhereWithoutReferralCodeInput[]
    deleteMany?: ReferralUseScalarWhereInput | ReferralUseScalarWhereInput[]
  }

  export type ReferralUseUncheckedUpdateManyWithoutReferralCodeNestedInput = {
    create?: XOR<ReferralUseCreateWithoutReferralCodeInput, ReferralUseUncheckedCreateWithoutReferralCodeInput> | ReferralUseCreateWithoutReferralCodeInput[] | ReferralUseUncheckedCreateWithoutReferralCodeInput[]
    connectOrCreate?: ReferralUseCreateOrConnectWithoutReferralCodeInput | ReferralUseCreateOrConnectWithoutReferralCodeInput[]
    upsert?: ReferralUseUpsertWithWhereUniqueWithoutReferralCodeInput | ReferralUseUpsertWithWhereUniqueWithoutReferralCodeInput[]
    createMany?: ReferralUseCreateManyReferralCodeInputEnvelope
    set?: ReferralUseWhereUniqueInput | ReferralUseWhereUniqueInput[]
    disconnect?: ReferralUseWhereUniqueInput | ReferralUseWhereUniqueInput[]
    delete?: ReferralUseWhereUniqueInput | ReferralUseWhereUniqueInput[]
    connect?: ReferralUseWhereUniqueInput | ReferralUseWhereUniqueInput[]
    update?: ReferralUseUpdateWithWhereUniqueWithoutReferralCodeInput | ReferralUseUpdateWithWhereUniqueWithoutReferralCodeInput[]
    updateMany?: ReferralUseUpdateManyWithWhereWithoutReferralCodeInput | ReferralUseUpdateManyWithWhereWithoutReferralCodeInput[]
    deleteMany?: ReferralUseScalarWhereInput | ReferralUseScalarWhereInput[]
  }

  export type ReferralCodeCreateNestedOneWithoutUsesInput = {
    create?: XOR<ReferralCodeCreateWithoutUsesInput, ReferralCodeUncheckedCreateWithoutUsesInput>
    connectOrCreate?: ReferralCodeCreateOrConnectWithoutUsesInput
    connect?: ReferralCodeWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReferralUsesGainedInput = {
    create?: XOR<UserCreateWithoutReferralUsesGainedInput, UserUncheckedCreateWithoutReferralUsesGainedInput>
    connectOrCreate?: UserCreateOrConnectWithoutReferralUsesGainedInput
    connect?: UserWhereUniqueInput
  }

  export type ReferralCodeUpdateOneRequiredWithoutUsesNestedInput = {
    create?: XOR<ReferralCodeCreateWithoutUsesInput, ReferralCodeUncheckedCreateWithoutUsesInput>
    connectOrCreate?: ReferralCodeCreateOrConnectWithoutUsesInput
    upsert?: ReferralCodeUpsertWithoutUsesInput
    connect?: ReferralCodeWhereUniqueInput
    update?: XOR<XOR<ReferralCodeUpdateToOneWithWhereWithoutUsesInput, ReferralCodeUpdateWithoutUsesInput>, ReferralCodeUncheckedUpdateWithoutUsesInput>
  }

  export type UserUpdateOneRequiredWithoutReferralUsesGainedNestedInput = {
    create?: XOR<UserCreateWithoutReferralUsesGainedInput, UserUncheckedCreateWithoutReferralUsesGainedInput>
    connectOrCreate?: UserCreateOrConnectWithoutReferralUsesGainedInput
    upsert?: UserUpsertWithoutReferralUsesGainedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReferralUsesGainedInput, UserUpdateWithoutReferralUsesGainedInput>, UserUncheckedUpdateWithoutReferralUsesGainedInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedEnumPointsTxnTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PointsTxnType | EnumPointsTxnTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PointsTxnType[] | ListEnumPointsTxnTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PointsTxnType[] | ListEnumPointsTxnTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPointsTxnTypeFilter<$PrismaModel> | $Enums.PointsTxnType
  }

  export type NestedEnumPointsTxnTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PointsTxnType | EnumPointsTxnTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PointsTxnType[] | ListEnumPointsTxnTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PointsTxnType[] | ListEnumPointsTxnTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPointsTxnTypeWithAggregatesFilter<$PrismaModel> | $Enums.PointsTxnType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPointsTxnTypeFilter<$PrismaModel>
    _max?: NestedEnumPointsTxnTypeFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumCourseStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CourseStatus | EnumCourseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CourseStatus[] | ListEnumCourseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CourseStatus[] | ListEnumCourseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCourseStatusFilter<$PrismaModel> | $Enums.CourseStatus
  }

  export type NestedEnumCourseStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CourseStatus | EnumCourseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CourseStatus[] | ListEnumCourseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CourseStatus[] | ListEnumCourseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCourseStatusWithAggregatesFilter<$PrismaModel> | $Enums.CourseStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCourseStatusFilter<$PrismaModel>
    _max?: NestedEnumCourseStatusFilter<$PrismaModel>
  }

  export type NestedEnumLessonTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LessonType | EnumLessonTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LessonType[] | ListEnumLessonTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LessonType[] | ListEnumLessonTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLessonTypeFilter<$PrismaModel> | $Enums.LessonType
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumLessonTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LessonType | EnumLessonTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LessonType[] | ListEnumLessonTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LessonType[] | ListEnumLessonTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLessonTypeWithAggregatesFilter<$PrismaModel> | $Enums.LessonType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLessonTypeFilter<$PrismaModel>
    _max?: NestedEnumLessonTypeFilter<$PrismaModel>
  }

  export type NestedEnumQuestionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestionType | EnumQuestionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumQuestionTypeFilter<$PrismaModel> | $Enums.QuestionType
  }

  export type NestedEnumQuestionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestionType | EnumQuestionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumQuestionTypeWithAggregatesFilter<$PrismaModel> | $Enums.QuestionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQuestionTypeFilter<$PrismaModel>
    _max?: NestedEnumQuestionTypeFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumTutoringLocationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TutoringLocationType | EnumTutoringLocationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TutoringLocationType[] | ListEnumTutoringLocationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TutoringLocationType[] | ListEnumTutoringLocationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTutoringLocationTypeFilter<$PrismaModel> | $Enums.TutoringLocationType
  }

  export type NestedEnumTutoringStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TutoringStatus | EnumTutoringStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TutoringStatus[] | ListEnumTutoringStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TutoringStatus[] | ListEnumTutoringStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTutoringStatusFilter<$PrismaModel> | $Enums.TutoringStatus
  }

  export type NestedEnumTutoringLocationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TutoringLocationType | EnumTutoringLocationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TutoringLocationType[] | ListEnumTutoringLocationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TutoringLocationType[] | ListEnumTutoringLocationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTutoringLocationTypeWithAggregatesFilter<$PrismaModel> | $Enums.TutoringLocationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTutoringLocationTypeFilter<$PrismaModel>
    _max?: NestedEnumTutoringLocationTypeFilter<$PrismaModel>
  }

  export type NestedEnumTutoringStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TutoringStatus | EnumTutoringStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TutoringStatus[] | ListEnumTutoringStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TutoringStatus[] | ListEnumTutoringStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTutoringStatusWithAggregatesFilter<$PrismaModel> | $Enums.TutoringStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTutoringStatusFilter<$PrismaModel>
    _max?: NestedEnumTutoringStatusFilter<$PrismaModel>
  }

  export type NestedEnumTutoringRequestStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TutoringRequestStatus | EnumTutoringRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TutoringRequestStatus[] | ListEnumTutoringRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TutoringRequestStatus[] | ListEnumTutoringRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTutoringRequestStatusFilter<$PrismaModel> | $Enums.TutoringRequestStatus
  }

  export type NestedEnumTutoringRequestStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TutoringRequestStatus | EnumTutoringRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TutoringRequestStatus[] | ListEnumTutoringRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TutoringRequestStatus[] | ListEnumTutoringRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTutoringRequestStatusWithAggregatesFilter<$PrismaModel> | $Enums.TutoringRequestStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTutoringRequestStatusFilter<$PrismaModel>
    _max?: NestedEnumTutoringRequestStatusFilter<$PrismaModel>
  }

  export type NestedEnumAppointmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AppointmentStatus | EnumAppointmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAppointmentStatusFilter<$PrismaModel> | $Enums.AppointmentStatus
  }

  export type NestedEnumAppointmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AppointmentStatus | EnumAppointmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAppointmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.AppointmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAppointmentStatusFilter<$PrismaModel>
    _max?: NestedEnumAppointmentStatusFilter<$PrismaModel>
  }

  export type NestedEnumAchievementCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.AchievementCategory | EnumAchievementCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.AchievementCategory[] | ListEnumAchievementCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.AchievementCategory[] | ListEnumAchievementCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumAchievementCategoryFilter<$PrismaModel> | $Enums.AchievementCategory
  }

  export type NestedEnumAchievementCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AchievementCategory | EnumAchievementCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.AchievementCategory[] | ListEnumAchievementCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.AchievementCategory[] | ListEnumAchievementCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumAchievementCategoryWithAggregatesFilter<$PrismaModel> | $Enums.AchievementCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAchievementCategoryFilter<$PrismaModel>
    _max?: NestedEnumAchievementCategoryFilter<$PrismaModel>
  }

  export type NestedEnumBadgeTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.BadgeType | EnumBadgeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BadgeType[] | ListEnumBadgeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BadgeType[] | ListEnumBadgeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBadgeTypeFilter<$PrismaModel> | $Enums.BadgeType
  }

  export type NestedEnumBadgeTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BadgeType | EnumBadgeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BadgeType[] | ListEnumBadgeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BadgeType[] | ListEnumBadgeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBadgeTypeWithAggregatesFilter<$PrismaModel> | $Enums.BadgeType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBadgeTypeFilter<$PrismaModel>
    _max?: NestedEnumBadgeTypeFilter<$PrismaModel>
  }

  export type NestedEnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type NestedEnumSubscriptionPeriodFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionPeriod | EnumSubscriptionPeriodFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionPeriod[] | ListEnumSubscriptionPeriodFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionPeriod[] | ListEnumSubscriptionPeriodFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionPeriodFilter<$PrismaModel> | $Enums.SubscriptionPeriod
  }

  export type NestedEnumSubscriptionPeriodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionPeriod | EnumSubscriptionPeriodFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionPeriod[] | ListEnumSubscriptionPeriodFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionPeriod[] | ListEnumSubscriptionPeriodFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionPeriodWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionPeriod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionPeriodFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionPeriodFilter<$PrismaModel>
  }

  export type NestedEnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type NestedEnumPaymentReferenceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentReferenceType | EnumPaymentReferenceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentReferenceType[] | ListEnumPaymentReferenceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentReferenceType[] | ListEnumPaymentReferenceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentReferenceTypeFilter<$PrismaModel> | $Enums.PaymentReferenceType
  }

  export type NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type NestedEnumPaymentReferenceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentReferenceType | EnumPaymentReferenceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentReferenceType[] | ListEnumPaymentReferenceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentReferenceType[] | ListEnumPaymentReferenceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentReferenceTypeWithAggregatesFilter<$PrismaModel> | $Enums.PaymentReferenceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentReferenceTypeFilter<$PrismaModel>
    _max?: NestedEnumPaymentReferenceTypeFilter<$PrismaModel>
  }

  export type UserCreateWithoutReferralsInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    avatar?: string | null
    bio?: string | null
    createdAt?: Date | string
    points?: number
    referralCode?: string | null
    lastLogin?: Date | string | null
    referredBy?: UserCreateNestedOneWithoutReferralsInput
    teacherProfile?: TeacherProfileCreateNestedOneWithoutUserInput
    availability?: UserAvailabilityCreateNestedManyWithoutUserInput
    pointsTransactions?: PointsTransactionCreateNestedManyWithoutUserInput
    courses?: CourseCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    savedCourses?: SavedCourseCreateNestedManyWithoutUserInput
    likedCourses?: LikedCourseCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutUserInput
    assignmentSubs?: AssignmentSubmissionCreateNestedManyWithoutUserInput
    courseReviews?: CourseReviewCreateNestedManyWithoutUserInput
    tutoringSessions?: TutoringSessionCreateNestedManyWithoutTeacherInput
    tutoringRequests?: TutoringRequestCreateNestedManyWithoutStudentInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentCreateNestedManyWithoutTeacherInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentCreateNestedManyWithoutStudentInput
    tutoringReviews?: TutoringReviewCreateNestedManyWithoutStudentInput
    tutoringMessages?: TutoringMessageCreateNestedManyWithoutSenderInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    conversationParts?: ConversationParticipantCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    attachments?: AttachmentCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    subscriptionRecords?: UserSubscriptionCreateNestedManyWithoutUserInput
    bundlesOwned?: UserBundleCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventCreateNestedManyWithoutUserInput
    eventsAsTeacher?: CalendarEventCreateNestedManyWithoutTeacherInput
    eventsAsStudent?: CalendarEventCreateNestedManyWithoutStudentInput
    blogPosts?: BlogPostCreateNestedManyWithoutAuthorInput
    blogComments?: BlogCommentCreateNestedManyWithoutUserInput
    submissionsGraded?: AssignmentSubmissionCreateNestedManyWithoutGradedByInput
    referralCodesOwned?: ReferralCodeCreateNestedManyWithoutUserInput
    referralUsesGained?: ReferralUseCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReferralsInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    avatar?: string | null
    bio?: string | null
    createdAt?: Date | string
    points?: number
    referralCode?: string | null
    referredById?: string | null
    lastLogin?: Date | string | null
    teacherProfile?: TeacherProfileUncheckedCreateNestedOneWithoutUserInput
    availability?: UserAvailabilityUncheckedCreateNestedManyWithoutUserInput
    pointsTransactions?: PointsTransactionUncheckedCreateNestedManyWithoutUserInput
    courses?: CourseUncheckedCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    savedCourses?: SavedCourseUncheckedCreateNestedManyWithoutUserInput
    likedCourses?: LikedCourseUncheckedCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressUncheckedCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutUserInput
    assignmentSubs?: AssignmentSubmissionUncheckedCreateNestedManyWithoutUserInput
    courseReviews?: CourseReviewUncheckedCreateNestedManyWithoutUserInput
    tutoringSessions?: TutoringSessionUncheckedCreateNestedManyWithoutTeacherInput
    tutoringRequests?: TutoringRequestUncheckedCreateNestedManyWithoutStudentInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUncheckedCreateNestedManyWithoutTeacherInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUncheckedCreateNestedManyWithoutStudentInput
    tutoringReviews?: TutoringReviewUncheckedCreateNestedManyWithoutStudentInput
    tutoringMessages?: TutoringMessageUncheckedCreateNestedManyWithoutSenderInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    conversationParts?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    subscriptionRecords?: UserSubscriptionUncheckedCreateNestedManyWithoutUserInput
    bundlesOwned?: UserBundleUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventUncheckedCreateNestedManyWithoutUserInput
    eventsAsTeacher?: CalendarEventUncheckedCreateNestedManyWithoutTeacherInput
    eventsAsStudent?: CalendarEventUncheckedCreateNestedManyWithoutStudentInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
    blogComments?: BlogCommentUncheckedCreateNestedManyWithoutUserInput
    submissionsGraded?: AssignmentSubmissionUncheckedCreateNestedManyWithoutGradedByInput
    referralCodesOwned?: ReferralCodeUncheckedCreateNestedManyWithoutUserInput
    referralUsesGained?: ReferralUseUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReferralsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReferralsInput, UserUncheckedCreateWithoutReferralsInput>
  }

  export type UserCreateWithoutReferredByInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    avatar?: string | null
    bio?: string | null
    createdAt?: Date | string
    points?: number
    referralCode?: string | null
    lastLogin?: Date | string | null
    referrals?: UserCreateNestedManyWithoutReferredByInput
    teacherProfile?: TeacherProfileCreateNestedOneWithoutUserInput
    availability?: UserAvailabilityCreateNestedManyWithoutUserInput
    pointsTransactions?: PointsTransactionCreateNestedManyWithoutUserInput
    courses?: CourseCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    savedCourses?: SavedCourseCreateNestedManyWithoutUserInput
    likedCourses?: LikedCourseCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutUserInput
    assignmentSubs?: AssignmentSubmissionCreateNestedManyWithoutUserInput
    courseReviews?: CourseReviewCreateNestedManyWithoutUserInput
    tutoringSessions?: TutoringSessionCreateNestedManyWithoutTeacherInput
    tutoringRequests?: TutoringRequestCreateNestedManyWithoutStudentInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentCreateNestedManyWithoutTeacherInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentCreateNestedManyWithoutStudentInput
    tutoringReviews?: TutoringReviewCreateNestedManyWithoutStudentInput
    tutoringMessages?: TutoringMessageCreateNestedManyWithoutSenderInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    conversationParts?: ConversationParticipantCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    attachments?: AttachmentCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    subscriptionRecords?: UserSubscriptionCreateNestedManyWithoutUserInput
    bundlesOwned?: UserBundleCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventCreateNestedManyWithoutUserInput
    eventsAsTeacher?: CalendarEventCreateNestedManyWithoutTeacherInput
    eventsAsStudent?: CalendarEventCreateNestedManyWithoutStudentInput
    blogPosts?: BlogPostCreateNestedManyWithoutAuthorInput
    blogComments?: BlogCommentCreateNestedManyWithoutUserInput
    submissionsGraded?: AssignmentSubmissionCreateNestedManyWithoutGradedByInput
    referralCodesOwned?: ReferralCodeCreateNestedManyWithoutUserInput
    referralUsesGained?: ReferralUseCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReferredByInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    avatar?: string | null
    bio?: string | null
    createdAt?: Date | string
    points?: number
    referralCode?: string | null
    lastLogin?: Date | string | null
    referrals?: UserUncheckedCreateNestedManyWithoutReferredByInput
    teacherProfile?: TeacherProfileUncheckedCreateNestedOneWithoutUserInput
    availability?: UserAvailabilityUncheckedCreateNestedManyWithoutUserInput
    pointsTransactions?: PointsTransactionUncheckedCreateNestedManyWithoutUserInput
    courses?: CourseUncheckedCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    savedCourses?: SavedCourseUncheckedCreateNestedManyWithoutUserInput
    likedCourses?: LikedCourseUncheckedCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressUncheckedCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutUserInput
    assignmentSubs?: AssignmentSubmissionUncheckedCreateNestedManyWithoutUserInput
    courseReviews?: CourseReviewUncheckedCreateNestedManyWithoutUserInput
    tutoringSessions?: TutoringSessionUncheckedCreateNestedManyWithoutTeacherInput
    tutoringRequests?: TutoringRequestUncheckedCreateNestedManyWithoutStudentInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUncheckedCreateNestedManyWithoutTeacherInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUncheckedCreateNestedManyWithoutStudentInput
    tutoringReviews?: TutoringReviewUncheckedCreateNestedManyWithoutStudentInput
    tutoringMessages?: TutoringMessageUncheckedCreateNestedManyWithoutSenderInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    conversationParts?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    subscriptionRecords?: UserSubscriptionUncheckedCreateNestedManyWithoutUserInput
    bundlesOwned?: UserBundleUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventUncheckedCreateNestedManyWithoutUserInput
    eventsAsTeacher?: CalendarEventUncheckedCreateNestedManyWithoutTeacherInput
    eventsAsStudent?: CalendarEventUncheckedCreateNestedManyWithoutStudentInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
    blogComments?: BlogCommentUncheckedCreateNestedManyWithoutUserInput
    submissionsGraded?: AssignmentSubmissionUncheckedCreateNestedManyWithoutGradedByInput
    referralCodesOwned?: ReferralCodeUncheckedCreateNestedManyWithoutUserInput
    referralUsesGained?: ReferralUseUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReferredByInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReferredByInput, UserUncheckedCreateWithoutReferredByInput>
  }

  export type UserCreateManyReferredByInputEnvelope = {
    data: UserCreateManyReferredByInput | UserCreateManyReferredByInput[]
    skipDuplicates?: boolean
  }

  export type TeacherProfileCreateWithoutUserInput = {
    specialization?: TeacherProfileCreatespecializationInput | string[]
    rating?: Decimal | DecimalJsLike | number | string | null
    students?: number
    education?: string | null
    experience?: string | null
    certificates?: TeacherProfileCreatecertificatesInput | string[]
  }

  export type TeacherProfileUncheckedCreateWithoutUserInput = {
    specialization?: TeacherProfileCreatespecializationInput | string[]
    rating?: Decimal | DecimalJsLike | number | string | null
    students?: number
    education?: string | null
    experience?: string | null
    certificates?: TeacherProfileCreatecertificatesInput | string[]
  }

  export type TeacherProfileCreateOrConnectWithoutUserInput = {
    where: TeacherProfileWhereUniqueInput
    create: XOR<TeacherProfileCreateWithoutUserInput, TeacherProfileUncheckedCreateWithoutUserInput>
  }

  export type UserAvailabilityCreateWithoutUserInput = {
    id?: string
    dayOfWeek: number
    startTime: Date | string
    endTime: Date | string
  }

  export type UserAvailabilityUncheckedCreateWithoutUserInput = {
    id?: string
    dayOfWeek: number
    startTime: Date | string
    endTime: Date | string
  }

  export type UserAvailabilityCreateOrConnectWithoutUserInput = {
    where: UserAvailabilityWhereUniqueInput
    create: XOR<UserAvailabilityCreateWithoutUserInput, UserAvailabilityUncheckedCreateWithoutUserInput>
  }

  export type UserAvailabilityCreateManyUserInputEnvelope = {
    data: UserAvailabilityCreateManyUserInput | UserAvailabilityCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PointsTransactionCreateWithoutUserInput = {
    id?: string
    amount: number
    type: $Enums.PointsTxnType
    description?: string | null
    createdAt?: Date | string
  }

  export type PointsTransactionUncheckedCreateWithoutUserInput = {
    id?: string
    amount: number
    type: $Enums.PointsTxnType
    description?: string | null
    createdAt?: Date | string
  }

  export type PointsTransactionCreateOrConnectWithoutUserInput = {
    where: PointsTransactionWhereUniqueInput
    create: XOR<PointsTransactionCreateWithoutUserInput, PointsTransactionUncheckedCreateWithoutUserInput>
  }

  export type PointsTransactionCreateManyUserInputEnvelope = {
    data: PointsTransactionCreateManyUserInput | PointsTransactionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CourseCreateWithoutTeacherInput = {
    id?: string
    title: string
    description?: string | null
    subject: string
    image?: string | null
    price: Decimal | DecimalJsLike | number | string
    pointsPrice: number
    students?: number
    rating?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.CourseStatus
    featured?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    topics?: TopicCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentCreateNestedManyWithoutCourseInput
    savedBy?: SavedCourseCreateNestedManyWithoutCourseInput
    likedBy?: LikedCourseCreateNestedManyWithoutCourseInput
    reviews?: CourseReviewCreateNestedManyWithoutCourseInput
    lessons?: LessonCreateNestedManyWithoutCourseInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutCourseInput
    certificates?: CertificateCreateNestedManyWithoutCourseInput
    bundleCourses?: BundleCourseCreateNestedManyWithoutCourseInput
    calendarEvents?: CalendarEventCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutTeacherInput = {
    id?: string
    title: string
    description?: string | null
    subject: string
    image?: string | null
    price: Decimal | DecimalJsLike | number | string
    pointsPrice: number
    students?: number
    rating?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.CourseStatus
    featured?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    topics?: TopicUncheckedCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutCourseInput
    savedBy?: SavedCourseUncheckedCreateNestedManyWithoutCourseInput
    likedBy?: LikedCourseUncheckedCreateNestedManyWithoutCourseInput
    reviews?: CourseReviewUncheckedCreateNestedManyWithoutCourseInput
    lessons?: LessonUncheckedCreateNestedManyWithoutCourseInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutCourseInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutCourseInput
    bundleCourses?: BundleCourseUncheckedCreateNestedManyWithoutCourseInput
    calendarEvents?: CalendarEventUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutTeacherInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutTeacherInput, CourseUncheckedCreateWithoutTeacherInput>
  }

  export type CourseCreateManyTeacherInputEnvelope = {
    data: CourseCreateManyTeacherInput | CourseCreateManyTeacherInput[]
    skipDuplicates?: boolean
  }

  export type EnrollmentCreateWithoutUserInput = {
    id?: string
    enrolledAt?: Date | string
    completed?: boolean
    completedAt?: Date | string | null
    status?: string
    course: CourseCreateNestedOneWithoutEnrollmentsInput
  }

  export type EnrollmentUncheckedCreateWithoutUserInput = {
    id?: string
    courseId: string
    enrolledAt?: Date | string
    completed?: boolean
    completedAt?: Date | string | null
    status?: string
  }

  export type EnrollmentCreateOrConnectWithoutUserInput = {
    where: EnrollmentWhereUniqueInput
    create: XOR<EnrollmentCreateWithoutUserInput, EnrollmentUncheckedCreateWithoutUserInput>
  }

  export type EnrollmentCreateManyUserInputEnvelope = {
    data: EnrollmentCreateManyUserInput | EnrollmentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SavedCourseCreateWithoutUserInput = {
    id?: string
    savedAt?: Date | string
    course: CourseCreateNestedOneWithoutSavedByInput
  }

  export type SavedCourseUncheckedCreateWithoutUserInput = {
    id?: string
    courseId: string
    savedAt?: Date | string
  }

  export type SavedCourseCreateOrConnectWithoutUserInput = {
    where: SavedCourseWhereUniqueInput
    create: XOR<SavedCourseCreateWithoutUserInput, SavedCourseUncheckedCreateWithoutUserInput>
  }

  export type SavedCourseCreateManyUserInputEnvelope = {
    data: SavedCourseCreateManyUserInput | SavedCourseCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type LikedCourseCreateWithoutUserInput = {
    id?: string
    likedAt?: Date | string
    course: CourseCreateNestedOneWithoutLikedByInput
  }

  export type LikedCourseUncheckedCreateWithoutUserInput = {
    id?: string
    courseId: string
    likedAt?: Date | string
  }

  export type LikedCourseCreateOrConnectWithoutUserInput = {
    where: LikedCourseWhereUniqueInput
    create: XOR<LikedCourseCreateWithoutUserInput, LikedCourseUncheckedCreateWithoutUserInput>
  }

  export type LikedCourseCreateManyUserInputEnvelope = {
    data: LikedCourseCreateManyUserInput | LikedCourseCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type LessonProgressCreateWithoutUserInput = {
    id?: string
    completed?: boolean
    completedAt?: Date | string | null
    lastPosition?: number
    lesson: LessonCreateNestedOneWithoutProgressInput
  }

  export type LessonProgressUncheckedCreateWithoutUserInput = {
    id?: string
    lessonId: string
    completed?: boolean
    completedAt?: Date | string | null
    lastPosition?: number
  }

  export type LessonProgressCreateOrConnectWithoutUserInput = {
    where: LessonProgressWhereUniqueInput
    create: XOR<LessonProgressCreateWithoutUserInput, LessonProgressUncheckedCreateWithoutUserInput>
  }

  export type LessonProgressCreateManyUserInputEnvelope = {
    data: LessonProgressCreateManyUserInput | LessonProgressCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type QuizAttemptCreateWithoutUserInput = {
    id?: string
    score: number
    duration?: number | null
    completedAt?: Date | string
    answers: JsonNullValueInput | InputJsonValue
    quiz: QuizCreateNestedOneWithoutAttemptsInput
    course?: CourseCreateNestedOneWithoutQuizAttemptsInput
  }

  export type QuizAttemptUncheckedCreateWithoutUserInput = {
    id?: string
    quizId: string
    score: number
    duration?: number | null
    completedAt?: Date | string
    answers: JsonNullValueInput | InputJsonValue
    courseId?: string | null
  }

  export type QuizAttemptCreateOrConnectWithoutUserInput = {
    where: QuizAttemptWhereUniqueInput
    create: XOR<QuizAttemptCreateWithoutUserInput, QuizAttemptUncheckedCreateWithoutUserInput>
  }

  export type QuizAttemptCreateManyUserInputEnvelope = {
    data: QuizAttemptCreateManyUserInput | QuizAttemptCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AssignmentSubmissionCreateWithoutUserInput = {
    id?: string
    content?: string | null
    fileUrls?: AssignmentSubmissionCreatefileUrlsInput | string[]
    submittedAt?: Date | string
    score?: number | null
    feedback?: string | null
    gradedAt?: Date | string | null
    assignment: AssignmentCreateNestedOneWithoutSubmissionsInput
    gradedBy?: UserCreateNestedOneWithoutSubmissionsGradedInput
  }

  export type AssignmentSubmissionUncheckedCreateWithoutUserInput = {
    id?: string
    assignmentId: string
    content?: string | null
    fileUrls?: AssignmentSubmissionCreatefileUrlsInput | string[]
    submittedAt?: Date | string
    score?: number | null
    feedback?: string | null
    gradedAt?: Date | string | null
    gradedById?: string | null
  }

  export type AssignmentSubmissionCreateOrConnectWithoutUserInput = {
    where: AssignmentSubmissionWhereUniqueInput
    create: XOR<AssignmentSubmissionCreateWithoutUserInput, AssignmentSubmissionUncheckedCreateWithoutUserInput>
  }

  export type AssignmentSubmissionCreateManyUserInputEnvelope = {
    data: AssignmentSubmissionCreateManyUserInput | AssignmentSubmissionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CourseReviewCreateWithoutUserInput = {
    id?: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
    course: CourseCreateNestedOneWithoutReviewsInput
  }

  export type CourseReviewUncheckedCreateWithoutUserInput = {
    id?: string
    courseId: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
  }

  export type CourseReviewCreateOrConnectWithoutUserInput = {
    where: CourseReviewWhereUniqueInput
    create: XOR<CourseReviewCreateWithoutUserInput, CourseReviewUncheckedCreateWithoutUserInput>
  }

  export type CourseReviewCreateManyUserInputEnvelope = {
    data: CourseReviewCreateManyUserInput | CourseReviewCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TutoringSessionCreateWithoutTeacherInput = {
    id?: string
    subject: string
    description?: string | null
    pricePerHour: Decimal | DecimalJsLike | number | string
    locationType: $Enums.TutoringLocationType
    status?: $Enums.TutoringStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    maxStudents?: number
    prerequisites?: TutoringSessionCreateprerequisitesInput | string[]
    level?: string | null
    tags?: TutoringSessionCreatetagsInput | string[]
    featured?: boolean
    availability?: TutoringAvailabilityCreateNestedManyWithoutSessionInput
    requests?: TutoringRequestCreateNestedManyWithoutSessionInput
    appointments?: TutoringAppointmentCreateNestedManyWithoutSessionInput
    reviews?: TutoringReviewCreateNestedManyWithoutSessionInput
    certificates?: CertificateCreateNestedManyWithoutTutoringInput
  }

  export type TutoringSessionUncheckedCreateWithoutTeacherInput = {
    id?: string
    subject: string
    description?: string | null
    pricePerHour: Decimal | DecimalJsLike | number | string
    locationType: $Enums.TutoringLocationType
    status?: $Enums.TutoringStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    maxStudents?: number
    prerequisites?: TutoringSessionCreateprerequisitesInput | string[]
    level?: string | null
    tags?: TutoringSessionCreatetagsInput | string[]
    featured?: boolean
    availability?: TutoringAvailabilityUncheckedCreateNestedManyWithoutSessionInput
    requests?: TutoringRequestUncheckedCreateNestedManyWithoutSessionInput
    appointments?: TutoringAppointmentUncheckedCreateNestedManyWithoutSessionInput
    reviews?: TutoringReviewUncheckedCreateNestedManyWithoutSessionInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutTutoringInput
  }

  export type TutoringSessionCreateOrConnectWithoutTeacherInput = {
    where: TutoringSessionWhereUniqueInput
    create: XOR<TutoringSessionCreateWithoutTeacherInput, TutoringSessionUncheckedCreateWithoutTeacherInput>
  }

  export type TutoringSessionCreateManyTeacherInputEnvelope = {
    data: TutoringSessionCreateManyTeacherInput | TutoringSessionCreateManyTeacherInput[]
    skipDuplicates?: boolean
  }

  export type TutoringRequestCreateWithoutStudentInput = {
    id?: string
    message?: string | null
    preferredDates?: TutoringRequestCreatepreferredDatesInput | Date[] | string[]
    status?: $Enums.TutoringRequestStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    session: TutoringSessionCreateNestedOneWithoutRequestsInput
    appointment?: TutoringAppointmentCreateNestedOneWithoutRequestInput
    messages?: TutoringMessageCreateNestedManyWithoutRequestInput
  }

  export type TutoringRequestUncheckedCreateWithoutStudentInput = {
    id?: string
    sessionId: string
    message?: string | null
    preferredDates?: TutoringRequestCreatepreferredDatesInput | Date[] | string[]
    status?: $Enums.TutoringRequestStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    appointment?: TutoringAppointmentUncheckedCreateNestedOneWithoutRequestInput
    messages?: TutoringMessageUncheckedCreateNestedManyWithoutRequestInput
  }

  export type TutoringRequestCreateOrConnectWithoutStudentInput = {
    where: TutoringRequestWhereUniqueInput
    create: XOR<TutoringRequestCreateWithoutStudentInput, TutoringRequestUncheckedCreateWithoutStudentInput>
  }

  export type TutoringRequestCreateManyStudentInputEnvelope = {
    data: TutoringRequestCreateManyStudentInput | TutoringRequestCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type TutoringAppointmentCreateWithoutTeacherInput = {
    id?: string
    scheduledAt: Date | string
    duration: number
    notes?: string | null
    meetingLink?: string | null
    status?: $Enums.AppointmentStatus
    price: Decimal | DecimalJsLike | number | string
    request: TutoringRequestCreateNestedOneWithoutAppointmentInput
    session: TutoringSessionCreateNestedOneWithoutAppointmentsInput
    student: UserCreateNestedOneWithoutTutoringAppointmentsAsStudentInput
  }

  export type TutoringAppointmentUncheckedCreateWithoutTeacherInput = {
    id?: string
    requestId: string
    sessionId: string
    scheduledAt: Date | string
    duration: number
    notes?: string | null
    meetingLink?: string | null
    status?: $Enums.AppointmentStatus
    price: Decimal | DecimalJsLike | number | string
    studentId: string
  }

  export type TutoringAppointmentCreateOrConnectWithoutTeacherInput = {
    where: TutoringAppointmentWhereUniqueInput
    create: XOR<TutoringAppointmentCreateWithoutTeacherInput, TutoringAppointmentUncheckedCreateWithoutTeacherInput>
  }

  export type TutoringAppointmentCreateManyTeacherInputEnvelope = {
    data: TutoringAppointmentCreateManyTeacherInput | TutoringAppointmentCreateManyTeacherInput[]
    skipDuplicates?: boolean
  }

  export type TutoringAppointmentCreateWithoutStudentInput = {
    id?: string
    scheduledAt: Date | string
    duration: number
    notes?: string | null
    meetingLink?: string | null
    status?: $Enums.AppointmentStatus
    price: Decimal | DecimalJsLike | number | string
    request: TutoringRequestCreateNestedOneWithoutAppointmentInput
    session: TutoringSessionCreateNestedOneWithoutAppointmentsInput
    teacher: UserCreateNestedOneWithoutTutoringAppointmentsAsTeacherInput
  }

  export type TutoringAppointmentUncheckedCreateWithoutStudentInput = {
    id?: string
    requestId: string
    sessionId: string
    scheduledAt: Date | string
    duration: number
    notes?: string | null
    meetingLink?: string | null
    status?: $Enums.AppointmentStatus
    price: Decimal | DecimalJsLike | number | string
    teacherId: string
  }

  export type TutoringAppointmentCreateOrConnectWithoutStudentInput = {
    where: TutoringAppointmentWhereUniqueInput
    create: XOR<TutoringAppointmentCreateWithoutStudentInput, TutoringAppointmentUncheckedCreateWithoutStudentInput>
  }

  export type TutoringAppointmentCreateManyStudentInputEnvelope = {
    data: TutoringAppointmentCreateManyStudentInput | TutoringAppointmentCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type TutoringReviewCreateWithoutStudentInput = {
    id?: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
    session: TutoringSessionCreateNestedOneWithoutReviewsInput
  }

  export type TutoringReviewUncheckedCreateWithoutStudentInput = {
    id?: string
    sessionId: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
  }

  export type TutoringReviewCreateOrConnectWithoutStudentInput = {
    where: TutoringReviewWhereUniqueInput
    create: XOR<TutoringReviewCreateWithoutStudentInput, TutoringReviewUncheckedCreateWithoutStudentInput>
  }

  export type TutoringReviewCreateManyStudentInputEnvelope = {
    data: TutoringReviewCreateManyStudentInput | TutoringReviewCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type TutoringMessageCreateWithoutSenderInput = {
    id?: string
    message: string
    read?: boolean
    createdAt?: Date | string
    request: TutoringRequestCreateNestedOneWithoutMessagesInput
  }

  export type TutoringMessageUncheckedCreateWithoutSenderInput = {
    id?: string
    requestId: string
    message: string
    read?: boolean
    createdAt?: Date | string
  }

  export type TutoringMessageCreateOrConnectWithoutSenderInput = {
    where: TutoringMessageWhereUniqueInput
    create: XOR<TutoringMessageCreateWithoutSenderInput, TutoringMessageUncheckedCreateWithoutSenderInput>
  }

  export type TutoringMessageCreateManySenderInputEnvelope = {
    data: TutoringMessageCreateManySenderInput | TutoringMessageCreateManySenderInput[]
    skipDuplicates?: boolean
  }

  export type UserAchievementCreateWithoutUserInput = {
    id?: string
    completed?: boolean
    completedAt?: Date | string | null
    progress?: number
    achievement: AchievementCreateNestedOneWithoutUsersInput
  }

  export type UserAchievementUncheckedCreateWithoutUserInput = {
    id?: string
    achievementId: string
    completed?: boolean
    completedAt?: Date | string | null
    progress?: number
  }

  export type UserAchievementCreateOrConnectWithoutUserInput = {
    where: UserAchievementWhereUniqueInput
    create: XOR<UserAchievementCreateWithoutUserInput, UserAchievementUncheckedCreateWithoutUserInput>
  }

  export type UserAchievementCreateManyUserInputEnvelope = {
    data: UserAchievementCreateManyUserInput | UserAchievementCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CertificateCreateWithoutUserInput = {
    id?: string
    title: string
    issueDate?: Date | string
    type: string
    courseName?: string | null
    tutoringSubject?: string | null
    teacherId?: string | null
    teacherName?: string | null
    customMessage?: string | null
    imageUrl?: string | null
    course?: CourseCreateNestedOneWithoutCertificatesInput
    tutoring?: TutoringSessionCreateNestedOneWithoutCertificatesInput
    badge?: BadgeCreateNestedOneWithoutCertificatesInput
  }

  export type CertificateUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    issueDate?: Date | string
    type: string
    courseId?: string | null
    courseName?: string | null
    tutoringId?: string | null
    tutoringSubject?: string | null
    teacherId?: string | null
    teacherName?: string | null
    customMessage?: string | null
    imageUrl?: string | null
    badgeId?: string | null
  }

  export type CertificateCreateOrConnectWithoutUserInput = {
    where: CertificateWhereUniqueInput
    create: XOR<CertificateCreateWithoutUserInput, CertificateUncheckedCreateWithoutUserInput>
  }

  export type CertificateCreateManyUserInputEnvelope = {
    data: CertificateCreateManyUserInput | CertificateCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ConversationParticipantCreateWithoutUserInput = {
    conversation: ConversationCreateNestedOneWithoutParticipantsInput
  }

  export type ConversationParticipantUncheckedCreateWithoutUserInput = {
    conversationId: string
  }

  export type ConversationParticipantCreateOrConnectWithoutUserInput = {
    where: ConversationParticipantWhereUniqueInput
    create: XOR<ConversationParticipantCreateWithoutUserInput, ConversationParticipantUncheckedCreateWithoutUserInput>
  }

  export type ConversationParticipantCreateManyUserInputEnvelope = {
    data: ConversationParticipantCreateManyUserInput | ConversationParticipantCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutSenderInput = {
    id?: string
    content: string
    timestamp?: Date | string
    read?: boolean
    conversation: ConversationCreateNestedOneWithoutMessagesInput
    attachments?: AttachmentCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutSenderInput = {
    id?: string
    conversationId: string
    content: string
    timestamp?: Date | string
    read?: boolean
    attachments?: AttachmentUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutSenderInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageCreateManySenderInputEnvelope = {
    data: MessageCreateManySenderInput | MessageCreateManySenderInput[]
    skipDuplicates?: boolean
  }

  export type AttachmentCreateWithoutUserInput = {
    id?: string
    fileName: string
    fileUrl: string
    fileType: string
    fileSize: number
    message: MessageCreateNestedOneWithoutAttachmentsInput
  }

  export type AttachmentUncheckedCreateWithoutUserInput = {
    id?: string
    messageId: string
    fileName: string
    fileUrl: string
    fileType: string
    fileSize: number
  }

  export type AttachmentCreateOrConnectWithoutUserInput = {
    where: AttachmentWhereUniqueInput
    create: XOR<AttachmentCreateWithoutUserInput, AttachmentUncheckedCreateWithoutUserInput>
  }

  export type AttachmentCreateManyUserInputEnvelope = {
    data: AttachmentCreateManyUserInput | AttachmentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    title: string
    message: string
    read?: boolean
    type: $Enums.NotificationType
    link?: string | null
    createdAt?: Date | string
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    message: string
    read?: boolean
    type: $Enums.NotificationType
    link?: string | null
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserSubscriptionCreateWithoutUserInput = {
    id?: string
    startDate?: Date | string
    endDate: Date | string
    isActive?: boolean
    autoRenew?: boolean
    paymentMethod?: string | null
    lastPaymentDate?: Date | string | null
    plan: SubscriptionPlanCreateNestedOneWithoutUsersInput
  }

  export type UserSubscriptionUncheckedCreateWithoutUserInput = {
    id?: string
    planId: string
    startDate?: Date | string
    endDate: Date | string
    isActive?: boolean
    autoRenew?: boolean
    paymentMethod?: string | null
    lastPaymentDate?: Date | string | null
  }

  export type UserSubscriptionCreateOrConnectWithoutUserInput = {
    where: UserSubscriptionWhereUniqueInput
    create: XOR<UserSubscriptionCreateWithoutUserInput, UserSubscriptionUncheckedCreateWithoutUserInput>
  }

  export type UserSubscriptionCreateManyUserInputEnvelope = {
    data: UserSubscriptionCreateManyUserInput | UserSubscriptionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserBundleCreateWithoutUserInput = {
    id?: string
    purchaseDate?: Date | string
    bundle: CourseBundleCreateNestedOneWithoutOwnersInput
  }

  export type UserBundleUncheckedCreateWithoutUserInput = {
    id?: string
    bundleId: string
    purchaseDate?: Date | string
  }

  export type UserBundleCreateOrConnectWithoutUserInput = {
    where: UserBundleWhereUniqueInput
    create: XOR<UserBundleCreateWithoutUserInput, UserBundleUncheckedCreateWithoutUserInput>
  }

  export type UserBundleCreateManyUserInputEnvelope = {
    data: UserBundleCreateManyUserInput | UserBundleCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutUserInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    paymentMethod?: string | null
    status: $Enums.PaymentStatus
    referenceType: $Enums.PaymentReferenceType
    referenceId?: string | null
    transactionId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUncheckedCreateWithoutUserInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    paymentMethod?: string | null
    status: $Enums.PaymentStatus
    referenceType: $Enums.PaymentReferenceType
    referenceId?: string | null
    transactionId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutUserInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput>
  }

  export type PaymentCreateManyUserInputEnvelope = {
    data: PaymentCreateManyUserInput | PaymentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CalendarEventCreateWithoutUserInput = {
    id?: string
    title: string
    description?: string | null
    type: string
    startTime: Date | string
    endTime?: Date | string | null
    location?: string | null
    createdAt?: Date | string
    course?: CourseCreateNestedOneWithoutCalendarEventsInput
    lesson?: LessonCreateNestedOneWithoutCalendarEventsInput
    teacher?: UserCreateNestedOneWithoutEventsAsTeacherInput
    student?: UserCreateNestedOneWithoutEventsAsStudentInput
  }

  export type CalendarEventUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    description?: string | null
    type: string
    startTime: Date | string
    endTime?: Date | string | null
    courseId?: string | null
    lessonId?: string | null
    teacherId?: string | null
    studentId?: string | null
    location?: string | null
    createdAt?: Date | string
  }

  export type CalendarEventCreateOrConnectWithoutUserInput = {
    where: CalendarEventWhereUniqueInput
    create: XOR<CalendarEventCreateWithoutUserInput, CalendarEventUncheckedCreateWithoutUserInput>
  }

  export type CalendarEventCreateManyUserInputEnvelope = {
    data: CalendarEventCreateManyUserInput | CalendarEventCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CalendarEventCreateWithoutTeacherInput = {
    id?: string
    title: string
    description?: string | null
    type: string
    startTime: Date | string
    endTime?: Date | string | null
    location?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutCalendarEventsInput
    course?: CourseCreateNestedOneWithoutCalendarEventsInput
    lesson?: LessonCreateNestedOneWithoutCalendarEventsInput
    student?: UserCreateNestedOneWithoutEventsAsStudentInput
  }

  export type CalendarEventUncheckedCreateWithoutTeacherInput = {
    id?: string
    userId: string
    title: string
    description?: string | null
    type: string
    startTime: Date | string
    endTime?: Date | string | null
    courseId?: string | null
    lessonId?: string | null
    studentId?: string | null
    location?: string | null
    createdAt?: Date | string
  }

  export type CalendarEventCreateOrConnectWithoutTeacherInput = {
    where: CalendarEventWhereUniqueInput
    create: XOR<CalendarEventCreateWithoutTeacherInput, CalendarEventUncheckedCreateWithoutTeacherInput>
  }

  export type CalendarEventCreateManyTeacherInputEnvelope = {
    data: CalendarEventCreateManyTeacherInput | CalendarEventCreateManyTeacherInput[]
    skipDuplicates?: boolean
  }

  export type CalendarEventCreateWithoutStudentInput = {
    id?: string
    title: string
    description?: string | null
    type: string
    startTime: Date | string
    endTime?: Date | string | null
    location?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutCalendarEventsInput
    course?: CourseCreateNestedOneWithoutCalendarEventsInput
    lesson?: LessonCreateNestedOneWithoutCalendarEventsInput
    teacher?: UserCreateNestedOneWithoutEventsAsTeacherInput
  }

  export type CalendarEventUncheckedCreateWithoutStudentInput = {
    id?: string
    userId: string
    title: string
    description?: string | null
    type: string
    startTime: Date | string
    endTime?: Date | string | null
    courseId?: string | null
    lessonId?: string | null
    teacherId?: string | null
    location?: string | null
    createdAt?: Date | string
  }

  export type CalendarEventCreateOrConnectWithoutStudentInput = {
    where: CalendarEventWhereUniqueInput
    create: XOR<CalendarEventCreateWithoutStudentInput, CalendarEventUncheckedCreateWithoutStudentInput>
  }

  export type CalendarEventCreateManyStudentInputEnvelope = {
    data: CalendarEventCreateManyStudentInput | CalendarEventCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type BlogPostCreateWithoutAuthorInput = {
    id?: string
    title: string
    excerpt?: string | null
    content: string
    image?: string | null
    published?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    readTime?: number | null
    categories?: PostCategoryCreateNestedManyWithoutPostInput
    tags?: PostTagCreateNestedManyWithoutPostInput
    comments?: BlogCommentCreateNestedManyWithoutPostInput
  }

  export type BlogPostUncheckedCreateWithoutAuthorInput = {
    id?: string
    title: string
    excerpt?: string | null
    content: string
    image?: string | null
    published?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    readTime?: number | null
    categories?: PostCategoryUncheckedCreateNestedManyWithoutPostInput
    tags?: PostTagUncheckedCreateNestedManyWithoutPostInput
    comments?: BlogCommentUncheckedCreateNestedManyWithoutPostInput
  }

  export type BlogPostCreateOrConnectWithoutAuthorInput = {
    where: BlogPostWhereUniqueInput
    create: XOR<BlogPostCreateWithoutAuthorInput, BlogPostUncheckedCreateWithoutAuthorInput>
  }

  export type BlogPostCreateManyAuthorInputEnvelope = {
    data: BlogPostCreateManyAuthorInput | BlogPostCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type BlogCommentCreateWithoutUserInput = {
    id?: string
    content: string
    createdAt?: Date | string
    post: BlogPostCreateNestedOneWithoutCommentsInput
    parent?: BlogCommentCreateNestedOneWithoutRepliesInput
    replies?: BlogCommentCreateNestedManyWithoutParentInput
  }

  export type BlogCommentUncheckedCreateWithoutUserInput = {
    id?: string
    postId: string
    content: string
    createdAt?: Date | string
    parentId?: string | null
    replies?: BlogCommentUncheckedCreateNestedManyWithoutParentInput
  }

  export type BlogCommentCreateOrConnectWithoutUserInput = {
    where: BlogCommentWhereUniqueInput
    create: XOR<BlogCommentCreateWithoutUserInput, BlogCommentUncheckedCreateWithoutUserInput>
  }

  export type BlogCommentCreateManyUserInputEnvelope = {
    data: BlogCommentCreateManyUserInput | BlogCommentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AssignmentSubmissionCreateWithoutGradedByInput = {
    id?: string
    content?: string | null
    fileUrls?: AssignmentSubmissionCreatefileUrlsInput | string[]
    submittedAt?: Date | string
    score?: number | null
    feedback?: string | null
    gradedAt?: Date | string | null
    user: UserCreateNestedOneWithoutAssignmentSubsInput
    assignment: AssignmentCreateNestedOneWithoutSubmissionsInput
  }

  export type AssignmentSubmissionUncheckedCreateWithoutGradedByInput = {
    id?: string
    userId: string
    assignmentId: string
    content?: string | null
    fileUrls?: AssignmentSubmissionCreatefileUrlsInput | string[]
    submittedAt?: Date | string
    score?: number | null
    feedback?: string | null
    gradedAt?: Date | string | null
  }

  export type AssignmentSubmissionCreateOrConnectWithoutGradedByInput = {
    where: AssignmentSubmissionWhereUniqueInput
    create: XOR<AssignmentSubmissionCreateWithoutGradedByInput, AssignmentSubmissionUncheckedCreateWithoutGradedByInput>
  }

  export type AssignmentSubmissionCreateManyGradedByInputEnvelope = {
    data: AssignmentSubmissionCreateManyGradedByInput | AssignmentSubmissionCreateManyGradedByInput[]
    skipDuplicates?: boolean
  }

  export type ReferralCodeCreateWithoutUserInput = {
    id?: string
    code: string
    isActive?: boolean
    usageLimit?: number | null
    maxUses?: number | null
    pointsReward?: number
    isUserCode?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    uses?: ReferralUseCreateNestedManyWithoutReferralCodeInput
  }

  export type ReferralCodeUncheckedCreateWithoutUserInput = {
    id?: string
    code: string
    isActive?: boolean
    usageLimit?: number | null
    maxUses?: number | null
    pointsReward?: number
    isUserCode?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    uses?: ReferralUseUncheckedCreateNestedManyWithoutReferralCodeInput
  }

  export type ReferralCodeCreateOrConnectWithoutUserInput = {
    where: ReferralCodeWhereUniqueInput
    create: XOR<ReferralCodeCreateWithoutUserInput, ReferralCodeUncheckedCreateWithoutUserInput>
  }

  export type ReferralCodeCreateManyUserInputEnvelope = {
    data: ReferralCodeCreateManyUserInput | ReferralCodeCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ReferralUseCreateWithoutUserInput = {
    id?: string
    pointsAwarded?: number
    createdAt?: Date | string
    referralCode: ReferralCodeCreateNestedOneWithoutUsesInput
  }

  export type ReferralUseUncheckedCreateWithoutUserInput = {
    id?: string
    referralCodeId: string
    pointsAwarded?: number
    createdAt?: Date | string
  }

  export type ReferralUseCreateOrConnectWithoutUserInput = {
    where: ReferralUseWhereUniqueInput
    create: XOR<ReferralUseCreateWithoutUserInput, ReferralUseUncheckedCreateWithoutUserInput>
  }

  export type ReferralUseCreateManyUserInputEnvelope = {
    data: ReferralUseCreateManyUserInput | ReferralUseCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutReferralsInput = {
    update: XOR<UserUpdateWithoutReferralsInput, UserUncheckedUpdateWithoutReferralsInput>
    create: XOR<UserCreateWithoutReferralsInput, UserUncheckedCreateWithoutReferralsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReferralsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReferralsInput, UserUncheckedUpdateWithoutReferralsInput>
  }

  export type UserUpdateWithoutReferralsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: IntFieldUpdateOperationsInput | number
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referredBy?: UserUpdateOneWithoutReferralsNestedInput
    teacherProfile?: TeacherProfileUpdateOneWithoutUserNestedInput
    availability?: UserAvailabilityUpdateManyWithoutUserNestedInput
    pointsTransactions?: PointsTransactionUpdateManyWithoutUserNestedInput
    courses?: CourseUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    savedCourses?: SavedCourseUpdateManyWithoutUserNestedInput
    likedCourses?: LikedCourseUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutUserNestedInput
    assignmentSubs?: AssignmentSubmissionUpdateManyWithoutUserNestedInput
    courseReviews?: CourseReviewUpdateManyWithoutUserNestedInput
    tutoringSessions?: TutoringSessionUpdateManyWithoutTeacherNestedInput
    tutoringRequests?: TutoringRequestUpdateManyWithoutStudentNestedInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUpdateManyWithoutTeacherNestedInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUpdateManyWithoutStudentNestedInput
    tutoringReviews?: TutoringReviewUpdateManyWithoutStudentNestedInput
    tutoringMessages?: TutoringMessageUpdateManyWithoutSenderNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    conversationParts?: ConversationParticipantUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    attachments?: AttachmentUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    subscriptionRecords?: UserSubscriptionUpdateManyWithoutUserNestedInput
    bundlesOwned?: UserBundleUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUpdateManyWithoutUserNestedInput
    eventsAsTeacher?: CalendarEventUpdateManyWithoutTeacherNestedInput
    eventsAsStudent?: CalendarEventUpdateManyWithoutStudentNestedInput
    blogPosts?: BlogPostUpdateManyWithoutAuthorNestedInput
    blogComments?: BlogCommentUpdateManyWithoutUserNestedInput
    submissionsGraded?: AssignmentSubmissionUpdateManyWithoutGradedByNestedInput
    referralCodesOwned?: ReferralCodeUpdateManyWithoutUserNestedInput
    referralUsesGained?: ReferralUseUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReferralsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: IntFieldUpdateOperationsInput | number
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    teacherProfile?: TeacherProfileUncheckedUpdateOneWithoutUserNestedInput
    availability?: UserAvailabilityUncheckedUpdateManyWithoutUserNestedInput
    pointsTransactions?: PointsTransactionUncheckedUpdateManyWithoutUserNestedInput
    courses?: CourseUncheckedUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    savedCourses?: SavedCourseUncheckedUpdateManyWithoutUserNestedInput
    likedCourses?: LikedCourseUncheckedUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUncheckedUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    assignmentSubs?: AssignmentSubmissionUncheckedUpdateManyWithoutUserNestedInput
    courseReviews?: CourseReviewUncheckedUpdateManyWithoutUserNestedInput
    tutoringSessions?: TutoringSessionUncheckedUpdateManyWithoutTeacherNestedInput
    tutoringRequests?: TutoringRequestUncheckedUpdateManyWithoutStudentNestedInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUncheckedUpdateManyWithoutTeacherNestedInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUncheckedUpdateManyWithoutStudentNestedInput
    tutoringReviews?: TutoringReviewUncheckedUpdateManyWithoutStudentNestedInput
    tutoringMessages?: TutoringMessageUncheckedUpdateManyWithoutSenderNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    conversationParts?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    subscriptionRecords?: UserSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    bundlesOwned?: UserBundleUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUncheckedUpdateManyWithoutUserNestedInput
    eventsAsTeacher?: CalendarEventUncheckedUpdateManyWithoutTeacherNestedInput
    eventsAsStudent?: CalendarEventUncheckedUpdateManyWithoutStudentNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
    blogComments?: BlogCommentUncheckedUpdateManyWithoutUserNestedInput
    submissionsGraded?: AssignmentSubmissionUncheckedUpdateManyWithoutGradedByNestedInput
    referralCodesOwned?: ReferralCodeUncheckedUpdateManyWithoutUserNestedInput
    referralUsesGained?: ReferralUseUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithWhereUniqueWithoutReferredByInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutReferredByInput, UserUncheckedUpdateWithoutReferredByInput>
    create: XOR<UserCreateWithoutReferredByInput, UserUncheckedCreateWithoutReferredByInput>
  }

  export type UserUpdateWithWhereUniqueWithoutReferredByInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutReferredByInput, UserUncheckedUpdateWithoutReferredByInput>
  }

  export type UserUpdateManyWithWhereWithoutReferredByInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutReferredByInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    avatar?: StringNullableFilter<"User"> | string | null
    bio?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    points?: IntFilter<"User"> | number
    referralCode?: StringNullableFilter<"User"> | string | null
    referredById?: StringNullableFilter<"User"> | string | null
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
  }

  export type TeacherProfileUpsertWithoutUserInput = {
    update: XOR<TeacherProfileUpdateWithoutUserInput, TeacherProfileUncheckedUpdateWithoutUserInput>
    create: XOR<TeacherProfileCreateWithoutUserInput, TeacherProfileUncheckedCreateWithoutUserInput>
    where?: TeacherProfileWhereInput
  }

  export type TeacherProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: TeacherProfileWhereInput
    data: XOR<TeacherProfileUpdateWithoutUserInput, TeacherProfileUncheckedUpdateWithoutUserInput>
  }

  export type TeacherProfileUpdateWithoutUserInput = {
    specialization?: TeacherProfileUpdatespecializationInput | string[]
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    students?: IntFieldUpdateOperationsInput | number
    education?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    certificates?: TeacherProfileUpdatecertificatesInput | string[]
  }

  export type TeacherProfileUncheckedUpdateWithoutUserInput = {
    specialization?: TeacherProfileUpdatespecializationInput | string[]
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    students?: IntFieldUpdateOperationsInput | number
    education?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    certificates?: TeacherProfileUpdatecertificatesInput | string[]
  }

  export type UserAvailabilityUpsertWithWhereUniqueWithoutUserInput = {
    where: UserAvailabilityWhereUniqueInput
    update: XOR<UserAvailabilityUpdateWithoutUserInput, UserAvailabilityUncheckedUpdateWithoutUserInput>
    create: XOR<UserAvailabilityCreateWithoutUserInput, UserAvailabilityUncheckedCreateWithoutUserInput>
  }

  export type UserAvailabilityUpdateWithWhereUniqueWithoutUserInput = {
    where: UserAvailabilityWhereUniqueInput
    data: XOR<UserAvailabilityUpdateWithoutUserInput, UserAvailabilityUncheckedUpdateWithoutUserInput>
  }

  export type UserAvailabilityUpdateManyWithWhereWithoutUserInput = {
    where: UserAvailabilityScalarWhereInput
    data: XOR<UserAvailabilityUpdateManyMutationInput, UserAvailabilityUncheckedUpdateManyWithoutUserInput>
  }

  export type UserAvailabilityScalarWhereInput = {
    AND?: UserAvailabilityScalarWhereInput | UserAvailabilityScalarWhereInput[]
    OR?: UserAvailabilityScalarWhereInput[]
    NOT?: UserAvailabilityScalarWhereInput | UserAvailabilityScalarWhereInput[]
    id?: StringFilter<"UserAvailability"> | string
    userId?: StringFilter<"UserAvailability"> | string
    dayOfWeek?: IntFilter<"UserAvailability"> | number
    startTime?: DateTimeFilter<"UserAvailability"> | Date | string
    endTime?: DateTimeFilter<"UserAvailability"> | Date | string
  }

  export type PointsTransactionUpsertWithWhereUniqueWithoutUserInput = {
    where: PointsTransactionWhereUniqueInput
    update: XOR<PointsTransactionUpdateWithoutUserInput, PointsTransactionUncheckedUpdateWithoutUserInput>
    create: XOR<PointsTransactionCreateWithoutUserInput, PointsTransactionUncheckedCreateWithoutUserInput>
  }

  export type PointsTransactionUpdateWithWhereUniqueWithoutUserInput = {
    where: PointsTransactionWhereUniqueInput
    data: XOR<PointsTransactionUpdateWithoutUserInput, PointsTransactionUncheckedUpdateWithoutUserInput>
  }

  export type PointsTransactionUpdateManyWithWhereWithoutUserInput = {
    where: PointsTransactionScalarWhereInput
    data: XOR<PointsTransactionUpdateManyMutationInput, PointsTransactionUncheckedUpdateManyWithoutUserInput>
  }

  export type PointsTransactionScalarWhereInput = {
    AND?: PointsTransactionScalarWhereInput | PointsTransactionScalarWhereInput[]
    OR?: PointsTransactionScalarWhereInput[]
    NOT?: PointsTransactionScalarWhereInput | PointsTransactionScalarWhereInput[]
    id?: StringFilter<"PointsTransaction"> | string
    userId?: StringFilter<"PointsTransaction"> | string
    amount?: IntFilter<"PointsTransaction"> | number
    type?: EnumPointsTxnTypeFilter<"PointsTransaction"> | $Enums.PointsTxnType
    description?: StringNullableFilter<"PointsTransaction"> | string | null
    createdAt?: DateTimeFilter<"PointsTransaction"> | Date | string
  }

  export type CourseUpsertWithWhereUniqueWithoutTeacherInput = {
    where: CourseWhereUniqueInput
    update: XOR<CourseUpdateWithoutTeacherInput, CourseUncheckedUpdateWithoutTeacherInput>
    create: XOR<CourseCreateWithoutTeacherInput, CourseUncheckedCreateWithoutTeacherInput>
  }

  export type CourseUpdateWithWhereUniqueWithoutTeacherInput = {
    where: CourseWhereUniqueInput
    data: XOR<CourseUpdateWithoutTeacherInput, CourseUncheckedUpdateWithoutTeacherInput>
  }

  export type CourseUpdateManyWithWhereWithoutTeacherInput = {
    where: CourseScalarWhereInput
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyWithoutTeacherInput>
  }

  export type CourseScalarWhereInput = {
    AND?: CourseScalarWhereInput | CourseScalarWhereInput[]
    OR?: CourseScalarWhereInput[]
    NOT?: CourseScalarWhereInput | CourseScalarWhereInput[]
    id?: StringFilter<"Course"> | string
    title?: StringFilter<"Course"> | string
    description?: StringNullableFilter<"Course"> | string | null
    subject?: StringFilter<"Course"> | string
    image?: StringNullableFilter<"Course"> | string | null
    price?: DecimalFilter<"Course"> | Decimal | DecimalJsLike | number | string
    pointsPrice?: IntFilter<"Course"> | number
    teacherId?: StringFilter<"Course"> | string
    students?: IntFilter<"Course"> | number
    rating?: DecimalNullableFilter<"Course"> | Decimal | DecimalJsLike | number | string | null
    status?: EnumCourseStatusFilter<"Course"> | $Enums.CourseStatus
    featured?: BoolFilter<"Course"> | boolean
    createdAt?: DateTimeFilter<"Course"> | Date | string
    updatedAt?: DateTimeFilter<"Course"> | Date | string
  }

  export type EnrollmentUpsertWithWhereUniqueWithoutUserInput = {
    where: EnrollmentWhereUniqueInput
    update: XOR<EnrollmentUpdateWithoutUserInput, EnrollmentUncheckedUpdateWithoutUserInput>
    create: XOR<EnrollmentCreateWithoutUserInput, EnrollmentUncheckedCreateWithoutUserInput>
  }

  export type EnrollmentUpdateWithWhereUniqueWithoutUserInput = {
    where: EnrollmentWhereUniqueInput
    data: XOR<EnrollmentUpdateWithoutUserInput, EnrollmentUncheckedUpdateWithoutUserInput>
  }

  export type EnrollmentUpdateManyWithWhereWithoutUserInput = {
    where: EnrollmentScalarWhereInput
    data: XOR<EnrollmentUpdateManyMutationInput, EnrollmentUncheckedUpdateManyWithoutUserInput>
  }

  export type EnrollmentScalarWhereInput = {
    AND?: EnrollmentScalarWhereInput | EnrollmentScalarWhereInput[]
    OR?: EnrollmentScalarWhereInput[]
    NOT?: EnrollmentScalarWhereInput | EnrollmentScalarWhereInput[]
    id?: StringFilter<"Enrollment"> | string
    userId?: StringFilter<"Enrollment"> | string
    courseId?: StringFilter<"Enrollment"> | string
    enrolledAt?: DateTimeFilter<"Enrollment"> | Date | string
    completed?: BoolFilter<"Enrollment"> | boolean
    completedAt?: DateTimeNullableFilter<"Enrollment"> | Date | string | null
    status?: StringFilter<"Enrollment"> | string
  }

  export type SavedCourseUpsertWithWhereUniqueWithoutUserInput = {
    where: SavedCourseWhereUniqueInput
    update: XOR<SavedCourseUpdateWithoutUserInput, SavedCourseUncheckedUpdateWithoutUserInput>
    create: XOR<SavedCourseCreateWithoutUserInput, SavedCourseUncheckedCreateWithoutUserInput>
  }

  export type SavedCourseUpdateWithWhereUniqueWithoutUserInput = {
    where: SavedCourseWhereUniqueInput
    data: XOR<SavedCourseUpdateWithoutUserInput, SavedCourseUncheckedUpdateWithoutUserInput>
  }

  export type SavedCourseUpdateManyWithWhereWithoutUserInput = {
    where: SavedCourseScalarWhereInput
    data: XOR<SavedCourseUpdateManyMutationInput, SavedCourseUncheckedUpdateManyWithoutUserInput>
  }

  export type SavedCourseScalarWhereInput = {
    AND?: SavedCourseScalarWhereInput | SavedCourseScalarWhereInput[]
    OR?: SavedCourseScalarWhereInput[]
    NOT?: SavedCourseScalarWhereInput | SavedCourseScalarWhereInput[]
    id?: StringFilter<"SavedCourse"> | string
    userId?: StringFilter<"SavedCourse"> | string
    courseId?: StringFilter<"SavedCourse"> | string
    savedAt?: DateTimeFilter<"SavedCourse"> | Date | string
  }

  export type LikedCourseUpsertWithWhereUniqueWithoutUserInput = {
    where: LikedCourseWhereUniqueInput
    update: XOR<LikedCourseUpdateWithoutUserInput, LikedCourseUncheckedUpdateWithoutUserInput>
    create: XOR<LikedCourseCreateWithoutUserInput, LikedCourseUncheckedCreateWithoutUserInput>
  }

  export type LikedCourseUpdateWithWhereUniqueWithoutUserInput = {
    where: LikedCourseWhereUniqueInput
    data: XOR<LikedCourseUpdateWithoutUserInput, LikedCourseUncheckedUpdateWithoutUserInput>
  }

  export type LikedCourseUpdateManyWithWhereWithoutUserInput = {
    where: LikedCourseScalarWhereInput
    data: XOR<LikedCourseUpdateManyMutationInput, LikedCourseUncheckedUpdateManyWithoutUserInput>
  }

  export type LikedCourseScalarWhereInput = {
    AND?: LikedCourseScalarWhereInput | LikedCourseScalarWhereInput[]
    OR?: LikedCourseScalarWhereInput[]
    NOT?: LikedCourseScalarWhereInput | LikedCourseScalarWhereInput[]
    id?: StringFilter<"LikedCourse"> | string
    userId?: StringFilter<"LikedCourse"> | string
    courseId?: StringFilter<"LikedCourse"> | string
    likedAt?: DateTimeFilter<"LikedCourse"> | Date | string
  }

  export type LessonProgressUpsertWithWhereUniqueWithoutUserInput = {
    where: LessonProgressWhereUniqueInput
    update: XOR<LessonProgressUpdateWithoutUserInput, LessonProgressUncheckedUpdateWithoutUserInput>
    create: XOR<LessonProgressCreateWithoutUserInput, LessonProgressUncheckedCreateWithoutUserInput>
  }

  export type LessonProgressUpdateWithWhereUniqueWithoutUserInput = {
    where: LessonProgressWhereUniqueInput
    data: XOR<LessonProgressUpdateWithoutUserInput, LessonProgressUncheckedUpdateWithoutUserInput>
  }

  export type LessonProgressUpdateManyWithWhereWithoutUserInput = {
    where: LessonProgressScalarWhereInput
    data: XOR<LessonProgressUpdateManyMutationInput, LessonProgressUncheckedUpdateManyWithoutUserInput>
  }

  export type LessonProgressScalarWhereInput = {
    AND?: LessonProgressScalarWhereInput | LessonProgressScalarWhereInput[]
    OR?: LessonProgressScalarWhereInput[]
    NOT?: LessonProgressScalarWhereInput | LessonProgressScalarWhereInput[]
    id?: StringFilter<"LessonProgress"> | string
    userId?: StringFilter<"LessonProgress"> | string
    lessonId?: StringFilter<"LessonProgress"> | string
    completed?: BoolFilter<"LessonProgress"> | boolean
    completedAt?: DateTimeNullableFilter<"LessonProgress"> | Date | string | null
    lastPosition?: IntFilter<"LessonProgress"> | number
  }

  export type QuizAttemptUpsertWithWhereUniqueWithoutUserInput = {
    where: QuizAttemptWhereUniqueInput
    update: XOR<QuizAttemptUpdateWithoutUserInput, QuizAttemptUncheckedUpdateWithoutUserInput>
    create: XOR<QuizAttemptCreateWithoutUserInput, QuizAttemptUncheckedCreateWithoutUserInput>
  }

  export type QuizAttemptUpdateWithWhereUniqueWithoutUserInput = {
    where: QuizAttemptWhereUniqueInput
    data: XOR<QuizAttemptUpdateWithoutUserInput, QuizAttemptUncheckedUpdateWithoutUserInput>
  }

  export type QuizAttemptUpdateManyWithWhereWithoutUserInput = {
    where: QuizAttemptScalarWhereInput
    data: XOR<QuizAttemptUpdateManyMutationInput, QuizAttemptUncheckedUpdateManyWithoutUserInput>
  }

  export type QuizAttemptScalarWhereInput = {
    AND?: QuizAttemptScalarWhereInput | QuizAttemptScalarWhereInput[]
    OR?: QuizAttemptScalarWhereInput[]
    NOT?: QuizAttemptScalarWhereInput | QuizAttemptScalarWhereInput[]
    id?: StringFilter<"QuizAttempt"> | string
    userId?: StringFilter<"QuizAttempt"> | string
    quizId?: StringFilter<"QuizAttempt"> | string
    score?: IntFilter<"QuizAttempt"> | number
    duration?: IntNullableFilter<"QuizAttempt"> | number | null
    completedAt?: DateTimeFilter<"QuizAttempt"> | Date | string
    answers?: JsonFilter<"QuizAttempt">
    courseId?: StringNullableFilter<"QuizAttempt"> | string | null
  }

  export type AssignmentSubmissionUpsertWithWhereUniqueWithoutUserInput = {
    where: AssignmentSubmissionWhereUniqueInput
    update: XOR<AssignmentSubmissionUpdateWithoutUserInput, AssignmentSubmissionUncheckedUpdateWithoutUserInput>
    create: XOR<AssignmentSubmissionCreateWithoutUserInput, AssignmentSubmissionUncheckedCreateWithoutUserInput>
  }

  export type AssignmentSubmissionUpdateWithWhereUniqueWithoutUserInput = {
    where: AssignmentSubmissionWhereUniqueInput
    data: XOR<AssignmentSubmissionUpdateWithoutUserInput, AssignmentSubmissionUncheckedUpdateWithoutUserInput>
  }

  export type AssignmentSubmissionUpdateManyWithWhereWithoutUserInput = {
    where: AssignmentSubmissionScalarWhereInput
    data: XOR<AssignmentSubmissionUpdateManyMutationInput, AssignmentSubmissionUncheckedUpdateManyWithoutUserInput>
  }

  export type AssignmentSubmissionScalarWhereInput = {
    AND?: AssignmentSubmissionScalarWhereInput | AssignmentSubmissionScalarWhereInput[]
    OR?: AssignmentSubmissionScalarWhereInput[]
    NOT?: AssignmentSubmissionScalarWhereInput | AssignmentSubmissionScalarWhereInput[]
    id?: StringFilter<"AssignmentSubmission"> | string
    userId?: StringFilter<"AssignmentSubmission"> | string
    assignmentId?: StringFilter<"AssignmentSubmission"> | string
    content?: StringNullableFilter<"AssignmentSubmission"> | string | null
    fileUrls?: StringNullableListFilter<"AssignmentSubmission">
    submittedAt?: DateTimeFilter<"AssignmentSubmission"> | Date | string
    score?: IntNullableFilter<"AssignmentSubmission"> | number | null
    feedback?: StringNullableFilter<"AssignmentSubmission"> | string | null
    gradedAt?: DateTimeNullableFilter<"AssignmentSubmission"> | Date | string | null
    gradedById?: StringNullableFilter<"AssignmentSubmission"> | string | null
  }

  export type CourseReviewUpsertWithWhereUniqueWithoutUserInput = {
    where: CourseReviewWhereUniqueInput
    update: XOR<CourseReviewUpdateWithoutUserInput, CourseReviewUncheckedUpdateWithoutUserInput>
    create: XOR<CourseReviewCreateWithoutUserInput, CourseReviewUncheckedCreateWithoutUserInput>
  }

  export type CourseReviewUpdateWithWhereUniqueWithoutUserInput = {
    where: CourseReviewWhereUniqueInput
    data: XOR<CourseReviewUpdateWithoutUserInput, CourseReviewUncheckedUpdateWithoutUserInput>
  }

  export type CourseReviewUpdateManyWithWhereWithoutUserInput = {
    where: CourseReviewScalarWhereInput
    data: XOR<CourseReviewUpdateManyMutationInput, CourseReviewUncheckedUpdateManyWithoutUserInput>
  }

  export type CourseReviewScalarWhereInput = {
    AND?: CourseReviewScalarWhereInput | CourseReviewScalarWhereInput[]
    OR?: CourseReviewScalarWhereInput[]
    NOT?: CourseReviewScalarWhereInput | CourseReviewScalarWhereInput[]
    id?: StringFilter<"CourseReview"> | string
    userId?: StringFilter<"CourseReview"> | string
    courseId?: StringFilter<"CourseReview"> | string
    rating?: IntFilter<"CourseReview"> | number
    comment?: StringNullableFilter<"CourseReview"> | string | null
    createdAt?: DateTimeFilter<"CourseReview"> | Date | string
  }

  export type TutoringSessionUpsertWithWhereUniqueWithoutTeacherInput = {
    where: TutoringSessionWhereUniqueInput
    update: XOR<TutoringSessionUpdateWithoutTeacherInput, TutoringSessionUncheckedUpdateWithoutTeacherInput>
    create: XOR<TutoringSessionCreateWithoutTeacherInput, TutoringSessionUncheckedCreateWithoutTeacherInput>
  }

  export type TutoringSessionUpdateWithWhereUniqueWithoutTeacherInput = {
    where: TutoringSessionWhereUniqueInput
    data: XOR<TutoringSessionUpdateWithoutTeacherInput, TutoringSessionUncheckedUpdateWithoutTeacherInput>
  }

  export type TutoringSessionUpdateManyWithWhereWithoutTeacherInput = {
    where: TutoringSessionScalarWhereInput
    data: XOR<TutoringSessionUpdateManyMutationInput, TutoringSessionUncheckedUpdateManyWithoutTeacherInput>
  }

  export type TutoringSessionScalarWhereInput = {
    AND?: TutoringSessionScalarWhereInput | TutoringSessionScalarWhereInput[]
    OR?: TutoringSessionScalarWhereInput[]
    NOT?: TutoringSessionScalarWhereInput | TutoringSessionScalarWhereInput[]
    id?: StringFilter<"TutoringSession"> | string
    teacherId?: StringFilter<"TutoringSession"> | string
    subject?: StringFilter<"TutoringSession"> | string
    description?: StringNullableFilter<"TutoringSession"> | string | null
    pricePerHour?: DecimalFilter<"TutoringSession"> | Decimal | DecimalJsLike | number | string
    locationType?: EnumTutoringLocationTypeFilter<"TutoringSession"> | $Enums.TutoringLocationType
    status?: EnumTutoringStatusFilter<"TutoringSession"> | $Enums.TutoringStatus
    createdAt?: DateTimeFilter<"TutoringSession"> | Date | string
    updatedAt?: DateTimeFilter<"TutoringSession"> | Date | string
    maxStudents?: IntFilter<"TutoringSession"> | number
    prerequisites?: StringNullableListFilter<"TutoringSession">
    level?: StringNullableFilter<"TutoringSession"> | string | null
    tags?: StringNullableListFilter<"TutoringSession">
    featured?: BoolFilter<"TutoringSession"> | boolean
  }

  export type TutoringRequestUpsertWithWhereUniqueWithoutStudentInput = {
    where: TutoringRequestWhereUniqueInput
    update: XOR<TutoringRequestUpdateWithoutStudentInput, TutoringRequestUncheckedUpdateWithoutStudentInput>
    create: XOR<TutoringRequestCreateWithoutStudentInput, TutoringRequestUncheckedCreateWithoutStudentInput>
  }

  export type TutoringRequestUpdateWithWhereUniqueWithoutStudentInput = {
    where: TutoringRequestWhereUniqueInput
    data: XOR<TutoringRequestUpdateWithoutStudentInput, TutoringRequestUncheckedUpdateWithoutStudentInput>
  }

  export type TutoringRequestUpdateManyWithWhereWithoutStudentInput = {
    where: TutoringRequestScalarWhereInput
    data: XOR<TutoringRequestUpdateManyMutationInput, TutoringRequestUncheckedUpdateManyWithoutStudentInput>
  }

  export type TutoringRequestScalarWhereInput = {
    AND?: TutoringRequestScalarWhereInput | TutoringRequestScalarWhereInput[]
    OR?: TutoringRequestScalarWhereInput[]
    NOT?: TutoringRequestScalarWhereInput | TutoringRequestScalarWhereInput[]
    id?: StringFilter<"TutoringRequest"> | string
    sessionId?: StringFilter<"TutoringRequest"> | string
    studentId?: StringFilter<"TutoringRequest"> | string
    message?: StringNullableFilter<"TutoringRequest"> | string | null
    preferredDates?: DateTimeNullableListFilter<"TutoringRequest">
    status?: EnumTutoringRequestStatusFilter<"TutoringRequest"> | $Enums.TutoringRequestStatus
    createdAt?: DateTimeFilter<"TutoringRequest"> | Date | string
    updatedAt?: DateTimeFilter<"TutoringRequest"> | Date | string
  }

  export type TutoringAppointmentUpsertWithWhereUniqueWithoutTeacherInput = {
    where: TutoringAppointmentWhereUniqueInput
    update: XOR<TutoringAppointmentUpdateWithoutTeacherInput, TutoringAppointmentUncheckedUpdateWithoutTeacherInput>
    create: XOR<TutoringAppointmentCreateWithoutTeacherInput, TutoringAppointmentUncheckedCreateWithoutTeacherInput>
  }

  export type TutoringAppointmentUpdateWithWhereUniqueWithoutTeacherInput = {
    where: TutoringAppointmentWhereUniqueInput
    data: XOR<TutoringAppointmentUpdateWithoutTeacherInput, TutoringAppointmentUncheckedUpdateWithoutTeacherInput>
  }

  export type TutoringAppointmentUpdateManyWithWhereWithoutTeacherInput = {
    where: TutoringAppointmentScalarWhereInput
    data: XOR<TutoringAppointmentUpdateManyMutationInput, TutoringAppointmentUncheckedUpdateManyWithoutTeacherInput>
  }

  export type TutoringAppointmentScalarWhereInput = {
    AND?: TutoringAppointmentScalarWhereInput | TutoringAppointmentScalarWhereInput[]
    OR?: TutoringAppointmentScalarWhereInput[]
    NOT?: TutoringAppointmentScalarWhereInput | TutoringAppointmentScalarWhereInput[]
    id?: StringFilter<"TutoringAppointment"> | string
    requestId?: StringFilter<"TutoringAppointment"> | string
    sessionId?: StringFilter<"TutoringAppointment"> | string
    scheduledAt?: DateTimeFilter<"TutoringAppointment"> | Date | string
    duration?: IntFilter<"TutoringAppointment"> | number
    notes?: StringNullableFilter<"TutoringAppointment"> | string | null
    meetingLink?: StringNullableFilter<"TutoringAppointment"> | string | null
    status?: EnumAppointmentStatusFilter<"TutoringAppointment"> | $Enums.AppointmentStatus
    price?: DecimalFilter<"TutoringAppointment"> | Decimal | DecimalJsLike | number | string
    teacherId?: StringFilter<"TutoringAppointment"> | string
    studentId?: StringFilter<"TutoringAppointment"> | string
  }

  export type TutoringAppointmentUpsertWithWhereUniqueWithoutStudentInput = {
    where: TutoringAppointmentWhereUniqueInput
    update: XOR<TutoringAppointmentUpdateWithoutStudentInput, TutoringAppointmentUncheckedUpdateWithoutStudentInput>
    create: XOR<TutoringAppointmentCreateWithoutStudentInput, TutoringAppointmentUncheckedCreateWithoutStudentInput>
  }

  export type TutoringAppointmentUpdateWithWhereUniqueWithoutStudentInput = {
    where: TutoringAppointmentWhereUniqueInput
    data: XOR<TutoringAppointmentUpdateWithoutStudentInput, TutoringAppointmentUncheckedUpdateWithoutStudentInput>
  }

  export type TutoringAppointmentUpdateManyWithWhereWithoutStudentInput = {
    where: TutoringAppointmentScalarWhereInput
    data: XOR<TutoringAppointmentUpdateManyMutationInput, TutoringAppointmentUncheckedUpdateManyWithoutStudentInput>
  }

  export type TutoringReviewUpsertWithWhereUniqueWithoutStudentInput = {
    where: TutoringReviewWhereUniqueInput
    update: XOR<TutoringReviewUpdateWithoutStudentInput, TutoringReviewUncheckedUpdateWithoutStudentInput>
    create: XOR<TutoringReviewCreateWithoutStudentInput, TutoringReviewUncheckedCreateWithoutStudentInput>
  }

  export type TutoringReviewUpdateWithWhereUniqueWithoutStudentInput = {
    where: TutoringReviewWhereUniqueInput
    data: XOR<TutoringReviewUpdateWithoutStudentInput, TutoringReviewUncheckedUpdateWithoutStudentInput>
  }

  export type TutoringReviewUpdateManyWithWhereWithoutStudentInput = {
    where: TutoringReviewScalarWhereInput
    data: XOR<TutoringReviewUpdateManyMutationInput, TutoringReviewUncheckedUpdateManyWithoutStudentInput>
  }

  export type TutoringReviewScalarWhereInput = {
    AND?: TutoringReviewScalarWhereInput | TutoringReviewScalarWhereInput[]
    OR?: TutoringReviewScalarWhereInput[]
    NOT?: TutoringReviewScalarWhereInput | TutoringReviewScalarWhereInput[]
    id?: StringFilter<"TutoringReview"> | string
    sessionId?: StringFilter<"TutoringReview"> | string
    studentId?: StringFilter<"TutoringReview"> | string
    rating?: IntFilter<"TutoringReview"> | number
    comment?: StringNullableFilter<"TutoringReview"> | string | null
    createdAt?: DateTimeFilter<"TutoringReview"> | Date | string
  }

  export type TutoringMessageUpsertWithWhereUniqueWithoutSenderInput = {
    where: TutoringMessageWhereUniqueInput
    update: XOR<TutoringMessageUpdateWithoutSenderInput, TutoringMessageUncheckedUpdateWithoutSenderInput>
    create: XOR<TutoringMessageCreateWithoutSenderInput, TutoringMessageUncheckedCreateWithoutSenderInput>
  }

  export type TutoringMessageUpdateWithWhereUniqueWithoutSenderInput = {
    where: TutoringMessageWhereUniqueInput
    data: XOR<TutoringMessageUpdateWithoutSenderInput, TutoringMessageUncheckedUpdateWithoutSenderInput>
  }

  export type TutoringMessageUpdateManyWithWhereWithoutSenderInput = {
    where: TutoringMessageScalarWhereInput
    data: XOR<TutoringMessageUpdateManyMutationInput, TutoringMessageUncheckedUpdateManyWithoutSenderInput>
  }

  export type TutoringMessageScalarWhereInput = {
    AND?: TutoringMessageScalarWhereInput | TutoringMessageScalarWhereInput[]
    OR?: TutoringMessageScalarWhereInput[]
    NOT?: TutoringMessageScalarWhereInput | TutoringMessageScalarWhereInput[]
    id?: StringFilter<"TutoringMessage"> | string
    requestId?: StringFilter<"TutoringMessage"> | string
    senderId?: StringFilter<"TutoringMessage"> | string
    message?: StringFilter<"TutoringMessage"> | string
    read?: BoolFilter<"TutoringMessage"> | boolean
    createdAt?: DateTimeFilter<"TutoringMessage"> | Date | string
  }

  export type UserAchievementUpsertWithWhereUniqueWithoutUserInput = {
    where: UserAchievementWhereUniqueInput
    update: XOR<UserAchievementUpdateWithoutUserInput, UserAchievementUncheckedUpdateWithoutUserInput>
    create: XOR<UserAchievementCreateWithoutUserInput, UserAchievementUncheckedCreateWithoutUserInput>
  }

  export type UserAchievementUpdateWithWhereUniqueWithoutUserInput = {
    where: UserAchievementWhereUniqueInput
    data: XOR<UserAchievementUpdateWithoutUserInput, UserAchievementUncheckedUpdateWithoutUserInput>
  }

  export type UserAchievementUpdateManyWithWhereWithoutUserInput = {
    where: UserAchievementScalarWhereInput
    data: XOR<UserAchievementUpdateManyMutationInput, UserAchievementUncheckedUpdateManyWithoutUserInput>
  }

  export type UserAchievementScalarWhereInput = {
    AND?: UserAchievementScalarWhereInput | UserAchievementScalarWhereInput[]
    OR?: UserAchievementScalarWhereInput[]
    NOT?: UserAchievementScalarWhereInput | UserAchievementScalarWhereInput[]
    id?: StringFilter<"UserAchievement"> | string
    userId?: StringFilter<"UserAchievement"> | string
    achievementId?: StringFilter<"UserAchievement"> | string
    completed?: BoolFilter<"UserAchievement"> | boolean
    completedAt?: DateTimeNullableFilter<"UserAchievement"> | Date | string | null
    progress?: IntFilter<"UserAchievement"> | number
  }

  export type CertificateUpsertWithWhereUniqueWithoutUserInput = {
    where: CertificateWhereUniqueInput
    update: XOR<CertificateUpdateWithoutUserInput, CertificateUncheckedUpdateWithoutUserInput>
    create: XOR<CertificateCreateWithoutUserInput, CertificateUncheckedCreateWithoutUserInput>
  }

  export type CertificateUpdateWithWhereUniqueWithoutUserInput = {
    where: CertificateWhereUniqueInput
    data: XOR<CertificateUpdateWithoutUserInput, CertificateUncheckedUpdateWithoutUserInput>
  }

  export type CertificateUpdateManyWithWhereWithoutUserInput = {
    where: CertificateScalarWhereInput
    data: XOR<CertificateUpdateManyMutationInput, CertificateUncheckedUpdateManyWithoutUserInput>
  }

  export type CertificateScalarWhereInput = {
    AND?: CertificateScalarWhereInput | CertificateScalarWhereInput[]
    OR?: CertificateScalarWhereInput[]
    NOT?: CertificateScalarWhereInput | CertificateScalarWhereInput[]
    id?: StringFilter<"Certificate"> | string
    userId?: StringFilter<"Certificate"> | string
    title?: StringFilter<"Certificate"> | string
    issueDate?: DateTimeFilter<"Certificate"> | Date | string
    type?: StringFilter<"Certificate"> | string
    courseId?: StringNullableFilter<"Certificate"> | string | null
    courseName?: StringNullableFilter<"Certificate"> | string | null
    tutoringId?: StringNullableFilter<"Certificate"> | string | null
    tutoringSubject?: StringNullableFilter<"Certificate"> | string | null
    teacherId?: StringNullableFilter<"Certificate"> | string | null
    teacherName?: StringNullableFilter<"Certificate"> | string | null
    customMessage?: StringNullableFilter<"Certificate"> | string | null
    imageUrl?: StringNullableFilter<"Certificate"> | string | null
    badgeId?: StringNullableFilter<"Certificate"> | string | null
  }

  export type ConversationParticipantUpsertWithWhereUniqueWithoutUserInput = {
    where: ConversationParticipantWhereUniqueInput
    update: XOR<ConversationParticipantUpdateWithoutUserInput, ConversationParticipantUncheckedUpdateWithoutUserInput>
    create: XOR<ConversationParticipantCreateWithoutUserInput, ConversationParticipantUncheckedCreateWithoutUserInput>
  }

  export type ConversationParticipantUpdateWithWhereUniqueWithoutUserInput = {
    where: ConversationParticipantWhereUniqueInput
    data: XOR<ConversationParticipantUpdateWithoutUserInput, ConversationParticipantUncheckedUpdateWithoutUserInput>
  }

  export type ConversationParticipantUpdateManyWithWhereWithoutUserInput = {
    where: ConversationParticipantScalarWhereInput
    data: XOR<ConversationParticipantUpdateManyMutationInput, ConversationParticipantUncheckedUpdateManyWithoutUserInput>
  }

  export type ConversationParticipantScalarWhereInput = {
    AND?: ConversationParticipantScalarWhereInput | ConversationParticipantScalarWhereInput[]
    OR?: ConversationParticipantScalarWhereInput[]
    NOT?: ConversationParticipantScalarWhereInput | ConversationParticipantScalarWhereInput[]
    conversationId?: StringFilter<"ConversationParticipant"> | string
    userId?: StringFilter<"ConversationParticipant"> | string
  }

  export type MessageUpsertWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
  }

  export type MessageUpdateManyWithWhereWithoutSenderInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutSenderInput>
  }

  export type MessageScalarWhereInput = {
    AND?: MessageScalarWhereInput | MessageScalarWhereInput[]
    OR?: MessageScalarWhereInput[]
    NOT?: MessageScalarWhereInput | MessageScalarWhereInput[]
    id?: StringFilter<"Message"> | string
    conversationId?: StringFilter<"Message"> | string
    senderId?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    timestamp?: DateTimeFilter<"Message"> | Date | string
    read?: BoolFilter<"Message"> | boolean
  }

  export type AttachmentUpsertWithWhereUniqueWithoutUserInput = {
    where: AttachmentWhereUniqueInput
    update: XOR<AttachmentUpdateWithoutUserInput, AttachmentUncheckedUpdateWithoutUserInput>
    create: XOR<AttachmentCreateWithoutUserInput, AttachmentUncheckedCreateWithoutUserInput>
  }

  export type AttachmentUpdateWithWhereUniqueWithoutUserInput = {
    where: AttachmentWhereUniqueInput
    data: XOR<AttachmentUpdateWithoutUserInput, AttachmentUncheckedUpdateWithoutUserInput>
  }

  export type AttachmentUpdateManyWithWhereWithoutUserInput = {
    where: AttachmentScalarWhereInput
    data: XOR<AttachmentUpdateManyMutationInput, AttachmentUncheckedUpdateManyWithoutUserInput>
  }

  export type AttachmentScalarWhereInput = {
    AND?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
    OR?: AttachmentScalarWhereInput[]
    NOT?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
    id?: StringFilter<"Attachment"> | string
    messageId?: StringFilter<"Attachment"> | string
    userId?: StringNullableFilter<"Attachment"> | string | null
    fileName?: StringFilter<"Attachment"> | string
    fileUrl?: StringFilter<"Attachment"> | string
    fileType?: StringFilter<"Attachment"> | string
    fileSize?: IntFilter<"Attachment"> | number
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    read?: BoolFilter<"Notification"> | boolean
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    link?: StringNullableFilter<"Notification"> | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type UserSubscriptionUpsertWithWhereUniqueWithoutUserInput = {
    where: UserSubscriptionWhereUniqueInput
    update: XOR<UserSubscriptionUpdateWithoutUserInput, UserSubscriptionUncheckedUpdateWithoutUserInput>
    create: XOR<UserSubscriptionCreateWithoutUserInput, UserSubscriptionUncheckedCreateWithoutUserInput>
  }

  export type UserSubscriptionUpdateWithWhereUniqueWithoutUserInput = {
    where: UserSubscriptionWhereUniqueInput
    data: XOR<UserSubscriptionUpdateWithoutUserInput, UserSubscriptionUncheckedUpdateWithoutUserInput>
  }

  export type UserSubscriptionUpdateManyWithWhereWithoutUserInput = {
    where: UserSubscriptionScalarWhereInput
    data: XOR<UserSubscriptionUpdateManyMutationInput, UserSubscriptionUncheckedUpdateManyWithoutUserInput>
  }

  export type UserSubscriptionScalarWhereInput = {
    AND?: UserSubscriptionScalarWhereInput | UserSubscriptionScalarWhereInput[]
    OR?: UserSubscriptionScalarWhereInput[]
    NOT?: UserSubscriptionScalarWhereInput | UserSubscriptionScalarWhereInput[]
    id?: StringFilter<"UserSubscription"> | string
    userId?: StringFilter<"UserSubscription"> | string
    planId?: StringFilter<"UserSubscription"> | string
    startDate?: DateTimeFilter<"UserSubscription"> | Date | string
    endDate?: DateTimeFilter<"UserSubscription"> | Date | string
    isActive?: BoolFilter<"UserSubscription"> | boolean
    autoRenew?: BoolFilter<"UserSubscription"> | boolean
    paymentMethod?: StringNullableFilter<"UserSubscription"> | string | null
    lastPaymentDate?: DateTimeNullableFilter<"UserSubscription"> | Date | string | null
  }

  export type UserBundleUpsertWithWhereUniqueWithoutUserInput = {
    where: UserBundleWhereUniqueInput
    update: XOR<UserBundleUpdateWithoutUserInput, UserBundleUncheckedUpdateWithoutUserInput>
    create: XOR<UserBundleCreateWithoutUserInput, UserBundleUncheckedCreateWithoutUserInput>
  }

  export type UserBundleUpdateWithWhereUniqueWithoutUserInput = {
    where: UserBundleWhereUniqueInput
    data: XOR<UserBundleUpdateWithoutUserInput, UserBundleUncheckedUpdateWithoutUserInput>
  }

  export type UserBundleUpdateManyWithWhereWithoutUserInput = {
    where: UserBundleScalarWhereInput
    data: XOR<UserBundleUpdateManyMutationInput, UserBundleUncheckedUpdateManyWithoutUserInput>
  }

  export type UserBundleScalarWhereInput = {
    AND?: UserBundleScalarWhereInput | UserBundleScalarWhereInput[]
    OR?: UserBundleScalarWhereInput[]
    NOT?: UserBundleScalarWhereInput | UserBundleScalarWhereInput[]
    id?: StringFilter<"UserBundle"> | string
    userId?: StringFilter<"UserBundle"> | string
    bundleId?: StringFilter<"UserBundle"> | string
    purchaseDate?: DateTimeFilter<"UserBundle"> | Date | string
  }

  export type PaymentUpsertWithWhereUniqueWithoutUserInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutUserInput, PaymentUncheckedUpdateWithoutUserInput>
    create: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutUserInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutUserInput, PaymentUncheckedUpdateWithoutUserInput>
  }

  export type PaymentUpdateManyWithWhereWithoutUserInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutUserInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: StringFilter<"Payment"> | string
    userId?: StringFilter<"Payment"> | string
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Payment"> | string
    paymentMethod?: StringNullableFilter<"Payment"> | string | null
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    referenceType?: EnumPaymentReferenceTypeFilter<"Payment"> | $Enums.PaymentReferenceType
    referenceId?: StringNullableFilter<"Payment"> | string | null
    transactionId?: StringNullableFilter<"Payment"> | string | null
    metadata?: JsonNullableFilter<"Payment">
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
  }

  export type CalendarEventUpsertWithWhereUniqueWithoutUserInput = {
    where: CalendarEventWhereUniqueInput
    update: XOR<CalendarEventUpdateWithoutUserInput, CalendarEventUncheckedUpdateWithoutUserInput>
    create: XOR<CalendarEventCreateWithoutUserInput, CalendarEventUncheckedCreateWithoutUserInput>
  }

  export type CalendarEventUpdateWithWhereUniqueWithoutUserInput = {
    where: CalendarEventWhereUniqueInput
    data: XOR<CalendarEventUpdateWithoutUserInput, CalendarEventUncheckedUpdateWithoutUserInput>
  }

  export type CalendarEventUpdateManyWithWhereWithoutUserInput = {
    where: CalendarEventScalarWhereInput
    data: XOR<CalendarEventUpdateManyMutationInput, CalendarEventUncheckedUpdateManyWithoutUserInput>
  }

  export type CalendarEventScalarWhereInput = {
    AND?: CalendarEventScalarWhereInput | CalendarEventScalarWhereInput[]
    OR?: CalendarEventScalarWhereInput[]
    NOT?: CalendarEventScalarWhereInput | CalendarEventScalarWhereInput[]
    id?: StringFilter<"CalendarEvent"> | string
    userId?: StringFilter<"CalendarEvent"> | string
    title?: StringFilter<"CalendarEvent"> | string
    description?: StringNullableFilter<"CalendarEvent"> | string | null
    type?: StringFilter<"CalendarEvent"> | string
    startTime?: DateTimeFilter<"CalendarEvent"> | Date | string
    endTime?: DateTimeNullableFilter<"CalendarEvent"> | Date | string | null
    courseId?: StringNullableFilter<"CalendarEvent"> | string | null
    lessonId?: StringNullableFilter<"CalendarEvent"> | string | null
    teacherId?: StringNullableFilter<"CalendarEvent"> | string | null
    studentId?: StringNullableFilter<"CalendarEvent"> | string | null
    location?: StringNullableFilter<"CalendarEvent"> | string | null
    createdAt?: DateTimeFilter<"CalendarEvent"> | Date | string
  }

  export type CalendarEventUpsertWithWhereUniqueWithoutTeacherInput = {
    where: CalendarEventWhereUniqueInput
    update: XOR<CalendarEventUpdateWithoutTeacherInput, CalendarEventUncheckedUpdateWithoutTeacherInput>
    create: XOR<CalendarEventCreateWithoutTeacherInput, CalendarEventUncheckedCreateWithoutTeacherInput>
  }

  export type CalendarEventUpdateWithWhereUniqueWithoutTeacherInput = {
    where: CalendarEventWhereUniqueInput
    data: XOR<CalendarEventUpdateWithoutTeacherInput, CalendarEventUncheckedUpdateWithoutTeacherInput>
  }

  export type CalendarEventUpdateManyWithWhereWithoutTeacherInput = {
    where: CalendarEventScalarWhereInput
    data: XOR<CalendarEventUpdateManyMutationInput, CalendarEventUncheckedUpdateManyWithoutTeacherInput>
  }

  export type CalendarEventUpsertWithWhereUniqueWithoutStudentInput = {
    where: CalendarEventWhereUniqueInput
    update: XOR<CalendarEventUpdateWithoutStudentInput, CalendarEventUncheckedUpdateWithoutStudentInput>
    create: XOR<CalendarEventCreateWithoutStudentInput, CalendarEventUncheckedCreateWithoutStudentInput>
  }

  export type CalendarEventUpdateWithWhereUniqueWithoutStudentInput = {
    where: CalendarEventWhereUniqueInput
    data: XOR<CalendarEventUpdateWithoutStudentInput, CalendarEventUncheckedUpdateWithoutStudentInput>
  }

  export type CalendarEventUpdateManyWithWhereWithoutStudentInput = {
    where: CalendarEventScalarWhereInput
    data: XOR<CalendarEventUpdateManyMutationInput, CalendarEventUncheckedUpdateManyWithoutStudentInput>
  }

  export type BlogPostUpsertWithWhereUniqueWithoutAuthorInput = {
    where: BlogPostWhereUniqueInput
    update: XOR<BlogPostUpdateWithoutAuthorInput, BlogPostUncheckedUpdateWithoutAuthorInput>
    create: XOR<BlogPostCreateWithoutAuthorInput, BlogPostUncheckedCreateWithoutAuthorInput>
  }

  export type BlogPostUpdateWithWhereUniqueWithoutAuthorInput = {
    where: BlogPostWhereUniqueInput
    data: XOR<BlogPostUpdateWithoutAuthorInput, BlogPostUncheckedUpdateWithoutAuthorInput>
  }

  export type BlogPostUpdateManyWithWhereWithoutAuthorInput = {
    where: BlogPostScalarWhereInput
    data: XOR<BlogPostUpdateManyMutationInput, BlogPostUncheckedUpdateManyWithoutAuthorInput>
  }

  export type BlogPostScalarWhereInput = {
    AND?: BlogPostScalarWhereInput | BlogPostScalarWhereInput[]
    OR?: BlogPostScalarWhereInput[]
    NOT?: BlogPostScalarWhereInput | BlogPostScalarWhereInput[]
    id?: StringFilter<"BlogPost"> | string
    title?: StringFilter<"BlogPost"> | string
    excerpt?: StringNullableFilter<"BlogPost"> | string | null
    content?: StringFilter<"BlogPost"> | string
    image?: StringNullableFilter<"BlogPost"> | string | null
    authorId?: StringFilter<"BlogPost"> | string
    published?: BoolFilter<"BlogPost"> | boolean
    publishedAt?: DateTimeNullableFilter<"BlogPost"> | Date | string | null
    createdAt?: DateTimeFilter<"BlogPost"> | Date | string
    updatedAt?: DateTimeFilter<"BlogPost"> | Date | string
    readTime?: IntNullableFilter<"BlogPost"> | number | null
  }

  export type BlogCommentUpsertWithWhereUniqueWithoutUserInput = {
    where: BlogCommentWhereUniqueInput
    update: XOR<BlogCommentUpdateWithoutUserInput, BlogCommentUncheckedUpdateWithoutUserInput>
    create: XOR<BlogCommentCreateWithoutUserInput, BlogCommentUncheckedCreateWithoutUserInput>
  }

  export type BlogCommentUpdateWithWhereUniqueWithoutUserInput = {
    where: BlogCommentWhereUniqueInput
    data: XOR<BlogCommentUpdateWithoutUserInput, BlogCommentUncheckedUpdateWithoutUserInput>
  }

  export type BlogCommentUpdateManyWithWhereWithoutUserInput = {
    where: BlogCommentScalarWhereInput
    data: XOR<BlogCommentUpdateManyMutationInput, BlogCommentUncheckedUpdateManyWithoutUserInput>
  }

  export type BlogCommentScalarWhereInput = {
    AND?: BlogCommentScalarWhereInput | BlogCommentScalarWhereInput[]
    OR?: BlogCommentScalarWhereInput[]
    NOT?: BlogCommentScalarWhereInput | BlogCommentScalarWhereInput[]
    id?: StringFilter<"BlogComment"> | string
    postId?: StringFilter<"BlogComment"> | string
    userId?: StringFilter<"BlogComment"> | string
    content?: StringFilter<"BlogComment"> | string
    createdAt?: DateTimeFilter<"BlogComment"> | Date | string
    parentId?: StringNullableFilter<"BlogComment"> | string | null
  }

  export type AssignmentSubmissionUpsertWithWhereUniqueWithoutGradedByInput = {
    where: AssignmentSubmissionWhereUniqueInput
    update: XOR<AssignmentSubmissionUpdateWithoutGradedByInput, AssignmentSubmissionUncheckedUpdateWithoutGradedByInput>
    create: XOR<AssignmentSubmissionCreateWithoutGradedByInput, AssignmentSubmissionUncheckedCreateWithoutGradedByInput>
  }

  export type AssignmentSubmissionUpdateWithWhereUniqueWithoutGradedByInput = {
    where: AssignmentSubmissionWhereUniqueInput
    data: XOR<AssignmentSubmissionUpdateWithoutGradedByInput, AssignmentSubmissionUncheckedUpdateWithoutGradedByInput>
  }

  export type AssignmentSubmissionUpdateManyWithWhereWithoutGradedByInput = {
    where: AssignmentSubmissionScalarWhereInput
    data: XOR<AssignmentSubmissionUpdateManyMutationInput, AssignmentSubmissionUncheckedUpdateManyWithoutGradedByInput>
  }

  export type ReferralCodeUpsertWithWhereUniqueWithoutUserInput = {
    where: ReferralCodeWhereUniqueInput
    update: XOR<ReferralCodeUpdateWithoutUserInput, ReferralCodeUncheckedUpdateWithoutUserInput>
    create: XOR<ReferralCodeCreateWithoutUserInput, ReferralCodeUncheckedCreateWithoutUserInput>
  }

  export type ReferralCodeUpdateWithWhereUniqueWithoutUserInput = {
    where: ReferralCodeWhereUniqueInput
    data: XOR<ReferralCodeUpdateWithoutUserInput, ReferralCodeUncheckedUpdateWithoutUserInput>
  }

  export type ReferralCodeUpdateManyWithWhereWithoutUserInput = {
    where: ReferralCodeScalarWhereInput
    data: XOR<ReferralCodeUpdateManyMutationInput, ReferralCodeUncheckedUpdateManyWithoutUserInput>
  }

  export type ReferralCodeScalarWhereInput = {
    AND?: ReferralCodeScalarWhereInput | ReferralCodeScalarWhereInput[]
    OR?: ReferralCodeScalarWhereInput[]
    NOT?: ReferralCodeScalarWhereInput | ReferralCodeScalarWhereInput[]
    id?: StringFilter<"ReferralCode"> | string
    code?: StringFilter<"ReferralCode"> | string
    userId?: StringFilter<"ReferralCode"> | string
    isActive?: BoolFilter<"ReferralCode"> | boolean
    usageLimit?: IntNullableFilter<"ReferralCode"> | number | null
    maxUses?: IntNullableFilter<"ReferralCode"> | number | null
    pointsReward?: IntFilter<"ReferralCode"> | number
    isUserCode?: BoolFilter<"ReferralCode"> | boolean
    expiresAt?: DateTimeNullableFilter<"ReferralCode"> | Date | string | null
    createdAt?: DateTimeFilter<"ReferralCode"> | Date | string
    updatedAt?: DateTimeFilter<"ReferralCode"> | Date | string
  }

  export type ReferralUseUpsertWithWhereUniqueWithoutUserInput = {
    where: ReferralUseWhereUniqueInput
    update: XOR<ReferralUseUpdateWithoutUserInput, ReferralUseUncheckedUpdateWithoutUserInput>
    create: XOR<ReferralUseCreateWithoutUserInput, ReferralUseUncheckedCreateWithoutUserInput>
  }

  export type ReferralUseUpdateWithWhereUniqueWithoutUserInput = {
    where: ReferralUseWhereUniqueInput
    data: XOR<ReferralUseUpdateWithoutUserInput, ReferralUseUncheckedUpdateWithoutUserInput>
  }

  export type ReferralUseUpdateManyWithWhereWithoutUserInput = {
    where: ReferralUseScalarWhereInput
    data: XOR<ReferralUseUpdateManyMutationInput, ReferralUseUncheckedUpdateManyWithoutUserInput>
  }

  export type ReferralUseScalarWhereInput = {
    AND?: ReferralUseScalarWhereInput | ReferralUseScalarWhereInput[]
    OR?: ReferralUseScalarWhereInput[]
    NOT?: ReferralUseScalarWhereInput | ReferralUseScalarWhereInput[]
    id?: StringFilter<"ReferralUse"> | string
    referralCodeId?: StringFilter<"ReferralUse"> | string
    userId?: StringFilter<"ReferralUse"> | string
    pointsAwarded?: IntFilter<"ReferralUse"> | number
    createdAt?: DateTimeFilter<"ReferralUse"> | Date | string
  }

  export type UserCreateWithoutTeacherProfileInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    avatar?: string | null
    bio?: string | null
    createdAt?: Date | string
    points?: number
    referralCode?: string | null
    lastLogin?: Date | string | null
    referredBy?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferredByInput
    availability?: UserAvailabilityCreateNestedManyWithoutUserInput
    pointsTransactions?: PointsTransactionCreateNestedManyWithoutUserInput
    courses?: CourseCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    savedCourses?: SavedCourseCreateNestedManyWithoutUserInput
    likedCourses?: LikedCourseCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutUserInput
    assignmentSubs?: AssignmentSubmissionCreateNestedManyWithoutUserInput
    courseReviews?: CourseReviewCreateNestedManyWithoutUserInput
    tutoringSessions?: TutoringSessionCreateNestedManyWithoutTeacherInput
    tutoringRequests?: TutoringRequestCreateNestedManyWithoutStudentInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentCreateNestedManyWithoutTeacherInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentCreateNestedManyWithoutStudentInput
    tutoringReviews?: TutoringReviewCreateNestedManyWithoutStudentInput
    tutoringMessages?: TutoringMessageCreateNestedManyWithoutSenderInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    conversationParts?: ConversationParticipantCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    attachments?: AttachmentCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    subscriptionRecords?: UserSubscriptionCreateNestedManyWithoutUserInput
    bundlesOwned?: UserBundleCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventCreateNestedManyWithoutUserInput
    eventsAsTeacher?: CalendarEventCreateNestedManyWithoutTeacherInput
    eventsAsStudent?: CalendarEventCreateNestedManyWithoutStudentInput
    blogPosts?: BlogPostCreateNestedManyWithoutAuthorInput
    blogComments?: BlogCommentCreateNestedManyWithoutUserInput
    submissionsGraded?: AssignmentSubmissionCreateNestedManyWithoutGradedByInput
    referralCodesOwned?: ReferralCodeCreateNestedManyWithoutUserInput
    referralUsesGained?: ReferralUseCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTeacherProfileInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    avatar?: string | null
    bio?: string | null
    createdAt?: Date | string
    points?: number
    referralCode?: string | null
    referredById?: string | null
    lastLogin?: Date | string | null
    referrals?: UserUncheckedCreateNestedManyWithoutReferredByInput
    availability?: UserAvailabilityUncheckedCreateNestedManyWithoutUserInput
    pointsTransactions?: PointsTransactionUncheckedCreateNestedManyWithoutUserInput
    courses?: CourseUncheckedCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    savedCourses?: SavedCourseUncheckedCreateNestedManyWithoutUserInput
    likedCourses?: LikedCourseUncheckedCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressUncheckedCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutUserInput
    assignmentSubs?: AssignmentSubmissionUncheckedCreateNestedManyWithoutUserInput
    courseReviews?: CourseReviewUncheckedCreateNestedManyWithoutUserInput
    tutoringSessions?: TutoringSessionUncheckedCreateNestedManyWithoutTeacherInput
    tutoringRequests?: TutoringRequestUncheckedCreateNestedManyWithoutStudentInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUncheckedCreateNestedManyWithoutTeacherInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUncheckedCreateNestedManyWithoutStudentInput
    tutoringReviews?: TutoringReviewUncheckedCreateNestedManyWithoutStudentInput
    tutoringMessages?: TutoringMessageUncheckedCreateNestedManyWithoutSenderInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    conversationParts?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    subscriptionRecords?: UserSubscriptionUncheckedCreateNestedManyWithoutUserInput
    bundlesOwned?: UserBundleUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventUncheckedCreateNestedManyWithoutUserInput
    eventsAsTeacher?: CalendarEventUncheckedCreateNestedManyWithoutTeacherInput
    eventsAsStudent?: CalendarEventUncheckedCreateNestedManyWithoutStudentInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
    blogComments?: BlogCommentUncheckedCreateNestedManyWithoutUserInput
    submissionsGraded?: AssignmentSubmissionUncheckedCreateNestedManyWithoutGradedByInput
    referralCodesOwned?: ReferralCodeUncheckedCreateNestedManyWithoutUserInput
    referralUsesGained?: ReferralUseUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTeacherProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTeacherProfileInput, UserUncheckedCreateWithoutTeacherProfileInput>
  }

  export type UserUpsertWithoutTeacherProfileInput = {
    update: XOR<UserUpdateWithoutTeacherProfileInput, UserUncheckedUpdateWithoutTeacherProfileInput>
    create: XOR<UserCreateWithoutTeacherProfileInput, UserUncheckedCreateWithoutTeacherProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTeacherProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTeacherProfileInput, UserUncheckedUpdateWithoutTeacherProfileInput>
  }

  export type UserUpdateWithoutTeacherProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: IntFieldUpdateOperationsInput | number
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referredBy?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferredByNestedInput
    availability?: UserAvailabilityUpdateManyWithoutUserNestedInput
    pointsTransactions?: PointsTransactionUpdateManyWithoutUserNestedInput
    courses?: CourseUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    savedCourses?: SavedCourseUpdateManyWithoutUserNestedInput
    likedCourses?: LikedCourseUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutUserNestedInput
    assignmentSubs?: AssignmentSubmissionUpdateManyWithoutUserNestedInput
    courseReviews?: CourseReviewUpdateManyWithoutUserNestedInput
    tutoringSessions?: TutoringSessionUpdateManyWithoutTeacherNestedInput
    tutoringRequests?: TutoringRequestUpdateManyWithoutStudentNestedInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUpdateManyWithoutTeacherNestedInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUpdateManyWithoutStudentNestedInput
    tutoringReviews?: TutoringReviewUpdateManyWithoutStudentNestedInput
    tutoringMessages?: TutoringMessageUpdateManyWithoutSenderNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    conversationParts?: ConversationParticipantUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    attachments?: AttachmentUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    subscriptionRecords?: UserSubscriptionUpdateManyWithoutUserNestedInput
    bundlesOwned?: UserBundleUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUpdateManyWithoutUserNestedInput
    eventsAsTeacher?: CalendarEventUpdateManyWithoutTeacherNestedInput
    eventsAsStudent?: CalendarEventUpdateManyWithoutStudentNestedInput
    blogPosts?: BlogPostUpdateManyWithoutAuthorNestedInput
    blogComments?: BlogCommentUpdateManyWithoutUserNestedInput
    submissionsGraded?: AssignmentSubmissionUpdateManyWithoutGradedByNestedInput
    referralCodesOwned?: ReferralCodeUpdateManyWithoutUserNestedInput
    referralUsesGained?: ReferralUseUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTeacherProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: IntFieldUpdateOperationsInput | number
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referrals?: UserUncheckedUpdateManyWithoutReferredByNestedInput
    availability?: UserAvailabilityUncheckedUpdateManyWithoutUserNestedInput
    pointsTransactions?: PointsTransactionUncheckedUpdateManyWithoutUserNestedInput
    courses?: CourseUncheckedUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    savedCourses?: SavedCourseUncheckedUpdateManyWithoutUserNestedInput
    likedCourses?: LikedCourseUncheckedUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUncheckedUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    assignmentSubs?: AssignmentSubmissionUncheckedUpdateManyWithoutUserNestedInput
    courseReviews?: CourseReviewUncheckedUpdateManyWithoutUserNestedInput
    tutoringSessions?: TutoringSessionUncheckedUpdateManyWithoutTeacherNestedInput
    tutoringRequests?: TutoringRequestUncheckedUpdateManyWithoutStudentNestedInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUncheckedUpdateManyWithoutTeacherNestedInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUncheckedUpdateManyWithoutStudentNestedInput
    tutoringReviews?: TutoringReviewUncheckedUpdateManyWithoutStudentNestedInput
    tutoringMessages?: TutoringMessageUncheckedUpdateManyWithoutSenderNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    conversationParts?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    subscriptionRecords?: UserSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    bundlesOwned?: UserBundleUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUncheckedUpdateManyWithoutUserNestedInput
    eventsAsTeacher?: CalendarEventUncheckedUpdateManyWithoutTeacherNestedInput
    eventsAsStudent?: CalendarEventUncheckedUpdateManyWithoutStudentNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
    blogComments?: BlogCommentUncheckedUpdateManyWithoutUserNestedInput
    submissionsGraded?: AssignmentSubmissionUncheckedUpdateManyWithoutGradedByNestedInput
    referralCodesOwned?: ReferralCodeUncheckedUpdateManyWithoutUserNestedInput
    referralUsesGained?: ReferralUseUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutAvailabilityInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    avatar?: string | null
    bio?: string | null
    createdAt?: Date | string
    points?: number
    referralCode?: string | null
    lastLogin?: Date | string | null
    referredBy?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferredByInput
    teacherProfile?: TeacherProfileCreateNestedOneWithoutUserInput
    pointsTransactions?: PointsTransactionCreateNestedManyWithoutUserInput
    courses?: CourseCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    savedCourses?: SavedCourseCreateNestedManyWithoutUserInput
    likedCourses?: LikedCourseCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutUserInput
    assignmentSubs?: AssignmentSubmissionCreateNestedManyWithoutUserInput
    courseReviews?: CourseReviewCreateNestedManyWithoutUserInput
    tutoringSessions?: TutoringSessionCreateNestedManyWithoutTeacherInput
    tutoringRequests?: TutoringRequestCreateNestedManyWithoutStudentInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentCreateNestedManyWithoutTeacherInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentCreateNestedManyWithoutStudentInput
    tutoringReviews?: TutoringReviewCreateNestedManyWithoutStudentInput
    tutoringMessages?: TutoringMessageCreateNestedManyWithoutSenderInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    conversationParts?: ConversationParticipantCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    attachments?: AttachmentCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    subscriptionRecords?: UserSubscriptionCreateNestedManyWithoutUserInput
    bundlesOwned?: UserBundleCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventCreateNestedManyWithoutUserInput
    eventsAsTeacher?: CalendarEventCreateNestedManyWithoutTeacherInput
    eventsAsStudent?: CalendarEventCreateNestedManyWithoutStudentInput
    blogPosts?: BlogPostCreateNestedManyWithoutAuthorInput
    blogComments?: BlogCommentCreateNestedManyWithoutUserInput
    submissionsGraded?: AssignmentSubmissionCreateNestedManyWithoutGradedByInput
    referralCodesOwned?: ReferralCodeCreateNestedManyWithoutUserInput
    referralUsesGained?: ReferralUseCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAvailabilityInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    avatar?: string | null
    bio?: string | null
    createdAt?: Date | string
    points?: number
    referralCode?: string | null
    referredById?: string | null
    lastLogin?: Date | string | null
    referrals?: UserUncheckedCreateNestedManyWithoutReferredByInput
    teacherProfile?: TeacherProfileUncheckedCreateNestedOneWithoutUserInput
    pointsTransactions?: PointsTransactionUncheckedCreateNestedManyWithoutUserInput
    courses?: CourseUncheckedCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    savedCourses?: SavedCourseUncheckedCreateNestedManyWithoutUserInput
    likedCourses?: LikedCourseUncheckedCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressUncheckedCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutUserInput
    assignmentSubs?: AssignmentSubmissionUncheckedCreateNestedManyWithoutUserInput
    courseReviews?: CourseReviewUncheckedCreateNestedManyWithoutUserInput
    tutoringSessions?: TutoringSessionUncheckedCreateNestedManyWithoutTeacherInput
    tutoringRequests?: TutoringRequestUncheckedCreateNestedManyWithoutStudentInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUncheckedCreateNestedManyWithoutTeacherInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUncheckedCreateNestedManyWithoutStudentInput
    tutoringReviews?: TutoringReviewUncheckedCreateNestedManyWithoutStudentInput
    tutoringMessages?: TutoringMessageUncheckedCreateNestedManyWithoutSenderInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    conversationParts?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    subscriptionRecords?: UserSubscriptionUncheckedCreateNestedManyWithoutUserInput
    bundlesOwned?: UserBundleUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventUncheckedCreateNestedManyWithoutUserInput
    eventsAsTeacher?: CalendarEventUncheckedCreateNestedManyWithoutTeacherInput
    eventsAsStudent?: CalendarEventUncheckedCreateNestedManyWithoutStudentInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
    blogComments?: BlogCommentUncheckedCreateNestedManyWithoutUserInput
    submissionsGraded?: AssignmentSubmissionUncheckedCreateNestedManyWithoutGradedByInput
    referralCodesOwned?: ReferralCodeUncheckedCreateNestedManyWithoutUserInput
    referralUsesGained?: ReferralUseUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAvailabilityInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAvailabilityInput, UserUncheckedCreateWithoutAvailabilityInput>
  }

  export type UserUpsertWithoutAvailabilityInput = {
    update: XOR<UserUpdateWithoutAvailabilityInput, UserUncheckedUpdateWithoutAvailabilityInput>
    create: XOR<UserCreateWithoutAvailabilityInput, UserUncheckedCreateWithoutAvailabilityInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAvailabilityInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAvailabilityInput, UserUncheckedUpdateWithoutAvailabilityInput>
  }

  export type UserUpdateWithoutAvailabilityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: IntFieldUpdateOperationsInput | number
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referredBy?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferredByNestedInput
    teacherProfile?: TeacherProfileUpdateOneWithoutUserNestedInput
    pointsTransactions?: PointsTransactionUpdateManyWithoutUserNestedInput
    courses?: CourseUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    savedCourses?: SavedCourseUpdateManyWithoutUserNestedInput
    likedCourses?: LikedCourseUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutUserNestedInput
    assignmentSubs?: AssignmentSubmissionUpdateManyWithoutUserNestedInput
    courseReviews?: CourseReviewUpdateManyWithoutUserNestedInput
    tutoringSessions?: TutoringSessionUpdateManyWithoutTeacherNestedInput
    tutoringRequests?: TutoringRequestUpdateManyWithoutStudentNestedInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUpdateManyWithoutTeacherNestedInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUpdateManyWithoutStudentNestedInput
    tutoringReviews?: TutoringReviewUpdateManyWithoutStudentNestedInput
    tutoringMessages?: TutoringMessageUpdateManyWithoutSenderNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    conversationParts?: ConversationParticipantUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    attachments?: AttachmentUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    subscriptionRecords?: UserSubscriptionUpdateManyWithoutUserNestedInput
    bundlesOwned?: UserBundleUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUpdateManyWithoutUserNestedInput
    eventsAsTeacher?: CalendarEventUpdateManyWithoutTeacherNestedInput
    eventsAsStudent?: CalendarEventUpdateManyWithoutStudentNestedInput
    blogPosts?: BlogPostUpdateManyWithoutAuthorNestedInput
    blogComments?: BlogCommentUpdateManyWithoutUserNestedInput
    submissionsGraded?: AssignmentSubmissionUpdateManyWithoutGradedByNestedInput
    referralCodesOwned?: ReferralCodeUpdateManyWithoutUserNestedInput
    referralUsesGained?: ReferralUseUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAvailabilityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: IntFieldUpdateOperationsInput | number
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referrals?: UserUncheckedUpdateManyWithoutReferredByNestedInput
    teacherProfile?: TeacherProfileUncheckedUpdateOneWithoutUserNestedInput
    pointsTransactions?: PointsTransactionUncheckedUpdateManyWithoutUserNestedInput
    courses?: CourseUncheckedUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    savedCourses?: SavedCourseUncheckedUpdateManyWithoutUserNestedInput
    likedCourses?: LikedCourseUncheckedUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUncheckedUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    assignmentSubs?: AssignmentSubmissionUncheckedUpdateManyWithoutUserNestedInput
    courseReviews?: CourseReviewUncheckedUpdateManyWithoutUserNestedInput
    tutoringSessions?: TutoringSessionUncheckedUpdateManyWithoutTeacherNestedInput
    tutoringRequests?: TutoringRequestUncheckedUpdateManyWithoutStudentNestedInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUncheckedUpdateManyWithoutTeacherNestedInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUncheckedUpdateManyWithoutStudentNestedInput
    tutoringReviews?: TutoringReviewUncheckedUpdateManyWithoutStudentNestedInput
    tutoringMessages?: TutoringMessageUncheckedUpdateManyWithoutSenderNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    conversationParts?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    subscriptionRecords?: UserSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    bundlesOwned?: UserBundleUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUncheckedUpdateManyWithoutUserNestedInput
    eventsAsTeacher?: CalendarEventUncheckedUpdateManyWithoutTeacherNestedInput
    eventsAsStudent?: CalendarEventUncheckedUpdateManyWithoutStudentNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
    blogComments?: BlogCommentUncheckedUpdateManyWithoutUserNestedInput
    submissionsGraded?: AssignmentSubmissionUncheckedUpdateManyWithoutGradedByNestedInput
    referralCodesOwned?: ReferralCodeUncheckedUpdateManyWithoutUserNestedInput
    referralUsesGained?: ReferralUseUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutPointsTransactionsInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    avatar?: string | null
    bio?: string | null
    createdAt?: Date | string
    points?: number
    referralCode?: string | null
    lastLogin?: Date | string | null
    referredBy?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferredByInput
    teacherProfile?: TeacherProfileCreateNestedOneWithoutUserInput
    availability?: UserAvailabilityCreateNestedManyWithoutUserInput
    courses?: CourseCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    savedCourses?: SavedCourseCreateNestedManyWithoutUserInput
    likedCourses?: LikedCourseCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutUserInput
    assignmentSubs?: AssignmentSubmissionCreateNestedManyWithoutUserInput
    courseReviews?: CourseReviewCreateNestedManyWithoutUserInput
    tutoringSessions?: TutoringSessionCreateNestedManyWithoutTeacherInput
    tutoringRequests?: TutoringRequestCreateNestedManyWithoutStudentInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentCreateNestedManyWithoutTeacherInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentCreateNestedManyWithoutStudentInput
    tutoringReviews?: TutoringReviewCreateNestedManyWithoutStudentInput
    tutoringMessages?: TutoringMessageCreateNestedManyWithoutSenderInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    conversationParts?: ConversationParticipantCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    attachments?: AttachmentCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    subscriptionRecords?: UserSubscriptionCreateNestedManyWithoutUserInput
    bundlesOwned?: UserBundleCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventCreateNestedManyWithoutUserInput
    eventsAsTeacher?: CalendarEventCreateNestedManyWithoutTeacherInput
    eventsAsStudent?: CalendarEventCreateNestedManyWithoutStudentInput
    blogPosts?: BlogPostCreateNestedManyWithoutAuthorInput
    blogComments?: BlogCommentCreateNestedManyWithoutUserInput
    submissionsGraded?: AssignmentSubmissionCreateNestedManyWithoutGradedByInput
    referralCodesOwned?: ReferralCodeCreateNestedManyWithoutUserInput
    referralUsesGained?: ReferralUseCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPointsTransactionsInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    avatar?: string | null
    bio?: string | null
    createdAt?: Date | string
    points?: number
    referralCode?: string | null
    referredById?: string | null
    lastLogin?: Date | string | null
    referrals?: UserUncheckedCreateNestedManyWithoutReferredByInput
    teacherProfile?: TeacherProfileUncheckedCreateNestedOneWithoutUserInput
    availability?: UserAvailabilityUncheckedCreateNestedManyWithoutUserInput
    courses?: CourseUncheckedCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    savedCourses?: SavedCourseUncheckedCreateNestedManyWithoutUserInput
    likedCourses?: LikedCourseUncheckedCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressUncheckedCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutUserInput
    assignmentSubs?: AssignmentSubmissionUncheckedCreateNestedManyWithoutUserInput
    courseReviews?: CourseReviewUncheckedCreateNestedManyWithoutUserInput
    tutoringSessions?: TutoringSessionUncheckedCreateNestedManyWithoutTeacherInput
    tutoringRequests?: TutoringRequestUncheckedCreateNestedManyWithoutStudentInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUncheckedCreateNestedManyWithoutTeacherInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUncheckedCreateNestedManyWithoutStudentInput
    tutoringReviews?: TutoringReviewUncheckedCreateNestedManyWithoutStudentInput
    tutoringMessages?: TutoringMessageUncheckedCreateNestedManyWithoutSenderInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    conversationParts?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    subscriptionRecords?: UserSubscriptionUncheckedCreateNestedManyWithoutUserInput
    bundlesOwned?: UserBundleUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventUncheckedCreateNestedManyWithoutUserInput
    eventsAsTeacher?: CalendarEventUncheckedCreateNestedManyWithoutTeacherInput
    eventsAsStudent?: CalendarEventUncheckedCreateNestedManyWithoutStudentInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
    blogComments?: BlogCommentUncheckedCreateNestedManyWithoutUserInput
    submissionsGraded?: AssignmentSubmissionUncheckedCreateNestedManyWithoutGradedByInput
    referralCodesOwned?: ReferralCodeUncheckedCreateNestedManyWithoutUserInput
    referralUsesGained?: ReferralUseUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPointsTransactionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPointsTransactionsInput, UserUncheckedCreateWithoutPointsTransactionsInput>
  }

  export type UserUpsertWithoutPointsTransactionsInput = {
    update: XOR<UserUpdateWithoutPointsTransactionsInput, UserUncheckedUpdateWithoutPointsTransactionsInput>
    create: XOR<UserCreateWithoutPointsTransactionsInput, UserUncheckedCreateWithoutPointsTransactionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPointsTransactionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPointsTransactionsInput, UserUncheckedUpdateWithoutPointsTransactionsInput>
  }

  export type UserUpdateWithoutPointsTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: IntFieldUpdateOperationsInput | number
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referredBy?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferredByNestedInput
    teacherProfile?: TeacherProfileUpdateOneWithoutUserNestedInput
    availability?: UserAvailabilityUpdateManyWithoutUserNestedInput
    courses?: CourseUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    savedCourses?: SavedCourseUpdateManyWithoutUserNestedInput
    likedCourses?: LikedCourseUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutUserNestedInput
    assignmentSubs?: AssignmentSubmissionUpdateManyWithoutUserNestedInput
    courseReviews?: CourseReviewUpdateManyWithoutUserNestedInput
    tutoringSessions?: TutoringSessionUpdateManyWithoutTeacherNestedInput
    tutoringRequests?: TutoringRequestUpdateManyWithoutStudentNestedInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUpdateManyWithoutTeacherNestedInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUpdateManyWithoutStudentNestedInput
    tutoringReviews?: TutoringReviewUpdateManyWithoutStudentNestedInput
    tutoringMessages?: TutoringMessageUpdateManyWithoutSenderNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    conversationParts?: ConversationParticipantUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    attachments?: AttachmentUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    subscriptionRecords?: UserSubscriptionUpdateManyWithoutUserNestedInput
    bundlesOwned?: UserBundleUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUpdateManyWithoutUserNestedInput
    eventsAsTeacher?: CalendarEventUpdateManyWithoutTeacherNestedInput
    eventsAsStudent?: CalendarEventUpdateManyWithoutStudentNestedInput
    blogPosts?: BlogPostUpdateManyWithoutAuthorNestedInput
    blogComments?: BlogCommentUpdateManyWithoutUserNestedInput
    submissionsGraded?: AssignmentSubmissionUpdateManyWithoutGradedByNestedInput
    referralCodesOwned?: ReferralCodeUpdateManyWithoutUserNestedInput
    referralUsesGained?: ReferralUseUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPointsTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: IntFieldUpdateOperationsInput | number
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referrals?: UserUncheckedUpdateManyWithoutReferredByNestedInput
    teacherProfile?: TeacherProfileUncheckedUpdateOneWithoutUserNestedInput
    availability?: UserAvailabilityUncheckedUpdateManyWithoutUserNestedInput
    courses?: CourseUncheckedUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    savedCourses?: SavedCourseUncheckedUpdateManyWithoutUserNestedInput
    likedCourses?: LikedCourseUncheckedUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUncheckedUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    assignmentSubs?: AssignmentSubmissionUncheckedUpdateManyWithoutUserNestedInput
    courseReviews?: CourseReviewUncheckedUpdateManyWithoutUserNestedInput
    tutoringSessions?: TutoringSessionUncheckedUpdateManyWithoutTeacherNestedInput
    tutoringRequests?: TutoringRequestUncheckedUpdateManyWithoutStudentNestedInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUncheckedUpdateManyWithoutTeacherNestedInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUncheckedUpdateManyWithoutStudentNestedInput
    tutoringReviews?: TutoringReviewUncheckedUpdateManyWithoutStudentNestedInput
    tutoringMessages?: TutoringMessageUncheckedUpdateManyWithoutSenderNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    conversationParts?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    subscriptionRecords?: UserSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    bundlesOwned?: UserBundleUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUncheckedUpdateManyWithoutUserNestedInput
    eventsAsTeacher?: CalendarEventUncheckedUpdateManyWithoutTeacherNestedInput
    eventsAsStudent?: CalendarEventUncheckedUpdateManyWithoutStudentNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
    blogComments?: BlogCommentUncheckedUpdateManyWithoutUserNestedInput
    submissionsGraded?: AssignmentSubmissionUncheckedUpdateManyWithoutGradedByNestedInput
    referralCodesOwned?: ReferralCodeUncheckedUpdateManyWithoutUserNestedInput
    referralUsesGained?: ReferralUseUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutCoursesInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    avatar?: string | null
    bio?: string | null
    createdAt?: Date | string
    points?: number
    referralCode?: string | null
    lastLogin?: Date | string | null
    referredBy?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferredByInput
    teacherProfile?: TeacherProfileCreateNestedOneWithoutUserInput
    availability?: UserAvailabilityCreateNestedManyWithoutUserInput
    pointsTransactions?: PointsTransactionCreateNestedManyWithoutUserInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    savedCourses?: SavedCourseCreateNestedManyWithoutUserInput
    likedCourses?: LikedCourseCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutUserInput
    assignmentSubs?: AssignmentSubmissionCreateNestedManyWithoutUserInput
    courseReviews?: CourseReviewCreateNestedManyWithoutUserInput
    tutoringSessions?: TutoringSessionCreateNestedManyWithoutTeacherInput
    tutoringRequests?: TutoringRequestCreateNestedManyWithoutStudentInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentCreateNestedManyWithoutTeacherInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentCreateNestedManyWithoutStudentInput
    tutoringReviews?: TutoringReviewCreateNestedManyWithoutStudentInput
    tutoringMessages?: TutoringMessageCreateNestedManyWithoutSenderInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    conversationParts?: ConversationParticipantCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    attachments?: AttachmentCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    subscriptionRecords?: UserSubscriptionCreateNestedManyWithoutUserInput
    bundlesOwned?: UserBundleCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventCreateNestedManyWithoutUserInput
    eventsAsTeacher?: CalendarEventCreateNestedManyWithoutTeacherInput
    eventsAsStudent?: CalendarEventCreateNestedManyWithoutStudentInput
    blogPosts?: BlogPostCreateNestedManyWithoutAuthorInput
    blogComments?: BlogCommentCreateNestedManyWithoutUserInput
    submissionsGraded?: AssignmentSubmissionCreateNestedManyWithoutGradedByInput
    referralCodesOwned?: ReferralCodeCreateNestedManyWithoutUserInput
    referralUsesGained?: ReferralUseCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCoursesInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    avatar?: string | null
    bio?: string | null
    createdAt?: Date | string
    points?: number
    referralCode?: string | null
    referredById?: string | null
    lastLogin?: Date | string | null
    referrals?: UserUncheckedCreateNestedManyWithoutReferredByInput
    teacherProfile?: TeacherProfileUncheckedCreateNestedOneWithoutUserInput
    availability?: UserAvailabilityUncheckedCreateNestedManyWithoutUserInput
    pointsTransactions?: PointsTransactionUncheckedCreateNestedManyWithoutUserInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    savedCourses?: SavedCourseUncheckedCreateNestedManyWithoutUserInput
    likedCourses?: LikedCourseUncheckedCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressUncheckedCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutUserInput
    assignmentSubs?: AssignmentSubmissionUncheckedCreateNestedManyWithoutUserInput
    courseReviews?: CourseReviewUncheckedCreateNestedManyWithoutUserInput
    tutoringSessions?: TutoringSessionUncheckedCreateNestedManyWithoutTeacherInput
    tutoringRequests?: TutoringRequestUncheckedCreateNestedManyWithoutStudentInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUncheckedCreateNestedManyWithoutTeacherInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUncheckedCreateNestedManyWithoutStudentInput
    tutoringReviews?: TutoringReviewUncheckedCreateNestedManyWithoutStudentInput
    tutoringMessages?: TutoringMessageUncheckedCreateNestedManyWithoutSenderInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    conversationParts?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    subscriptionRecords?: UserSubscriptionUncheckedCreateNestedManyWithoutUserInput
    bundlesOwned?: UserBundleUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventUncheckedCreateNestedManyWithoutUserInput
    eventsAsTeacher?: CalendarEventUncheckedCreateNestedManyWithoutTeacherInput
    eventsAsStudent?: CalendarEventUncheckedCreateNestedManyWithoutStudentInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
    blogComments?: BlogCommentUncheckedCreateNestedManyWithoutUserInput
    submissionsGraded?: AssignmentSubmissionUncheckedCreateNestedManyWithoutGradedByInput
    referralCodesOwned?: ReferralCodeUncheckedCreateNestedManyWithoutUserInput
    referralUsesGained?: ReferralUseUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCoursesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCoursesInput, UserUncheckedCreateWithoutCoursesInput>
  }

  export type TopicCreateWithoutCourseInput = {
    id?: string
    title: string
    description?: string | null
    orderIndex: number
    lessons?: LessonCreateNestedManyWithoutTopicInput
  }

  export type TopicUncheckedCreateWithoutCourseInput = {
    id?: string
    title: string
    description?: string | null
    orderIndex: number
    lessons?: LessonUncheckedCreateNestedManyWithoutTopicInput
  }

  export type TopicCreateOrConnectWithoutCourseInput = {
    where: TopicWhereUniqueInput
    create: XOR<TopicCreateWithoutCourseInput, TopicUncheckedCreateWithoutCourseInput>
  }

  export type TopicCreateManyCourseInputEnvelope = {
    data: TopicCreateManyCourseInput | TopicCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type EnrollmentCreateWithoutCourseInput = {
    id?: string
    enrolledAt?: Date | string
    completed?: boolean
    completedAt?: Date | string | null
    status?: string
    user: UserCreateNestedOneWithoutEnrollmentsInput
  }

  export type EnrollmentUncheckedCreateWithoutCourseInput = {
    id?: string
    userId: string
    enrolledAt?: Date | string
    completed?: boolean
    completedAt?: Date | string | null
    status?: string
  }

  export type EnrollmentCreateOrConnectWithoutCourseInput = {
    where: EnrollmentWhereUniqueInput
    create: XOR<EnrollmentCreateWithoutCourseInput, EnrollmentUncheckedCreateWithoutCourseInput>
  }

  export type EnrollmentCreateManyCourseInputEnvelope = {
    data: EnrollmentCreateManyCourseInput | EnrollmentCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type SavedCourseCreateWithoutCourseInput = {
    id?: string
    savedAt?: Date | string
    user: UserCreateNestedOneWithoutSavedCoursesInput
  }

  export type SavedCourseUncheckedCreateWithoutCourseInput = {
    id?: string
    userId: string
    savedAt?: Date | string
  }

  export type SavedCourseCreateOrConnectWithoutCourseInput = {
    where: SavedCourseWhereUniqueInput
    create: XOR<SavedCourseCreateWithoutCourseInput, SavedCourseUncheckedCreateWithoutCourseInput>
  }

  export type SavedCourseCreateManyCourseInputEnvelope = {
    data: SavedCourseCreateManyCourseInput | SavedCourseCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type LikedCourseCreateWithoutCourseInput = {
    id?: string
    likedAt?: Date | string
    user: UserCreateNestedOneWithoutLikedCoursesInput
  }

  export type LikedCourseUncheckedCreateWithoutCourseInput = {
    id?: string
    userId: string
    likedAt?: Date | string
  }

  export type LikedCourseCreateOrConnectWithoutCourseInput = {
    where: LikedCourseWhereUniqueInput
    create: XOR<LikedCourseCreateWithoutCourseInput, LikedCourseUncheckedCreateWithoutCourseInput>
  }

  export type LikedCourseCreateManyCourseInputEnvelope = {
    data: LikedCourseCreateManyCourseInput | LikedCourseCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type CourseReviewCreateWithoutCourseInput = {
    id?: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutCourseReviewsInput
  }

  export type CourseReviewUncheckedCreateWithoutCourseInput = {
    id?: string
    userId: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
  }

  export type CourseReviewCreateOrConnectWithoutCourseInput = {
    where: CourseReviewWhereUniqueInput
    create: XOR<CourseReviewCreateWithoutCourseInput, CourseReviewUncheckedCreateWithoutCourseInput>
  }

  export type CourseReviewCreateManyCourseInputEnvelope = {
    data: CourseReviewCreateManyCourseInput | CourseReviewCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type LessonCreateWithoutCourseInput = {
    id?: string
    title: string
    description?: string | null
    videoUrl?: string | null
    content?: string | null
    duration?: number | null
    orderIndex: number
    type: $Enums.LessonType
    topic: TopicCreateNestedOneWithoutLessonsInput
    quiz?: QuizCreateNestedOneWithoutLessonInput
    assignment?: AssignmentCreateNestedOneWithoutLessonInput
    progress?: LessonProgressCreateNestedManyWithoutLessonInput
    calendarEvents?: CalendarEventCreateNestedManyWithoutLessonInput
  }

  export type LessonUncheckedCreateWithoutCourseInput = {
    id?: string
    topicId: string
    title: string
    description?: string | null
    videoUrl?: string | null
    content?: string | null
    duration?: number | null
    orderIndex: number
    type: $Enums.LessonType
    quiz?: QuizUncheckedCreateNestedOneWithoutLessonInput
    assignment?: AssignmentUncheckedCreateNestedOneWithoutLessonInput
    progress?: LessonProgressUncheckedCreateNestedManyWithoutLessonInput
    calendarEvents?: CalendarEventUncheckedCreateNestedManyWithoutLessonInput
  }

  export type LessonCreateOrConnectWithoutCourseInput = {
    where: LessonWhereUniqueInput
    create: XOR<LessonCreateWithoutCourseInput, LessonUncheckedCreateWithoutCourseInput>
  }

  export type LessonCreateManyCourseInputEnvelope = {
    data: LessonCreateManyCourseInput | LessonCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type QuizAttemptCreateWithoutCourseInput = {
    id?: string
    score: number
    duration?: number | null
    completedAt?: Date | string
    answers: JsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutQuizAttemptsInput
    quiz: QuizCreateNestedOneWithoutAttemptsInput
  }

  export type QuizAttemptUncheckedCreateWithoutCourseInput = {
    id?: string
    userId: string
    quizId: string
    score: number
    duration?: number | null
    completedAt?: Date | string
    answers: JsonNullValueInput | InputJsonValue
  }

  export type QuizAttemptCreateOrConnectWithoutCourseInput = {
    where: QuizAttemptWhereUniqueInput
    create: XOR<QuizAttemptCreateWithoutCourseInput, QuizAttemptUncheckedCreateWithoutCourseInput>
  }

  export type QuizAttemptCreateManyCourseInputEnvelope = {
    data: QuizAttemptCreateManyCourseInput | QuizAttemptCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type CertificateCreateWithoutCourseInput = {
    id?: string
    title: string
    issueDate?: Date | string
    type: string
    courseName?: string | null
    tutoringSubject?: string | null
    teacherId?: string | null
    teacherName?: string | null
    customMessage?: string | null
    imageUrl?: string | null
    user: UserCreateNestedOneWithoutCertificatesInput
    tutoring?: TutoringSessionCreateNestedOneWithoutCertificatesInput
    badge?: BadgeCreateNestedOneWithoutCertificatesInput
  }

  export type CertificateUncheckedCreateWithoutCourseInput = {
    id?: string
    userId: string
    title: string
    issueDate?: Date | string
    type: string
    courseName?: string | null
    tutoringId?: string | null
    tutoringSubject?: string | null
    teacherId?: string | null
    teacherName?: string | null
    customMessage?: string | null
    imageUrl?: string | null
    badgeId?: string | null
  }

  export type CertificateCreateOrConnectWithoutCourseInput = {
    where: CertificateWhereUniqueInput
    create: XOR<CertificateCreateWithoutCourseInput, CertificateUncheckedCreateWithoutCourseInput>
  }

  export type CertificateCreateManyCourseInputEnvelope = {
    data: CertificateCreateManyCourseInput | CertificateCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type BundleCourseCreateWithoutCourseInput = {
    bundle: CourseBundleCreateNestedOneWithoutCoursesInput
  }

  export type BundleCourseUncheckedCreateWithoutCourseInput = {
    bundleId: string
  }

  export type BundleCourseCreateOrConnectWithoutCourseInput = {
    where: BundleCourseWhereUniqueInput
    create: XOR<BundleCourseCreateWithoutCourseInput, BundleCourseUncheckedCreateWithoutCourseInput>
  }

  export type BundleCourseCreateManyCourseInputEnvelope = {
    data: BundleCourseCreateManyCourseInput | BundleCourseCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type CalendarEventCreateWithoutCourseInput = {
    id?: string
    title: string
    description?: string | null
    type: string
    startTime: Date | string
    endTime?: Date | string | null
    location?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutCalendarEventsInput
    lesson?: LessonCreateNestedOneWithoutCalendarEventsInput
    teacher?: UserCreateNestedOneWithoutEventsAsTeacherInput
    student?: UserCreateNestedOneWithoutEventsAsStudentInput
  }

  export type CalendarEventUncheckedCreateWithoutCourseInput = {
    id?: string
    userId: string
    title: string
    description?: string | null
    type: string
    startTime: Date | string
    endTime?: Date | string | null
    lessonId?: string | null
    teacherId?: string | null
    studentId?: string | null
    location?: string | null
    createdAt?: Date | string
  }

  export type CalendarEventCreateOrConnectWithoutCourseInput = {
    where: CalendarEventWhereUniqueInput
    create: XOR<CalendarEventCreateWithoutCourseInput, CalendarEventUncheckedCreateWithoutCourseInput>
  }

  export type CalendarEventCreateManyCourseInputEnvelope = {
    data: CalendarEventCreateManyCourseInput | CalendarEventCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCoursesInput = {
    update: XOR<UserUpdateWithoutCoursesInput, UserUncheckedUpdateWithoutCoursesInput>
    create: XOR<UserCreateWithoutCoursesInput, UserUncheckedCreateWithoutCoursesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCoursesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCoursesInput, UserUncheckedUpdateWithoutCoursesInput>
  }

  export type UserUpdateWithoutCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: IntFieldUpdateOperationsInput | number
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referredBy?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferredByNestedInput
    teacherProfile?: TeacherProfileUpdateOneWithoutUserNestedInput
    availability?: UserAvailabilityUpdateManyWithoutUserNestedInput
    pointsTransactions?: PointsTransactionUpdateManyWithoutUserNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    savedCourses?: SavedCourseUpdateManyWithoutUserNestedInput
    likedCourses?: LikedCourseUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutUserNestedInput
    assignmentSubs?: AssignmentSubmissionUpdateManyWithoutUserNestedInput
    courseReviews?: CourseReviewUpdateManyWithoutUserNestedInput
    tutoringSessions?: TutoringSessionUpdateManyWithoutTeacherNestedInput
    tutoringRequests?: TutoringRequestUpdateManyWithoutStudentNestedInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUpdateManyWithoutTeacherNestedInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUpdateManyWithoutStudentNestedInput
    tutoringReviews?: TutoringReviewUpdateManyWithoutStudentNestedInput
    tutoringMessages?: TutoringMessageUpdateManyWithoutSenderNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    conversationParts?: ConversationParticipantUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    attachments?: AttachmentUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    subscriptionRecords?: UserSubscriptionUpdateManyWithoutUserNestedInput
    bundlesOwned?: UserBundleUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUpdateManyWithoutUserNestedInput
    eventsAsTeacher?: CalendarEventUpdateManyWithoutTeacherNestedInput
    eventsAsStudent?: CalendarEventUpdateManyWithoutStudentNestedInput
    blogPosts?: BlogPostUpdateManyWithoutAuthorNestedInput
    blogComments?: BlogCommentUpdateManyWithoutUserNestedInput
    submissionsGraded?: AssignmentSubmissionUpdateManyWithoutGradedByNestedInput
    referralCodesOwned?: ReferralCodeUpdateManyWithoutUserNestedInput
    referralUsesGained?: ReferralUseUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: IntFieldUpdateOperationsInput | number
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referrals?: UserUncheckedUpdateManyWithoutReferredByNestedInput
    teacherProfile?: TeacherProfileUncheckedUpdateOneWithoutUserNestedInput
    availability?: UserAvailabilityUncheckedUpdateManyWithoutUserNestedInput
    pointsTransactions?: PointsTransactionUncheckedUpdateManyWithoutUserNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    savedCourses?: SavedCourseUncheckedUpdateManyWithoutUserNestedInput
    likedCourses?: LikedCourseUncheckedUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUncheckedUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    assignmentSubs?: AssignmentSubmissionUncheckedUpdateManyWithoutUserNestedInput
    courseReviews?: CourseReviewUncheckedUpdateManyWithoutUserNestedInput
    tutoringSessions?: TutoringSessionUncheckedUpdateManyWithoutTeacherNestedInput
    tutoringRequests?: TutoringRequestUncheckedUpdateManyWithoutStudentNestedInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUncheckedUpdateManyWithoutTeacherNestedInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUncheckedUpdateManyWithoutStudentNestedInput
    tutoringReviews?: TutoringReviewUncheckedUpdateManyWithoutStudentNestedInput
    tutoringMessages?: TutoringMessageUncheckedUpdateManyWithoutSenderNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    conversationParts?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    subscriptionRecords?: UserSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    bundlesOwned?: UserBundleUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUncheckedUpdateManyWithoutUserNestedInput
    eventsAsTeacher?: CalendarEventUncheckedUpdateManyWithoutTeacherNestedInput
    eventsAsStudent?: CalendarEventUncheckedUpdateManyWithoutStudentNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
    blogComments?: BlogCommentUncheckedUpdateManyWithoutUserNestedInput
    submissionsGraded?: AssignmentSubmissionUncheckedUpdateManyWithoutGradedByNestedInput
    referralCodesOwned?: ReferralCodeUncheckedUpdateManyWithoutUserNestedInput
    referralUsesGained?: ReferralUseUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TopicUpsertWithWhereUniqueWithoutCourseInput = {
    where: TopicWhereUniqueInput
    update: XOR<TopicUpdateWithoutCourseInput, TopicUncheckedUpdateWithoutCourseInput>
    create: XOR<TopicCreateWithoutCourseInput, TopicUncheckedCreateWithoutCourseInput>
  }

  export type TopicUpdateWithWhereUniqueWithoutCourseInput = {
    where: TopicWhereUniqueInput
    data: XOR<TopicUpdateWithoutCourseInput, TopicUncheckedUpdateWithoutCourseInput>
  }

  export type TopicUpdateManyWithWhereWithoutCourseInput = {
    where: TopicScalarWhereInput
    data: XOR<TopicUpdateManyMutationInput, TopicUncheckedUpdateManyWithoutCourseInput>
  }

  export type TopicScalarWhereInput = {
    AND?: TopicScalarWhereInput | TopicScalarWhereInput[]
    OR?: TopicScalarWhereInput[]
    NOT?: TopicScalarWhereInput | TopicScalarWhereInput[]
    id?: StringFilter<"Topic"> | string
    courseId?: StringFilter<"Topic"> | string
    title?: StringFilter<"Topic"> | string
    description?: StringNullableFilter<"Topic"> | string | null
    orderIndex?: IntFilter<"Topic"> | number
  }

  export type EnrollmentUpsertWithWhereUniqueWithoutCourseInput = {
    where: EnrollmentWhereUniqueInput
    update: XOR<EnrollmentUpdateWithoutCourseInput, EnrollmentUncheckedUpdateWithoutCourseInput>
    create: XOR<EnrollmentCreateWithoutCourseInput, EnrollmentUncheckedCreateWithoutCourseInput>
  }

  export type EnrollmentUpdateWithWhereUniqueWithoutCourseInput = {
    where: EnrollmentWhereUniqueInput
    data: XOR<EnrollmentUpdateWithoutCourseInput, EnrollmentUncheckedUpdateWithoutCourseInput>
  }

  export type EnrollmentUpdateManyWithWhereWithoutCourseInput = {
    where: EnrollmentScalarWhereInput
    data: XOR<EnrollmentUpdateManyMutationInput, EnrollmentUncheckedUpdateManyWithoutCourseInput>
  }

  export type SavedCourseUpsertWithWhereUniqueWithoutCourseInput = {
    where: SavedCourseWhereUniqueInput
    update: XOR<SavedCourseUpdateWithoutCourseInput, SavedCourseUncheckedUpdateWithoutCourseInput>
    create: XOR<SavedCourseCreateWithoutCourseInput, SavedCourseUncheckedCreateWithoutCourseInput>
  }

  export type SavedCourseUpdateWithWhereUniqueWithoutCourseInput = {
    where: SavedCourseWhereUniqueInput
    data: XOR<SavedCourseUpdateWithoutCourseInput, SavedCourseUncheckedUpdateWithoutCourseInput>
  }

  export type SavedCourseUpdateManyWithWhereWithoutCourseInput = {
    where: SavedCourseScalarWhereInput
    data: XOR<SavedCourseUpdateManyMutationInput, SavedCourseUncheckedUpdateManyWithoutCourseInput>
  }

  export type LikedCourseUpsertWithWhereUniqueWithoutCourseInput = {
    where: LikedCourseWhereUniqueInput
    update: XOR<LikedCourseUpdateWithoutCourseInput, LikedCourseUncheckedUpdateWithoutCourseInput>
    create: XOR<LikedCourseCreateWithoutCourseInput, LikedCourseUncheckedCreateWithoutCourseInput>
  }

  export type LikedCourseUpdateWithWhereUniqueWithoutCourseInput = {
    where: LikedCourseWhereUniqueInput
    data: XOR<LikedCourseUpdateWithoutCourseInput, LikedCourseUncheckedUpdateWithoutCourseInput>
  }

  export type LikedCourseUpdateManyWithWhereWithoutCourseInput = {
    where: LikedCourseScalarWhereInput
    data: XOR<LikedCourseUpdateManyMutationInput, LikedCourseUncheckedUpdateManyWithoutCourseInput>
  }

  export type CourseReviewUpsertWithWhereUniqueWithoutCourseInput = {
    where: CourseReviewWhereUniqueInput
    update: XOR<CourseReviewUpdateWithoutCourseInput, CourseReviewUncheckedUpdateWithoutCourseInput>
    create: XOR<CourseReviewCreateWithoutCourseInput, CourseReviewUncheckedCreateWithoutCourseInput>
  }

  export type CourseReviewUpdateWithWhereUniqueWithoutCourseInput = {
    where: CourseReviewWhereUniqueInput
    data: XOR<CourseReviewUpdateWithoutCourseInput, CourseReviewUncheckedUpdateWithoutCourseInput>
  }

  export type CourseReviewUpdateManyWithWhereWithoutCourseInput = {
    where: CourseReviewScalarWhereInput
    data: XOR<CourseReviewUpdateManyMutationInput, CourseReviewUncheckedUpdateManyWithoutCourseInput>
  }

  export type LessonUpsertWithWhereUniqueWithoutCourseInput = {
    where: LessonWhereUniqueInput
    update: XOR<LessonUpdateWithoutCourseInput, LessonUncheckedUpdateWithoutCourseInput>
    create: XOR<LessonCreateWithoutCourseInput, LessonUncheckedCreateWithoutCourseInput>
  }

  export type LessonUpdateWithWhereUniqueWithoutCourseInput = {
    where: LessonWhereUniqueInput
    data: XOR<LessonUpdateWithoutCourseInput, LessonUncheckedUpdateWithoutCourseInput>
  }

  export type LessonUpdateManyWithWhereWithoutCourseInput = {
    where: LessonScalarWhereInput
    data: XOR<LessonUpdateManyMutationInput, LessonUncheckedUpdateManyWithoutCourseInput>
  }

  export type LessonScalarWhereInput = {
    AND?: LessonScalarWhereInput | LessonScalarWhereInput[]
    OR?: LessonScalarWhereInput[]
    NOT?: LessonScalarWhereInput | LessonScalarWhereInput[]
    id?: StringFilter<"Lesson"> | string
    topicId?: StringFilter<"Lesson"> | string
    title?: StringFilter<"Lesson"> | string
    description?: StringNullableFilter<"Lesson"> | string | null
    videoUrl?: StringNullableFilter<"Lesson"> | string | null
    content?: StringNullableFilter<"Lesson"> | string | null
    duration?: IntNullableFilter<"Lesson"> | number | null
    orderIndex?: IntFilter<"Lesson"> | number
    type?: EnumLessonTypeFilter<"Lesson"> | $Enums.LessonType
    courseId?: StringNullableFilter<"Lesson"> | string | null
  }

  export type QuizAttemptUpsertWithWhereUniqueWithoutCourseInput = {
    where: QuizAttemptWhereUniqueInput
    update: XOR<QuizAttemptUpdateWithoutCourseInput, QuizAttemptUncheckedUpdateWithoutCourseInput>
    create: XOR<QuizAttemptCreateWithoutCourseInput, QuizAttemptUncheckedCreateWithoutCourseInput>
  }

  export type QuizAttemptUpdateWithWhereUniqueWithoutCourseInput = {
    where: QuizAttemptWhereUniqueInput
    data: XOR<QuizAttemptUpdateWithoutCourseInput, QuizAttemptUncheckedUpdateWithoutCourseInput>
  }

  export type QuizAttemptUpdateManyWithWhereWithoutCourseInput = {
    where: QuizAttemptScalarWhereInput
    data: XOR<QuizAttemptUpdateManyMutationInput, QuizAttemptUncheckedUpdateManyWithoutCourseInput>
  }

  export type CertificateUpsertWithWhereUniqueWithoutCourseInput = {
    where: CertificateWhereUniqueInput
    update: XOR<CertificateUpdateWithoutCourseInput, CertificateUncheckedUpdateWithoutCourseInput>
    create: XOR<CertificateCreateWithoutCourseInput, CertificateUncheckedCreateWithoutCourseInput>
  }

  export type CertificateUpdateWithWhereUniqueWithoutCourseInput = {
    where: CertificateWhereUniqueInput
    data: XOR<CertificateUpdateWithoutCourseInput, CertificateUncheckedUpdateWithoutCourseInput>
  }

  export type CertificateUpdateManyWithWhereWithoutCourseInput = {
    where: CertificateScalarWhereInput
    data: XOR<CertificateUpdateManyMutationInput, CertificateUncheckedUpdateManyWithoutCourseInput>
  }

  export type BundleCourseUpsertWithWhereUniqueWithoutCourseInput = {
    where: BundleCourseWhereUniqueInput
    update: XOR<BundleCourseUpdateWithoutCourseInput, BundleCourseUncheckedUpdateWithoutCourseInput>
    create: XOR<BundleCourseCreateWithoutCourseInput, BundleCourseUncheckedCreateWithoutCourseInput>
  }

  export type BundleCourseUpdateWithWhereUniqueWithoutCourseInput = {
    where: BundleCourseWhereUniqueInput
    data: XOR<BundleCourseUpdateWithoutCourseInput, BundleCourseUncheckedUpdateWithoutCourseInput>
  }

  export type BundleCourseUpdateManyWithWhereWithoutCourseInput = {
    where: BundleCourseScalarWhereInput
    data: XOR<BundleCourseUpdateManyMutationInput, BundleCourseUncheckedUpdateManyWithoutCourseInput>
  }

  export type BundleCourseScalarWhereInput = {
    AND?: BundleCourseScalarWhereInput | BundleCourseScalarWhereInput[]
    OR?: BundleCourseScalarWhereInput[]
    NOT?: BundleCourseScalarWhereInput | BundleCourseScalarWhereInput[]
    bundleId?: StringFilter<"BundleCourse"> | string
    courseId?: StringFilter<"BundleCourse"> | string
  }

  export type CalendarEventUpsertWithWhereUniqueWithoutCourseInput = {
    where: CalendarEventWhereUniqueInput
    update: XOR<CalendarEventUpdateWithoutCourseInput, CalendarEventUncheckedUpdateWithoutCourseInput>
    create: XOR<CalendarEventCreateWithoutCourseInput, CalendarEventUncheckedCreateWithoutCourseInput>
  }

  export type CalendarEventUpdateWithWhereUniqueWithoutCourseInput = {
    where: CalendarEventWhereUniqueInput
    data: XOR<CalendarEventUpdateWithoutCourseInput, CalendarEventUncheckedUpdateWithoutCourseInput>
  }

  export type CalendarEventUpdateManyWithWhereWithoutCourseInput = {
    where: CalendarEventScalarWhereInput
    data: XOR<CalendarEventUpdateManyMutationInput, CalendarEventUncheckedUpdateManyWithoutCourseInput>
  }

  export type CourseCreateWithoutTopicsInput = {
    id?: string
    title: string
    description?: string | null
    subject: string
    image?: string | null
    price: Decimal | DecimalJsLike | number | string
    pointsPrice: number
    students?: number
    rating?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.CourseStatus
    featured?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teacher: UserCreateNestedOneWithoutCoursesInput
    enrollments?: EnrollmentCreateNestedManyWithoutCourseInput
    savedBy?: SavedCourseCreateNestedManyWithoutCourseInput
    likedBy?: LikedCourseCreateNestedManyWithoutCourseInput
    reviews?: CourseReviewCreateNestedManyWithoutCourseInput
    lessons?: LessonCreateNestedManyWithoutCourseInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutCourseInput
    certificates?: CertificateCreateNestedManyWithoutCourseInput
    bundleCourses?: BundleCourseCreateNestedManyWithoutCourseInput
    calendarEvents?: CalendarEventCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutTopicsInput = {
    id?: string
    title: string
    description?: string | null
    subject: string
    image?: string | null
    price: Decimal | DecimalJsLike | number | string
    pointsPrice: number
    teacherId: string
    students?: number
    rating?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.CourseStatus
    featured?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutCourseInput
    savedBy?: SavedCourseUncheckedCreateNestedManyWithoutCourseInput
    likedBy?: LikedCourseUncheckedCreateNestedManyWithoutCourseInput
    reviews?: CourseReviewUncheckedCreateNestedManyWithoutCourseInput
    lessons?: LessonUncheckedCreateNestedManyWithoutCourseInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutCourseInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutCourseInput
    bundleCourses?: BundleCourseUncheckedCreateNestedManyWithoutCourseInput
    calendarEvents?: CalendarEventUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutTopicsInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutTopicsInput, CourseUncheckedCreateWithoutTopicsInput>
  }

  export type LessonCreateWithoutTopicInput = {
    id?: string
    title: string
    description?: string | null
    videoUrl?: string | null
    content?: string | null
    duration?: number | null
    orderIndex: number
    type: $Enums.LessonType
    quiz?: QuizCreateNestedOneWithoutLessonInput
    assignment?: AssignmentCreateNestedOneWithoutLessonInput
    progress?: LessonProgressCreateNestedManyWithoutLessonInput
    calendarEvents?: CalendarEventCreateNestedManyWithoutLessonInput
    course?: CourseCreateNestedOneWithoutLessonsInput
  }

  export type LessonUncheckedCreateWithoutTopicInput = {
    id?: string
    title: string
    description?: string | null
    videoUrl?: string | null
    content?: string | null
    duration?: number | null
    orderIndex: number
    type: $Enums.LessonType
    courseId?: string | null
    quiz?: QuizUncheckedCreateNestedOneWithoutLessonInput
    assignment?: AssignmentUncheckedCreateNestedOneWithoutLessonInput
    progress?: LessonProgressUncheckedCreateNestedManyWithoutLessonInput
    calendarEvents?: CalendarEventUncheckedCreateNestedManyWithoutLessonInput
  }

  export type LessonCreateOrConnectWithoutTopicInput = {
    where: LessonWhereUniqueInput
    create: XOR<LessonCreateWithoutTopicInput, LessonUncheckedCreateWithoutTopicInput>
  }

  export type LessonCreateManyTopicInputEnvelope = {
    data: LessonCreateManyTopicInput | LessonCreateManyTopicInput[]
    skipDuplicates?: boolean
  }

  export type CourseUpsertWithoutTopicsInput = {
    update: XOR<CourseUpdateWithoutTopicsInput, CourseUncheckedUpdateWithoutTopicsInput>
    create: XOR<CourseCreateWithoutTopicsInput, CourseUncheckedCreateWithoutTopicsInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutTopicsInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutTopicsInput, CourseUncheckedUpdateWithoutTopicsInput>
  }

  export type CourseUpdateWithoutTopicsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pointsPrice?: IntFieldUpdateOperationsInput | number
    students?: IntFieldUpdateOperationsInput | number
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumCourseStatusFieldUpdateOperationsInput | $Enums.CourseStatus
    featured?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher?: UserUpdateOneRequiredWithoutCoursesNestedInput
    enrollments?: EnrollmentUpdateManyWithoutCourseNestedInput
    savedBy?: SavedCourseUpdateManyWithoutCourseNestedInput
    likedBy?: LikedCourseUpdateManyWithoutCourseNestedInput
    reviews?: CourseReviewUpdateManyWithoutCourseNestedInput
    lessons?: LessonUpdateManyWithoutCourseNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutCourseNestedInput
    certificates?: CertificateUpdateManyWithoutCourseNestedInput
    bundleCourses?: BundleCourseUpdateManyWithoutCourseNestedInput
    calendarEvents?: CalendarEventUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutTopicsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pointsPrice?: IntFieldUpdateOperationsInput | number
    teacherId?: StringFieldUpdateOperationsInput | string
    students?: IntFieldUpdateOperationsInput | number
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumCourseStatusFieldUpdateOperationsInput | $Enums.CourseStatus
    featured?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: EnrollmentUncheckedUpdateManyWithoutCourseNestedInput
    savedBy?: SavedCourseUncheckedUpdateManyWithoutCourseNestedInput
    likedBy?: LikedCourseUncheckedUpdateManyWithoutCourseNestedInput
    reviews?: CourseReviewUncheckedUpdateManyWithoutCourseNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutCourseNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutCourseNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutCourseNestedInput
    bundleCourses?: BundleCourseUncheckedUpdateManyWithoutCourseNestedInput
    calendarEvents?: CalendarEventUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type LessonUpsertWithWhereUniqueWithoutTopicInput = {
    where: LessonWhereUniqueInput
    update: XOR<LessonUpdateWithoutTopicInput, LessonUncheckedUpdateWithoutTopicInput>
    create: XOR<LessonCreateWithoutTopicInput, LessonUncheckedCreateWithoutTopicInput>
  }

  export type LessonUpdateWithWhereUniqueWithoutTopicInput = {
    where: LessonWhereUniqueInput
    data: XOR<LessonUpdateWithoutTopicInput, LessonUncheckedUpdateWithoutTopicInput>
  }

  export type LessonUpdateManyWithWhereWithoutTopicInput = {
    where: LessonScalarWhereInput
    data: XOR<LessonUpdateManyMutationInput, LessonUncheckedUpdateManyWithoutTopicInput>
  }

  export type TopicCreateWithoutLessonsInput = {
    id?: string
    title: string
    description?: string | null
    orderIndex: number
    course: CourseCreateNestedOneWithoutTopicsInput
  }

  export type TopicUncheckedCreateWithoutLessonsInput = {
    id?: string
    courseId: string
    title: string
    description?: string | null
    orderIndex: number
  }

  export type TopicCreateOrConnectWithoutLessonsInput = {
    where: TopicWhereUniqueInput
    create: XOR<TopicCreateWithoutLessonsInput, TopicUncheckedCreateWithoutLessonsInput>
  }

  export type QuizCreateWithoutLessonInput = {
    id?: string
    title: string
    description?: string | null
    timeLimit?: number | null
    questions?: QuestionCreateNestedManyWithoutQuizInput
    attempts?: QuizAttemptCreateNestedManyWithoutQuizInput
  }

  export type QuizUncheckedCreateWithoutLessonInput = {
    id?: string
    title: string
    description?: string | null
    timeLimit?: number | null
    questions?: QuestionUncheckedCreateNestedManyWithoutQuizInput
    attempts?: QuizAttemptUncheckedCreateNestedManyWithoutQuizInput
  }

  export type QuizCreateOrConnectWithoutLessonInput = {
    where: QuizWhereUniqueInput
    create: XOR<QuizCreateWithoutLessonInput, QuizUncheckedCreateWithoutLessonInput>
  }

  export type AssignmentCreateWithoutLessonInput = {
    id?: string
    title: string
    description?: string | null
    dueDate?: Date | string | null
    maxScore: number
    allowFileUpload?: boolean
    allowedFileTypes?: AssignmentCreateallowedFileTypesInput | string[]
    unitTests?: NullableJsonNullValueInput | InputJsonValue
    submissions?: AssignmentSubmissionCreateNestedManyWithoutAssignmentInput
  }

  export type AssignmentUncheckedCreateWithoutLessonInput = {
    id?: string
    title: string
    description?: string | null
    dueDate?: Date | string | null
    maxScore: number
    allowFileUpload?: boolean
    allowedFileTypes?: AssignmentCreateallowedFileTypesInput | string[]
    unitTests?: NullableJsonNullValueInput | InputJsonValue
    submissions?: AssignmentSubmissionUncheckedCreateNestedManyWithoutAssignmentInput
  }

  export type AssignmentCreateOrConnectWithoutLessonInput = {
    where: AssignmentWhereUniqueInput
    create: XOR<AssignmentCreateWithoutLessonInput, AssignmentUncheckedCreateWithoutLessonInput>
  }

  export type LessonProgressCreateWithoutLessonInput = {
    id?: string
    completed?: boolean
    completedAt?: Date | string | null
    lastPosition?: number
    user: UserCreateNestedOneWithoutLessonProgressInput
  }

  export type LessonProgressUncheckedCreateWithoutLessonInput = {
    id?: string
    userId: string
    completed?: boolean
    completedAt?: Date | string | null
    lastPosition?: number
  }

  export type LessonProgressCreateOrConnectWithoutLessonInput = {
    where: LessonProgressWhereUniqueInput
    create: XOR<LessonProgressCreateWithoutLessonInput, LessonProgressUncheckedCreateWithoutLessonInput>
  }

  export type LessonProgressCreateManyLessonInputEnvelope = {
    data: LessonProgressCreateManyLessonInput | LessonProgressCreateManyLessonInput[]
    skipDuplicates?: boolean
  }

  export type CalendarEventCreateWithoutLessonInput = {
    id?: string
    title: string
    description?: string | null
    type: string
    startTime: Date | string
    endTime?: Date | string | null
    location?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutCalendarEventsInput
    course?: CourseCreateNestedOneWithoutCalendarEventsInput
    teacher?: UserCreateNestedOneWithoutEventsAsTeacherInput
    student?: UserCreateNestedOneWithoutEventsAsStudentInput
  }

  export type CalendarEventUncheckedCreateWithoutLessonInput = {
    id?: string
    userId: string
    title: string
    description?: string | null
    type: string
    startTime: Date | string
    endTime?: Date | string | null
    courseId?: string | null
    teacherId?: string | null
    studentId?: string | null
    location?: string | null
    createdAt?: Date | string
  }

  export type CalendarEventCreateOrConnectWithoutLessonInput = {
    where: CalendarEventWhereUniqueInput
    create: XOR<CalendarEventCreateWithoutLessonInput, CalendarEventUncheckedCreateWithoutLessonInput>
  }

  export type CalendarEventCreateManyLessonInputEnvelope = {
    data: CalendarEventCreateManyLessonInput | CalendarEventCreateManyLessonInput[]
    skipDuplicates?: boolean
  }

  export type CourseCreateWithoutLessonsInput = {
    id?: string
    title: string
    description?: string | null
    subject: string
    image?: string | null
    price: Decimal | DecimalJsLike | number | string
    pointsPrice: number
    students?: number
    rating?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.CourseStatus
    featured?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teacher: UserCreateNestedOneWithoutCoursesInput
    topics?: TopicCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentCreateNestedManyWithoutCourseInput
    savedBy?: SavedCourseCreateNestedManyWithoutCourseInput
    likedBy?: LikedCourseCreateNestedManyWithoutCourseInput
    reviews?: CourseReviewCreateNestedManyWithoutCourseInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutCourseInput
    certificates?: CertificateCreateNestedManyWithoutCourseInput
    bundleCourses?: BundleCourseCreateNestedManyWithoutCourseInput
    calendarEvents?: CalendarEventCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutLessonsInput = {
    id?: string
    title: string
    description?: string | null
    subject: string
    image?: string | null
    price: Decimal | DecimalJsLike | number | string
    pointsPrice: number
    teacherId: string
    students?: number
    rating?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.CourseStatus
    featured?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    topics?: TopicUncheckedCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutCourseInput
    savedBy?: SavedCourseUncheckedCreateNestedManyWithoutCourseInput
    likedBy?: LikedCourseUncheckedCreateNestedManyWithoutCourseInput
    reviews?: CourseReviewUncheckedCreateNestedManyWithoutCourseInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutCourseInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutCourseInput
    bundleCourses?: BundleCourseUncheckedCreateNestedManyWithoutCourseInput
    calendarEvents?: CalendarEventUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutLessonsInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutLessonsInput, CourseUncheckedCreateWithoutLessonsInput>
  }

  export type TopicUpsertWithoutLessonsInput = {
    update: XOR<TopicUpdateWithoutLessonsInput, TopicUncheckedUpdateWithoutLessonsInput>
    create: XOR<TopicCreateWithoutLessonsInput, TopicUncheckedCreateWithoutLessonsInput>
    where?: TopicWhereInput
  }

  export type TopicUpdateToOneWithWhereWithoutLessonsInput = {
    where?: TopicWhereInput
    data: XOR<TopicUpdateWithoutLessonsInput, TopicUncheckedUpdateWithoutLessonsInput>
  }

  export type TopicUpdateWithoutLessonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    orderIndex?: IntFieldUpdateOperationsInput | number
    course?: CourseUpdateOneRequiredWithoutTopicsNestedInput
  }

  export type TopicUncheckedUpdateWithoutLessonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    orderIndex?: IntFieldUpdateOperationsInput | number
  }

  export type QuizUpsertWithoutLessonInput = {
    update: XOR<QuizUpdateWithoutLessonInput, QuizUncheckedUpdateWithoutLessonInput>
    create: XOR<QuizCreateWithoutLessonInput, QuizUncheckedCreateWithoutLessonInput>
    where?: QuizWhereInput
  }

  export type QuizUpdateToOneWithWhereWithoutLessonInput = {
    where?: QuizWhereInput
    data: XOR<QuizUpdateWithoutLessonInput, QuizUncheckedUpdateWithoutLessonInput>
  }

  export type QuizUpdateWithoutLessonInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    questions?: QuestionUpdateManyWithoutQuizNestedInput
    attempts?: QuizAttemptUpdateManyWithoutQuizNestedInput
  }

  export type QuizUncheckedUpdateWithoutLessonInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    questions?: QuestionUncheckedUpdateManyWithoutQuizNestedInput
    attempts?: QuizAttemptUncheckedUpdateManyWithoutQuizNestedInput
  }

  export type AssignmentUpsertWithoutLessonInput = {
    update: XOR<AssignmentUpdateWithoutLessonInput, AssignmentUncheckedUpdateWithoutLessonInput>
    create: XOR<AssignmentCreateWithoutLessonInput, AssignmentUncheckedCreateWithoutLessonInput>
    where?: AssignmentWhereInput
  }

  export type AssignmentUpdateToOneWithWhereWithoutLessonInput = {
    where?: AssignmentWhereInput
    data: XOR<AssignmentUpdateWithoutLessonInput, AssignmentUncheckedUpdateWithoutLessonInput>
  }

  export type AssignmentUpdateWithoutLessonInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxScore?: IntFieldUpdateOperationsInput | number
    allowFileUpload?: BoolFieldUpdateOperationsInput | boolean
    allowedFileTypes?: AssignmentUpdateallowedFileTypesInput | string[]
    unitTests?: NullableJsonNullValueInput | InputJsonValue
    submissions?: AssignmentSubmissionUpdateManyWithoutAssignmentNestedInput
  }

  export type AssignmentUncheckedUpdateWithoutLessonInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxScore?: IntFieldUpdateOperationsInput | number
    allowFileUpload?: BoolFieldUpdateOperationsInput | boolean
    allowedFileTypes?: AssignmentUpdateallowedFileTypesInput | string[]
    unitTests?: NullableJsonNullValueInput | InputJsonValue
    submissions?: AssignmentSubmissionUncheckedUpdateManyWithoutAssignmentNestedInput
  }

  export type LessonProgressUpsertWithWhereUniqueWithoutLessonInput = {
    where: LessonProgressWhereUniqueInput
    update: XOR<LessonProgressUpdateWithoutLessonInput, LessonProgressUncheckedUpdateWithoutLessonInput>
    create: XOR<LessonProgressCreateWithoutLessonInput, LessonProgressUncheckedCreateWithoutLessonInput>
  }

  export type LessonProgressUpdateWithWhereUniqueWithoutLessonInput = {
    where: LessonProgressWhereUniqueInput
    data: XOR<LessonProgressUpdateWithoutLessonInput, LessonProgressUncheckedUpdateWithoutLessonInput>
  }

  export type LessonProgressUpdateManyWithWhereWithoutLessonInput = {
    where: LessonProgressScalarWhereInput
    data: XOR<LessonProgressUpdateManyMutationInput, LessonProgressUncheckedUpdateManyWithoutLessonInput>
  }

  export type CalendarEventUpsertWithWhereUniqueWithoutLessonInput = {
    where: CalendarEventWhereUniqueInput
    update: XOR<CalendarEventUpdateWithoutLessonInput, CalendarEventUncheckedUpdateWithoutLessonInput>
    create: XOR<CalendarEventCreateWithoutLessonInput, CalendarEventUncheckedCreateWithoutLessonInput>
  }

  export type CalendarEventUpdateWithWhereUniqueWithoutLessonInput = {
    where: CalendarEventWhereUniqueInput
    data: XOR<CalendarEventUpdateWithoutLessonInput, CalendarEventUncheckedUpdateWithoutLessonInput>
  }

  export type CalendarEventUpdateManyWithWhereWithoutLessonInput = {
    where: CalendarEventScalarWhereInput
    data: XOR<CalendarEventUpdateManyMutationInput, CalendarEventUncheckedUpdateManyWithoutLessonInput>
  }

  export type CourseUpsertWithoutLessonsInput = {
    update: XOR<CourseUpdateWithoutLessonsInput, CourseUncheckedUpdateWithoutLessonsInput>
    create: XOR<CourseCreateWithoutLessonsInput, CourseUncheckedCreateWithoutLessonsInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutLessonsInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutLessonsInput, CourseUncheckedUpdateWithoutLessonsInput>
  }

  export type CourseUpdateWithoutLessonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pointsPrice?: IntFieldUpdateOperationsInput | number
    students?: IntFieldUpdateOperationsInput | number
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumCourseStatusFieldUpdateOperationsInput | $Enums.CourseStatus
    featured?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher?: UserUpdateOneRequiredWithoutCoursesNestedInput
    topics?: TopicUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUpdateManyWithoutCourseNestedInput
    savedBy?: SavedCourseUpdateManyWithoutCourseNestedInput
    likedBy?: LikedCourseUpdateManyWithoutCourseNestedInput
    reviews?: CourseReviewUpdateManyWithoutCourseNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutCourseNestedInput
    certificates?: CertificateUpdateManyWithoutCourseNestedInput
    bundleCourses?: BundleCourseUpdateManyWithoutCourseNestedInput
    calendarEvents?: CalendarEventUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutLessonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pointsPrice?: IntFieldUpdateOperationsInput | number
    teacherId?: StringFieldUpdateOperationsInput | string
    students?: IntFieldUpdateOperationsInput | number
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumCourseStatusFieldUpdateOperationsInput | $Enums.CourseStatus
    featured?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    topics?: TopicUncheckedUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutCourseNestedInput
    savedBy?: SavedCourseUncheckedUpdateManyWithoutCourseNestedInput
    likedBy?: LikedCourseUncheckedUpdateManyWithoutCourseNestedInput
    reviews?: CourseReviewUncheckedUpdateManyWithoutCourseNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutCourseNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutCourseNestedInput
    bundleCourses?: BundleCourseUncheckedUpdateManyWithoutCourseNestedInput
    calendarEvents?: CalendarEventUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type LessonCreateWithoutQuizInput = {
    id?: string
    title: string
    description?: string | null
    videoUrl?: string | null
    content?: string | null
    duration?: number | null
    orderIndex: number
    type: $Enums.LessonType
    topic: TopicCreateNestedOneWithoutLessonsInput
    assignment?: AssignmentCreateNestedOneWithoutLessonInput
    progress?: LessonProgressCreateNestedManyWithoutLessonInput
    calendarEvents?: CalendarEventCreateNestedManyWithoutLessonInput
    course?: CourseCreateNestedOneWithoutLessonsInput
  }

  export type LessonUncheckedCreateWithoutQuizInput = {
    id?: string
    topicId: string
    title: string
    description?: string | null
    videoUrl?: string | null
    content?: string | null
    duration?: number | null
    orderIndex: number
    type: $Enums.LessonType
    courseId?: string | null
    assignment?: AssignmentUncheckedCreateNestedOneWithoutLessonInput
    progress?: LessonProgressUncheckedCreateNestedManyWithoutLessonInput
    calendarEvents?: CalendarEventUncheckedCreateNestedManyWithoutLessonInput
  }

  export type LessonCreateOrConnectWithoutQuizInput = {
    where: LessonWhereUniqueInput
    create: XOR<LessonCreateWithoutQuizInput, LessonUncheckedCreateWithoutQuizInput>
  }

  export type QuestionCreateWithoutQuizInput = {
    id?: string
    questionText: string
    type: $Enums.QuestionType
    options: JsonNullValueInput | InputJsonValue
    correctOptions?: QuestionCreatecorrectOptionsInput | number[]
    orderIndex?: number | null
  }

  export type QuestionUncheckedCreateWithoutQuizInput = {
    id?: string
    questionText: string
    type: $Enums.QuestionType
    options: JsonNullValueInput | InputJsonValue
    correctOptions?: QuestionCreatecorrectOptionsInput | number[]
    orderIndex?: number | null
  }

  export type QuestionCreateOrConnectWithoutQuizInput = {
    where: QuestionWhereUniqueInput
    create: XOR<QuestionCreateWithoutQuizInput, QuestionUncheckedCreateWithoutQuizInput>
  }

  export type QuestionCreateManyQuizInputEnvelope = {
    data: QuestionCreateManyQuizInput | QuestionCreateManyQuizInput[]
    skipDuplicates?: boolean
  }

  export type QuizAttemptCreateWithoutQuizInput = {
    id?: string
    score: number
    duration?: number | null
    completedAt?: Date | string
    answers: JsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutQuizAttemptsInput
    course?: CourseCreateNestedOneWithoutQuizAttemptsInput
  }

  export type QuizAttemptUncheckedCreateWithoutQuizInput = {
    id?: string
    userId: string
    score: number
    duration?: number | null
    completedAt?: Date | string
    answers: JsonNullValueInput | InputJsonValue
    courseId?: string | null
  }

  export type QuizAttemptCreateOrConnectWithoutQuizInput = {
    where: QuizAttemptWhereUniqueInput
    create: XOR<QuizAttemptCreateWithoutQuizInput, QuizAttemptUncheckedCreateWithoutQuizInput>
  }

  export type QuizAttemptCreateManyQuizInputEnvelope = {
    data: QuizAttemptCreateManyQuizInput | QuizAttemptCreateManyQuizInput[]
    skipDuplicates?: boolean
  }

  export type LessonUpsertWithoutQuizInput = {
    update: XOR<LessonUpdateWithoutQuizInput, LessonUncheckedUpdateWithoutQuizInput>
    create: XOR<LessonCreateWithoutQuizInput, LessonUncheckedCreateWithoutQuizInput>
    where?: LessonWhereInput
  }

  export type LessonUpdateToOneWithWhereWithoutQuizInput = {
    where?: LessonWhereInput
    data: XOR<LessonUpdateWithoutQuizInput, LessonUncheckedUpdateWithoutQuizInput>
  }

  export type LessonUpdateWithoutQuizInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    orderIndex?: IntFieldUpdateOperationsInput | number
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    topic?: TopicUpdateOneRequiredWithoutLessonsNestedInput
    assignment?: AssignmentUpdateOneWithoutLessonNestedInput
    progress?: LessonProgressUpdateManyWithoutLessonNestedInput
    calendarEvents?: CalendarEventUpdateManyWithoutLessonNestedInput
    course?: CourseUpdateOneWithoutLessonsNestedInput
  }

  export type LessonUncheckedUpdateWithoutQuizInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    orderIndex?: IntFieldUpdateOperationsInput | number
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    assignment?: AssignmentUncheckedUpdateOneWithoutLessonNestedInput
    progress?: LessonProgressUncheckedUpdateManyWithoutLessonNestedInput
    calendarEvents?: CalendarEventUncheckedUpdateManyWithoutLessonNestedInput
  }

  export type QuestionUpsertWithWhereUniqueWithoutQuizInput = {
    where: QuestionWhereUniqueInput
    update: XOR<QuestionUpdateWithoutQuizInput, QuestionUncheckedUpdateWithoutQuizInput>
    create: XOR<QuestionCreateWithoutQuizInput, QuestionUncheckedCreateWithoutQuizInput>
  }

  export type QuestionUpdateWithWhereUniqueWithoutQuizInput = {
    where: QuestionWhereUniqueInput
    data: XOR<QuestionUpdateWithoutQuizInput, QuestionUncheckedUpdateWithoutQuizInput>
  }

  export type QuestionUpdateManyWithWhereWithoutQuizInput = {
    where: QuestionScalarWhereInput
    data: XOR<QuestionUpdateManyMutationInput, QuestionUncheckedUpdateManyWithoutQuizInput>
  }

  export type QuestionScalarWhereInput = {
    AND?: QuestionScalarWhereInput | QuestionScalarWhereInput[]
    OR?: QuestionScalarWhereInput[]
    NOT?: QuestionScalarWhereInput | QuestionScalarWhereInput[]
    id?: StringFilter<"Question"> | string
    quizId?: StringFilter<"Question"> | string
    questionText?: StringFilter<"Question"> | string
    type?: EnumQuestionTypeFilter<"Question"> | $Enums.QuestionType
    options?: JsonFilter<"Question">
    correctOptions?: IntNullableListFilter<"Question">
    orderIndex?: IntNullableFilter<"Question"> | number | null
  }

  export type QuizAttemptUpsertWithWhereUniqueWithoutQuizInput = {
    where: QuizAttemptWhereUniqueInput
    update: XOR<QuizAttemptUpdateWithoutQuizInput, QuizAttemptUncheckedUpdateWithoutQuizInput>
    create: XOR<QuizAttemptCreateWithoutQuizInput, QuizAttemptUncheckedCreateWithoutQuizInput>
  }

  export type QuizAttemptUpdateWithWhereUniqueWithoutQuizInput = {
    where: QuizAttemptWhereUniqueInput
    data: XOR<QuizAttemptUpdateWithoutQuizInput, QuizAttemptUncheckedUpdateWithoutQuizInput>
  }

  export type QuizAttemptUpdateManyWithWhereWithoutQuizInput = {
    where: QuizAttemptScalarWhereInput
    data: XOR<QuizAttemptUpdateManyMutationInput, QuizAttemptUncheckedUpdateManyWithoutQuizInput>
  }

  export type QuizCreateWithoutQuestionsInput = {
    id?: string
    title: string
    description?: string | null
    timeLimit?: number | null
    lesson: LessonCreateNestedOneWithoutQuizInput
    attempts?: QuizAttemptCreateNestedManyWithoutQuizInput
  }

  export type QuizUncheckedCreateWithoutQuestionsInput = {
    id?: string
    lessonId: string
    title: string
    description?: string | null
    timeLimit?: number | null
    attempts?: QuizAttemptUncheckedCreateNestedManyWithoutQuizInput
  }

  export type QuizCreateOrConnectWithoutQuestionsInput = {
    where: QuizWhereUniqueInput
    create: XOR<QuizCreateWithoutQuestionsInput, QuizUncheckedCreateWithoutQuestionsInput>
  }

  export type QuizUpsertWithoutQuestionsInput = {
    update: XOR<QuizUpdateWithoutQuestionsInput, QuizUncheckedUpdateWithoutQuestionsInput>
    create: XOR<QuizCreateWithoutQuestionsInput, QuizUncheckedCreateWithoutQuestionsInput>
    where?: QuizWhereInput
  }

  export type QuizUpdateToOneWithWhereWithoutQuestionsInput = {
    where?: QuizWhereInput
    data: XOR<QuizUpdateWithoutQuestionsInput, QuizUncheckedUpdateWithoutQuestionsInput>
  }

  export type QuizUpdateWithoutQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    lesson?: LessonUpdateOneRequiredWithoutQuizNestedInput
    attempts?: QuizAttemptUpdateManyWithoutQuizNestedInput
  }

  export type QuizUncheckedUpdateWithoutQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    lessonId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    attempts?: QuizAttemptUncheckedUpdateManyWithoutQuizNestedInput
  }

  export type LessonCreateWithoutAssignmentInput = {
    id?: string
    title: string
    description?: string | null
    videoUrl?: string | null
    content?: string | null
    duration?: number | null
    orderIndex: number
    type: $Enums.LessonType
    topic: TopicCreateNestedOneWithoutLessonsInput
    quiz?: QuizCreateNestedOneWithoutLessonInput
    progress?: LessonProgressCreateNestedManyWithoutLessonInput
    calendarEvents?: CalendarEventCreateNestedManyWithoutLessonInput
    course?: CourseCreateNestedOneWithoutLessonsInput
  }

  export type LessonUncheckedCreateWithoutAssignmentInput = {
    id?: string
    topicId: string
    title: string
    description?: string | null
    videoUrl?: string | null
    content?: string | null
    duration?: number | null
    orderIndex: number
    type: $Enums.LessonType
    courseId?: string | null
    quiz?: QuizUncheckedCreateNestedOneWithoutLessonInput
    progress?: LessonProgressUncheckedCreateNestedManyWithoutLessonInput
    calendarEvents?: CalendarEventUncheckedCreateNestedManyWithoutLessonInput
  }

  export type LessonCreateOrConnectWithoutAssignmentInput = {
    where: LessonWhereUniqueInput
    create: XOR<LessonCreateWithoutAssignmentInput, LessonUncheckedCreateWithoutAssignmentInput>
  }

  export type AssignmentSubmissionCreateWithoutAssignmentInput = {
    id?: string
    content?: string | null
    fileUrls?: AssignmentSubmissionCreatefileUrlsInput | string[]
    submittedAt?: Date | string
    score?: number | null
    feedback?: string | null
    gradedAt?: Date | string | null
    user: UserCreateNestedOneWithoutAssignmentSubsInput
    gradedBy?: UserCreateNestedOneWithoutSubmissionsGradedInput
  }

  export type AssignmentSubmissionUncheckedCreateWithoutAssignmentInput = {
    id?: string
    userId: string
    content?: string | null
    fileUrls?: AssignmentSubmissionCreatefileUrlsInput | string[]
    submittedAt?: Date | string
    score?: number | null
    feedback?: string | null
    gradedAt?: Date | string | null
    gradedById?: string | null
  }

  export type AssignmentSubmissionCreateOrConnectWithoutAssignmentInput = {
    where: AssignmentSubmissionWhereUniqueInput
    create: XOR<AssignmentSubmissionCreateWithoutAssignmentInput, AssignmentSubmissionUncheckedCreateWithoutAssignmentInput>
  }

  export type AssignmentSubmissionCreateManyAssignmentInputEnvelope = {
    data: AssignmentSubmissionCreateManyAssignmentInput | AssignmentSubmissionCreateManyAssignmentInput[]
    skipDuplicates?: boolean
  }

  export type LessonUpsertWithoutAssignmentInput = {
    update: XOR<LessonUpdateWithoutAssignmentInput, LessonUncheckedUpdateWithoutAssignmentInput>
    create: XOR<LessonCreateWithoutAssignmentInput, LessonUncheckedCreateWithoutAssignmentInput>
    where?: LessonWhereInput
  }

  export type LessonUpdateToOneWithWhereWithoutAssignmentInput = {
    where?: LessonWhereInput
    data: XOR<LessonUpdateWithoutAssignmentInput, LessonUncheckedUpdateWithoutAssignmentInput>
  }

  export type LessonUpdateWithoutAssignmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    orderIndex?: IntFieldUpdateOperationsInput | number
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    topic?: TopicUpdateOneRequiredWithoutLessonsNestedInput
    quiz?: QuizUpdateOneWithoutLessonNestedInput
    progress?: LessonProgressUpdateManyWithoutLessonNestedInput
    calendarEvents?: CalendarEventUpdateManyWithoutLessonNestedInput
    course?: CourseUpdateOneWithoutLessonsNestedInput
  }

  export type LessonUncheckedUpdateWithoutAssignmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    orderIndex?: IntFieldUpdateOperationsInput | number
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    quiz?: QuizUncheckedUpdateOneWithoutLessonNestedInput
    progress?: LessonProgressUncheckedUpdateManyWithoutLessonNestedInput
    calendarEvents?: CalendarEventUncheckedUpdateManyWithoutLessonNestedInput
  }

  export type AssignmentSubmissionUpsertWithWhereUniqueWithoutAssignmentInput = {
    where: AssignmentSubmissionWhereUniqueInput
    update: XOR<AssignmentSubmissionUpdateWithoutAssignmentInput, AssignmentSubmissionUncheckedUpdateWithoutAssignmentInput>
    create: XOR<AssignmentSubmissionCreateWithoutAssignmentInput, AssignmentSubmissionUncheckedCreateWithoutAssignmentInput>
  }

  export type AssignmentSubmissionUpdateWithWhereUniqueWithoutAssignmentInput = {
    where: AssignmentSubmissionWhereUniqueInput
    data: XOR<AssignmentSubmissionUpdateWithoutAssignmentInput, AssignmentSubmissionUncheckedUpdateWithoutAssignmentInput>
  }

  export type AssignmentSubmissionUpdateManyWithWhereWithoutAssignmentInput = {
    where: AssignmentSubmissionScalarWhereInput
    data: XOR<AssignmentSubmissionUpdateManyMutationInput, AssignmentSubmissionUncheckedUpdateManyWithoutAssignmentInput>
  }

  export type UserCreateWithoutEnrollmentsInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    avatar?: string | null
    bio?: string | null
    createdAt?: Date | string
    points?: number
    referralCode?: string | null
    lastLogin?: Date | string | null
    referredBy?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferredByInput
    teacherProfile?: TeacherProfileCreateNestedOneWithoutUserInput
    availability?: UserAvailabilityCreateNestedManyWithoutUserInput
    pointsTransactions?: PointsTransactionCreateNestedManyWithoutUserInput
    courses?: CourseCreateNestedManyWithoutTeacherInput
    savedCourses?: SavedCourseCreateNestedManyWithoutUserInput
    likedCourses?: LikedCourseCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutUserInput
    assignmentSubs?: AssignmentSubmissionCreateNestedManyWithoutUserInput
    courseReviews?: CourseReviewCreateNestedManyWithoutUserInput
    tutoringSessions?: TutoringSessionCreateNestedManyWithoutTeacherInput
    tutoringRequests?: TutoringRequestCreateNestedManyWithoutStudentInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentCreateNestedManyWithoutTeacherInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentCreateNestedManyWithoutStudentInput
    tutoringReviews?: TutoringReviewCreateNestedManyWithoutStudentInput
    tutoringMessages?: TutoringMessageCreateNestedManyWithoutSenderInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    conversationParts?: ConversationParticipantCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    attachments?: AttachmentCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    subscriptionRecords?: UserSubscriptionCreateNestedManyWithoutUserInput
    bundlesOwned?: UserBundleCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventCreateNestedManyWithoutUserInput
    eventsAsTeacher?: CalendarEventCreateNestedManyWithoutTeacherInput
    eventsAsStudent?: CalendarEventCreateNestedManyWithoutStudentInput
    blogPosts?: BlogPostCreateNestedManyWithoutAuthorInput
    blogComments?: BlogCommentCreateNestedManyWithoutUserInput
    submissionsGraded?: AssignmentSubmissionCreateNestedManyWithoutGradedByInput
    referralCodesOwned?: ReferralCodeCreateNestedManyWithoutUserInput
    referralUsesGained?: ReferralUseCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEnrollmentsInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    avatar?: string | null
    bio?: string | null
    createdAt?: Date | string
    points?: number
    referralCode?: string | null
    referredById?: string | null
    lastLogin?: Date | string | null
    referrals?: UserUncheckedCreateNestedManyWithoutReferredByInput
    teacherProfile?: TeacherProfileUncheckedCreateNestedOneWithoutUserInput
    availability?: UserAvailabilityUncheckedCreateNestedManyWithoutUserInput
    pointsTransactions?: PointsTransactionUncheckedCreateNestedManyWithoutUserInput
    courses?: CourseUncheckedCreateNestedManyWithoutTeacherInput
    savedCourses?: SavedCourseUncheckedCreateNestedManyWithoutUserInput
    likedCourses?: LikedCourseUncheckedCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressUncheckedCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutUserInput
    assignmentSubs?: AssignmentSubmissionUncheckedCreateNestedManyWithoutUserInput
    courseReviews?: CourseReviewUncheckedCreateNestedManyWithoutUserInput
    tutoringSessions?: TutoringSessionUncheckedCreateNestedManyWithoutTeacherInput
    tutoringRequests?: TutoringRequestUncheckedCreateNestedManyWithoutStudentInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUncheckedCreateNestedManyWithoutTeacherInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUncheckedCreateNestedManyWithoutStudentInput
    tutoringReviews?: TutoringReviewUncheckedCreateNestedManyWithoutStudentInput
    tutoringMessages?: TutoringMessageUncheckedCreateNestedManyWithoutSenderInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    conversationParts?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    subscriptionRecords?: UserSubscriptionUncheckedCreateNestedManyWithoutUserInput
    bundlesOwned?: UserBundleUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventUncheckedCreateNestedManyWithoutUserInput
    eventsAsTeacher?: CalendarEventUncheckedCreateNestedManyWithoutTeacherInput
    eventsAsStudent?: CalendarEventUncheckedCreateNestedManyWithoutStudentInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
    blogComments?: BlogCommentUncheckedCreateNestedManyWithoutUserInput
    submissionsGraded?: AssignmentSubmissionUncheckedCreateNestedManyWithoutGradedByInput
    referralCodesOwned?: ReferralCodeUncheckedCreateNestedManyWithoutUserInput
    referralUsesGained?: ReferralUseUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEnrollmentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEnrollmentsInput, UserUncheckedCreateWithoutEnrollmentsInput>
  }

  export type CourseCreateWithoutEnrollmentsInput = {
    id?: string
    title: string
    description?: string | null
    subject: string
    image?: string | null
    price: Decimal | DecimalJsLike | number | string
    pointsPrice: number
    students?: number
    rating?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.CourseStatus
    featured?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teacher: UserCreateNestedOneWithoutCoursesInput
    topics?: TopicCreateNestedManyWithoutCourseInput
    savedBy?: SavedCourseCreateNestedManyWithoutCourseInput
    likedBy?: LikedCourseCreateNestedManyWithoutCourseInput
    reviews?: CourseReviewCreateNestedManyWithoutCourseInput
    lessons?: LessonCreateNestedManyWithoutCourseInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutCourseInput
    certificates?: CertificateCreateNestedManyWithoutCourseInput
    bundleCourses?: BundleCourseCreateNestedManyWithoutCourseInput
    calendarEvents?: CalendarEventCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutEnrollmentsInput = {
    id?: string
    title: string
    description?: string | null
    subject: string
    image?: string | null
    price: Decimal | DecimalJsLike | number | string
    pointsPrice: number
    teacherId: string
    students?: number
    rating?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.CourseStatus
    featured?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    topics?: TopicUncheckedCreateNestedManyWithoutCourseInput
    savedBy?: SavedCourseUncheckedCreateNestedManyWithoutCourseInput
    likedBy?: LikedCourseUncheckedCreateNestedManyWithoutCourseInput
    reviews?: CourseReviewUncheckedCreateNestedManyWithoutCourseInput
    lessons?: LessonUncheckedCreateNestedManyWithoutCourseInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutCourseInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutCourseInput
    bundleCourses?: BundleCourseUncheckedCreateNestedManyWithoutCourseInput
    calendarEvents?: CalendarEventUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutEnrollmentsInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutEnrollmentsInput, CourseUncheckedCreateWithoutEnrollmentsInput>
  }

  export type UserUpsertWithoutEnrollmentsInput = {
    update: XOR<UserUpdateWithoutEnrollmentsInput, UserUncheckedUpdateWithoutEnrollmentsInput>
    create: XOR<UserCreateWithoutEnrollmentsInput, UserUncheckedCreateWithoutEnrollmentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEnrollmentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEnrollmentsInput, UserUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type UserUpdateWithoutEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: IntFieldUpdateOperationsInput | number
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referredBy?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferredByNestedInput
    teacherProfile?: TeacherProfileUpdateOneWithoutUserNestedInput
    availability?: UserAvailabilityUpdateManyWithoutUserNestedInput
    pointsTransactions?: PointsTransactionUpdateManyWithoutUserNestedInput
    courses?: CourseUpdateManyWithoutTeacherNestedInput
    savedCourses?: SavedCourseUpdateManyWithoutUserNestedInput
    likedCourses?: LikedCourseUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutUserNestedInput
    assignmentSubs?: AssignmentSubmissionUpdateManyWithoutUserNestedInput
    courseReviews?: CourseReviewUpdateManyWithoutUserNestedInput
    tutoringSessions?: TutoringSessionUpdateManyWithoutTeacherNestedInput
    tutoringRequests?: TutoringRequestUpdateManyWithoutStudentNestedInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUpdateManyWithoutTeacherNestedInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUpdateManyWithoutStudentNestedInput
    tutoringReviews?: TutoringReviewUpdateManyWithoutStudentNestedInput
    tutoringMessages?: TutoringMessageUpdateManyWithoutSenderNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    conversationParts?: ConversationParticipantUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    attachments?: AttachmentUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    subscriptionRecords?: UserSubscriptionUpdateManyWithoutUserNestedInput
    bundlesOwned?: UserBundleUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUpdateManyWithoutUserNestedInput
    eventsAsTeacher?: CalendarEventUpdateManyWithoutTeacherNestedInput
    eventsAsStudent?: CalendarEventUpdateManyWithoutStudentNestedInput
    blogPosts?: BlogPostUpdateManyWithoutAuthorNestedInput
    blogComments?: BlogCommentUpdateManyWithoutUserNestedInput
    submissionsGraded?: AssignmentSubmissionUpdateManyWithoutGradedByNestedInput
    referralCodesOwned?: ReferralCodeUpdateManyWithoutUserNestedInput
    referralUsesGained?: ReferralUseUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: IntFieldUpdateOperationsInput | number
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referrals?: UserUncheckedUpdateManyWithoutReferredByNestedInput
    teacherProfile?: TeacherProfileUncheckedUpdateOneWithoutUserNestedInput
    availability?: UserAvailabilityUncheckedUpdateManyWithoutUserNestedInput
    pointsTransactions?: PointsTransactionUncheckedUpdateManyWithoutUserNestedInput
    courses?: CourseUncheckedUpdateManyWithoutTeacherNestedInput
    savedCourses?: SavedCourseUncheckedUpdateManyWithoutUserNestedInput
    likedCourses?: LikedCourseUncheckedUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUncheckedUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    assignmentSubs?: AssignmentSubmissionUncheckedUpdateManyWithoutUserNestedInput
    courseReviews?: CourseReviewUncheckedUpdateManyWithoutUserNestedInput
    tutoringSessions?: TutoringSessionUncheckedUpdateManyWithoutTeacherNestedInput
    tutoringRequests?: TutoringRequestUncheckedUpdateManyWithoutStudentNestedInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUncheckedUpdateManyWithoutTeacherNestedInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUncheckedUpdateManyWithoutStudentNestedInput
    tutoringReviews?: TutoringReviewUncheckedUpdateManyWithoutStudentNestedInput
    tutoringMessages?: TutoringMessageUncheckedUpdateManyWithoutSenderNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    conversationParts?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    subscriptionRecords?: UserSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    bundlesOwned?: UserBundleUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUncheckedUpdateManyWithoutUserNestedInput
    eventsAsTeacher?: CalendarEventUncheckedUpdateManyWithoutTeacherNestedInput
    eventsAsStudent?: CalendarEventUncheckedUpdateManyWithoutStudentNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
    blogComments?: BlogCommentUncheckedUpdateManyWithoutUserNestedInput
    submissionsGraded?: AssignmentSubmissionUncheckedUpdateManyWithoutGradedByNestedInput
    referralCodesOwned?: ReferralCodeUncheckedUpdateManyWithoutUserNestedInput
    referralUsesGained?: ReferralUseUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CourseUpsertWithoutEnrollmentsInput = {
    update: XOR<CourseUpdateWithoutEnrollmentsInput, CourseUncheckedUpdateWithoutEnrollmentsInput>
    create: XOR<CourseCreateWithoutEnrollmentsInput, CourseUncheckedCreateWithoutEnrollmentsInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutEnrollmentsInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutEnrollmentsInput, CourseUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type CourseUpdateWithoutEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pointsPrice?: IntFieldUpdateOperationsInput | number
    students?: IntFieldUpdateOperationsInput | number
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumCourseStatusFieldUpdateOperationsInput | $Enums.CourseStatus
    featured?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher?: UserUpdateOneRequiredWithoutCoursesNestedInput
    topics?: TopicUpdateManyWithoutCourseNestedInput
    savedBy?: SavedCourseUpdateManyWithoutCourseNestedInput
    likedBy?: LikedCourseUpdateManyWithoutCourseNestedInput
    reviews?: CourseReviewUpdateManyWithoutCourseNestedInput
    lessons?: LessonUpdateManyWithoutCourseNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutCourseNestedInput
    certificates?: CertificateUpdateManyWithoutCourseNestedInput
    bundleCourses?: BundleCourseUpdateManyWithoutCourseNestedInput
    calendarEvents?: CalendarEventUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pointsPrice?: IntFieldUpdateOperationsInput | number
    teacherId?: StringFieldUpdateOperationsInput | string
    students?: IntFieldUpdateOperationsInput | number
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumCourseStatusFieldUpdateOperationsInput | $Enums.CourseStatus
    featured?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    topics?: TopicUncheckedUpdateManyWithoutCourseNestedInput
    savedBy?: SavedCourseUncheckedUpdateManyWithoutCourseNestedInput
    likedBy?: LikedCourseUncheckedUpdateManyWithoutCourseNestedInput
    reviews?: CourseReviewUncheckedUpdateManyWithoutCourseNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutCourseNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutCourseNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutCourseNestedInput
    bundleCourses?: BundleCourseUncheckedUpdateManyWithoutCourseNestedInput
    calendarEvents?: CalendarEventUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type UserCreateWithoutSavedCoursesInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    avatar?: string | null
    bio?: string | null
    createdAt?: Date | string
    points?: number
    referralCode?: string | null
    lastLogin?: Date | string | null
    referredBy?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferredByInput
    teacherProfile?: TeacherProfileCreateNestedOneWithoutUserInput
    availability?: UserAvailabilityCreateNestedManyWithoutUserInput
    pointsTransactions?: PointsTransactionCreateNestedManyWithoutUserInput
    courses?: CourseCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    likedCourses?: LikedCourseCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutUserInput
    assignmentSubs?: AssignmentSubmissionCreateNestedManyWithoutUserInput
    courseReviews?: CourseReviewCreateNestedManyWithoutUserInput
    tutoringSessions?: TutoringSessionCreateNestedManyWithoutTeacherInput
    tutoringRequests?: TutoringRequestCreateNestedManyWithoutStudentInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentCreateNestedManyWithoutTeacherInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentCreateNestedManyWithoutStudentInput
    tutoringReviews?: TutoringReviewCreateNestedManyWithoutStudentInput
    tutoringMessages?: TutoringMessageCreateNestedManyWithoutSenderInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    conversationParts?: ConversationParticipantCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    attachments?: AttachmentCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    subscriptionRecords?: UserSubscriptionCreateNestedManyWithoutUserInput
    bundlesOwned?: UserBundleCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventCreateNestedManyWithoutUserInput
    eventsAsTeacher?: CalendarEventCreateNestedManyWithoutTeacherInput
    eventsAsStudent?: CalendarEventCreateNestedManyWithoutStudentInput
    blogPosts?: BlogPostCreateNestedManyWithoutAuthorInput
    blogComments?: BlogCommentCreateNestedManyWithoutUserInput
    submissionsGraded?: AssignmentSubmissionCreateNestedManyWithoutGradedByInput
    referralCodesOwned?: ReferralCodeCreateNestedManyWithoutUserInput
    referralUsesGained?: ReferralUseCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSavedCoursesInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    avatar?: string | null
    bio?: string | null
    createdAt?: Date | string
    points?: number
    referralCode?: string | null
    referredById?: string | null
    lastLogin?: Date | string | null
    referrals?: UserUncheckedCreateNestedManyWithoutReferredByInput
    teacherProfile?: TeacherProfileUncheckedCreateNestedOneWithoutUserInput
    availability?: UserAvailabilityUncheckedCreateNestedManyWithoutUserInput
    pointsTransactions?: PointsTransactionUncheckedCreateNestedManyWithoutUserInput
    courses?: CourseUncheckedCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    likedCourses?: LikedCourseUncheckedCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressUncheckedCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutUserInput
    assignmentSubs?: AssignmentSubmissionUncheckedCreateNestedManyWithoutUserInput
    courseReviews?: CourseReviewUncheckedCreateNestedManyWithoutUserInput
    tutoringSessions?: TutoringSessionUncheckedCreateNestedManyWithoutTeacherInput
    tutoringRequests?: TutoringRequestUncheckedCreateNestedManyWithoutStudentInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUncheckedCreateNestedManyWithoutTeacherInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUncheckedCreateNestedManyWithoutStudentInput
    tutoringReviews?: TutoringReviewUncheckedCreateNestedManyWithoutStudentInput
    tutoringMessages?: TutoringMessageUncheckedCreateNestedManyWithoutSenderInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    conversationParts?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    subscriptionRecords?: UserSubscriptionUncheckedCreateNestedManyWithoutUserInput
    bundlesOwned?: UserBundleUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventUncheckedCreateNestedManyWithoutUserInput
    eventsAsTeacher?: CalendarEventUncheckedCreateNestedManyWithoutTeacherInput
    eventsAsStudent?: CalendarEventUncheckedCreateNestedManyWithoutStudentInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
    blogComments?: BlogCommentUncheckedCreateNestedManyWithoutUserInput
    submissionsGraded?: AssignmentSubmissionUncheckedCreateNestedManyWithoutGradedByInput
    referralCodesOwned?: ReferralCodeUncheckedCreateNestedManyWithoutUserInput
    referralUsesGained?: ReferralUseUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSavedCoursesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSavedCoursesInput, UserUncheckedCreateWithoutSavedCoursesInput>
  }

  export type CourseCreateWithoutSavedByInput = {
    id?: string
    title: string
    description?: string | null
    subject: string
    image?: string | null
    price: Decimal | DecimalJsLike | number | string
    pointsPrice: number
    students?: number
    rating?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.CourseStatus
    featured?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teacher: UserCreateNestedOneWithoutCoursesInput
    topics?: TopicCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentCreateNestedManyWithoutCourseInput
    likedBy?: LikedCourseCreateNestedManyWithoutCourseInput
    reviews?: CourseReviewCreateNestedManyWithoutCourseInput
    lessons?: LessonCreateNestedManyWithoutCourseInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutCourseInput
    certificates?: CertificateCreateNestedManyWithoutCourseInput
    bundleCourses?: BundleCourseCreateNestedManyWithoutCourseInput
    calendarEvents?: CalendarEventCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutSavedByInput = {
    id?: string
    title: string
    description?: string | null
    subject: string
    image?: string | null
    price: Decimal | DecimalJsLike | number | string
    pointsPrice: number
    teacherId: string
    students?: number
    rating?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.CourseStatus
    featured?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    topics?: TopicUncheckedCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutCourseInput
    likedBy?: LikedCourseUncheckedCreateNestedManyWithoutCourseInput
    reviews?: CourseReviewUncheckedCreateNestedManyWithoutCourseInput
    lessons?: LessonUncheckedCreateNestedManyWithoutCourseInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutCourseInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutCourseInput
    bundleCourses?: BundleCourseUncheckedCreateNestedManyWithoutCourseInput
    calendarEvents?: CalendarEventUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutSavedByInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutSavedByInput, CourseUncheckedCreateWithoutSavedByInput>
  }

  export type UserUpsertWithoutSavedCoursesInput = {
    update: XOR<UserUpdateWithoutSavedCoursesInput, UserUncheckedUpdateWithoutSavedCoursesInput>
    create: XOR<UserCreateWithoutSavedCoursesInput, UserUncheckedCreateWithoutSavedCoursesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSavedCoursesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSavedCoursesInput, UserUncheckedUpdateWithoutSavedCoursesInput>
  }

  export type UserUpdateWithoutSavedCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: IntFieldUpdateOperationsInput | number
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referredBy?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferredByNestedInput
    teacherProfile?: TeacherProfileUpdateOneWithoutUserNestedInput
    availability?: UserAvailabilityUpdateManyWithoutUserNestedInput
    pointsTransactions?: PointsTransactionUpdateManyWithoutUserNestedInput
    courses?: CourseUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    likedCourses?: LikedCourseUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutUserNestedInput
    assignmentSubs?: AssignmentSubmissionUpdateManyWithoutUserNestedInput
    courseReviews?: CourseReviewUpdateManyWithoutUserNestedInput
    tutoringSessions?: TutoringSessionUpdateManyWithoutTeacherNestedInput
    tutoringRequests?: TutoringRequestUpdateManyWithoutStudentNestedInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUpdateManyWithoutTeacherNestedInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUpdateManyWithoutStudentNestedInput
    tutoringReviews?: TutoringReviewUpdateManyWithoutStudentNestedInput
    tutoringMessages?: TutoringMessageUpdateManyWithoutSenderNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    conversationParts?: ConversationParticipantUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    attachments?: AttachmentUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    subscriptionRecords?: UserSubscriptionUpdateManyWithoutUserNestedInput
    bundlesOwned?: UserBundleUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUpdateManyWithoutUserNestedInput
    eventsAsTeacher?: CalendarEventUpdateManyWithoutTeacherNestedInput
    eventsAsStudent?: CalendarEventUpdateManyWithoutStudentNestedInput
    blogPosts?: BlogPostUpdateManyWithoutAuthorNestedInput
    blogComments?: BlogCommentUpdateManyWithoutUserNestedInput
    submissionsGraded?: AssignmentSubmissionUpdateManyWithoutGradedByNestedInput
    referralCodesOwned?: ReferralCodeUpdateManyWithoutUserNestedInput
    referralUsesGained?: ReferralUseUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSavedCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: IntFieldUpdateOperationsInput | number
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referrals?: UserUncheckedUpdateManyWithoutReferredByNestedInput
    teacherProfile?: TeacherProfileUncheckedUpdateOneWithoutUserNestedInput
    availability?: UserAvailabilityUncheckedUpdateManyWithoutUserNestedInput
    pointsTransactions?: PointsTransactionUncheckedUpdateManyWithoutUserNestedInput
    courses?: CourseUncheckedUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    likedCourses?: LikedCourseUncheckedUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUncheckedUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    assignmentSubs?: AssignmentSubmissionUncheckedUpdateManyWithoutUserNestedInput
    courseReviews?: CourseReviewUncheckedUpdateManyWithoutUserNestedInput
    tutoringSessions?: TutoringSessionUncheckedUpdateManyWithoutTeacherNestedInput
    tutoringRequests?: TutoringRequestUncheckedUpdateManyWithoutStudentNestedInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUncheckedUpdateManyWithoutTeacherNestedInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUncheckedUpdateManyWithoutStudentNestedInput
    tutoringReviews?: TutoringReviewUncheckedUpdateManyWithoutStudentNestedInput
    tutoringMessages?: TutoringMessageUncheckedUpdateManyWithoutSenderNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    conversationParts?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    subscriptionRecords?: UserSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    bundlesOwned?: UserBundleUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUncheckedUpdateManyWithoutUserNestedInput
    eventsAsTeacher?: CalendarEventUncheckedUpdateManyWithoutTeacherNestedInput
    eventsAsStudent?: CalendarEventUncheckedUpdateManyWithoutStudentNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
    blogComments?: BlogCommentUncheckedUpdateManyWithoutUserNestedInput
    submissionsGraded?: AssignmentSubmissionUncheckedUpdateManyWithoutGradedByNestedInput
    referralCodesOwned?: ReferralCodeUncheckedUpdateManyWithoutUserNestedInput
    referralUsesGained?: ReferralUseUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CourseUpsertWithoutSavedByInput = {
    update: XOR<CourseUpdateWithoutSavedByInput, CourseUncheckedUpdateWithoutSavedByInput>
    create: XOR<CourseCreateWithoutSavedByInput, CourseUncheckedCreateWithoutSavedByInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutSavedByInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutSavedByInput, CourseUncheckedUpdateWithoutSavedByInput>
  }

  export type CourseUpdateWithoutSavedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pointsPrice?: IntFieldUpdateOperationsInput | number
    students?: IntFieldUpdateOperationsInput | number
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumCourseStatusFieldUpdateOperationsInput | $Enums.CourseStatus
    featured?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher?: UserUpdateOneRequiredWithoutCoursesNestedInput
    topics?: TopicUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUpdateManyWithoutCourseNestedInput
    likedBy?: LikedCourseUpdateManyWithoutCourseNestedInput
    reviews?: CourseReviewUpdateManyWithoutCourseNestedInput
    lessons?: LessonUpdateManyWithoutCourseNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutCourseNestedInput
    certificates?: CertificateUpdateManyWithoutCourseNestedInput
    bundleCourses?: BundleCourseUpdateManyWithoutCourseNestedInput
    calendarEvents?: CalendarEventUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutSavedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pointsPrice?: IntFieldUpdateOperationsInput | number
    teacherId?: StringFieldUpdateOperationsInput | string
    students?: IntFieldUpdateOperationsInput | number
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumCourseStatusFieldUpdateOperationsInput | $Enums.CourseStatus
    featured?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    topics?: TopicUncheckedUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutCourseNestedInput
    likedBy?: LikedCourseUncheckedUpdateManyWithoutCourseNestedInput
    reviews?: CourseReviewUncheckedUpdateManyWithoutCourseNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutCourseNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutCourseNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutCourseNestedInput
    bundleCourses?: BundleCourseUncheckedUpdateManyWithoutCourseNestedInput
    calendarEvents?: CalendarEventUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type UserCreateWithoutLikedCoursesInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    avatar?: string | null
    bio?: string | null
    createdAt?: Date | string
    points?: number
    referralCode?: string | null
    lastLogin?: Date | string | null
    referredBy?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferredByInput
    teacherProfile?: TeacherProfileCreateNestedOneWithoutUserInput
    availability?: UserAvailabilityCreateNestedManyWithoutUserInput
    pointsTransactions?: PointsTransactionCreateNestedManyWithoutUserInput
    courses?: CourseCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    savedCourses?: SavedCourseCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutUserInput
    assignmentSubs?: AssignmentSubmissionCreateNestedManyWithoutUserInput
    courseReviews?: CourseReviewCreateNestedManyWithoutUserInput
    tutoringSessions?: TutoringSessionCreateNestedManyWithoutTeacherInput
    tutoringRequests?: TutoringRequestCreateNestedManyWithoutStudentInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentCreateNestedManyWithoutTeacherInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentCreateNestedManyWithoutStudentInput
    tutoringReviews?: TutoringReviewCreateNestedManyWithoutStudentInput
    tutoringMessages?: TutoringMessageCreateNestedManyWithoutSenderInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    conversationParts?: ConversationParticipantCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    attachments?: AttachmentCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    subscriptionRecords?: UserSubscriptionCreateNestedManyWithoutUserInput
    bundlesOwned?: UserBundleCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventCreateNestedManyWithoutUserInput
    eventsAsTeacher?: CalendarEventCreateNestedManyWithoutTeacherInput
    eventsAsStudent?: CalendarEventCreateNestedManyWithoutStudentInput
    blogPosts?: BlogPostCreateNestedManyWithoutAuthorInput
    blogComments?: BlogCommentCreateNestedManyWithoutUserInput
    submissionsGraded?: AssignmentSubmissionCreateNestedManyWithoutGradedByInput
    referralCodesOwned?: ReferralCodeCreateNestedManyWithoutUserInput
    referralUsesGained?: ReferralUseCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLikedCoursesInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    avatar?: string | null
    bio?: string | null
    createdAt?: Date | string
    points?: number
    referralCode?: string | null
    referredById?: string | null
    lastLogin?: Date | string | null
    referrals?: UserUncheckedCreateNestedManyWithoutReferredByInput
    teacherProfile?: TeacherProfileUncheckedCreateNestedOneWithoutUserInput
    availability?: UserAvailabilityUncheckedCreateNestedManyWithoutUserInput
    pointsTransactions?: PointsTransactionUncheckedCreateNestedManyWithoutUserInput
    courses?: CourseUncheckedCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    savedCourses?: SavedCourseUncheckedCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressUncheckedCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutUserInput
    assignmentSubs?: AssignmentSubmissionUncheckedCreateNestedManyWithoutUserInput
    courseReviews?: CourseReviewUncheckedCreateNestedManyWithoutUserInput
    tutoringSessions?: TutoringSessionUncheckedCreateNestedManyWithoutTeacherInput
    tutoringRequests?: TutoringRequestUncheckedCreateNestedManyWithoutStudentInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUncheckedCreateNestedManyWithoutTeacherInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUncheckedCreateNestedManyWithoutStudentInput
    tutoringReviews?: TutoringReviewUncheckedCreateNestedManyWithoutStudentInput
    tutoringMessages?: TutoringMessageUncheckedCreateNestedManyWithoutSenderInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    conversationParts?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    subscriptionRecords?: UserSubscriptionUncheckedCreateNestedManyWithoutUserInput
    bundlesOwned?: UserBundleUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventUncheckedCreateNestedManyWithoutUserInput
    eventsAsTeacher?: CalendarEventUncheckedCreateNestedManyWithoutTeacherInput
    eventsAsStudent?: CalendarEventUncheckedCreateNestedManyWithoutStudentInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
    blogComments?: BlogCommentUncheckedCreateNestedManyWithoutUserInput
    submissionsGraded?: AssignmentSubmissionUncheckedCreateNestedManyWithoutGradedByInput
    referralCodesOwned?: ReferralCodeUncheckedCreateNestedManyWithoutUserInput
    referralUsesGained?: ReferralUseUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLikedCoursesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLikedCoursesInput, UserUncheckedCreateWithoutLikedCoursesInput>
  }

  export type CourseCreateWithoutLikedByInput = {
    id?: string
    title: string
    description?: string | null
    subject: string
    image?: string | null
    price: Decimal | DecimalJsLike | number | string
    pointsPrice: number
    students?: number
    rating?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.CourseStatus
    featured?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teacher: UserCreateNestedOneWithoutCoursesInput
    topics?: TopicCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentCreateNestedManyWithoutCourseInput
    savedBy?: SavedCourseCreateNestedManyWithoutCourseInput
    reviews?: CourseReviewCreateNestedManyWithoutCourseInput
    lessons?: LessonCreateNestedManyWithoutCourseInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutCourseInput
    certificates?: CertificateCreateNestedManyWithoutCourseInput
    bundleCourses?: BundleCourseCreateNestedManyWithoutCourseInput
    calendarEvents?: CalendarEventCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutLikedByInput = {
    id?: string
    title: string
    description?: string | null
    subject: string
    image?: string | null
    price: Decimal | DecimalJsLike | number | string
    pointsPrice: number
    teacherId: string
    students?: number
    rating?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.CourseStatus
    featured?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    topics?: TopicUncheckedCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutCourseInput
    savedBy?: SavedCourseUncheckedCreateNestedManyWithoutCourseInput
    reviews?: CourseReviewUncheckedCreateNestedManyWithoutCourseInput
    lessons?: LessonUncheckedCreateNestedManyWithoutCourseInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutCourseInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutCourseInput
    bundleCourses?: BundleCourseUncheckedCreateNestedManyWithoutCourseInput
    calendarEvents?: CalendarEventUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutLikedByInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutLikedByInput, CourseUncheckedCreateWithoutLikedByInput>
  }

  export type UserUpsertWithoutLikedCoursesInput = {
    update: XOR<UserUpdateWithoutLikedCoursesInput, UserUncheckedUpdateWithoutLikedCoursesInput>
    create: XOR<UserCreateWithoutLikedCoursesInput, UserUncheckedCreateWithoutLikedCoursesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLikedCoursesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLikedCoursesInput, UserUncheckedUpdateWithoutLikedCoursesInput>
  }

  export type UserUpdateWithoutLikedCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: IntFieldUpdateOperationsInput | number
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referredBy?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferredByNestedInput
    teacherProfile?: TeacherProfileUpdateOneWithoutUserNestedInput
    availability?: UserAvailabilityUpdateManyWithoutUserNestedInput
    pointsTransactions?: PointsTransactionUpdateManyWithoutUserNestedInput
    courses?: CourseUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    savedCourses?: SavedCourseUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutUserNestedInput
    assignmentSubs?: AssignmentSubmissionUpdateManyWithoutUserNestedInput
    courseReviews?: CourseReviewUpdateManyWithoutUserNestedInput
    tutoringSessions?: TutoringSessionUpdateManyWithoutTeacherNestedInput
    tutoringRequests?: TutoringRequestUpdateManyWithoutStudentNestedInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUpdateManyWithoutTeacherNestedInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUpdateManyWithoutStudentNestedInput
    tutoringReviews?: TutoringReviewUpdateManyWithoutStudentNestedInput
    tutoringMessages?: TutoringMessageUpdateManyWithoutSenderNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    conversationParts?: ConversationParticipantUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    attachments?: AttachmentUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    subscriptionRecords?: UserSubscriptionUpdateManyWithoutUserNestedInput
    bundlesOwned?: UserBundleUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUpdateManyWithoutUserNestedInput
    eventsAsTeacher?: CalendarEventUpdateManyWithoutTeacherNestedInput
    eventsAsStudent?: CalendarEventUpdateManyWithoutStudentNestedInput
    blogPosts?: BlogPostUpdateManyWithoutAuthorNestedInput
    blogComments?: BlogCommentUpdateManyWithoutUserNestedInput
    submissionsGraded?: AssignmentSubmissionUpdateManyWithoutGradedByNestedInput
    referralCodesOwned?: ReferralCodeUpdateManyWithoutUserNestedInput
    referralUsesGained?: ReferralUseUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLikedCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: IntFieldUpdateOperationsInput | number
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referrals?: UserUncheckedUpdateManyWithoutReferredByNestedInput
    teacherProfile?: TeacherProfileUncheckedUpdateOneWithoutUserNestedInput
    availability?: UserAvailabilityUncheckedUpdateManyWithoutUserNestedInput
    pointsTransactions?: PointsTransactionUncheckedUpdateManyWithoutUserNestedInput
    courses?: CourseUncheckedUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    savedCourses?: SavedCourseUncheckedUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUncheckedUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    assignmentSubs?: AssignmentSubmissionUncheckedUpdateManyWithoutUserNestedInput
    courseReviews?: CourseReviewUncheckedUpdateManyWithoutUserNestedInput
    tutoringSessions?: TutoringSessionUncheckedUpdateManyWithoutTeacherNestedInput
    tutoringRequests?: TutoringRequestUncheckedUpdateManyWithoutStudentNestedInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUncheckedUpdateManyWithoutTeacherNestedInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUncheckedUpdateManyWithoutStudentNestedInput
    tutoringReviews?: TutoringReviewUncheckedUpdateManyWithoutStudentNestedInput
    tutoringMessages?: TutoringMessageUncheckedUpdateManyWithoutSenderNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    conversationParts?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    subscriptionRecords?: UserSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    bundlesOwned?: UserBundleUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUncheckedUpdateManyWithoutUserNestedInput
    eventsAsTeacher?: CalendarEventUncheckedUpdateManyWithoutTeacherNestedInput
    eventsAsStudent?: CalendarEventUncheckedUpdateManyWithoutStudentNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
    blogComments?: BlogCommentUncheckedUpdateManyWithoutUserNestedInput
    submissionsGraded?: AssignmentSubmissionUncheckedUpdateManyWithoutGradedByNestedInput
    referralCodesOwned?: ReferralCodeUncheckedUpdateManyWithoutUserNestedInput
    referralUsesGained?: ReferralUseUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CourseUpsertWithoutLikedByInput = {
    update: XOR<CourseUpdateWithoutLikedByInput, CourseUncheckedUpdateWithoutLikedByInput>
    create: XOR<CourseCreateWithoutLikedByInput, CourseUncheckedCreateWithoutLikedByInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutLikedByInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutLikedByInput, CourseUncheckedUpdateWithoutLikedByInput>
  }

  export type CourseUpdateWithoutLikedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pointsPrice?: IntFieldUpdateOperationsInput | number
    students?: IntFieldUpdateOperationsInput | number
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumCourseStatusFieldUpdateOperationsInput | $Enums.CourseStatus
    featured?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher?: UserUpdateOneRequiredWithoutCoursesNestedInput
    topics?: TopicUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUpdateManyWithoutCourseNestedInput
    savedBy?: SavedCourseUpdateManyWithoutCourseNestedInput
    reviews?: CourseReviewUpdateManyWithoutCourseNestedInput
    lessons?: LessonUpdateManyWithoutCourseNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutCourseNestedInput
    certificates?: CertificateUpdateManyWithoutCourseNestedInput
    bundleCourses?: BundleCourseUpdateManyWithoutCourseNestedInput
    calendarEvents?: CalendarEventUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutLikedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pointsPrice?: IntFieldUpdateOperationsInput | number
    teacherId?: StringFieldUpdateOperationsInput | string
    students?: IntFieldUpdateOperationsInput | number
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumCourseStatusFieldUpdateOperationsInput | $Enums.CourseStatus
    featured?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    topics?: TopicUncheckedUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutCourseNestedInput
    savedBy?: SavedCourseUncheckedUpdateManyWithoutCourseNestedInput
    reviews?: CourseReviewUncheckedUpdateManyWithoutCourseNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutCourseNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutCourseNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutCourseNestedInput
    bundleCourses?: BundleCourseUncheckedUpdateManyWithoutCourseNestedInput
    calendarEvents?: CalendarEventUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type UserCreateWithoutLessonProgressInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    avatar?: string | null
    bio?: string | null
    createdAt?: Date | string
    points?: number
    referralCode?: string | null
    lastLogin?: Date | string | null
    referredBy?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferredByInput
    teacherProfile?: TeacherProfileCreateNestedOneWithoutUserInput
    availability?: UserAvailabilityCreateNestedManyWithoutUserInput
    pointsTransactions?: PointsTransactionCreateNestedManyWithoutUserInput
    courses?: CourseCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    savedCourses?: SavedCourseCreateNestedManyWithoutUserInput
    likedCourses?: LikedCourseCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutUserInput
    assignmentSubs?: AssignmentSubmissionCreateNestedManyWithoutUserInput
    courseReviews?: CourseReviewCreateNestedManyWithoutUserInput
    tutoringSessions?: TutoringSessionCreateNestedManyWithoutTeacherInput
    tutoringRequests?: TutoringRequestCreateNestedManyWithoutStudentInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentCreateNestedManyWithoutTeacherInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentCreateNestedManyWithoutStudentInput
    tutoringReviews?: TutoringReviewCreateNestedManyWithoutStudentInput
    tutoringMessages?: TutoringMessageCreateNestedManyWithoutSenderInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    conversationParts?: ConversationParticipantCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    attachments?: AttachmentCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    subscriptionRecords?: UserSubscriptionCreateNestedManyWithoutUserInput
    bundlesOwned?: UserBundleCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventCreateNestedManyWithoutUserInput
    eventsAsTeacher?: CalendarEventCreateNestedManyWithoutTeacherInput
    eventsAsStudent?: CalendarEventCreateNestedManyWithoutStudentInput
    blogPosts?: BlogPostCreateNestedManyWithoutAuthorInput
    blogComments?: BlogCommentCreateNestedManyWithoutUserInput
    submissionsGraded?: AssignmentSubmissionCreateNestedManyWithoutGradedByInput
    referralCodesOwned?: ReferralCodeCreateNestedManyWithoutUserInput
    referralUsesGained?: ReferralUseCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLessonProgressInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    avatar?: string | null
    bio?: string | null
    createdAt?: Date | string
    points?: number
    referralCode?: string | null
    referredById?: string | null
    lastLogin?: Date | string | null
    referrals?: UserUncheckedCreateNestedManyWithoutReferredByInput
    teacherProfile?: TeacherProfileUncheckedCreateNestedOneWithoutUserInput
    availability?: UserAvailabilityUncheckedCreateNestedManyWithoutUserInput
    pointsTransactions?: PointsTransactionUncheckedCreateNestedManyWithoutUserInput
    courses?: CourseUncheckedCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    savedCourses?: SavedCourseUncheckedCreateNestedManyWithoutUserInput
    likedCourses?: LikedCourseUncheckedCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutUserInput
    assignmentSubs?: AssignmentSubmissionUncheckedCreateNestedManyWithoutUserInput
    courseReviews?: CourseReviewUncheckedCreateNestedManyWithoutUserInput
    tutoringSessions?: TutoringSessionUncheckedCreateNestedManyWithoutTeacherInput
    tutoringRequests?: TutoringRequestUncheckedCreateNestedManyWithoutStudentInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUncheckedCreateNestedManyWithoutTeacherInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUncheckedCreateNestedManyWithoutStudentInput
    tutoringReviews?: TutoringReviewUncheckedCreateNestedManyWithoutStudentInput
    tutoringMessages?: TutoringMessageUncheckedCreateNestedManyWithoutSenderInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    conversationParts?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    subscriptionRecords?: UserSubscriptionUncheckedCreateNestedManyWithoutUserInput
    bundlesOwned?: UserBundleUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventUncheckedCreateNestedManyWithoutUserInput
    eventsAsTeacher?: CalendarEventUncheckedCreateNestedManyWithoutTeacherInput
    eventsAsStudent?: CalendarEventUncheckedCreateNestedManyWithoutStudentInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
    blogComments?: BlogCommentUncheckedCreateNestedManyWithoutUserInput
    submissionsGraded?: AssignmentSubmissionUncheckedCreateNestedManyWithoutGradedByInput
    referralCodesOwned?: ReferralCodeUncheckedCreateNestedManyWithoutUserInput
    referralUsesGained?: ReferralUseUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLessonProgressInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLessonProgressInput, UserUncheckedCreateWithoutLessonProgressInput>
  }

  export type LessonCreateWithoutProgressInput = {
    id?: string
    title: string
    description?: string | null
    videoUrl?: string | null
    content?: string | null
    duration?: number | null
    orderIndex: number
    type: $Enums.LessonType
    topic: TopicCreateNestedOneWithoutLessonsInput
    quiz?: QuizCreateNestedOneWithoutLessonInput
    assignment?: AssignmentCreateNestedOneWithoutLessonInput
    calendarEvents?: CalendarEventCreateNestedManyWithoutLessonInput
    course?: CourseCreateNestedOneWithoutLessonsInput
  }

  export type LessonUncheckedCreateWithoutProgressInput = {
    id?: string
    topicId: string
    title: string
    description?: string | null
    videoUrl?: string | null
    content?: string | null
    duration?: number | null
    orderIndex: number
    type: $Enums.LessonType
    courseId?: string | null
    quiz?: QuizUncheckedCreateNestedOneWithoutLessonInput
    assignment?: AssignmentUncheckedCreateNestedOneWithoutLessonInput
    calendarEvents?: CalendarEventUncheckedCreateNestedManyWithoutLessonInput
  }

  export type LessonCreateOrConnectWithoutProgressInput = {
    where: LessonWhereUniqueInput
    create: XOR<LessonCreateWithoutProgressInput, LessonUncheckedCreateWithoutProgressInput>
  }

  export type UserUpsertWithoutLessonProgressInput = {
    update: XOR<UserUpdateWithoutLessonProgressInput, UserUncheckedUpdateWithoutLessonProgressInput>
    create: XOR<UserCreateWithoutLessonProgressInput, UserUncheckedCreateWithoutLessonProgressInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLessonProgressInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLessonProgressInput, UserUncheckedUpdateWithoutLessonProgressInput>
  }

  export type UserUpdateWithoutLessonProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: IntFieldUpdateOperationsInput | number
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referredBy?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferredByNestedInput
    teacherProfile?: TeacherProfileUpdateOneWithoutUserNestedInput
    availability?: UserAvailabilityUpdateManyWithoutUserNestedInput
    pointsTransactions?: PointsTransactionUpdateManyWithoutUserNestedInput
    courses?: CourseUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    savedCourses?: SavedCourseUpdateManyWithoutUserNestedInput
    likedCourses?: LikedCourseUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutUserNestedInput
    assignmentSubs?: AssignmentSubmissionUpdateManyWithoutUserNestedInput
    courseReviews?: CourseReviewUpdateManyWithoutUserNestedInput
    tutoringSessions?: TutoringSessionUpdateManyWithoutTeacherNestedInput
    tutoringRequests?: TutoringRequestUpdateManyWithoutStudentNestedInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUpdateManyWithoutTeacherNestedInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUpdateManyWithoutStudentNestedInput
    tutoringReviews?: TutoringReviewUpdateManyWithoutStudentNestedInput
    tutoringMessages?: TutoringMessageUpdateManyWithoutSenderNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    conversationParts?: ConversationParticipantUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    attachments?: AttachmentUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    subscriptionRecords?: UserSubscriptionUpdateManyWithoutUserNestedInput
    bundlesOwned?: UserBundleUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUpdateManyWithoutUserNestedInput
    eventsAsTeacher?: CalendarEventUpdateManyWithoutTeacherNestedInput
    eventsAsStudent?: CalendarEventUpdateManyWithoutStudentNestedInput
    blogPosts?: BlogPostUpdateManyWithoutAuthorNestedInput
    blogComments?: BlogCommentUpdateManyWithoutUserNestedInput
    submissionsGraded?: AssignmentSubmissionUpdateManyWithoutGradedByNestedInput
    referralCodesOwned?: ReferralCodeUpdateManyWithoutUserNestedInput
    referralUsesGained?: ReferralUseUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLessonProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: IntFieldUpdateOperationsInput | number
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referrals?: UserUncheckedUpdateManyWithoutReferredByNestedInput
    teacherProfile?: TeacherProfileUncheckedUpdateOneWithoutUserNestedInput
    availability?: UserAvailabilityUncheckedUpdateManyWithoutUserNestedInput
    pointsTransactions?: PointsTransactionUncheckedUpdateManyWithoutUserNestedInput
    courses?: CourseUncheckedUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    savedCourses?: SavedCourseUncheckedUpdateManyWithoutUserNestedInput
    likedCourses?: LikedCourseUncheckedUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    assignmentSubs?: AssignmentSubmissionUncheckedUpdateManyWithoutUserNestedInput
    courseReviews?: CourseReviewUncheckedUpdateManyWithoutUserNestedInput
    tutoringSessions?: TutoringSessionUncheckedUpdateManyWithoutTeacherNestedInput
    tutoringRequests?: TutoringRequestUncheckedUpdateManyWithoutStudentNestedInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUncheckedUpdateManyWithoutTeacherNestedInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUncheckedUpdateManyWithoutStudentNestedInput
    tutoringReviews?: TutoringReviewUncheckedUpdateManyWithoutStudentNestedInput
    tutoringMessages?: TutoringMessageUncheckedUpdateManyWithoutSenderNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    conversationParts?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    subscriptionRecords?: UserSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    bundlesOwned?: UserBundleUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUncheckedUpdateManyWithoutUserNestedInput
    eventsAsTeacher?: CalendarEventUncheckedUpdateManyWithoutTeacherNestedInput
    eventsAsStudent?: CalendarEventUncheckedUpdateManyWithoutStudentNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
    blogComments?: BlogCommentUncheckedUpdateManyWithoutUserNestedInput
    submissionsGraded?: AssignmentSubmissionUncheckedUpdateManyWithoutGradedByNestedInput
    referralCodesOwned?: ReferralCodeUncheckedUpdateManyWithoutUserNestedInput
    referralUsesGained?: ReferralUseUncheckedUpdateManyWithoutUserNestedInput
  }

  export type LessonUpsertWithoutProgressInput = {
    update: XOR<LessonUpdateWithoutProgressInput, LessonUncheckedUpdateWithoutProgressInput>
    create: XOR<LessonCreateWithoutProgressInput, LessonUncheckedCreateWithoutProgressInput>
    where?: LessonWhereInput
  }

  export type LessonUpdateToOneWithWhereWithoutProgressInput = {
    where?: LessonWhereInput
    data: XOR<LessonUpdateWithoutProgressInput, LessonUncheckedUpdateWithoutProgressInput>
  }

  export type LessonUpdateWithoutProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    orderIndex?: IntFieldUpdateOperationsInput | number
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    topic?: TopicUpdateOneRequiredWithoutLessonsNestedInput
    quiz?: QuizUpdateOneWithoutLessonNestedInput
    assignment?: AssignmentUpdateOneWithoutLessonNestedInput
    calendarEvents?: CalendarEventUpdateManyWithoutLessonNestedInput
    course?: CourseUpdateOneWithoutLessonsNestedInput
  }

  export type LessonUncheckedUpdateWithoutProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    orderIndex?: IntFieldUpdateOperationsInput | number
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    quiz?: QuizUncheckedUpdateOneWithoutLessonNestedInput
    assignment?: AssignmentUncheckedUpdateOneWithoutLessonNestedInput
    calendarEvents?: CalendarEventUncheckedUpdateManyWithoutLessonNestedInput
  }

  export type UserCreateWithoutQuizAttemptsInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    avatar?: string | null
    bio?: string | null
    createdAt?: Date | string
    points?: number
    referralCode?: string | null
    lastLogin?: Date | string | null
    referredBy?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferredByInput
    teacherProfile?: TeacherProfileCreateNestedOneWithoutUserInput
    availability?: UserAvailabilityCreateNestedManyWithoutUserInput
    pointsTransactions?: PointsTransactionCreateNestedManyWithoutUserInput
    courses?: CourseCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    savedCourses?: SavedCourseCreateNestedManyWithoutUserInput
    likedCourses?: LikedCourseCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressCreateNestedManyWithoutUserInput
    assignmentSubs?: AssignmentSubmissionCreateNestedManyWithoutUserInput
    courseReviews?: CourseReviewCreateNestedManyWithoutUserInput
    tutoringSessions?: TutoringSessionCreateNestedManyWithoutTeacherInput
    tutoringRequests?: TutoringRequestCreateNestedManyWithoutStudentInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentCreateNestedManyWithoutTeacherInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentCreateNestedManyWithoutStudentInput
    tutoringReviews?: TutoringReviewCreateNestedManyWithoutStudentInput
    tutoringMessages?: TutoringMessageCreateNestedManyWithoutSenderInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    conversationParts?: ConversationParticipantCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    attachments?: AttachmentCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    subscriptionRecords?: UserSubscriptionCreateNestedManyWithoutUserInput
    bundlesOwned?: UserBundleCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventCreateNestedManyWithoutUserInput
    eventsAsTeacher?: CalendarEventCreateNestedManyWithoutTeacherInput
    eventsAsStudent?: CalendarEventCreateNestedManyWithoutStudentInput
    blogPosts?: BlogPostCreateNestedManyWithoutAuthorInput
    blogComments?: BlogCommentCreateNestedManyWithoutUserInput
    submissionsGraded?: AssignmentSubmissionCreateNestedManyWithoutGradedByInput
    referralCodesOwned?: ReferralCodeCreateNestedManyWithoutUserInput
    referralUsesGained?: ReferralUseCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutQuizAttemptsInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    avatar?: string | null
    bio?: string | null
    createdAt?: Date | string
    points?: number
    referralCode?: string | null
    referredById?: string | null
    lastLogin?: Date | string | null
    referrals?: UserUncheckedCreateNestedManyWithoutReferredByInput
    teacherProfile?: TeacherProfileUncheckedCreateNestedOneWithoutUserInput
    availability?: UserAvailabilityUncheckedCreateNestedManyWithoutUserInput
    pointsTransactions?: PointsTransactionUncheckedCreateNestedManyWithoutUserInput
    courses?: CourseUncheckedCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    savedCourses?: SavedCourseUncheckedCreateNestedManyWithoutUserInput
    likedCourses?: LikedCourseUncheckedCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressUncheckedCreateNestedManyWithoutUserInput
    assignmentSubs?: AssignmentSubmissionUncheckedCreateNestedManyWithoutUserInput
    courseReviews?: CourseReviewUncheckedCreateNestedManyWithoutUserInput
    tutoringSessions?: TutoringSessionUncheckedCreateNestedManyWithoutTeacherInput
    tutoringRequests?: TutoringRequestUncheckedCreateNestedManyWithoutStudentInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUncheckedCreateNestedManyWithoutTeacherInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUncheckedCreateNestedManyWithoutStudentInput
    tutoringReviews?: TutoringReviewUncheckedCreateNestedManyWithoutStudentInput
    tutoringMessages?: TutoringMessageUncheckedCreateNestedManyWithoutSenderInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    conversationParts?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    subscriptionRecords?: UserSubscriptionUncheckedCreateNestedManyWithoutUserInput
    bundlesOwned?: UserBundleUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventUncheckedCreateNestedManyWithoutUserInput
    eventsAsTeacher?: CalendarEventUncheckedCreateNestedManyWithoutTeacherInput
    eventsAsStudent?: CalendarEventUncheckedCreateNestedManyWithoutStudentInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
    blogComments?: BlogCommentUncheckedCreateNestedManyWithoutUserInput
    submissionsGraded?: AssignmentSubmissionUncheckedCreateNestedManyWithoutGradedByInput
    referralCodesOwned?: ReferralCodeUncheckedCreateNestedManyWithoutUserInput
    referralUsesGained?: ReferralUseUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutQuizAttemptsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutQuizAttemptsInput, UserUncheckedCreateWithoutQuizAttemptsInput>
  }

  export type QuizCreateWithoutAttemptsInput = {
    id?: string
    title: string
    description?: string | null
    timeLimit?: number | null
    lesson: LessonCreateNestedOneWithoutQuizInput
    questions?: QuestionCreateNestedManyWithoutQuizInput
  }

  export type QuizUncheckedCreateWithoutAttemptsInput = {
    id?: string
    lessonId: string
    title: string
    description?: string | null
    timeLimit?: number | null
    questions?: QuestionUncheckedCreateNestedManyWithoutQuizInput
  }

  export type QuizCreateOrConnectWithoutAttemptsInput = {
    where: QuizWhereUniqueInput
    create: XOR<QuizCreateWithoutAttemptsInput, QuizUncheckedCreateWithoutAttemptsInput>
  }

  export type CourseCreateWithoutQuizAttemptsInput = {
    id?: string
    title: string
    description?: string | null
    subject: string
    image?: string | null
    price: Decimal | DecimalJsLike | number | string
    pointsPrice: number
    students?: number
    rating?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.CourseStatus
    featured?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teacher: UserCreateNestedOneWithoutCoursesInput
    topics?: TopicCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentCreateNestedManyWithoutCourseInput
    savedBy?: SavedCourseCreateNestedManyWithoutCourseInput
    likedBy?: LikedCourseCreateNestedManyWithoutCourseInput
    reviews?: CourseReviewCreateNestedManyWithoutCourseInput
    lessons?: LessonCreateNestedManyWithoutCourseInput
    certificates?: CertificateCreateNestedManyWithoutCourseInput
    bundleCourses?: BundleCourseCreateNestedManyWithoutCourseInput
    calendarEvents?: CalendarEventCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutQuizAttemptsInput = {
    id?: string
    title: string
    description?: string | null
    subject: string
    image?: string | null
    price: Decimal | DecimalJsLike | number | string
    pointsPrice: number
    teacherId: string
    students?: number
    rating?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.CourseStatus
    featured?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    topics?: TopicUncheckedCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutCourseInput
    savedBy?: SavedCourseUncheckedCreateNestedManyWithoutCourseInput
    likedBy?: LikedCourseUncheckedCreateNestedManyWithoutCourseInput
    reviews?: CourseReviewUncheckedCreateNestedManyWithoutCourseInput
    lessons?: LessonUncheckedCreateNestedManyWithoutCourseInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutCourseInput
    bundleCourses?: BundleCourseUncheckedCreateNestedManyWithoutCourseInput
    calendarEvents?: CalendarEventUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutQuizAttemptsInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutQuizAttemptsInput, CourseUncheckedCreateWithoutQuizAttemptsInput>
  }

  export type UserUpsertWithoutQuizAttemptsInput = {
    update: XOR<UserUpdateWithoutQuizAttemptsInput, UserUncheckedUpdateWithoutQuizAttemptsInput>
    create: XOR<UserCreateWithoutQuizAttemptsInput, UserUncheckedCreateWithoutQuizAttemptsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutQuizAttemptsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutQuizAttemptsInput, UserUncheckedUpdateWithoutQuizAttemptsInput>
  }

  export type UserUpdateWithoutQuizAttemptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: IntFieldUpdateOperationsInput | number
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referredBy?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferredByNestedInput
    teacherProfile?: TeacherProfileUpdateOneWithoutUserNestedInput
    availability?: UserAvailabilityUpdateManyWithoutUserNestedInput
    pointsTransactions?: PointsTransactionUpdateManyWithoutUserNestedInput
    courses?: CourseUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    savedCourses?: SavedCourseUpdateManyWithoutUserNestedInput
    likedCourses?: LikedCourseUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUpdateManyWithoutUserNestedInput
    assignmentSubs?: AssignmentSubmissionUpdateManyWithoutUserNestedInput
    courseReviews?: CourseReviewUpdateManyWithoutUserNestedInput
    tutoringSessions?: TutoringSessionUpdateManyWithoutTeacherNestedInput
    tutoringRequests?: TutoringRequestUpdateManyWithoutStudentNestedInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUpdateManyWithoutTeacherNestedInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUpdateManyWithoutStudentNestedInput
    tutoringReviews?: TutoringReviewUpdateManyWithoutStudentNestedInput
    tutoringMessages?: TutoringMessageUpdateManyWithoutSenderNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    conversationParts?: ConversationParticipantUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    attachments?: AttachmentUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    subscriptionRecords?: UserSubscriptionUpdateManyWithoutUserNestedInput
    bundlesOwned?: UserBundleUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUpdateManyWithoutUserNestedInput
    eventsAsTeacher?: CalendarEventUpdateManyWithoutTeacherNestedInput
    eventsAsStudent?: CalendarEventUpdateManyWithoutStudentNestedInput
    blogPosts?: BlogPostUpdateManyWithoutAuthorNestedInput
    blogComments?: BlogCommentUpdateManyWithoutUserNestedInput
    submissionsGraded?: AssignmentSubmissionUpdateManyWithoutGradedByNestedInput
    referralCodesOwned?: ReferralCodeUpdateManyWithoutUserNestedInput
    referralUsesGained?: ReferralUseUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutQuizAttemptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: IntFieldUpdateOperationsInput | number
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referrals?: UserUncheckedUpdateManyWithoutReferredByNestedInput
    teacherProfile?: TeacherProfileUncheckedUpdateOneWithoutUserNestedInput
    availability?: UserAvailabilityUncheckedUpdateManyWithoutUserNestedInput
    pointsTransactions?: PointsTransactionUncheckedUpdateManyWithoutUserNestedInput
    courses?: CourseUncheckedUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    savedCourses?: SavedCourseUncheckedUpdateManyWithoutUserNestedInput
    likedCourses?: LikedCourseUncheckedUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUncheckedUpdateManyWithoutUserNestedInput
    assignmentSubs?: AssignmentSubmissionUncheckedUpdateManyWithoutUserNestedInput
    courseReviews?: CourseReviewUncheckedUpdateManyWithoutUserNestedInput
    tutoringSessions?: TutoringSessionUncheckedUpdateManyWithoutTeacherNestedInput
    tutoringRequests?: TutoringRequestUncheckedUpdateManyWithoutStudentNestedInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUncheckedUpdateManyWithoutTeacherNestedInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUncheckedUpdateManyWithoutStudentNestedInput
    tutoringReviews?: TutoringReviewUncheckedUpdateManyWithoutStudentNestedInput
    tutoringMessages?: TutoringMessageUncheckedUpdateManyWithoutSenderNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    conversationParts?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    subscriptionRecords?: UserSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    bundlesOwned?: UserBundleUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUncheckedUpdateManyWithoutUserNestedInput
    eventsAsTeacher?: CalendarEventUncheckedUpdateManyWithoutTeacherNestedInput
    eventsAsStudent?: CalendarEventUncheckedUpdateManyWithoutStudentNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
    blogComments?: BlogCommentUncheckedUpdateManyWithoutUserNestedInput
    submissionsGraded?: AssignmentSubmissionUncheckedUpdateManyWithoutGradedByNestedInput
    referralCodesOwned?: ReferralCodeUncheckedUpdateManyWithoutUserNestedInput
    referralUsesGained?: ReferralUseUncheckedUpdateManyWithoutUserNestedInput
  }

  export type QuizUpsertWithoutAttemptsInput = {
    update: XOR<QuizUpdateWithoutAttemptsInput, QuizUncheckedUpdateWithoutAttemptsInput>
    create: XOR<QuizCreateWithoutAttemptsInput, QuizUncheckedCreateWithoutAttemptsInput>
    where?: QuizWhereInput
  }

  export type QuizUpdateToOneWithWhereWithoutAttemptsInput = {
    where?: QuizWhereInput
    data: XOR<QuizUpdateWithoutAttemptsInput, QuizUncheckedUpdateWithoutAttemptsInput>
  }

  export type QuizUpdateWithoutAttemptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    lesson?: LessonUpdateOneRequiredWithoutQuizNestedInput
    questions?: QuestionUpdateManyWithoutQuizNestedInput
  }

  export type QuizUncheckedUpdateWithoutAttemptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    lessonId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    questions?: QuestionUncheckedUpdateManyWithoutQuizNestedInput
  }

  export type CourseUpsertWithoutQuizAttemptsInput = {
    update: XOR<CourseUpdateWithoutQuizAttemptsInput, CourseUncheckedUpdateWithoutQuizAttemptsInput>
    create: XOR<CourseCreateWithoutQuizAttemptsInput, CourseUncheckedCreateWithoutQuizAttemptsInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutQuizAttemptsInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutQuizAttemptsInput, CourseUncheckedUpdateWithoutQuizAttemptsInput>
  }

  export type CourseUpdateWithoutQuizAttemptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pointsPrice?: IntFieldUpdateOperationsInput | number
    students?: IntFieldUpdateOperationsInput | number
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumCourseStatusFieldUpdateOperationsInput | $Enums.CourseStatus
    featured?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher?: UserUpdateOneRequiredWithoutCoursesNestedInput
    topics?: TopicUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUpdateManyWithoutCourseNestedInput
    savedBy?: SavedCourseUpdateManyWithoutCourseNestedInput
    likedBy?: LikedCourseUpdateManyWithoutCourseNestedInput
    reviews?: CourseReviewUpdateManyWithoutCourseNestedInput
    lessons?: LessonUpdateManyWithoutCourseNestedInput
    certificates?: CertificateUpdateManyWithoutCourseNestedInput
    bundleCourses?: BundleCourseUpdateManyWithoutCourseNestedInput
    calendarEvents?: CalendarEventUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutQuizAttemptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pointsPrice?: IntFieldUpdateOperationsInput | number
    teacherId?: StringFieldUpdateOperationsInput | string
    students?: IntFieldUpdateOperationsInput | number
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumCourseStatusFieldUpdateOperationsInput | $Enums.CourseStatus
    featured?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    topics?: TopicUncheckedUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutCourseNestedInput
    savedBy?: SavedCourseUncheckedUpdateManyWithoutCourseNestedInput
    likedBy?: LikedCourseUncheckedUpdateManyWithoutCourseNestedInput
    reviews?: CourseReviewUncheckedUpdateManyWithoutCourseNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutCourseNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutCourseNestedInput
    bundleCourses?: BundleCourseUncheckedUpdateManyWithoutCourseNestedInput
    calendarEvents?: CalendarEventUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type UserCreateWithoutAssignmentSubsInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    avatar?: string | null
    bio?: string | null
    createdAt?: Date | string
    points?: number
    referralCode?: string | null
    lastLogin?: Date | string | null
    referredBy?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferredByInput
    teacherProfile?: TeacherProfileCreateNestedOneWithoutUserInput
    availability?: UserAvailabilityCreateNestedManyWithoutUserInput
    pointsTransactions?: PointsTransactionCreateNestedManyWithoutUserInput
    courses?: CourseCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    savedCourses?: SavedCourseCreateNestedManyWithoutUserInput
    likedCourses?: LikedCourseCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutUserInput
    courseReviews?: CourseReviewCreateNestedManyWithoutUserInput
    tutoringSessions?: TutoringSessionCreateNestedManyWithoutTeacherInput
    tutoringRequests?: TutoringRequestCreateNestedManyWithoutStudentInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentCreateNestedManyWithoutTeacherInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentCreateNestedManyWithoutStudentInput
    tutoringReviews?: TutoringReviewCreateNestedManyWithoutStudentInput
    tutoringMessages?: TutoringMessageCreateNestedManyWithoutSenderInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    conversationParts?: ConversationParticipantCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    attachments?: AttachmentCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    subscriptionRecords?: UserSubscriptionCreateNestedManyWithoutUserInput
    bundlesOwned?: UserBundleCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventCreateNestedManyWithoutUserInput
    eventsAsTeacher?: CalendarEventCreateNestedManyWithoutTeacherInput
    eventsAsStudent?: CalendarEventCreateNestedManyWithoutStudentInput
    blogPosts?: BlogPostCreateNestedManyWithoutAuthorInput
    blogComments?: BlogCommentCreateNestedManyWithoutUserInput
    submissionsGraded?: AssignmentSubmissionCreateNestedManyWithoutGradedByInput
    referralCodesOwned?: ReferralCodeCreateNestedManyWithoutUserInput
    referralUsesGained?: ReferralUseCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAssignmentSubsInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    avatar?: string | null
    bio?: string | null
    createdAt?: Date | string
    points?: number
    referralCode?: string | null
    referredById?: string | null
    lastLogin?: Date | string | null
    referrals?: UserUncheckedCreateNestedManyWithoutReferredByInput
    teacherProfile?: TeacherProfileUncheckedCreateNestedOneWithoutUserInput
    availability?: UserAvailabilityUncheckedCreateNestedManyWithoutUserInput
    pointsTransactions?: PointsTransactionUncheckedCreateNestedManyWithoutUserInput
    courses?: CourseUncheckedCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    savedCourses?: SavedCourseUncheckedCreateNestedManyWithoutUserInput
    likedCourses?: LikedCourseUncheckedCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressUncheckedCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutUserInput
    courseReviews?: CourseReviewUncheckedCreateNestedManyWithoutUserInput
    tutoringSessions?: TutoringSessionUncheckedCreateNestedManyWithoutTeacherInput
    tutoringRequests?: TutoringRequestUncheckedCreateNestedManyWithoutStudentInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUncheckedCreateNestedManyWithoutTeacherInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUncheckedCreateNestedManyWithoutStudentInput
    tutoringReviews?: TutoringReviewUncheckedCreateNestedManyWithoutStudentInput
    tutoringMessages?: TutoringMessageUncheckedCreateNestedManyWithoutSenderInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    conversationParts?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    subscriptionRecords?: UserSubscriptionUncheckedCreateNestedManyWithoutUserInput
    bundlesOwned?: UserBundleUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventUncheckedCreateNestedManyWithoutUserInput
    eventsAsTeacher?: CalendarEventUncheckedCreateNestedManyWithoutTeacherInput
    eventsAsStudent?: CalendarEventUncheckedCreateNestedManyWithoutStudentInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
    blogComments?: BlogCommentUncheckedCreateNestedManyWithoutUserInput
    submissionsGraded?: AssignmentSubmissionUncheckedCreateNestedManyWithoutGradedByInput
    referralCodesOwned?: ReferralCodeUncheckedCreateNestedManyWithoutUserInput
    referralUsesGained?: ReferralUseUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAssignmentSubsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAssignmentSubsInput, UserUncheckedCreateWithoutAssignmentSubsInput>
  }

  export type AssignmentCreateWithoutSubmissionsInput = {
    id?: string
    title: string
    description?: string | null
    dueDate?: Date | string | null
    maxScore: number
    allowFileUpload?: boolean
    allowedFileTypes?: AssignmentCreateallowedFileTypesInput | string[]
    unitTests?: NullableJsonNullValueInput | InputJsonValue
    lesson: LessonCreateNestedOneWithoutAssignmentInput
  }

  export type AssignmentUncheckedCreateWithoutSubmissionsInput = {
    id?: string
    lessonId: string
    title: string
    description?: string | null
    dueDate?: Date | string | null
    maxScore: number
    allowFileUpload?: boolean
    allowedFileTypes?: AssignmentCreateallowedFileTypesInput | string[]
    unitTests?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AssignmentCreateOrConnectWithoutSubmissionsInput = {
    where: AssignmentWhereUniqueInput
    create: XOR<AssignmentCreateWithoutSubmissionsInput, AssignmentUncheckedCreateWithoutSubmissionsInput>
  }

  export type UserCreateWithoutSubmissionsGradedInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    avatar?: string | null
    bio?: string | null
    createdAt?: Date | string
    points?: number
    referralCode?: string | null
    lastLogin?: Date | string | null
    referredBy?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferredByInput
    teacherProfile?: TeacherProfileCreateNestedOneWithoutUserInput
    availability?: UserAvailabilityCreateNestedManyWithoutUserInput
    pointsTransactions?: PointsTransactionCreateNestedManyWithoutUserInput
    courses?: CourseCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    savedCourses?: SavedCourseCreateNestedManyWithoutUserInput
    likedCourses?: LikedCourseCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutUserInput
    assignmentSubs?: AssignmentSubmissionCreateNestedManyWithoutUserInput
    courseReviews?: CourseReviewCreateNestedManyWithoutUserInput
    tutoringSessions?: TutoringSessionCreateNestedManyWithoutTeacherInput
    tutoringRequests?: TutoringRequestCreateNestedManyWithoutStudentInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentCreateNestedManyWithoutTeacherInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentCreateNestedManyWithoutStudentInput
    tutoringReviews?: TutoringReviewCreateNestedManyWithoutStudentInput
    tutoringMessages?: TutoringMessageCreateNestedManyWithoutSenderInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    conversationParts?: ConversationParticipantCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    attachments?: AttachmentCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    subscriptionRecords?: UserSubscriptionCreateNestedManyWithoutUserInput
    bundlesOwned?: UserBundleCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventCreateNestedManyWithoutUserInput
    eventsAsTeacher?: CalendarEventCreateNestedManyWithoutTeacherInput
    eventsAsStudent?: CalendarEventCreateNestedManyWithoutStudentInput
    blogPosts?: BlogPostCreateNestedManyWithoutAuthorInput
    blogComments?: BlogCommentCreateNestedManyWithoutUserInput
    referralCodesOwned?: ReferralCodeCreateNestedManyWithoutUserInput
    referralUsesGained?: ReferralUseCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSubmissionsGradedInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    avatar?: string | null
    bio?: string | null
    createdAt?: Date | string
    points?: number
    referralCode?: string | null
    referredById?: string | null
    lastLogin?: Date | string | null
    referrals?: UserUncheckedCreateNestedManyWithoutReferredByInput
    teacherProfile?: TeacherProfileUncheckedCreateNestedOneWithoutUserInput
    availability?: UserAvailabilityUncheckedCreateNestedManyWithoutUserInput
    pointsTransactions?: PointsTransactionUncheckedCreateNestedManyWithoutUserInput
    courses?: CourseUncheckedCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    savedCourses?: SavedCourseUncheckedCreateNestedManyWithoutUserInput
    likedCourses?: LikedCourseUncheckedCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressUncheckedCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutUserInput
    assignmentSubs?: AssignmentSubmissionUncheckedCreateNestedManyWithoutUserInput
    courseReviews?: CourseReviewUncheckedCreateNestedManyWithoutUserInput
    tutoringSessions?: TutoringSessionUncheckedCreateNestedManyWithoutTeacherInput
    tutoringRequests?: TutoringRequestUncheckedCreateNestedManyWithoutStudentInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUncheckedCreateNestedManyWithoutTeacherInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUncheckedCreateNestedManyWithoutStudentInput
    tutoringReviews?: TutoringReviewUncheckedCreateNestedManyWithoutStudentInput
    tutoringMessages?: TutoringMessageUncheckedCreateNestedManyWithoutSenderInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    conversationParts?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    subscriptionRecords?: UserSubscriptionUncheckedCreateNestedManyWithoutUserInput
    bundlesOwned?: UserBundleUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventUncheckedCreateNestedManyWithoutUserInput
    eventsAsTeacher?: CalendarEventUncheckedCreateNestedManyWithoutTeacherInput
    eventsAsStudent?: CalendarEventUncheckedCreateNestedManyWithoutStudentInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
    blogComments?: BlogCommentUncheckedCreateNestedManyWithoutUserInput
    referralCodesOwned?: ReferralCodeUncheckedCreateNestedManyWithoutUserInput
    referralUsesGained?: ReferralUseUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSubmissionsGradedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSubmissionsGradedInput, UserUncheckedCreateWithoutSubmissionsGradedInput>
  }

  export type UserUpsertWithoutAssignmentSubsInput = {
    update: XOR<UserUpdateWithoutAssignmentSubsInput, UserUncheckedUpdateWithoutAssignmentSubsInput>
    create: XOR<UserCreateWithoutAssignmentSubsInput, UserUncheckedCreateWithoutAssignmentSubsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAssignmentSubsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAssignmentSubsInput, UserUncheckedUpdateWithoutAssignmentSubsInput>
  }

  export type UserUpdateWithoutAssignmentSubsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: IntFieldUpdateOperationsInput | number
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referredBy?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferredByNestedInput
    teacherProfile?: TeacherProfileUpdateOneWithoutUserNestedInput
    availability?: UserAvailabilityUpdateManyWithoutUserNestedInput
    pointsTransactions?: PointsTransactionUpdateManyWithoutUserNestedInput
    courses?: CourseUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    savedCourses?: SavedCourseUpdateManyWithoutUserNestedInput
    likedCourses?: LikedCourseUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutUserNestedInput
    courseReviews?: CourseReviewUpdateManyWithoutUserNestedInput
    tutoringSessions?: TutoringSessionUpdateManyWithoutTeacherNestedInput
    tutoringRequests?: TutoringRequestUpdateManyWithoutStudentNestedInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUpdateManyWithoutTeacherNestedInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUpdateManyWithoutStudentNestedInput
    tutoringReviews?: TutoringReviewUpdateManyWithoutStudentNestedInput
    tutoringMessages?: TutoringMessageUpdateManyWithoutSenderNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    conversationParts?: ConversationParticipantUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    attachments?: AttachmentUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    subscriptionRecords?: UserSubscriptionUpdateManyWithoutUserNestedInput
    bundlesOwned?: UserBundleUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUpdateManyWithoutUserNestedInput
    eventsAsTeacher?: CalendarEventUpdateManyWithoutTeacherNestedInput
    eventsAsStudent?: CalendarEventUpdateManyWithoutStudentNestedInput
    blogPosts?: BlogPostUpdateManyWithoutAuthorNestedInput
    blogComments?: BlogCommentUpdateManyWithoutUserNestedInput
    submissionsGraded?: AssignmentSubmissionUpdateManyWithoutGradedByNestedInput
    referralCodesOwned?: ReferralCodeUpdateManyWithoutUserNestedInput
    referralUsesGained?: ReferralUseUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAssignmentSubsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: IntFieldUpdateOperationsInput | number
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referrals?: UserUncheckedUpdateManyWithoutReferredByNestedInput
    teacherProfile?: TeacherProfileUncheckedUpdateOneWithoutUserNestedInput
    availability?: UserAvailabilityUncheckedUpdateManyWithoutUserNestedInput
    pointsTransactions?: PointsTransactionUncheckedUpdateManyWithoutUserNestedInput
    courses?: CourseUncheckedUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    savedCourses?: SavedCourseUncheckedUpdateManyWithoutUserNestedInput
    likedCourses?: LikedCourseUncheckedUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUncheckedUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    courseReviews?: CourseReviewUncheckedUpdateManyWithoutUserNestedInput
    tutoringSessions?: TutoringSessionUncheckedUpdateManyWithoutTeacherNestedInput
    tutoringRequests?: TutoringRequestUncheckedUpdateManyWithoutStudentNestedInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUncheckedUpdateManyWithoutTeacherNestedInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUncheckedUpdateManyWithoutStudentNestedInput
    tutoringReviews?: TutoringReviewUncheckedUpdateManyWithoutStudentNestedInput
    tutoringMessages?: TutoringMessageUncheckedUpdateManyWithoutSenderNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    conversationParts?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    subscriptionRecords?: UserSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    bundlesOwned?: UserBundleUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUncheckedUpdateManyWithoutUserNestedInput
    eventsAsTeacher?: CalendarEventUncheckedUpdateManyWithoutTeacherNestedInput
    eventsAsStudent?: CalendarEventUncheckedUpdateManyWithoutStudentNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
    blogComments?: BlogCommentUncheckedUpdateManyWithoutUserNestedInput
    submissionsGraded?: AssignmentSubmissionUncheckedUpdateManyWithoutGradedByNestedInput
    referralCodesOwned?: ReferralCodeUncheckedUpdateManyWithoutUserNestedInput
    referralUsesGained?: ReferralUseUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AssignmentUpsertWithoutSubmissionsInput = {
    update: XOR<AssignmentUpdateWithoutSubmissionsInput, AssignmentUncheckedUpdateWithoutSubmissionsInput>
    create: XOR<AssignmentCreateWithoutSubmissionsInput, AssignmentUncheckedCreateWithoutSubmissionsInput>
    where?: AssignmentWhereInput
  }

  export type AssignmentUpdateToOneWithWhereWithoutSubmissionsInput = {
    where?: AssignmentWhereInput
    data: XOR<AssignmentUpdateWithoutSubmissionsInput, AssignmentUncheckedUpdateWithoutSubmissionsInput>
  }

  export type AssignmentUpdateWithoutSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxScore?: IntFieldUpdateOperationsInput | number
    allowFileUpload?: BoolFieldUpdateOperationsInput | boolean
    allowedFileTypes?: AssignmentUpdateallowedFileTypesInput | string[]
    unitTests?: NullableJsonNullValueInput | InputJsonValue
    lesson?: LessonUpdateOneRequiredWithoutAssignmentNestedInput
  }

  export type AssignmentUncheckedUpdateWithoutSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    lessonId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxScore?: IntFieldUpdateOperationsInput | number
    allowFileUpload?: BoolFieldUpdateOperationsInput | boolean
    allowedFileTypes?: AssignmentUpdateallowedFileTypesInput | string[]
    unitTests?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserUpsertWithoutSubmissionsGradedInput = {
    update: XOR<UserUpdateWithoutSubmissionsGradedInput, UserUncheckedUpdateWithoutSubmissionsGradedInput>
    create: XOR<UserCreateWithoutSubmissionsGradedInput, UserUncheckedCreateWithoutSubmissionsGradedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSubmissionsGradedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSubmissionsGradedInput, UserUncheckedUpdateWithoutSubmissionsGradedInput>
  }

  export type UserUpdateWithoutSubmissionsGradedInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: IntFieldUpdateOperationsInput | number
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referredBy?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferredByNestedInput
    teacherProfile?: TeacherProfileUpdateOneWithoutUserNestedInput
    availability?: UserAvailabilityUpdateManyWithoutUserNestedInput
    pointsTransactions?: PointsTransactionUpdateManyWithoutUserNestedInput
    courses?: CourseUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    savedCourses?: SavedCourseUpdateManyWithoutUserNestedInput
    likedCourses?: LikedCourseUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutUserNestedInput
    assignmentSubs?: AssignmentSubmissionUpdateManyWithoutUserNestedInput
    courseReviews?: CourseReviewUpdateManyWithoutUserNestedInput
    tutoringSessions?: TutoringSessionUpdateManyWithoutTeacherNestedInput
    tutoringRequests?: TutoringRequestUpdateManyWithoutStudentNestedInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUpdateManyWithoutTeacherNestedInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUpdateManyWithoutStudentNestedInput
    tutoringReviews?: TutoringReviewUpdateManyWithoutStudentNestedInput
    tutoringMessages?: TutoringMessageUpdateManyWithoutSenderNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    conversationParts?: ConversationParticipantUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    attachments?: AttachmentUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    subscriptionRecords?: UserSubscriptionUpdateManyWithoutUserNestedInput
    bundlesOwned?: UserBundleUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUpdateManyWithoutUserNestedInput
    eventsAsTeacher?: CalendarEventUpdateManyWithoutTeacherNestedInput
    eventsAsStudent?: CalendarEventUpdateManyWithoutStudentNestedInput
    blogPosts?: BlogPostUpdateManyWithoutAuthorNestedInput
    blogComments?: BlogCommentUpdateManyWithoutUserNestedInput
    referralCodesOwned?: ReferralCodeUpdateManyWithoutUserNestedInput
    referralUsesGained?: ReferralUseUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSubmissionsGradedInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: IntFieldUpdateOperationsInput | number
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referrals?: UserUncheckedUpdateManyWithoutReferredByNestedInput
    teacherProfile?: TeacherProfileUncheckedUpdateOneWithoutUserNestedInput
    availability?: UserAvailabilityUncheckedUpdateManyWithoutUserNestedInput
    pointsTransactions?: PointsTransactionUncheckedUpdateManyWithoutUserNestedInput
    courses?: CourseUncheckedUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    savedCourses?: SavedCourseUncheckedUpdateManyWithoutUserNestedInput
    likedCourses?: LikedCourseUncheckedUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUncheckedUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    assignmentSubs?: AssignmentSubmissionUncheckedUpdateManyWithoutUserNestedInput
    courseReviews?: CourseReviewUncheckedUpdateManyWithoutUserNestedInput
    tutoringSessions?: TutoringSessionUncheckedUpdateManyWithoutTeacherNestedInput
    tutoringRequests?: TutoringRequestUncheckedUpdateManyWithoutStudentNestedInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUncheckedUpdateManyWithoutTeacherNestedInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUncheckedUpdateManyWithoutStudentNestedInput
    tutoringReviews?: TutoringReviewUncheckedUpdateManyWithoutStudentNestedInput
    tutoringMessages?: TutoringMessageUncheckedUpdateManyWithoutSenderNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    conversationParts?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    subscriptionRecords?: UserSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    bundlesOwned?: UserBundleUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUncheckedUpdateManyWithoutUserNestedInput
    eventsAsTeacher?: CalendarEventUncheckedUpdateManyWithoutTeacherNestedInput
    eventsAsStudent?: CalendarEventUncheckedUpdateManyWithoutStudentNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
    blogComments?: BlogCommentUncheckedUpdateManyWithoutUserNestedInput
    referralCodesOwned?: ReferralCodeUncheckedUpdateManyWithoutUserNestedInput
    referralUsesGained?: ReferralUseUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutCourseReviewsInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    avatar?: string | null
    bio?: string | null
    createdAt?: Date | string
    points?: number
    referralCode?: string | null
    lastLogin?: Date | string | null
    referredBy?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferredByInput
    teacherProfile?: TeacherProfileCreateNestedOneWithoutUserInput
    availability?: UserAvailabilityCreateNestedManyWithoutUserInput
    pointsTransactions?: PointsTransactionCreateNestedManyWithoutUserInput
    courses?: CourseCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    savedCourses?: SavedCourseCreateNestedManyWithoutUserInput
    likedCourses?: LikedCourseCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutUserInput
    assignmentSubs?: AssignmentSubmissionCreateNestedManyWithoutUserInput
    tutoringSessions?: TutoringSessionCreateNestedManyWithoutTeacherInput
    tutoringRequests?: TutoringRequestCreateNestedManyWithoutStudentInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentCreateNestedManyWithoutTeacherInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentCreateNestedManyWithoutStudentInput
    tutoringReviews?: TutoringReviewCreateNestedManyWithoutStudentInput
    tutoringMessages?: TutoringMessageCreateNestedManyWithoutSenderInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    conversationParts?: ConversationParticipantCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    attachments?: AttachmentCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    subscriptionRecords?: UserSubscriptionCreateNestedManyWithoutUserInput
    bundlesOwned?: UserBundleCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventCreateNestedManyWithoutUserInput
    eventsAsTeacher?: CalendarEventCreateNestedManyWithoutTeacherInput
    eventsAsStudent?: CalendarEventCreateNestedManyWithoutStudentInput
    blogPosts?: BlogPostCreateNestedManyWithoutAuthorInput
    blogComments?: BlogCommentCreateNestedManyWithoutUserInput
    submissionsGraded?: AssignmentSubmissionCreateNestedManyWithoutGradedByInput
    referralCodesOwned?: ReferralCodeCreateNestedManyWithoutUserInput
    referralUsesGained?: ReferralUseCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCourseReviewsInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    avatar?: string | null
    bio?: string | null
    createdAt?: Date | string
    points?: number
    referralCode?: string | null
    referredById?: string | null
    lastLogin?: Date | string | null
    referrals?: UserUncheckedCreateNestedManyWithoutReferredByInput
    teacherProfile?: TeacherProfileUncheckedCreateNestedOneWithoutUserInput
    availability?: UserAvailabilityUncheckedCreateNestedManyWithoutUserInput
    pointsTransactions?: PointsTransactionUncheckedCreateNestedManyWithoutUserInput
    courses?: CourseUncheckedCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    savedCourses?: SavedCourseUncheckedCreateNestedManyWithoutUserInput
    likedCourses?: LikedCourseUncheckedCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressUncheckedCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutUserInput
    assignmentSubs?: AssignmentSubmissionUncheckedCreateNestedManyWithoutUserInput
    tutoringSessions?: TutoringSessionUncheckedCreateNestedManyWithoutTeacherInput
    tutoringRequests?: TutoringRequestUncheckedCreateNestedManyWithoutStudentInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUncheckedCreateNestedManyWithoutTeacherInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUncheckedCreateNestedManyWithoutStudentInput
    tutoringReviews?: TutoringReviewUncheckedCreateNestedManyWithoutStudentInput
    tutoringMessages?: TutoringMessageUncheckedCreateNestedManyWithoutSenderInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    conversationParts?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    subscriptionRecords?: UserSubscriptionUncheckedCreateNestedManyWithoutUserInput
    bundlesOwned?: UserBundleUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventUncheckedCreateNestedManyWithoutUserInput
    eventsAsTeacher?: CalendarEventUncheckedCreateNestedManyWithoutTeacherInput
    eventsAsStudent?: CalendarEventUncheckedCreateNestedManyWithoutStudentInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
    blogComments?: BlogCommentUncheckedCreateNestedManyWithoutUserInput
    submissionsGraded?: AssignmentSubmissionUncheckedCreateNestedManyWithoutGradedByInput
    referralCodesOwned?: ReferralCodeUncheckedCreateNestedManyWithoutUserInput
    referralUsesGained?: ReferralUseUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCourseReviewsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCourseReviewsInput, UserUncheckedCreateWithoutCourseReviewsInput>
  }

  export type CourseCreateWithoutReviewsInput = {
    id?: string
    title: string
    description?: string | null
    subject: string
    image?: string | null
    price: Decimal | DecimalJsLike | number | string
    pointsPrice: number
    students?: number
    rating?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.CourseStatus
    featured?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teacher: UserCreateNestedOneWithoutCoursesInput
    topics?: TopicCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentCreateNestedManyWithoutCourseInput
    savedBy?: SavedCourseCreateNestedManyWithoutCourseInput
    likedBy?: LikedCourseCreateNestedManyWithoutCourseInput
    lessons?: LessonCreateNestedManyWithoutCourseInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutCourseInput
    certificates?: CertificateCreateNestedManyWithoutCourseInput
    bundleCourses?: BundleCourseCreateNestedManyWithoutCourseInput
    calendarEvents?: CalendarEventCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutReviewsInput = {
    id?: string
    title: string
    description?: string | null
    subject: string
    image?: string | null
    price: Decimal | DecimalJsLike | number | string
    pointsPrice: number
    teacherId: string
    students?: number
    rating?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.CourseStatus
    featured?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    topics?: TopicUncheckedCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutCourseInput
    savedBy?: SavedCourseUncheckedCreateNestedManyWithoutCourseInput
    likedBy?: LikedCourseUncheckedCreateNestedManyWithoutCourseInput
    lessons?: LessonUncheckedCreateNestedManyWithoutCourseInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutCourseInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutCourseInput
    bundleCourses?: BundleCourseUncheckedCreateNestedManyWithoutCourseInput
    calendarEvents?: CalendarEventUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutReviewsInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutReviewsInput, CourseUncheckedCreateWithoutReviewsInput>
  }

  export type UserUpsertWithoutCourseReviewsInput = {
    update: XOR<UserUpdateWithoutCourseReviewsInput, UserUncheckedUpdateWithoutCourseReviewsInput>
    create: XOR<UserCreateWithoutCourseReviewsInput, UserUncheckedCreateWithoutCourseReviewsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCourseReviewsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCourseReviewsInput, UserUncheckedUpdateWithoutCourseReviewsInput>
  }

  export type UserUpdateWithoutCourseReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: IntFieldUpdateOperationsInput | number
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referredBy?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferredByNestedInput
    teacherProfile?: TeacherProfileUpdateOneWithoutUserNestedInput
    availability?: UserAvailabilityUpdateManyWithoutUserNestedInput
    pointsTransactions?: PointsTransactionUpdateManyWithoutUserNestedInput
    courses?: CourseUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    savedCourses?: SavedCourseUpdateManyWithoutUserNestedInput
    likedCourses?: LikedCourseUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutUserNestedInput
    assignmentSubs?: AssignmentSubmissionUpdateManyWithoutUserNestedInput
    tutoringSessions?: TutoringSessionUpdateManyWithoutTeacherNestedInput
    tutoringRequests?: TutoringRequestUpdateManyWithoutStudentNestedInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUpdateManyWithoutTeacherNestedInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUpdateManyWithoutStudentNestedInput
    tutoringReviews?: TutoringReviewUpdateManyWithoutStudentNestedInput
    tutoringMessages?: TutoringMessageUpdateManyWithoutSenderNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    conversationParts?: ConversationParticipantUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    attachments?: AttachmentUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    subscriptionRecords?: UserSubscriptionUpdateManyWithoutUserNestedInput
    bundlesOwned?: UserBundleUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUpdateManyWithoutUserNestedInput
    eventsAsTeacher?: CalendarEventUpdateManyWithoutTeacherNestedInput
    eventsAsStudent?: CalendarEventUpdateManyWithoutStudentNestedInput
    blogPosts?: BlogPostUpdateManyWithoutAuthorNestedInput
    blogComments?: BlogCommentUpdateManyWithoutUserNestedInput
    submissionsGraded?: AssignmentSubmissionUpdateManyWithoutGradedByNestedInput
    referralCodesOwned?: ReferralCodeUpdateManyWithoutUserNestedInput
    referralUsesGained?: ReferralUseUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCourseReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: IntFieldUpdateOperationsInput | number
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referrals?: UserUncheckedUpdateManyWithoutReferredByNestedInput
    teacherProfile?: TeacherProfileUncheckedUpdateOneWithoutUserNestedInput
    availability?: UserAvailabilityUncheckedUpdateManyWithoutUserNestedInput
    pointsTransactions?: PointsTransactionUncheckedUpdateManyWithoutUserNestedInput
    courses?: CourseUncheckedUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    savedCourses?: SavedCourseUncheckedUpdateManyWithoutUserNestedInput
    likedCourses?: LikedCourseUncheckedUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUncheckedUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    assignmentSubs?: AssignmentSubmissionUncheckedUpdateManyWithoutUserNestedInput
    tutoringSessions?: TutoringSessionUncheckedUpdateManyWithoutTeacherNestedInput
    tutoringRequests?: TutoringRequestUncheckedUpdateManyWithoutStudentNestedInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUncheckedUpdateManyWithoutTeacherNestedInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUncheckedUpdateManyWithoutStudentNestedInput
    tutoringReviews?: TutoringReviewUncheckedUpdateManyWithoutStudentNestedInput
    tutoringMessages?: TutoringMessageUncheckedUpdateManyWithoutSenderNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    conversationParts?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    subscriptionRecords?: UserSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    bundlesOwned?: UserBundleUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUncheckedUpdateManyWithoutUserNestedInput
    eventsAsTeacher?: CalendarEventUncheckedUpdateManyWithoutTeacherNestedInput
    eventsAsStudent?: CalendarEventUncheckedUpdateManyWithoutStudentNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
    blogComments?: BlogCommentUncheckedUpdateManyWithoutUserNestedInput
    submissionsGraded?: AssignmentSubmissionUncheckedUpdateManyWithoutGradedByNestedInput
    referralCodesOwned?: ReferralCodeUncheckedUpdateManyWithoutUserNestedInput
    referralUsesGained?: ReferralUseUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CourseUpsertWithoutReviewsInput = {
    update: XOR<CourseUpdateWithoutReviewsInput, CourseUncheckedUpdateWithoutReviewsInput>
    create: XOR<CourseCreateWithoutReviewsInput, CourseUncheckedCreateWithoutReviewsInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutReviewsInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutReviewsInput, CourseUncheckedUpdateWithoutReviewsInput>
  }

  export type CourseUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pointsPrice?: IntFieldUpdateOperationsInput | number
    students?: IntFieldUpdateOperationsInput | number
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumCourseStatusFieldUpdateOperationsInput | $Enums.CourseStatus
    featured?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher?: UserUpdateOneRequiredWithoutCoursesNestedInput
    topics?: TopicUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUpdateManyWithoutCourseNestedInput
    savedBy?: SavedCourseUpdateManyWithoutCourseNestedInput
    likedBy?: LikedCourseUpdateManyWithoutCourseNestedInput
    lessons?: LessonUpdateManyWithoutCourseNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutCourseNestedInput
    certificates?: CertificateUpdateManyWithoutCourseNestedInput
    bundleCourses?: BundleCourseUpdateManyWithoutCourseNestedInput
    calendarEvents?: CalendarEventUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pointsPrice?: IntFieldUpdateOperationsInput | number
    teacherId?: StringFieldUpdateOperationsInput | string
    students?: IntFieldUpdateOperationsInput | number
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumCourseStatusFieldUpdateOperationsInput | $Enums.CourseStatus
    featured?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    topics?: TopicUncheckedUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutCourseNestedInput
    savedBy?: SavedCourseUncheckedUpdateManyWithoutCourseNestedInput
    likedBy?: LikedCourseUncheckedUpdateManyWithoutCourseNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutCourseNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutCourseNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutCourseNestedInput
    bundleCourses?: BundleCourseUncheckedUpdateManyWithoutCourseNestedInput
    calendarEvents?: CalendarEventUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type UserCreateWithoutTutoringSessionsInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    avatar?: string | null
    bio?: string | null
    createdAt?: Date | string
    points?: number
    referralCode?: string | null
    lastLogin?: Date | string | null
    referredBy?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferredByInput
    teacherProfile?: TeacherProfileCreateNestedOneWithoutUserInput
    availability?: UserAvailabilityCreateNestedManyWithoutUserInput
    pointsTransactions?: PointsTransactionCreateNestedManyWithoutUserInput
    courses?: CourseCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    savedCourses?: SavedCourseCreateNestedManyWithoutUserInput
    likedCourses?: LikedCourseCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutUserInput
    assignmentSubs?: AssignmentSubmissionCreateNestedManyWithoutUserInput
    courseReviews?: CourseReviewCreateNestedManyWithoutUserInput
    tutoringRequests?: TutoringRequestCreateNestedManyWithoutStudentInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentCreateNestedManyWithoutTeacherInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentCreateNestedManyWithoutStudentInput
    tutoringReviews?: TutoringReviewCreateNestedManyWithoutStudentInput
    tutoringMessages?: TutoringMessageCreateNestedManyWithoutSenderInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    conversationParts?: ConversationParticipantCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    attachments?: AttachmentCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    subscriptionRecords?: UserSubscriptionCreateNestedManyWithoutUserInput
    bundlesOwned?: UserBundleCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventCreateNestedManyWithoutUserInput
    eventsAsTeacher?: CalendarEventCreateNestedManyWithoutTeacherInput
    eventsAsStudent?: CalendarEventCreateNestedManyWithoutStudentInput
    blogPosts?: BlogPostCreateNestedManyWithoutAuthorInput
    blogComments?: BlogCommentCreateNestedManyWithoutUserInput
    submissionsGraded?: AssignmentSubmissionCreateNestedManyWithoutGradedByInput
    referralCodesOwned?: ReferralCodeCreateNestedManyWithoutUserInput
    referralUsesGained?: ReferralUseCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTutoringSessionsInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    avatar?: string | null
    bio?: string | null
    createdAt?: Date | string
    points?: number
    referralCode?: string | null
    referredById?: string | null
    lastLogin?: Date | string | null
    referrals?: UserUncheckedCreateNestedManyWithoutReferredByInput
    teacherProfile?: TeacherProfileUncheckedCreateNestedOneWithoutUserInput
    availability?: UserAvailabilityUncheckedCreateNestedManyWithoutUserInput
    pointsTransactions?: PointsTransactionUncheckedCreateNestedManyWithoutUserInput
    courses?: CourseUncheckedCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    savedCourses?: SavedCourseUncheckedCreateNestedManyWithoutUserInput
    likedCourses?: LikedCourseUncheckedCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressUncheckedCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutUserInput
    assignmentSubs?: AssignmentSubmissionUncheckedCreateNestedManyWithoutUserInput
    courseReviews?: CourseReviewUncheckedCreateNestedManyWithoutUserInput
    tutoringRequests?: TutoringRequestUncheckedCreateNestedManyWithoutStudentInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUncheckedCreateNestedManyWithoutTeacherInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUncheckedCreateNestedManyWithoutStudentInput
    tutoringReviews?: TutoringReviewUncheckedCreateNestedManyWithoutStudentInput
    tutoringMessages?: TutoringMessageUncheckedCreateNestedManyWithoutSenderInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    conversationParts?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    subscriptionRecords?: UserSubscriptionUncheckedCreateNestedManyWithoutUserInput
    bundlesOwned?: UserBundleUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventUncheckedCreateNestedManyWithoutUserInput
    eventsAsTeacher?: CalendarEventUncheckedCreateNestedManyWithoutTeacherInput
    eventsAsStudent?: CalendarEventUncheckedCreateNestedManyWithoutStudentInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
    blogComments?: BlogCommentUncheckedCreateNestedManyWithoutUserInput
    submissionsGraded?: AssignmentSubmissionUncheckedCreateNestedManyWithoutGradedByInput
    referralCodesOwned?: ReferralCodeUncheckedCreateNestedManyWithoutUserInput
    referralUsesGained?: ReferralUseUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTutoringSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTutoringSessionsInput, UserUncheckedCreateWithoutTutoringSessionsInput>
  }

  export type TutoringAvailabilityCreateWithoutSessionInput = {
    id?: string
    dayOfWeek: number
    startTime: Date | string
    endTime: Date | string
  }

  export type TutoringAvailabilityUncheckedCreateWithoutSessionInput = {
    id?: string
    dayOfWeek: number
    startTime: Date | string
    endTime: Date | string
  }

  export type TutoringAvailabilityCreateOrConnectWithoutSessionInput = {
    where: TutoringAvailabilityWhereUniqueInput
    create: XOR<TutoringAvailabilityCreateWithoutSessionInput, TutoringAvailabilityUncheckedCreateWithoutSessionInput>
  }

  export type TutoringAvailabilityCreateManySessionInputEnvelope = {
    data: TutoringAvailabilityCreateManySessionInput | TutoringAvailabilityCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type TutoringRequestCreateWithoutSessionInput = {
    id?: string
    message?: string | null
    preferredDates?: TutoringRequestCreatepreferredDatesInput | Date[] | string[]
    status?: $Enums.TutoringRequestStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    student: UserCreateNestedOneWithoutTutoringRequestsInput
    appointment?: TutoringAppointmentCreateNestedOneWithoutRequestInput
    messages?: TutoringMessageCreateNestedManyWithoutRequestInput
  }

  export type TutoringRequestUncheckedCreateWithoutSessionInput = {
    id?: string
    studentId: string
    message?: string | null
    preferredDates?: TutoringRequestCreatepreferredDatesInput | Date[] | string[]
    status?: $Enums.TutoringRequestStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    appointment?: TutoringAppointmentUncheckedCreateNestedOneWithoutRequestInput
    messages?: TutoringMessageUncheckedCreateNestedManyWithoutRequestInput
  }

  export type TutoringRequestCreateOrConnectWithoutSessionInput = {
    where: TutoringRequestWhereUniqueInput
    create: XOR<TutoringRequestCreateWithoutSessionInput, TutoringRequestUncheckedCreateWithoutSessionInput>
  }

  export type TutoringRequestCreateManySessionInputEnvelope = {
    data: TutoringRequestCreateManySessionInput | TutoringRequestCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type TutoringAppointmentCreateWithoutSessionInput = {
    id?: string
    scheduledAt: Date | string
    duration: number
    notes?: string | null
    meetingLink?: string | null
    status?: $Enums.AppointmentStatus
    price: Decimal | DecimalJsLike | number | string
    request: TutoringRequestCreateNestedOneWithoutAppointmentInput
    teacher: UserCreateNestedOneWithoutTutoringAppointmentsAsTeacherInput
    student: UserCreateNestedOneWithoutTutoringAppointmentsAsStudentInput
  }

  export type TutoringAppointmentUncheckedCreateWithoutSessionInput = {
    id?: string
    requestId: string
    scheduledAt: Date | string
    duration: number
    notes?: string | null
    meetingLink?: string | null
    status?: $Enums.AppointmentStatus
    price: Decimal | DecimalJsLike | number | string
    teacherId: string
    studentId: string
  }

  export type TutoringAppointmentCreateOrConnectWithoutSessionInput = {
    where: TutoringAppointmentWhereUniqueInput
    create: XOR<TutoringAppointmentCreateWithoutSessionInput, TutoringAppointmentUncheckedCreateWithoutSessionInput>
  }

  export type TutoringAppointmentCreateManySessionInputEnvelope = {
    data: TutoringAppointmentCreateManySessionInput | TutoringAppointmentCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type TutoringReviewCreateWithoutSessionInput = {
    id?: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
    student: UserCreateNestedOneWithoutTutoringReviewsInput
  }

  export type TutoringReviewUncheckedCreateWithoutSessionInput = {
    id?: string
    studentId: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
  }

  export type TutoringReviewCreateOrConnectWithoutSessionInput = {
    where: TutoringReviewWhereUniqueInput
    create: XOR<TutoringReviewCreateWithoutSessionInput, TutoringReviewUncheckedCreateWithoutSessionInput>
  }

  export type TutoringReviewCreateManySessionInputEnvelope = {
    data: TutoringReviewCreateManySessionInput | TutoringReviewCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type CertificateCreateWithoutTutoringInput = {
    id?: string
    title: string
    issueDate?: Date | string
    type: string
    courseName?: string | null
    tutoringSubject?: string | null
    teacherId?: string | null
    teacherName?: string | null
    customMessage?: string | null
    imageUrl?: string | null
    user: UserCreateNestedOneWithoutCertificatesInput
    course?: CourseCreateNestedOneWithoutCertificatesInput
    badge?: BadgeCreateNestedOneWithoutCertificatesInput
  }

  export type CertificateUncheckedCreateWithoutTutoringInput = {
    id?: string
    userId: string
    title: string
    issueDate?: Date | string
    type: string
    courseId?: string | null
    courseName?: string | null
    tutoringSubject?: string | null
    teacherId?: string | null
    teacherName?: string | null
    customMessage?: string | null
    imageUrl?: string | null
    badgeId?: string | null
  }

  export type CertificateCreateOrConnectWithoutTutoringInput = {
    where: CertificateWhereUniqueInput
    create: XOR<CertificateCreateWithoutTutoringInput, CertificateUncheckedCreateWithoutTutoringInput>
  }

  export type CertificateCreateManyTutoringInputEnvelope = {
    data: CertificateCreateManyTutoringInput | CertificateCreateManyTutoringInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutTutoringSessionsInput = {
    update: XOR<UserUpdateWithoutTutoringSessionsInput, UserUncheckedUpdateWithoutTutoringSessionsInput>
    create: XOR<UserCreateWithoutTutoringSessionsInput, UserUncheckedCreateWithoutTutoringSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTutoringSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTutoringSessionsInput, UserUncheckedUpdateWithoutTutoringSessionsInput>
  }

  export type UserUpdateWithoutTutoringSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: IntFieldUpdateOperationsInput | number
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referredBy?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferredByNestedInput
    teacherProfile?: TeacherProfileUpdateOneWithoutUserNestedInput
    availability?: UserAvailabilityUpdateManyWithoutUserNestedInput
    pointsTransactions?: PointsTransactionUpdateManyWithoutUserNestedInput
    courses?: CourseUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    savedCourses?: SavedCourseUpdateManyWithoutUserNestedInput
    likedCourses?: LikedCourseUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutUserNestedInput
    assignmentSubs?: AssignmentSubmissionUpdateManyWithoutUserNestedInput
    courseReviews?: CourseReviewUpdateManyWithoutUserNestedInput
    tutoringRequests?: TutoringRequestUpdateManyWithoutStudentNestedInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUpdateManyWithoutTeacherNestedInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUpdateManyWithoutStudentNestedInput
    tutoringReviews?: TutoringReviewUpdateManyWithoutStudentNestedInput
    tutoringMessages?: TutoringMessageUpdateManyWithoutSenderNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    conversationParts?: ConversationParticipantUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    attachments?: AttachmentUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    subscriptionRecords?: UserSubscriptionUpdateManyWithoutUserNestedInput
    bundlesOwned?: UserBundleUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUpdateManyWithoutUserNestedInput
    eventsAsTeacher?: CalendarEventUpdateManyWithoutTeacherNestedInput
    eventsAsStudent?: CalendarEventUpdateManyWithoutStudentNestedInput
    blogPosts?: BlogPostUpdateManyWithoutAuthorNestedInput
    blogComments?: BlogCommentUpdateManyWithoutUserNestedInput
    submissionsGraded?: AssignmentSubmissionUpdateManyWithoutGradedByNestedInput
    referralCodesOwned?: ReferralCodeUpdateManyWithoutUserNestedInput
    referralUsesGained?: ReferralUseUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTutoringSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: IntFieldUpdateOperationsInput | number
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referrals?: UserUncheckedUpdateManyWithoutReferredByNestedInput
    teacherProfile?: TeacherProfileUncheckedUpdateOneWithoutUserNestedInput
    availability?: UserAvailabilityUncheckedUpdateManyWithoutUserNestedInput
    pointsTransactions?: PointsTransactionUncheckedUpdateManyWithoutUserNestedInput
    courses?: CourseUncheckedUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    savedCourses?: SavedCourseUncheckedUpdateManyWithoutUserNestedInput
    likedCourses?: LikedCourseUncheckedUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUncheckedUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    assignmentSubs?: AssignmentSubmissionUncheckedUpdateManyWithoutUserNestedInput
    courseReviews?: CourseReviewUncheckedUpdateManyWithoutUserNestedInput
    tutoringRequests?: TutoringRequestUncheckedUpdateManyWithoutStudentNestedInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUncheckedUpdateManyWithoutTeacherNestedInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUncheckedUpdateManyWithoutStudentNestedInput
    tutoringReviews?: TutoringReviewUncheckedUpdateManyWithoutStudentNestedInput
    tutoringMessages?: TutoringMessageUncheckedUpdateManyWithoutSenderNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    conversationParts?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    subscriptionRecords?: UserSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    bundlesOwned?: UserBundleUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUncheckedUpdateManyWithoutUserNestedInput
    eventsAsTeacher?: CalendarEventUncheckedUpdateManyWithoutTeacherNestedInput
    eventsAsStudent?: CalendarEventUncheckedUpdateManyWithoutStudentNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
    blogComments?: BlogCommentUncheckedUpdateManyWithoutUserNestedInput
    submissionsGraded?: AssignmentSubmissionUncheckedUpdateManyWithoutGradedByNestedInput
    referralCodesOwned?: ReferralCodeUncheckedUpdateManyWithoutUserNestedInput
    referralUsesGained?: ReferralUseUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TutoringAvailabilityUpsertWithWhereUniqueWithoutSessionInput = {
    where: TutoringAvailabilityWhereUniqueInput
    update: XOR<TutoringAvailabilityUpdateWithoutSessionInput, TutoringAvailabilityUncheckedUpdateWithoutSessionInput>
    create: XOR<TutoringAvailabilityCreateWithoutSessionInput, TutoringAvailabilityUncheckedCreateWithoutSessionInput>
  }

  export type TutoringAvailabilityUpdateWithWhereUniqueWithoutSessionInput = {
    where: TutoringAvailabilityWhereUniqueInput
    data: XOR<TutoringAvailabilityUpdateWithoutSessionInput, TutoringAvailabilityUncheckedUpdateWithoutSessionInput>
  }

  export type TutoringAvailabilityUpdateManyWithWhereWithoutSessionInput = {
    where: TutoringAvailabilityScalarWhereInput
    data: XOR<TutoringAvailabilityUpdateManyMutationInput, TutoringAvailabilityUncheckedUpdateManyWithoutSessionInput>
  }

  export type TutoringAvailabilityScalarWhereInput = {
    AND?: TutoringAvailabilityScalarWhereInput | TutoringAvailabilityScalarWhereInput[]
    OR?: TutoringAvailabilityScalarWhereInput[]
    NOT?: TutoringAvailabilityScalarWhereInput | TutoringAvailabilityScalarWhereInput[]
    id?: StringFilter<"TutoringAvailability"> | string
    sessionId?: StringFilter<"TutoringAvailability"> | string
    dayOfWeek?: IntFilter<"TutoringAvailability"> | number
    startTime?: DateTimeFilter<"TutoringAvailability"> | Date | string
    endTime?: DateTimeFilter<"TutoringAvailability"> | Date | string
  }

  export type TutoringRequestUpsertWithWhereUniqueWithoutSessionInput = {
    where: TutoringRequestWhereUniqueInput
    update: XOR<TutoringRequestUpdateWithoutSessionInput, TutoringRequestUncheckedUpdateWithoutSessionInput>
    create: XOR<TutoringRequestCreateWithoutSessionInput, TutoringRequestUncheckedCreateWithoutSessionInput>
  }

  export type TutoringRequestUpdateWithWhereUniqueWithoutSessionInput = {
    where: TutoringRequestWhereUniqueInput
    data: XOR<TutoringRequestUpdateWithoutSessionInput, TutoringRequestUncheckedUpdateWithoutSessionInput>
  }

  export type TutoringRequestUpdateManyWithWhereWithoutSessionInput = {
    where: TutoringRequestScalarWhereInput
    data: XOR<TutoringRequestUpdateManyMutationInput, TutoringRequestUncheckedUpdateManyWithoutSessionInput>
  }

  export type TutoringAppointmentUpsertWithWhereUniqueWithoutSessionInput = {
    where: TutoringAppointmentWhereUniqueInput
    update: XOR<TutoringAppointmentUpdateWithoutSessionInput, TutoringAppointmentUncheckedUpdateWithoutSessionInput>
    create: XOR<TutoringAppointmentCreateWithoutSessionInput, TutoringAppointmentUncheckedCreateWithoutSessionInput>
  }

  export type TutoringAppointmentUpdateWithWhereUniqueWithoutSessionInput = {
    where: TutoringAppointmentWhereUniqueInput
    data: XOR<TutoringAppointmentUpdateWithoutSessionInput, TutoringAppointmentUncheckedUpdateWithoutSessionInput>
  }

  export type TutoringAppointmentUpdateManyWithWhereWithoutSessionInput = {
    where: TutoringAppointmentScalarWhereInput
    data: XOR<TutoringAppointmentUpdateManyMutationInput, TutoringAppointmentUncheckedUpdateManyWithoutSessionInput>
  }

  export type TutoringReviewUpsertWithWhereUniqueWithoutSessionInput = {
    where: TutoringReviewWhereUniqueInput
    update: XOR<TutoringReviewUpdateWithoutSessionInput, TutoringReviewUncheckedUpdateWithoutSessionInput>
    create: XOR<TutoringReviewCreateWithoutSessionInput, TutoringReviewUncheckedCreateWithoutSessionInput>
  }

  export type TutoringReviewUpdateWithWhereUniqueWithoutSessionInput = {
    where: TutoringReviewWhereUniqueInput
    data: XOR<TutoringReviewUpdateWithoutSessionInput, TutoringReviewUncheckedUpdateWithoutSessionInput>
  }

  export type TutoringReviewUpdateManyWithWhereWithoutSessionInput = {
    where: TutoringReviewScalarWhereInput
    data: XOR<TutoringReviewUpdateManyMutationInput, TutoringReviewUncheckedUpdateManyWithoutSessionInput>
  }

  export type CertificateUpsertWithWhereUniqueWithoutTutoringInput = {
    where: CertificateWhereUniqueInput
    update: XOR<CertificateUpdateWithoutTutoringInput, CertificateUncheckedUpdateWithoutTutoringInput>
    create: XOR<CertificateCreateWithoutTutoringInput, CertificateUncheckedCreateWithoutTutoringInput>
  }

  export type CertificateUpdateWithWhereUniqueWithoutTutoringInput = {
    where: CertificateWhereUniqueInput
    data: XOR<CertificateUpdateWithoutTutoringInput, CertificateUncheckedUpdateWithoutTutoringInput>
  }

  export type CertificateUpdateManyWithWhereWithoutTutoringInput = {
    where: CertificateScalarWhereInput
    data: XOR<CertificateUpdateManyMutationInput, CertificateUncheckedUpdateManyWithoutTutoringInput>
  }

  export type TutoringSessionCreateWithoutAvailabilityInput = {
    id?: string
    subject: string
    description?: string | null
    pricePerHour: Decimal | DecimalJsLike | number | string
    locationType: $Enums.TutoringLocationType
    status?: $Enums.TutoringStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    maxStudents?: number
    prerequisites?: TutoringSessionCreateprerequisitesInput | string[]
    level?: string | null
    tags?: TutoringSessionCreatetagsInput | string[]
    featured?: boolean
    teacher: UserCreateNestedOneWithoutTutoringSessionsInput
    requests?: TutoringRequestCreateNestedManyWithoutSessionInput
    appointments?: TutoringAppointmentCreateNestedManyWithoutSessionInput
    reviews?: TutoringReviewCreateNestedManyWithoutSessionInput
    certificates?: CertificateCreateNestedManyWithoutTutoringInput
  }

  export type TutoringSessionUncheckedCreateWithoutAvailabilityInput = {
    id?: string
    teacherId: string
    subject: string
    description?: string | null
    pricePerHour: Decimal | DecimalJsLike | number | string
    locationType: $Enums.TutoringLocationType
    status?: $Enums.TutoringStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    maxStudents?: number
    prerequisites?: TutoringSessionCreateprerequisitesInput | string[]
    level?: string | null
    tags?: TutoringSessionCreatetagsInput | string[]
    featured?: boolean
    requests?: TutoringRequestUncheckedCreateNestedManyWithoutSessionInput
    appointments?: TutoringAppointmentUncheckedCreateNestedManyWithoutSessionInput
    reviews?: TutoringReviewUncheckedCreateNestedManyWithoutSessionInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutTutoringInput
  }

  export type TutoringSessionCreateOrConnectWithoutAvailabilityInput = {
    where: TutoringSessionWhereUniqueInput
    create: XOR<TutoringSessionCreateWithoutAvailabilityInput, TutoringSessionUncheckedCreateWithoutAvailabilityInput>
  }

  export type TutoringSessionUpsertWithoutAvailabilityInput = {
    update: XOR<TutoringSessionUpdateWithoutAvailabilityInput, TutoringSessionUncheckedUpdateWithoutAvailabilityInput>
    create: XOR<TutoringSessionCreateWithoutAvailabilityInput, TutoringSessionUncheckedCreateWithoutAvailabilityInput>
    where?: TutoringSessionWhereInput
  }

  export type TutoringSessionUpdateToOneWithWhereWithoutAvailabilityInput = {
    where?: TutoringSessionWhereInput
    data: XOR<TutoringSessionUpdateWithoutAvailabilityInput, TutoringSessionUncheckedUpdateWithoutAvailabilityInput>
  }

  export type TutoringSessionUpdateWithoutAvailabilityInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pricePerHour?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    locationType?: EnumTutoringLocationTypeFieldUpdateOperationsInput | $Enums.TutoringLocationType
    status?: EnumTutoringStatusFieldUpdateOperationsInput | $Enums.TutoringStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maxStudents?: IntFieldUpdateOperationsInput | number
    prerequisites?: TutoringSessionUpdateprerequisitesInput | string[]
    level?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: TutoringSessionUpdatetagsInput | string[]
    featured?: BoolFieldUpdateOperationsInput | boolean
    teacher?: UserUpdateOneRequiredWithoutTutoringSessionsNestedInput
    requests?: TutoringRequestUpdateManyWithoutSessionNestedInput
    appointments?: TutoringAppointmentUpdateManyWithoutSessionNestedInput
    reviews?: TutoringReviewUpdateManyWithoutSessionNestedInput
    certificates?: CertificateUpdateManyWithoutTutoringNestedInput
  }

  export type TutoringSessionUncheckedUpdateWithoutAvailabilityInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pricePerHour?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    locationType?: EnumTutoringLocationTypeFieldUpdateOperationsInput | $Enums.TutoringLocationType
    status?: EnumTutoringStatusFieldUpdateOperationsInput | $Enums.TutoringStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maxStudents?: IntFieldUpdateOperationsInput | number
    prerequisites?: TutoringSessionUpdateprerequisitesInput | string[]
    level?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: TutoringSessionUpdatetagsInput | string[]
    featured?: BoolFieldUpdateOperationsInput | boolean
    requests?: TutoringRequestUncheckedUpdateManyWithoutSessionNestedInput
    appointments?: TutoringAppointmentUncheckedUpdateManyWithoutSessionNestedInput
    reviews?: TutoringReviewUncheckedUpdateManyWithoutSessionNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutTutoringNestedInput
  }

  export type TutoringSessionCreateWithoutRequestsInput = {
    id?: string
    subject: string
    description?: string | null
    pricePerHour: Decimal | DecimalJsLike | number | string
    locationType: $Enums.TutoringLocationType
    status?: $Enums.TutoringStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    maxStudents?: number
    prerequisites?: TutoringSessionCreateprerequisitesInput | string[]
    level?: string | null
    tags?: TutoringSessionCreatetagsInput | string[]
    featured?: boolean
    teacher: UserCreateNestedOneWithoutTutoringSessionsInput
    availability?: TutoringAvailabilityCreateNestedManyWithoutSessionInput
    appointments?: TutoringAppointmentCreateNestedManyWithoutSessionInput
    reviews?: TutoringReviewCreateNestedManyWithoutSessionInput
    certificates?: CertificateCreateNestedManyWithoutTutoringInput
  }

  export type TutoringSessionUncheckedCreateWithoutRequestsInput = {
    id?: string
    teacherId: string
    subject: string
    description?: string | null
    pricePerHour: Decimal | DecimalJsLike | number | string
    locationType: $Enums.TutoringLocationType
    status?: $Enums.TutoringStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    maxStudents?: number
    prerequisites?: TutoringSessionCreateprerequisitesInput | string[]
    level?: string | null
    tags?: TutoringSessionCreatetagsInput | string[]
    featured?: boolean
    availability?: TutoringAvailabilityUncheckedCreateNestedManyWithoutSessionInput
    appointments?: TutoringAppointmentUncheckedCreateNestedManyWithoutSessionInput
    reviews?: TutoringReviewUncheckedCreateNestedManyWithoutSessionInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutTutoringInput
  }

  export type TutoringSessionCreateOrConnectWithoutRequestsInput = {
    where: TutoringSessionWhereUniqueInput
    create: XOR<TutoringSessionCreateWithoutRequestsInput, TutoringSessionUncheckedCreateWithoutRequestsInput>
  }

  export type UserCreateWithoutTutoringRequestsInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    avatar?: string | null
    bio?: string | null
    createdAt?: Date | string
    points?: number
    referralCode?: string | null
    lastLogin?: Date | string | null
    referredBy?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferredByInput
    teacherProfile?: TeacherProfileCreateNestedOneWithoutUserInput
    availability?: UserAvailabilityCreateNestedManyWithoutUserInput
    pointsTransactions?: PointsTransactionCreateNestedManyWithoutUserInput
    courses?: CourseCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    savedCourses?: SavedCourseCreateNestedManyWithoutUserInput
    likedCourses?: LikedCourseCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutUserInput
    assignmentSubs?: AssignmentSubmissionCreateNestedManyWithoutUserInput
    courseReviews?: CourseReviewCreateNestedManyWithoutUserInput
    tutoringSessions?: TutoringSessionCreateNestedManyWithoutTeacherInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentCreateNestedManyWithoutTeacherInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentCreateNestedManyWithoutStudentInput
    tutoringReviews?: TutoringReviewCreateNestedManyWithoutStudentInput
    tutoringMessages?: TutoringMessageCreateNestedManyWithoutSenderInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    conversationParts?: ConversationParticipantCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    attachments?: AttachmentCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    subscriptionRecords?: UserSubscriptionCreateNestedManyWithoutUserInput
    bundlesOwned?: UserBundleCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventCreateNestedManyWithoutUserInput
    eventsAsTeacher?: CalendarEventCreateNestedManyWithoutTeacherInput
    eventsAsStudent?: CalendarEventCreateNestedManyWithoutStudentInput
    blogPosts?: BlogPostCreateNestedManyWithoutAuthorInput
    blogComments?: BlogCommentCreateNestedManyWithoutUserInput
    submissionsGraded?: AssignmentSubmissionCreateNestedManyWithoutGradedByInput
    referralCodesOwned?: ReferralCodeCreateNestedManyWithoutUserInput
    referralUsesGained?: ReferralUseCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTutoringRequestsInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    avatar?: string | null
    bio?: string | null
    createdAt?: Date | string
    points?: number
    referralCode?: string | null
    referredById?: string | null
    lastLogin?: Date | string | null
    referrals?: UserUncheckedCreateNestedManyWithoutReferredByInput
    teacherProfile?: TeacherProfileUncheckedCreateNestedOneWithoutUserInput
    availability?: UserAvailabilityUncheckedCreateNestedManyWithoutUserInput
    pointsTransactions?: PointsTransactionUncheckedCreateNestedManyWithoutUserInput
    courses?: CourseUncheckedCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    savedCourses?: SavedCourseUncheckedCreateNestedManyWithoutUserInput
    likedCourses?: LikedCourseUncheckedCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressUncheckedCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutUserInput
    assignmentSubs?: AssignmentSubmissionUncheckedCreateNestedManyWithoutUserInput
    courseReviews?: CourseReviewUncheckedCreateNestedManyWithoutUserInput
    tutoringSessions?: TutoringSessionUncheckedCreateNestedManyWithoutTeacherInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUncheckedCreateNestedManyWithoutTeacherInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUncheckedCreateNestedManyWithoutStudentInput
    tutoringReviews?: TutoringReviewUncheckedCreateNestedManyWithoutStudentInput
    tutoringMessages?: TutoringMessageUncheckedCreateNestedManyWithoutSenderInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    conversationParts?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    subscriptionRecords?: UserSubscriptionUncheckedCreateNestedManyWithoutUserInput
    bundlesOwned?: UserBundleUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventUncheckedCreateNestedManyWithoutUserInput
    eventsAsTeacher?: CalendarEventUncheckedCreateNestedManyWithoutTeacherInput
    eventsAsStudent?: CalendarEventUncheckedCreateNestedManyWithoutStudentInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
    blogComments?: BlogCommentUncheckedCreateNestedManyWithoutUserInput
    submissionsGraded?: AssignmentSubmissionUncheckedCreateNestedManyWithoutGradedByInput
    referralCodesOwned?: ReferralCodeUncheckedCreateNestedManyWithoutUserInput
    referralUsesGained?: ReferralUseUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTutoringRequestsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTutoringRequestsInput, UserUncheckedCreateWithoutTutoringRequestsInput>
  }

  export type TutoringAppointmentCreateWithoutRequestInput = {
    id?: string
    scheduledAt: Date | string
    duration: number
    notes?: string | null
    meetingLink?: string | null
    status?: $Enums.AppointmentStatus
    price: Decimal | DecimalJsLike | number | string
    session: TutoringSessionCreateNestedOneWithoutAppointmentsInput
    teacher: UserCreateNestedOneWithoutTutoringAppointmentsAsTeacherInput
    student: UserCreateNestedOneWithoutTutoringAppointmentsAsStudentInput
  }

  export type TutoringAppointmentUncheckedCreateWithoutRequestInput = {
    id?: string
    sessionId: string
    scheduledAt: Date | string
    duration: number
    notes?: string | null
    meetingLink?: string | null
    status?: $Enums.AppointmentStatus
    price: Decimal | DecimalJsLike | number | string
    teacherId: string
    studentId: string
  }

  export type TutoringAppointmentCreateOrConnectWithoutRequestInput = {
    where: TutoringAppointmentWhereUniqueInput
    create: XOR<TutoringAppointmentCreateWithoutRequestInput, TutoringAppointmentUncheckedCreateWithoutRequestInput>
  }

  export type TutoringMessageCreateWithoutRequestInput = {
    id?: string
    message: string
    read?: boolean
    createdAt?: Date | string
    sender: UserCreateNestedOneWithoutTutoringMessagesInput
  }

  export type TutoringMessageUncheckedCreateWithoutRequestInput = {
    id?: string
    senderId: string
    message: string
    read?: boolean
    createdAt?: Date | string
  }

  export type TutoringMessageCreateOrConnectWithoutRequestInput = {
    where: TutoringMessageWhereUniqueInput
    create: XOR<TutoringMessageCreateWithoutRequestInput, TutoringMessageUncheckedCreateWithoutRequestInput>
  }

  export type TutoringMessageCreateManyRequestInputEnvelope = {
    data: TutoringMessageCreateManyRequestInput | TutoringMessageCreateManyRequestInput[]
    skipDuplicates?: boolean
  }

  export type TutoringSessionUpsertWithoutRequestsInput = {
    update: XOR<TutoringSessionUpdateWithoutRequestsInput, TutoringSessionUncheckedUpdateWithoutRequestsInput>
    create: XOR<TutoringSessionCreateWithoutRequestsInput, TutoringSessionUncheckedCreateWithoutRequestsInput>
    where?: TutoringSessionWhereInput
  }

  export type TutoringSessionUpdateToOneWithWhereWithoutRequestsInput = {
    where?: TutoringSessionWhereInput
    data: XOR<TutoringSessionUpdateWithoutRequestsInput, TutoringSessionUncheckedUpdateWithoutRequestsInput>
  }

  export type TutoringSessionUpdateWithoutRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pricePerHour?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    locationType?: EnumTutoringLocationTypeFieldUpdateOperationsInput | $Enums.TutoringLocationType
    status?: EnumTutoringStatusFieldUpdateOperationsInput | $Enums.TutoringStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maxStudents?: IntFieldUpdateOperationsInput | number
    prerequisites?: TutoringSessionUpdateprerequisitesInput | string[]
    level?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: TutoringSessionUpdatetagsInput | string[]
    featured?: BoolFieldUpdateOperationsInput | boolean
    teacher?: UserUpdateOneRequiredWithoutTutoringSessionsNestedInput
    availability?: TutoringAvailabilityUpdateManyWithoutSessionNestedInput
    appointments?: TutoringAppointmentUpdateManyWithoutSessionNestedInput
    reviews?: TutoringReviewUpdateManyWithoutSessionNestedInput
    certificates?: CertificateUpdateManyWithoutTutoringNestedInput
  }

  export type TutoringSessionUncheckedUpdateWithoutRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pricePerHour?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    locationType?: EnumTutoringLocationTypeFieldUpdateOperationsInput | $Enums.TutoringLocationType
    status?: EnumTutoringStatusFieldUpdateOperationsInput | $Enums.TutoringStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maxStudents?: IntFieldUpdateOperationsInput | number
    prerequisites?: TutoringSessionUpdateprerequisitesInput | string[]
    level?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: TutoringSessionUpdatetagsInput | string[]
    featured?: BoolFieldUpdateOperationsInput | boolean
    availability?: TutoringAvailabilityUncheckedUpdateManyWithoutSessionNestedInput
    appointments?: TutoringAppointmentUncheckedUpdateManyWithoutSessionNestedInput
    reviews?: TutoringReviewUncheckedUpdateManyWithoutSessionNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutTutoringNestedInput
  }

  export type UserUpsertWithoutTutoringRequestsInput = {
    update: XOR<UserUpdateWithoutTutoringRequestsInput, UserUncheckedUpdateWithoutTutoringRequestsInput>
    create: XOR<UserCreateWithoutTutoringRequestsInput, UserUncheckedCreateWithoutTutoringRequestsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTutoringRequestsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTutoringRequestsInput, UserUncheckedUpdateWithoutTutoringRequestsInput>
  }

  export type UserUpdateWithoutTutoringRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: IntFieldUpdateOperationsInput | number
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referredBy?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferredByNestedInput
    teacherProfile?: TeacherProfileUpdateOneWithoutUserNestedInput
    availability?: UserAvailabilityUpdateManyWithoutUserNestedInput
    pointsTransactions?: PointsTransactionUpdateManyWithoutUserNestedInput
    courses?: CourseUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    savedCourses?: SavedCourseUpdateManyWithoutUserNestedInput
    likedCourses?: LikedCourseUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutUserNestedInput
    assignmentSubs?: AssignmentSubmissionUpdateManyWithoutUserNestedInput
    courseReviews?: CourseReviewUpdateManyWithoutUserNestedInput
    tutoringSessions?: TutoringSessionUpdateManyWithoutTeacherNestedInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUpdateManyWithoutTeacherNestedInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUpdateManyWithoutStudentNestedInput
    tutoringReviews?: TutoringReviewUpdateManyWithoutStudentNestedInput
    tutoringMessages?: TutoringMessageUpdateManyWithoutSenderNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    conversationParts?: ConversationParticipantUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    attachments?: AttachmentUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    subscriptionRecords?: UserSubscriptionUpdateManyWithoutUserNestedInput
    bundlesOwned?: UserBundleUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUpdateManyWithoutUserNestedInput
    eventsAsTeacher?: CalendarEventUpdateManyWithoutTeacherNestedInput
    eventsAsStudent?: CalendarEventUpdateManyWithoutStudentNestedInput
    blogPosts?: BlogPostUpdateManyWithoutAuthorNestedInput
    blogComments?: BlogCommentUpdateManyWithoutUserNestedInput
    submissionsGraded?: AssignmentSubmissionUpdateManyWithoutGradedByNestedInput
    referralCodesOwned?: ReferralCodeUpdateManyWithoutUserNestedInput
    referralUsesGained?: ReferralUseUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTutoringRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: IntFieldUpdateOperationsInput | number
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referrals?: UserUncheckedUpdateManyWithoutReferredByNestedInput
    teacherProfile?: TeacherProfileUncheckedUpdateOneWithoutUserNestedInput
    availability?: UserAvailabilityUncheckedUpdateManyWithoutUserNestedInput
    pointsTransactions?: PointsTransactionUncheckedUpdateManyWithoutUserNestedInput
    courses?: CourseUncheckedUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    savedCourses?: SavedCourseUncheckedUpdateManyWithoutUserNestedInput
    likedCourses?: LikedCourseUncheckedUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUncheckedUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    assignmentSubs?: AssignmentSubmissionUncheckedUpdateManyWithoutUserNestedInput
    courseReviews?: CourseReviewUncheckedUpdateManyWithoutUserNestedInput
    tutoringSessions?: TutoringSessionUncheckedUpdateManyWithoutTeacherNestedInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUncheckedUpdateManyWithoutTeacherNestedInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUncheckedUpdateManyWithoutStudentNestedInput
    tutoringReviews?: TutoringReviewUncheckedUpdateManyWithoutStudentNestedInput
    tutoringMessages?: TutoringMessageUncheckedUpdateManyWithoutSenderNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    conversationParts?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    subscriptionRecords?: UserSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    bundlesOwned?: UserBundleUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUncheckedUpdateManyWithoutUserNestedInput
    eventsAsTeacher?: CalendarEventUncheckedUpdateManyWithoutTeacherNestedInput
    eventsAsStudent?: CalendarEventUncheckedUpdateManyWithoutStudentNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
    blogComments?: BlogCommentUncheckedUpdateManyWithoutUserNestedInput
    submissionsGraded?: AssignmentSubmissionUncheckedUpdateManyWithoutGradedByNestedInput
    referralCodesOwned?: ReferralCodeUncheckedUpdateManyWithoutUserNestedInput
    referralUsesGained?: ReferralUseUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TutoringAppointmentUpsertWithoutRequestInput = {
    update: XOR<TutoringAppointmentUpdateWithoutRequestInput, TutoringAppointmentUncheckedUpdateWithoutRequestInput>
    create: XOR<TutoringAppointmentCreateWithoutRequestInput, TutoringAppointmentUncheckedCreateWithoutRequestInput>
    where?: TutoringAppointmentWhereInput
  }

  export type TutoringAppointmentUpdateToOneWithWhereWithoutRequestInput = {
    where?: TutoringAppointmentWhereInput
    data: XOR<TutoringAppointmentUpdateWithoutRequestInput, TutoringAppointmentUncheckedUpdateWithoutRequestInput>
  }

  export type TutoringAppointmentUpdateWithoutRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    session?: TutoringSessionUpdateOneRequiredWithoutAppointmentsNestedInput
    teacher?: UserUpdateOneRequiredWithoutTutoringAppointmentsAsTeacherNestedInput
    student?: UserUpdateOneRequiredWithoutTutoringAppointmentsAsStudentNestedInput
  }

  export type TutoringAppointmentUncheckedUpdateWithoutRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    teacherId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
  }

  export type TutoringMessageUpsertWithWhereUniqueWithoutRequestInput = {
    where: TutoringMessageWhereUniqueInput
    update: XOR<TutoringMessageUpdateWithoutRequestInput, TutoringMessageUncheckedUpdateWithoutRequestInput>
    create: XOR<TutoringMessageCreateWithoutRequestInput, TutoringMessageUncheckedCreateWithoutRequestInput>
  }

  export type TutoringMessageUpdateWithWhereUniqueWithoutRequestInput = {
    where: TutoringMessageWhereUniqueInput
    data: XOR<TutoringMessageUpdateWithoutRequestInput, TutoringMessageUncheckedUpdateWithoutRequestInput>
  }

  export type TutoringMessageUpdateManyWithWhereWithoutRequestInput = {
    where: TutoringMessageScalarWhereInput
    data: XOR<TutoringMessageUpdateManyMutationInput, TutoringMessageUncheckedUpdateManyWithoutRequestInput>
  }

  export type TutoringRequestCreateWithoutAppointmentInput = {
    id?: string
    message?: string | null
    preferredDates?: TutoringRequestCreatepreferredDatesInput | Date[] | string[]
    status?: $Enums.TutoringRequestStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    session: TutoringSessionCreateNestedOneWithoutRequestsInput
    student: UserCreateNestedOneWithoutTutoringRequestsInput
    messages?: TutoringMessageCreateNestedManyWithoutRequestInput
  }

  export type TutoringRequestUncheckedCreateWithoutAppointmentInput = {
    id?: string
    sessionId: string
    studentId: string
    message?: string | null
    preferredDates?: TutoringRequestCreatepreferredDatesInput | Date[] | string[]
    status?: $Enums.TutoringRequestStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: TutoringMessageUncheckedCreateNestedManyWithoutRequestInput
  }

  export type TutoringRequestCreateOrConnectWithoutAppointmentInput = {
    where: TutoringRequestWhereUniqueInput
    create: XOR<TutoringRequestCreateWithoutAppointmentInput, TutoringRequestUncheckedCreateWithoutAppointmentInput>
  }

  export type TutoringSessionCreateWithoutAppointmentsInput = {
    id?: string
    subject: string
    description?: string | null
    pricePerHour: Decimal | DecimalJsLike | number | string
    locationType: $Enums.TutoringLocationType
    status?: $Enums.TutoringStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    maxStudents?: number
    prerequisites?: TutoringSessionCreateprerequisitesInput | string[]
    level?: string | null
    tags?: TutoringSessionCreatetagsInput | string[]
    featured?: boolean
    teacher: UserCreateNestedOneWithoutTutoringSessionsInput
    availability?: TutoringAvailabilityCreateNestedManyWithoutSessionInput
    requests?: TutoringRequestCreateNestedManyWithoutSessionInput
    reviews?: TutoringReviewCreateNestedManyWithoutSessionInput
    certificates?: CertificateCreateNestedManyWithoutTutoringInput
  }

  export type TutoringSessionUncheckedCreateWithoutAppointmentsInput = {
    id?: string
    teacherId: string
    subject: string
    description?: string | null
    pricePerHour: Decimal | DecimalJsLike | number | string
    locationType: $Enums.TutoringLocationType
    status?: $Enums.TutoringStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    maxStudents?: number
    prerequisites?: TutoringSessionCreateprerequisitesInput | string[]
    level?: string | null
    tags?: TutoringSessionCreatetagsInput | string[]
    featured?: boolean
    availability?: TutoringAvailabilityUncheckedCreateNestedManyWithoutSessionInput
    requests?: TutoringRequestUncheckedCreateNestedManyWithoutSessionInput
    reviews?: TutoringReviewUncheckedCreateNestedManyWithoutSessionInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutTutoringInput
  }

  export type TutoringSessionCreateOrConnectWithoutAppointmentsInput = {
    where: TutoringSessionWhereUniqueInput
    create: XOR<TutoringSessionCreateWithoutAppointmentsInput, TutoringSessionUncheckedCreateWithoutAppointmentsInput>
  }

  export type UserCreateWithoutTutoringAppointmentsAsTeacherInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    avatar?: string | null
    bio?: string | null
    createdAt?: Date | string
    points?: number
    referralCode?: string | null
    lastLogin?: Date | string | null
    referredBy?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferredByInput
    teacherProfile?: TeacherProfileCreateNestedOneWithoutUserInput
    availability?: UserAvailabilityCreateNestedManyWithoutUserInput
    pointsTransactions?: PointsTransactionCreateNestedManyWithoutUserInput
    courses?: CourseCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    savedCourses?: SavedCourseCreateNestedManyWithoutUserInput
    likedCourses?: LikedCourseCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutUserInput
    assignmentSubs?: AssignmentSubmissionCreateNestedManyWithoutUserInput
    courseReviews?: CourseReviewCreateNestedManyWithoutUserInput
    tutoringSessions?: TutoringSessionCreateNestedManyWithoutTeacherInput
    tutoringRequests?: TutoringRequestCreateNestedManyWithoutStudentInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentCreateNestedManyWithoutStudentInput
    tutoringReviews?: TutoringReviewCreateNestedManyWithoutStudentInput
    tutoringMessages?: TutoringMessageCreateNestedManyWithoutSenderInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    conversationParts?: ConversationParticipantCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    attachments?: AttachmentCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    subscriptionRecords?: UserSubscriptionCreateNestedManyWithoutUserInput
    bundlesOwned?: UserBundleCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventCreateNestedManyWithoutUserInput
    eventsAsTeacher?: CalendarEventCreateNestedManyWithoutTeacherInput
    eventsAsStudent?: CalendarEventCreateNestedManyWithoutStudentInput
    blogPosts?: BlogPostCreateNestedManyWithoutAuthorInput
    blogComments?: BlogCommentCreateNestedManyWithoutUserInput
    submissionsGraded?: AssignmentSubmissionCreateNestedManyWithoutGradedByInput
    referralCodesOwned?: ReferralCodeCreateNestedManyWithoutUserInput
    referralUsesGained?: ReferralUseCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTutoringAppointmentsAsTeacherInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    avatar?: string | null
    bio?: string | null
    createdAt?: Date | string
    points?: number
    referralCode?: string | null
    referredById?: string | null
    lastLogin?: Date | string | null
    referrals?: UserUncheckedCreateNestedManyWithoutReferredByInput
    teacherProfile?: TeacherProfileUncheckedCreateNestedOneWithoutUserInput
    availability?: UserAvailabilityUncheckedCreateNestedManyWithoutUserInput
    pointsTransactions?: PointsTransactionUncheckedCreateNestedManyWithoutUserInput
    courses?: CourseUncheckedCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    savedCourses?: SavedCourseUncheckedCreateNestedManyWithoutUserInput
    likedCourses?: LikedCourseUncheckedCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressUncheckedCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutUserInput
    assignmentSubs?: AssignmentSubmissionUncheckedCreateNestedManyWithoutUserInput
    courseReviews?: CourseReviewUncheckedCreateNestedManyWithoutUserInput
    tutoringSessions?: TutoringSessionUncheckedCreateNestedManyWithoutTeacherInput
    tutoringRequests?: TutoringRequestUncheckedCreateNestedManyWithoutStudentInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUncheckedCreateNestedManyWithoutStudentInput
    tutoringReviews?: TutoringReviewUncheckedCreateNestedManyWithoutStudentInput
    tutoringMessages?: TutoringMessageUncheckedCreateNestedManyWithoutSenderInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    conversationParts?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    subscriptionRecords?: UserSubscriptionUncheckedCreateNestedManyWithoutUserInput
    bundlesOwned?: UserBundleUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventUncheckedCreateNestedManyWithoutUserInput
    eventsAsTeacher?: CalendarEventUncheckedCreateNestedManyWithoutTeacherInput
    eventsAsStudent?: CalendarEventUncheckedCreateNestedManyWithoutStudentInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
    blogComments?: BlogCommentUncheckedCreateNestedManyWithoutUserInput
    submissionsGraded?: AssignmentSubmissionUncheckedCreateNestedManyWithoutGradedByInput
    referralCodesOwned?: ReferralCodeUncheckedCreateNestedManyWithoutUserInput
    referralUsesGained?: ReferralUseUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTutoringAppointmentsAsTeacherInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTutoringAppointmentsAsTeacherInput, UserUncheckedCreateWithoutTutoringAppointmentsAsTeacherInput>
  }

  export type UserCreateWithoutTutoringAppointmentsAsStudentInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    avatar?: string | null
    bio?: string | null
    createdAt?: Date | string
    points?: number
    referralCode?: string | null
    lastLogin?: Date | string | null
    referredBy?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferredByInput
    teacherProfile?: TeacherProfileCreateNestedOneWithoutUserInput
    availability?: UserAvailabilityCreateNestedManyWithoutUserInput
    pointsTransactions?: PointsTransactionCreateNestedManyWithoutUserInput
    courses?: CourseCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    savedCourses?: SavedCourseCreateNestedManyWithoutUserInput
    likedCourses?: LikedCourseCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutUserInput
    assignmentSubs?: AssignmentSubmissionCreateNestedManyWithoutUserInput
    courseReviews?: CourseReviewCreateNestedManyWithoutUserInput
    tutoringSessions?: TutoringSessionCreateNestedManyWithoutTeacherInput
    tutoringRequests?: TutoringRequestCreateNestedManyWithoutStudentInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentCreateNestedManyWithoutTeacherInput
    tutoringReviews?: TutoringReviewCreateNestedManyWithoutStudentInput
    tutoringMessages?: TutoringMessageCreateNestedManyWithoutSenderInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    conversationParts?: ConversationParticipantCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    attachments?: AttachmentCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    subscriptionRecords?: UserSubscriptionCreateNestedManyWithoutUserInput
    bundlesOwned?: UserBundleCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventCreateNestedManyWithoutUserInput
    eventsAsTeacher?: CalendarEventCreateNestedManyWithoutTeacherInput
    eventsAsStudent?: CalendarEventCreateNestedManyWithoutStudentInput
    blogPosts?: BlogPostCreateNestedManyWithoutAuthorInput
    blogComments?: BlogCommentCreateNestedManyWithoutUserInput
    submissionsGraded?: AssignmentSubmissionCreateNestedManyWithoutGradedByInput
    referralCodesOwned?: ReferralCodeCreateNestedManyWithoutUserInput
    referralUsesGained?: ReferralUseCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTutoringAppointmentsAsStudentInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    avatar?: string | null
    bio?: string | null
    createdAt?: Date | string
    points?: number
    referralCode?: string | null
    referredById?: string | null
    lastLogin?: Date | string | null
    referrals?: UserUncheckedCreateNestedManyWithoutReferredByInput
    teacherProfile?: TeacherProfileUncheckedCreateNestedOneWithoutUserInput
    availability?: UserAvailabilityUncheckedCreateNestedManyWithoutUserInput
    pointsTransactions?: PointsTransactionUncheckedCreateNestedManyWithoutUserInput
    courses?: CourseUncheckedCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    savedCourses?: SavedCourseUncheckedCreateNestedManyWithoutUserInput
    likedCourses?: LikedCourseUncheckedCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressUncheckedCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutUserInput
    assignmentSubs?: AssignmentSubmissionUncheckedCreateNestedManyWithoutUserInput
    courseReviews?: CourseReviewUncheckedCreateNestedManyWithoutUserInput
    tutoringSessions?: TutoringSessionUncheckedCreateNestedManyWithoutTeacherInput
    tutoringRequests?: TutoringRequestUncheckedCreateNestedManyWithoutStudentInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUncheckedCreateNestedManyWithoutTeacherInput
    tutoringReviews?: TutoringReviewUncheckedCreateNestedManyWithoutStudentInput
    tutoringMessages?: TutoringMessageUncheckedCreateNestedManyWithoutSenderInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    conversationParts?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    subscriptionRecords?: UserSubscriptionUncheckedCreateNestedManyWithoutUserInput
    bundlesOwned?: UserBundleUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventUncheckedCreateNestedManyWithoutUserInput
    eventsAsTeacher?: CalendarEventUncheckedCreateNestedManyWithoutTeacherInput
    eventsAsStudent?: CalendarEventUncheckedCreateNestedManyWithoutStudentInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
    blogComments?: BlogCommentUncheckedCreateNestedManyWithoutUserInput
    submissionsGraded?: AssignmentSubmissionUncheckedCreateNestedManyWithoutGradedByInput
    referralCodesOwned?: ReferralCodeUncheckedCreateNestedManyWithoutUserInput
    referralUsesGained?: ReferralUseUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTutoringAppointmentsAsStudentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTutoringAppointmentsAsStudentInput, UserUncheckedCreateWithoutTutoringAppointmentsAsStudentInput>
  }

  export type TutoringRequestUpsertWithoutAppointmentInput = {
    update: XOR<TutoringRequestUpdateWithoutAppointmentInput, TutoringRequestUncheckedUpdateWithoutAppointmentInput>
    create: XOR<TutoringRequestCreateWithoutAppointmentInput, TutoringRequestUncheckedCreateWithoutAppointmentInput>
    where?: TutoringRequestWhereInput
  }

  export type TutoringRequestUpdateToOneWithWhereWithoutAppointmentInput = {
    where?: TutoringRequestWhereInput
    data: XOR<TutoringRequestUpdateWithoutAppointmentInput, TutoringRequestUncheckedUpdateWithoutAppointmentInput>
  }

  export type TutoringRequestUpdateWithoutAppointmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    preferredDates?: TutoringRequestUpdatepreferredDatesInput | Date[] | string[]
    status?: EnumTutoringRequestStatusFieldUpdateOperationsInput | $Enums.TutoringRequestStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: TutoringSessionUpdateOneRequiredWithoutRequestsNestedInput
    student?: UserUpdateOneRequiredWithoutTutoringRequestsNestedInput
    messages?: TutoringMessageUpdateManyWithoutRequestNestedInput
  }

  export type TutoringRequestUncheckedUpdateWithoutAppointmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    preferredDates?: TutoringRequestUpdatepreferredDatesInput | Date[] | string[]
    status?: EnumTutoringRequestStatusFieldUpdateOperationsInput | $Enums.TutoringRequestStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: TutoringMessageUncheckedUpdateManyWithoutRequestNestedInput
  }

  export type TutoringSessionUpsertWithoutAppointmentsInput = {
    update: XOR<TutoringSessionUpdateWithoutAppointmentsInput, TutoringSessionUncheckedUpdateWithoutAppointmentsInput>
    create: XOR<TutoringSessionCreateWithoutAppointmentsInput, TutoringSessionUncheckedCreateWithoutAppointmentsInput>
    where?: TutoringSessionWhereInput
  }

  export type TutoringSessionUpdateToOneWithWhereWithoutAppointmentsInput = {
    where?: TutoringSessionWhereInput
    data: XOR<TutoringSessionUpdateWithoutAppointmentsInput, TutoringSessionUncheckedUpdateWithoutAppointmentsInput>
  }

  export type TutoringSessionUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pricePerHour?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    locationType?: EnumTutoringLocationTypeFieldUpdateOperationsInput | $Enums.TutoringLocationType
    status?: EnumTutoringStatusFieldUpdateOperationsInput | $Enums.TutoringStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maxStudents?: IntFieldUpdateOperationsInput | number
    prerequisites?: TutoringSessionUpdateprerequisitesInput | string[]
    level?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: TutoringSessionUpdatetagsInput | string[]
    featured?: BoolFieldUpdateOperationsInput | boolean
    teacher?: UserUpdateOneRequiredWithoutTutoringSessionsNestedInput
    availability?: TutoringAvailabilityUpdateManyWithoutSessionNestedInput
    requests?: TutoringRequestUpdateManyWithoutSessionNestedInput
    reviews?: TutoringReviewUpdateManyWithoutSessionNestedInput
    certificates?: CertificateUpdateManyWithoutTutoringNestedInput
  }

  export type TutoringSessionUncheckedUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pricePerHour?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    locationType?: EnumTutoringLocationTypeFieldUpdateOperationsInput | $Enums.TutoringLocationType
    status?: EnumTutoringStatusFieldUpdateOperationsInput | $Enums.TutoringStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maxStudents?: IntFieldUpdateOperationsInput | number
    prerequisites?: TutoringSessionUpdateprerequisitesInput | string[]
    level?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: TutoringSessionUpdatetagsInput | string[]
    featured?: BoolFieldUpdateOperationsInput | boolean
    availability?: TutoringAvailabilityUncheckedUpdateManyWithoutSessionNestedInput
    requests?: TutoringRequestUncheckedUpdateManyWithoutSessionNestedInput
    reviews?: TutoringReviewUncheckedUpdateManyWithoutSessionNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutTutoringNestedInput
  }

  export type UserUpsertWithoutTutoringAppointmentsAsTeacherInput = {
    update: XOR<UserUpdateWithoutTutoringAppointmentsAsTeacherInput, UserUncheckedUpdateWithoutTutoringAppointmentsAsTeacherInput>
    create: XOR<UserCreateWithoutTutoringAppointmentsAsTeacherInput, UserUncheckedCreateWithoutTutoringAppointmentsAsTeacherInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTutoringAppointmentsAsTeacherInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTutoringAppointmentsAsTeacherInput, UserUncheckedUpdateWithoutTutoringAppointmentsAsTeacherInput>
  }

  export type UserUpdateWithoutTutoringAppointmentsAsTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: IntFieldUpdateOperationsInput | number
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referredBy?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferredByNestedInput
    teacherProfile?: TeacherProfileUpdateOneWithoutUserNestedInput
    availability?: UserAvailabilityUpdateManyWithoutUserNestedInput
    pointsTransactions?: PointsTransactionUpdateManyWithoutUserNestedInput
    courses?: CourseUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    savedCourses?: SavedCourseUpdateManyWithoutUserNestedInput
    likedCourses?: LikedCourseUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutUserNestedInput
    assignmentSubs?: AssignmentSubmissionUpdateManyWithoutUserNestedInput
    courseReviews?: CourseReviewUpdateManyWithoutUserNestedInput
    tutoringSessions?: TutoringSessionUpdateManyWithoutTeacherNestedInput
    tutoringRequests?: TutoringRequestUpdateManyWithoutStudentNestedInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUpdateManyWithoutStudentNestedInput
    tutoringReviews?: TutoringReviewUpdateManyWithoutStudentNestedInput
    tutoringMessages?: TutoringMessageUpdateManyWithoutSenderNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    conversationParts?: ConversationParticipantUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    attachments?: AttachmentUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    subscriptionRecords?: UserSubscriptionUpdateManyWithoutUserNestedInput
    bundlesOwned?: UserBundleUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUpdateManyWithoutUserNestedInput
    eventsAsTeacher?: CalendarEventUpdateManyWithoutTeacherNestedInput
    eventsAsStudent?: CalendarEventUpdateManyWithoutStudentNestedInput
    blogPosts?: BlogPostUpdateManyWithoutAuthorNestedInput
    blogComments?: BlogCommentUpdateManyWithoutUserNestedInput
    submissionsGraded?: AssignmentSubmissionUpdateManyWithoutGradedByNestedInput
    referralCodesOwned?: ReferralCodeUpdateManyWithoutUserNestedInput
    referralUsesGained?: ReferralUseUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTutoringAppointmentsAsTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: IntFieldUpdateOperationsInput | number
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referrals?: UserUncheckedUpdateManyWithoutReferredByNestedInput
    teacherProfile?: TeacherProfileUncheckedUpdateOneWithoutUserNestedInput
    availability?: UserAvailabilityUncheckedUpdateManyWithoutUserNestedInput
    pointsTransactions?: PointsTransactionUncheckedUpdateManyWithoutUserNestedInput
    courses?: CourseUncheckedUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    savedCourses?: SavedCourseUncheckedUpdateManyWithoutUserNestedInput
    likedCourses?: LikedCourseUncheckedUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUncheckedUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    assignmentSubs?: AssignmentSubmissionUncheckedUpdateManyWithoutUserNestedInput
    courseReviews?: CourseReviewUncheckedUpdateManyWithoutUserNestedInput
    tutoringSessions?: TutoringSessionUncheckedUpdateManyWithoutTeacherNestedInput
    tutoringRequests?: TutoringRequestUncheckedUpdateManyWithoutStudentNestedInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUncheckedUpdateManyWithoutStudentNestedInput
    tutoringReviews?: TutoringReviewUncheckedUpdateManyWithoutStudentNestedInput
    tutoringMessages?: TutoringMessageUncheckedUpdateManyWithoutSenderNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    conversationParts?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    subscriptionRecords?: UserSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    bundlesOwned?: UserBundleUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUncheckedUpdateManyWithoutUserNestedInput
    eventsAsTeacher?: CalendarEventUncheckedUpdateManyWithoutTeacherNestedInput
    eventsAsStudent?: CalendarEventUncheckedUpdateManyWithoutStudentNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
    blogComments?: BlogCommentUncheckedUpdateManyWithoutUserNestedInput
    submissionsGraded?: AssignmentSubmissionUncheckedUpdateManyWithoutGradedByNestedInput
    referralCodesOwned?: ReferralCodeUncheckedUpdateManyWithoutUserNestedInput
    referralUsesGained?: ReferralUseUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutTutoringAppointmentsAsStudentInput = {
    update: XOR<UserUpdateWithoutTutoringAppointmentsAsStudentInput, UserUncheckedUpdateWithoutTutoringAppointmentsAsStudentInput>
    create: XOR<UserCreateWithoutTutoringAppointmentsAsStudentInput, UserUncheckedCreateWithoutTutoringAppointmentsAsStudentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTutoringAppointmentsAsStudentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTutoringAppointmentsAsStudentInput, UserUncheckedUpdateWithoutTutoringAppointmentsAsStudentInput>
  }

  export type UserUpdateWithoutTutoringAppointmentsAsStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: IntFieldUpdateOperationsInput | number
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referredBy?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferredByNestedInput
    teacherProfile?: TeacherProfileUpdateOneWithoutUserNestedInput
    availability?: UserAvailabilityUpdateManyWithoutUserNestedInput
    pointsTransactions?: PointsTransactionUpdateManyWithoutUserNestedInput
    courses?: CourseUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    savedCourses?: SavedCourseUpdateManyWithoutUserNestedInput
    likedCourses?: LikedCourseUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutUserNestedInput
    assignmentSubs?: AssignmentSubmissionUpdateManyWithoutUserNestedInput
    courseReviews?: CourseReviewUpdateManyWithoutUserNestedInput
    tutoringSessions?: TutoringSessionUpdateManyWithoutTeacherNestedInput
    tutoringRequests?: TutoringRequestUpdateManyWithoutStudentNestedInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUpdateManyWithoutTeacherNestedInput
    tutoringReviews?: TutoringReviewUpdateManyWithoutStudentNestedInput
    tutoringMessages?: TutoringMessageUpdateManyWithoutSenderNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    conversationParts?: ConversationParticipantUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    attachments?: AttachmentUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    subscriptionRecords?: UserSubscriptionUpdateManyWithoutUserNestedInput
    bundlesOwned?: UserBundleUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUpdateManyWithoutUserNestedInput
    eventsAsTeacher?: CalendarEventUpdateManyWithoutTeacherNestedInput
    eventsAsStudent?: CalendarEventUpdateManyWithoutStudentNestedInput
    blogPosts?: BlogPostUpdateManyWithoutAuthorNestedInput
    blogComments?: BlogCommentUpdateManyWithoutUserNestedInput
    submissionsGraded?: AssignmentSubmissionUpdateManyWithoutGradedByNestedInput
    referralCodesOwned?: ReferralCodeUpdateManyWithoutUserNestedInput
    referralUsesGained?: ReferralUseUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTutoringAppointmentsAsStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: IntFieldUpdateOperationsInput | number
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referrals?: UserUncheckedUpdateManyWithoutReferredByNestedInput
    teacherProfile?: TeacherProfileUncheckedUpdateOneWithoutUserNestedInput
    availability?: UserAvailabilityUncheckedUpdateManyWithoutUserNestedInput
    pointsTransactions?: PointsTransactionUncheckedUpdateManyWithoutUserNestedInput
    courses?: CourseUncheckedUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    savedCourses?: SavedCourseUncheckedUpdateManyWithoutUserNestedInput
    likedCourses?: LikedCourseUncheckedUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUncheckedUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    assignmentSubs?: AssignmentSubmissionUncheckedUpdateManyWithoutUserNestedInput
    courseReviews?: CourseReviewUncheckedUpdateManyWithoutUserNestedInput
    tutoringSessions?: TutoringSessionUncheckedUpdateManyWithoutTeacherNestedInput
    tutoringRequests?: TutoringRequestUncheckedUpdateManyWithoutStudentNestedInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUncheckedUpdateManyWithoutTeacherNestedInput
    tutoringReviews?: TutoringReviewUncheckedUpdateManyWithoutStudentNestedInput
    tutoringMessages?: TutoringMessageUncheckedUpdateManyWithoutSenderNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    conversationParts?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    subscriptionRecords?: UserSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    bundlesOwned?: UserBundleUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUncheckedUpdateManyWithoutUserNestedInput
    eventsAsTeacher?: CalendarEventUncheckedUpdateManyWithoutTeacherNestedInput
    eventsAsStudent?: CalendarEventUncheckedUpdateManyWithoutStudentNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
    blogComments?: BlogCommentUncheckedUpdateManyWithoutUserNestedInput
    submissionsGraded?: AssignmentSubmissionUncheckedUpdateManyWithoutGradedByNestedInput
    referralCodesOwned?: ReferralCodeUncheckedUpdateManyWithoutUserNestedInput
    referralUsesGained?: ReferralUseUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TutoringSessionCreateWithoutReviewsInput = {
    id?: string
    subject: string
    description?: string | null
    pricePerHour: Decimal | DecimalJsLike | number | string
    locationType: $Enums.TutoringLocationType
    status?: $Enums.TutoringStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    maxStudents?: number
    prerequisites?: TutoringSessionCreateprerequisitesInput | string[]
    level?: string | null
    tags?: TutoringSessionCreatetagsInput | string[]
    featured?: boolean
    teacher: UserCreateNestedOneWithoutTutoringSessionsInput
    availability?: TutoringAvailabilityCreateNestedManyWithoutSessionInput
    requests?: TutoringRequestCreateNestedManyWithoutSessionInput
    appointments?: TutoringAppointmentCreateNestedManyWithoutSessionInput
    certificates?: CertificateCreateNestedManyWithoutTutoringInput
  }

  export type TutoringSessionUncheckedCreateWithoutReviewsInput = {
    id?: string
    teacherId: string
    subject: string
    description?: string | null
    pricePerHour: Decimal | DecimalJsLike | number | string
    locationType: $Enums.TutoringLocationType
    status?: $Enums.TutoringStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    maxStudents?: number
    prerequisites?: TutoringSessionCreateprerequisitesInput | string[]
    level?: string | null
    tags?: TutoringSessionCreatetagsInput | string[]
    featured?: boolean
    availability?: TutoringAvailabilityUncheckedCreateNestedManyWithoutSessionInput
    requests?: TutoringRequestUncheckedCreateNestedManyWithoutSessionInput
    appointments?: TutoringAppointmentUncheckedCreateNestedManyWithoutSessionInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutTutoringInput
  }

  export type TutoringSessionCreateOrConnectWithoutReviewsInput = {
    where: TutoringSessionWhereUniqueInput
    create: XOR<TutoringSessionCreateWithoutReviewsInput, TutoringSessionUncheckedCreateWithoutReviewsInput>
  }

  export type UserCreateWithoutTutoringReviewsInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    avatar?: string | null
    bio?: string | null
    createdAt?: Date | string
    points?: number
    referralCode?: string | null
    lastLogin?: Date | string | null
    referredBy?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferredByInput
    teacherProfile?: TeacherProfileCreateNestedOneWithoutUserInput
    availability?: UserAvailabilityCreateNestedManyWithoutUserInput
    pointsTransactions?: PointsTransactionCreateNestedManyWithoutUserInput
    courses?: CourseCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    savedCourses?: SavedCourseCreateNestedManyWithoutUserInput
    likedCourses?: LikedCourseCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutUserInput
    assignmentSubs?: AssignmentSubmissionCreateNestedManyWithoutUserInput
    courseReviews?: CourseReviewCreateNestedManyWithoutUserInput
    tutoringSessions?: TutoringSessionCreateNestedManyWithoutTeacherInput
    tutoringRequests?: TutoringRequestCreateNestedManyWithoutStudentInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentCreateNestedManyWithoutTeacherInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentCreateNestedManyWithoutStudentInput
    tutoringMessages?: TutoringMessageCreateNestedManyWithoutSenderInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    conversationParts?: ConversationParticipantCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    attachments?: AttachmentCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    subscriptionRecords?: UserSubscriptionCreateNestedManyWithoutUserInput
    bundlesOwned?: UserBundleCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventCreateNestedManyWithoutUserInput
    eventsAsTeacher?: CalendarEventCreateNestedManyWithoutTeacherInput
    eventsAsStudent?: CalendarEventCreateNestedManyWithoutStudentInput
    blogPosts?: BlogPostCreateNestedManyWithoutAuthorInput
    blogComments?: BlogCommentCreateNestedManyWithoutUserInput
    submissionsGraded?: AssignmentSubmissionCreateNestedManyWithoutGradedByInput
    referralCodesOwned?: ReferralCodeCreateNestedManyWithoutUserInput
    referralUsesGained?: ReferralUseCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTutoringReviewsInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    avatar?: string | null
    bio?: string | null
    createdAt?: Date | string
    points?: number
    referralCode?: string | null
    referredById?: string | null
    lastLogin?: Date | string | null
    referrals?: UserUncheckedCreateNestedManyWithoutReferredByInput
    teacherProfile?: TeacherProfileUncheckedCreateNestedOneWithoutUserInput
    availability?: UserAvailabilityUncheckedCreateNestedManyWithoutUserInput
    pointsTransactions?: PointsTransactionUncheckedCreateNestedManyWithoutUserInput
    courses?: CourseUncheckedCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    savedCourses?: SavedCourseUncheckedCreateNestedManyWithoutUserInput
    likedCourses?: LikedCourseUncheckedCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressUncheckedCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutUserInput
    assignmentSubs?: AssignmentSubmissionUncheckedCreateNestedManyWithoutUserInput
    courseReviews?: CourseReviewUncheckedCreateNestedManyWithoutUserInput
    tutoringSessions?: TutoringSessionUncheckedCreateNestedManyWithoutTeacherInput
    tutoringRequests?: TutoringRequestUncheckedCreateNestedManyWithoutStudentInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUncheckedCreateNestedManyWithoutTeacherInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUncheckedCreateNestedManyWithoutStudentInput
    tutoringMessages?: TutoringMessageUncheckedCreateNestedManyWithoutSenderInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    conversationParts?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    subscriptionRecords?: UserSubscriptionUncheckedCreateNestedManyWithoutUserInput
    bundlesOwned?: UserBundleUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventUncheckedCreateNestedManyWithoutUserInput
    eventsAsTeacher?: CalendarEventUncheckedCreateNestedManyWithoutTeacherInput
    eventsAsStudent?: CalendarEventUncheckedCreateNestedManyWithoutStudentInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
    blogComments?: BlogCommentUncheckedCreateNestedManyWithoutUserInput
    submissionsGraded?: AssignmentSubmissionUncheckedCreateNestedManyWithoutGradedByInput
    referralCodesOwned?: ReferralCodeUncheckedCreateNestedManyWithoutUserInput
    referralUsesGained?: ReferralUseUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTutoringReviewsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTutoringReviewsInput, UserUncheckedCreateWithoutTutoringReviewsInput>
  }

  export type TutoringSessionUpsertWithoutReviewsInput = {
    update: XOR<TutoringSessionUpdateWithoutReviewsInput, TutoringSessionUncheckedUpdateWithoutReviewsInput>
    create: XOR<TutoringSessionCreateWithoutReviewsInput, TutoringSessionUncheckedCreateWithoutReviewsInput>
    where?: TutoringSessionWhereInput
  }

  export type TutoringSessionUpdateToOneWithWhereWithoutReviewsInput = {
    where?: TutoringSessionWhereInput
    data: XOR<TutoringSessionUpdateWithoutReviewsInput, TutoringSessionUncheckedUpdateWithoutReviewsInput>
  }

  export type TutoringSessionUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pricePerHour?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    locationType?: EnumTutoringLocationTypeFieldUpdateOperationsInput | $Enums.TutoringLocationType
    status?: EnumTutoringStatusFieldUpdateOperationsInput | $Enums.TutoringStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maxStudents?: IntFieldUpdateOperationsInput | number
    prerequisites?: TutoringSessionUpdateprerequisitesInput | string[]
    level?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: TutoringSessionUpdatetagsInput | string[]
    featured?: BoolFieldUpdateOperationsInput | boolean
    teacher?: UserUpdateOneRequiredWithoutTutoringSessionsNestedInput
    availability?: TutoringAvailabilityUpdateManyWithoutSessionNestedInput
    requests?: TutoringRequestUpdateManyWithoutSessionNestedInput
    appointments?: TutoringAppointmentUpdateManyWithoutSessionNestedInput
    certificates?: CertificateUpdateManyWithoutTutoringNestedInput
  }

  export type TutoringSessionUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pricePerHour?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    locationType?: EnumTutoringLocationTypeFieldUpdateOperationsInput | $Enums.TutoringLocationType
    status?: EnumTutoringStatusFieldUpdateOperationsInput | $Enums.TutoringStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maxStudents?: IntFieldUpdateOperationsInput | number
    prerequisites?: TutoringSessionUpdateprerequisitesInput | string[]
    level?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: TutoringSessionUpdatetagsInput | string[]
    featured?: BoolFieldUpdateOperationsInput | boolean
    availability?: TutoringAvailabilityUncheckedUpdateManyWithoutSessionNestedInput
    requests?: TutoringRequestUncheckedUpdateManyWithoutSessionNestedInput
    appointments?: TutoringAppointmentUncheckedUpdateManyWithoutSessionNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutTutoringNestedInput
  }

  export type UserUpsertWithoutTutoringReviewsInput = {
    update: XOR<UserUpdateWithoutTutoringReviewsInput, UserUncheckedUpdateWithoutTutoringReviewsInput>
    create: XOR<UserCreateWithoutTutoringReviewsInput, UserUncheckedCreateWithoutTutoringReviewsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTutoringReviewsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTutoringReviewsInput, UserUncheckedUpdateWithoutTutoringReviewsInput>
  }

  export type UserUpdateWithoutTutoringReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: IntFieldUpdateOperationsInput | number
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referredBy?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferredByNestedInput
    teacherProfile?: TeacherProfileUpdateOneWithoutUserNestedInput
    availability?: UserAvailabilityUpdateManyWithoutUserNestedInput
    pointsTransactions?: PointsTransactionUpdateManyWithoutUserNestedInput
    courses?: CourseUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    savedCourses?: SavedCourseUpdateManyWithoutUserNestedInput
    likedCourses?: LikedCourseUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutUserNestedInput
    assignmentSubs?: AssignmentSubmissionUpdateManyWithoutUserNestedInput
    courseReviews?: CourseReviewUpdateManyWithoutUserNestedInput
    tutoringSessions?: TutoringSessionUpdateManyWithoutTeacherNestedInput
    tutoringRequests?: TutoringRequestUpdateManyWithoutStudentNestedInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUpdateManyWithoutTeacherNestedInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUpdateManyWithoutStudentNestedInput
    tutoringMessages?: TutoringMessageUpdateManyWithoutSenderNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    conversationParts?: ConversationParticipantUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    attachments?: AttachmentUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    subscriptionRecords?: UserSubscriptionUpdateManyWithoutUserNestedInput
    bundlesOwned?: UserBundleUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUpdateManyWithoutUserNestedInput
    eventsAsTeacher?: CalendarEventUpdateManyWithoutTeacherNestedInput
    eventsAsStudent?: CalendarEventUpdateManyWithoutStudentNestedInput
    blogPosts?: BlogPostUpdateManyWithoutAuthorNestedInput
    blogComments?: BlogCommentUpdateManyWithoutUserNestedInput
    submissionsGraded?: AssignmentSubmissionUpdateManyWithoutGradedByNestedInput
    referralCodesOwned?: ReferralCodeUpdateManyWithoutUserNestedInput
    referralUsesGained?: ReferralUseUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTutoringReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: IntFieldUpdateOperationsInput | number
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referrals?: UserUncheckedUpdateManyWithoutReferredByNestedInput
    teacherProfile?: TeacherProfileUncheckedUpdateOneWithoutUserNestedInput
    availability?: UserAvailabilityUncheckedUpdateManyWithoutUserNestedInput
    pointsTransactions?: PointsTransactionUncheckedUpdateManyWithoutUserNestedInput
    courses?: CourseUncheckedUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    savedCourses?: SavedCourseUncheckedUpdateManyWithoutUserNestedInput
    likedCourses?: LikedCourseUncheckedUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUncheckedUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    assignmentSubs?: AssignmentSubmissionUncheckedUpdateManyWithoutUserNestedInput
    courseReviews?: CourseReviewUncheckedUpdateManyWithoutUserNestedInput
    tutoringSessions?: TutoringSessionUncheckedUpdateManyWithoutTeacherNestedInput
    tutoringRequests?: TutoringRequestUncheckedUpdateManyWithoutStudentNestedInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUncheckedUpdateManyWithoutTeacherNestedInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUncheckedUpdateManyWithoutStudentNestedInput
    tutoringMessages?: TutoringMessageUncheckedUpdateManyWithoutSenderNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    conversationParts?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    subscriptionRecords?: UserSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    bundlesOwned?: UserBundleUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUncheckedUpdateManyWithoutUserNestedInput
    eventsAsTeacher?: CalendarEventUncheckedUpdateManyWithoutTeacherNestedInput
    eventsAsStudent?: CalendarEventUncheckedUpdateManyWithoutStudentNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
    blogComments?: BlogCommentUncheckedUpdateManyWithoutUserNestedInput
    submissionsGraded?: AssignmentSubmissionUncheckedUpdateManyWithoutGradedByNestedInput
    referralCodesOwned?: ReferralCodeUncheckedUpdateManyWithoutUserNestedInput
    referralUsesGained?: ReferralUseUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TutoringRequestCreateWithoutMessagesInput = {
    id?: string
    message?: string | null
    preferredDates?: TutoringRequestCreatepreferredDatesInput | Date[] | string[]
    status?: $Enums.TutoringRequestStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    session: TutoringSessionCreateNestedOneWithoutRequestsInput
    student: UserCreateNestedOneWithoutTutoringRequestsInput
    appointment?: TutoringAppointmentCreateNestedOneWithoutRequestInput
  }

  export type TutoringRequestUncheckedCreateWithoutMessagesInput = {
    id?: string
    sessionId: string
    studentId: string
    message?: string | null
    preferredDates?: TutoringRequestCreatepreferredDatesInput | Date[] | string[]
    status?: $Enums.TutoringRequestStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    appointment?: TutoringAppointmentUncheckedCreateNestedOneWithoutRequestInput
  }

  export type TutoringRequestCreateOrConnectWithoutMessagesInput = {
    where: TutoringRequestWhereUniqueInput
    create: XOR<TutoringRequestCreateWithoutMessagesInput, TutoringRequestUncheckedCreateWithoutMessagesInput>
  }

  export type UserCreateWithoutTutoringMessagesInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    avatar?: string | null
    bio?: string | null
    createdAt?: Date | string
    points?: number
    referralCode?: string | null
    lastLogin?: Date | string | null
    referredBy?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferredByInput
    teacherProfile?: TeacherProfileCreateNestedOneWithoutUserInput
    availability?: UserAvailabilityCreateNestedManyWithoutUserInput
    pointsTransactions?: PointsTransactionCreateNestedManyWithoutUserInput
    courses?: CourseCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    savedCourses?: SavedCourseCreateNestedManyWithoutUserInput
    likedCourses?: LikedCourseCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutUserInput
    assignmentSubs?: AssignmentSubmissionCreateNestedManyWithoutUserInput
    courseReviews?: CourseReviewCreateNestedManyWithoutUserInput
    tutoringSessions?: TutoringSessionCreateNestedManyWithoutTeacherInput
    tutoringRequests?: TutoringRequestCreateNestedManyWithoutStudentInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentCreateNestedManyWithoutTeacherInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentCreateNestedManyWithoutStudentInput
    tutoringReviews?: TutoringReviewCreateNestedManyWithoutStudentInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    conversationParts?: ConversationParticipantCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    attachments?: AttachmentCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    subscriptionRecords?: UserSubscriptionCreateNestedManyWithoutUserInput
    bundlesOwned?: UserBundleCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventCreateNestedManyWithoutUserInput
    eventsAsTeacher?: CalendarEventCreateNestedManyWithoutTeacherInput
    eventsAsStudent?: CalendarEventCreateNestedManyWithoutStudentInput
    blogPosts?: BlogPostCreateNestedManyWithoutAuthorInput
    blogComments?: BlogCommentCreateNestedManyWithoutUserInput
    submissionsGraded?: AssignmentSubmissionCreateNestedManyWithoutGradedByInput
    referralCodesOwned?: ReferralCodeCreateNestedManyWithoutUserInput
    referralUsesGained?: ReferralUseCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTutoringMessagesInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    avatar?: string | null
    bio?: string | null
    createdAt?: Date | string
    points?: number
    referralCode?: string | null
    referredById?: string | null
    lastLogin?: Date | string | null
    referrals?: UserUncheckedCreateNestedManyWithoutReferredByInput
    teacherProfile?: TeacherProfileUncheckedCreateNestedOneWithoutUserInput
    availability?: UserAvailabilityUncheckedCreateNestedManyWithoutUserInput
    pointsTransactions?: PointsTransactionUncheckedCreateNestedManyWithoutUserInput
    courses?: CourseUncheckedCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    savedCourses?: SavedCourseUncheckedCreateNestedManyWithoutUserInput
    likedCourses?: LikedCourseUncheckedCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressUncheckedCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutUserInput
    assignmentSubs?: AssignmentSubmissionUncheckedCreateNestedManyWithoutUserInput
    courseReviews?: CourseReviewUncheckedCreateNestedManyWithoutUserInput
    tutoringSessions?: TutoringSessionUncheckedCreateNestedManyWithoutTeacherInput
    tutoringRequests?: TutoringRequestUncheckedCreateNestedManyWithoutStudentInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUncheckedCreateNestedManyWithoutTeacherInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUncheckedCreateNestedManyWithoutStudentInput
    tutoringReviews?: TutoringReviewUncheckedCreateNestedManyWithoutStudentInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    conversationParts?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    subscriptionRecords?: UserSubscriptionUncheckedCreateNestedManyWithoutUserInput
    bundlesOwned?: UserBundleUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventUncheckedCreateNestedManyWithoutUserInput
    eventsAsTeacher?: CalendarEventUncheckedCreateNestedManyWithoutTeacherInput
    eventsAsStudent?: CalendarEventUncheckedCreateNestedManyWithoutStudentInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
    blogComments?: BlogCommentUncheckedCreateNestedManyWithoutUserInput
    submissionsGraded?: AssignmentSubmissionUncheckedCreateNestedManyWithoutGradedByInput
    referralCodesOwned?: ReferralCodeUncheckedCreateNestedManyWithoutUserInput
    referralUsesGained?: ReferralUseUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTutoringMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTutoringMessagesInput, UserUncheckedCreateWithoutTutoringMessagesInput>
  }

  export type TutoringRequestUpsertWithoutMessagesInput = {
    update: XOR<TutoringRequestUpdateWithoutMessagesInput, TutoringRequestUncheckedUpdateWithoutMessagesInput>
    create: XOR<TutoringRequestCreateWithoutMessagesInput, TutoringRequestUncheckedCreateWithoutMessagesInput>
    where?: TutoringRequestWhereInput
  }

  export type TutoringRequestUpdateToOneWithWhereWithoutMessagesInput = {
    where?: TutoringRequestWhereInput
    data: XOR<TutoringRequestUpdateWithoutMessagesInput, TutoringRequestUncheckedUpdateWithoutMessagesInput>
  }

  export type TutoringRequestUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    preferredDates?: TutoringRequestUpdatepreferredDatesInput | Date[] | string[]
    status?: EnumTutoringRequestStatusFieldUpdateOperationsInput | $Enums.TutoringRequestStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: TutoringSessionUpdateOneRequiredWithoutRequestsNestedInput
    student?: UserUpdateOneRequiredWithoutTutoringRequestsNestedInput
    appointment?: TutoringAppointmentUpdateOneWithoutRequestNestedInput
  }

  export type TutoringRequestUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    preferredDates?: TutoringRequestUpdatepreferredDatesInput | Date[] | string[]
    status?: EnumTutoringRequestStatusFieldUpdateOperationsInput | $Enums.TutoringRequestStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: TutoringAppointmentUncheckedUpdateOneWithoutRequestNestedInput
  }

  export type UserUpsertWithoutTutoringMessagesInput = {
    update: XOR<UserUpdateWithoutTutoringMessagesInput, UserUncheckedUpdateWithoutTutoringMessagesInput>
    create: XOR<UserCreateWithoutTutoringMessagesInput, UserUncheckedCreateWithoutTutoringMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTutoringMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTutoringMessagesInput, UserUncheckedUpdateWithoutTutoringMessagesInput>
  }

  export type UserUpdateWithoutTutoringMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: IntFieldUpdateOperationsInput | number
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referredBy?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferredByNestedInput
    teacherProfile?: TeacherProfileUpdateOneWithoutUserNestedInput
    availability?: UserAvailabilityUpdateManyWithoutUserNestedInput
    pointsTransactions?: PointsTransactionUpdateManyWithoutUserNestedInput
    courses?: CourseUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    savedCourses?: SavedCourseUpdateManyWithoutUserNestedInput
    likedCourses?: LikedCourseUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutUserNestedInput
    assignmentSubs?: AssignmentSubmissionUpdateManyWithoutUserNestedInput
    courseReviews?: CourseReviewUpdateManyWithoutUserNestedInput
    tutoringSessions?: TutoringSessionUpdateManyWithoutTeacherNestedInput
    tutoringRequests?: TutoringRequestUpdateManyWithoutStudentNestedInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUpdateManyWithoutTeacherNestedInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUpdateManyWithoutStudentNestedInput
    tutoringReviews?: TutoringReviewUpdateManyWithoutStudentNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    conversationParts?: ConversationParticipantUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    attachments?: AttachmentUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    subscriptionRecords?: UserSubscriptionUpdateManyWithoutUserNestedInput
    bundlesOwned?: UserBundleUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUpdateManyWithoutUserNestedInput
    eventsAsTeacher?: CalendarEventUpdateManyWithoutTeacherNestedInput
    eventsAsStudent?: CalendarEventUpdateManyWithoutStudentNestedInput
    blogPosts?: BlogPostUpdateManyWithoutAuthorNestedInput
    blogComments?: BlogCommentUpdateManyWithoutUserNestedInput
    submissionsGraded?: AssignmentSubmissionUpdateManyWithoutGradedByNestedInput
    referralCodesOwned?: ReferralCodeUpdateManyWithoutUserNestedInput
    referralUsesGained?: ReferralUseUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTutoringMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: IntFieldUpdateOperationsInput | number
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referrals?: UserUncheckedUpdateManyWithoutReferredByNestedInput
    teacherProfile?: TeacherProfileUncheckedUpdateOneWithoutUserNestedInput
    availability?: UserAvailabilityUncheckedUpdateManyWithoutUserNestedInput
    pointsTransactions?: PointsTransactionUncheckedUpdateManyWithoutUserNestedInput
    courses?: CourseUncheckedUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    savedCourses?: SavedCourseUncheckedUpdateManyWithoutUserNestedInput
    likedCourses?: LikedCourseUncheckedUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUncheckedUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    assignmentSubs?: AssignmentSubmissionUncheckedUpdateManyWithoutUserNestedInput
    courseReviews?: CourseReviewUncheckedUpdateManyWithoutUserNestedInput
    tutoringSessions?: TutoringSessionUncheckedUpdateManyWithoutTeacherNestedInput
    tutoringRequests?: TutoringRequestUncheckedUpdateManyWithoutStudentNestedInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUncheckedUpdateManyWithoutTeacherNestedInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUncheckedUpdateManyWithoutStudentNestedInput
    tutoringReviews?: TutoringReviewUncheckedUpdateManyWithoutStudentNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    conversationParts?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    subscriptionRecords?: UserSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    bundlesOwned?: UserBundleUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUncheckedUpdateManyWithoutUserNestedInput
    eventsAsTeacher?: CalendarEventUncheckedUpdateManyWithoutTeacherNestedInput
    eventsAsStudent?: CalendarEventUncheckedUpdateManyWithoutStudentNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
    blogComments?: BlogCommentUncheckedUpdateManyWithoutUserNestedInput
    submissionsGraded?: AssignmentSubmissionUncheckedUpdateManyWithoutGradedByNestedInput
    referralCodesOwned?: ReferralCodeUncheckedUpdateManyWithoutUserNestedInput
    referralUsesGained?: ReferralUseUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserAchievementCreateWithoutAchievementInput = {
    id?: string
    completed?: boolean
    completedAt?: Date | string | null
    progress?: number
    user: UserCreateNestedOneWithoutAchievementsInput
  }

  export type UserAchievementUncheckedCreateWithoutAchievementInput = {
    id?: string
    userId: string
    completed?: boolean
    completedAt?: Date | string | null
    progress?: number
  }

  export type UserAchievementCreateOrConnectWithoutAchievementInput = {
    where: UserAchievementWhereUniqueInput
    create: XOR<UserAchievementCreateWithoutAchievementInput, UserAchievementUncheckedCreateWithoutAchievementInput>
  }

  export type UserAchievementCreateManyAchievementInputEnvelope = {
    data: UserAchievementCreateManyAchievementInput | UserAchievementCreateManyAchievementInput[]
    skipDuplicates?: boolean
  }

  export type UserAchievementUpsertWithWhereUniqueWithoutAchievementInput = {
    where: UserAchievementWhereUniqueInput
    update: XOR<UserAchievementUpdateWithoutAchievementInput, UserAchievementUncheckedUpdateWithoutAchievementInput>
    create: XOR<UserAchievementCreateWithoutAchievementInput, UserAchievementUncheckedCreateWithoutAchievementInput>
  }

  export type UserAchievementUpdateWithWhereUniqueWithoutAchievementInput = {
    where: UserAchievementWhereUniqueInput
    data: XOR<UserAchievementUpdateWithoutAchievementInput, UserAchievementUncheckedUpdateWithoutAchievementInput>
  }

  export type UserAchievementUpdateManyWithWhereWithoutAchievementInput = {
    where: UserAchievementScalarWhereInput
    data: XOR<UserAchievementUpdateManyMutationInput, UserAchievementUncheckedUpdateManyWithoutAchievementInput>
  }

  export type UserCreateWithoutAchievementsInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    avatar?: string | null
    bio?: string | null
    createdAt?: Date | string
    points?: number
    referralCode?: string | null
    lastLogin?: Date | string | null
    referredBy?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferredByInput
    teacherProfile?: TeacherProfileCreateNestedOneWithoutUserInput
    availability?: UserAvailabilityCreateNestedManyWithoutUserInput
    pointsTransactions?: PointsTransactionCreateNestedManyWithoutUserInput
    courses?: CourseCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    savedCourses?: SavedCourseCreateNestedManyWithoutUserInput
    likedCourses?: LikedCourseCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutUserInput
    assignmentSubs?: AssignmentSubmissionCreateNestedManyWithoutUserInput
    courseReviews?: CourseReviewCreateNestedManyWithoutUserInput
    tutoringSessions?: TutoringSessionCreateNestedManyWithoutTeacherInput
    tutoringRequests?: TutoringRequestCreateNestedManyWithoutStudentInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentCreateNestedManyWithoutTeacherInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentCreateNestedManyWithoutStudentInput
    tutoringReviews?: TutoringReviewCreateNestedManyWithoutStudentInput
    tutoringMessages?: TutoringMessageCreateNestedManyWithoutSenderInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    conversationParts?: ConversationParticipantCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    attachments?: AttachmentCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    subscriptionRecords?: UserSubscriptionCreateNestedManyWithoutUserInput
    bundlesOwned?: UserBundleCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventCreateNestedManyWithoutUserInput
    eventsAsTeacher?: CalendarEventCreateNestedManyWithoutTeacherInput
    eventsAsStudent?: CalendarEventCreateNestedManyWithoutStudentInput
    blogPosts?: BlogPostCreateNestedManyWithoutAuthorInput
    blogComments?: BlogCommentCreateNestedManyWithoutUserInput
    submissionsGraded?: AssignmentSubmissionCreateNestedManyWithoutGradedByInput
    referralCodesOwned?: ReferralCodeCreateNestedManyWithoutUserInput
    referralUsesGained?: ReferralUseCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAchievementsInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    avatar?: string | null
    bio?: string | null
    createdAt?: Date | string
    points?: number
    referralCode?: string | null
    referredById?: string | null
    lastLogin?: Date | string | null
    referrals?: UserUncheckedCreateNestedManyWithoutReferredByInput
    teacherProfile?: TeacherProfileUncheckedCreateNestedOneWithoutUserInput
    availability?: UserAvailabilityUncheckedCreateNestedManyWithoutUserInput
    pointsTransactions?: PointsTransactionUncheckedCreateNestedManyWithoutUserInput
    courses?: CourseUncheckedCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    savedCourses?: SavedCourseUncheckedCreateNestedManyWithoutUserInput
    likedCourses?: LikedCourseUncheckedCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressUncheckedCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutUserInput
    assignmentSubs?: AssignmentSubmissionUncheckedCreateNestedManyWithoutUserInput
    courseReviews?: CourseReviewUncheckedCreateNestedManyWithoutUserInput
    tutoringSessions?: TutoringSessionUncheckedCreateNestedManyWithoutTeacherInput
    tutoringRequests?: TutoringRequestUncheckedCreateNestedManyWithoutStudentInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUncheckedCreateNestedManyWithoutTeacherInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUncheckedCreateNestedManyWithoutStudentInput
    tutoringReviews?: TutoringReviewUncheckedCreateNestedManyWithoutStudentInput
    tutoringMessages?: TutoringMessageUncheckedCreateNestedManyWithoutSenderInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    conversationParts?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    subscriptionRecords?: UserSubscriptionUncheckedCreateNestedManyWithoutUserInput
    bundlesOwned?: UserBundleUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventUncheckedCreateNestedManyWithoutUserInput
    eventsAsTeacher?: CalendarEventUncheckedCreateNestedManyWithoutTeacherInput
    eventsAsStudent?: CalendarEventUncheckedCreateNestedManyWithoutStudentInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
    blogComments?: BlogCommentUncheckedCreateNestedManyWithoutUserInput
    submissionsGraded?: AssignmentSubmissionUncheckedCreateNestedManyWithoutGradedByInput
    referralCodesOwned?: ReferralCodeUncheckedCreateNestedManyWithoutUserInput
    referralUsesGained?: ReferralUseUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAchievementsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAchievementsInput, UserUncheckedCreateWithoutAchievementsInput>
  }

  export type AchievementCreateWithoutUsersInput = {
    id?: string
    name: string
    description?: string | null
    pointsRewarded: number
    icon?: string | null
    category: $Enums.AchievementCategory
  }

  export type AchievementUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    description?: string | null
    pointsRewarded: number
    icon?: string | null
    category: $Enums.AchievementCategory
  }

  export type AchievementCreateOrConnectWithoutUsersInput = {
    where: AchievementWhereUniqueInput
    create: XOR<AchievementCreateWithoutUsersInput, AchievementUncheckedCreateWithoutUsersInput>
  }

  export type UserUpsertWithoutAchievementsInput = {
    update: XOR<UserUpdateWithoutAchievementsInput, UserUncheckedUpdateWithoutAchievementsInput>
    create: XOR<UserCreateWithoutAchievementsInput, UserUncheckedCreateWithoutAchievementsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAchievementsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAchievementsInput, UserUncheckedUpdateWithoutAchievementsInput>
  }

  export type UserUpdateWithoutAchievementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: IntFieldUpdateOperationsInput | number
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referredBy?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferredByNestedInput
    teacherProfile?: TeacherProfileUpdateOneWithoutUserNestedInput
    availability?: UserAvailabilityUpdateManyWithoutUserNestedInput
    pointsTransactions?: PointsTransactionUpdateManyWithoutUserNestedInput
    courses?: CourseUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    savedCourses?: SavedCourseUpdateManyWithoutUserNestedInput
    likedCourses?: LikedCourseUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutUserNestedInput
    assignmentSubs?: AssignmentSubmissionUpdateManyWithoutUserNestedInput
    courseReviews?: CourseReviewUpdateManyWithoutUserNestedInput
    tutoringSessions?: TutoringSessionUpdateManyWithoutTeacherNestedInput
    tutoringRequests?: TutoringRequestUpdateManyWithoutStudentNestedInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUpdateManyWithoutTeacherNestedInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUpdateManyWithoutStudentNestedInput
    tutoringReviews?: TutoringReviewUpdateManyWithoutStudentNestedInput
    tutoringMessages?: TutoringMessageUpdateManyWithoutSenderNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    conversationParts?: ConversationParticipantUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    attachments?: AttachmentUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    subscriptionRecords?: UserSubscriptionUpdateManyWithoutUserNestedInput
    bundlesOwned?: UserBundleUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUpdateManyWithoutUserNestedInput
    eventsAsTeacher?: CalendarEventUpdateManyWithoutTeacherNestedInput
    eventsAsStudent?: CalendarEventUpdateManyWithoutStudentNestedInput
    blogPosts?: BlogPostUpdateManyWithoutAuthorNestedInput
    blogComments?: BlogCommentUpdateManyWithoutUserNestedInput
    submissionsGraded?: AssignmentSubmissionUpdateManyWithoutGradedByNestedInput
    referralCodesOwned?: ReferralCodeUpdateManyWithoutUserNestedInput
    referralUsesGained?: ReferralUseUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAchievementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: IntFieldUpdateOperationsInput | number
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referrals?: UserUncheckedUpdateManyWithoutReferredByNestedInput
    teacherProfile?: TeacherProfileUncheckedUpdateOneWithoutUserNestedInput
    availability?: UserAvailabilityUncheckedUpdateManyWithoutUserNestedInput
    pointsTransactions?: PointsTransactionUncheckedUpdateManyWithoutUserNestedInput
    courses?: CourseUncheckedUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    savedCourses?: SavedCourseUncheckedUpdateManyWithoutUserNestedInput
    likedCourses?: LikedCourseUncheckedUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUncheckedUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    assignmentSubs?: AssignmentSubmissionUncheckedUpdateManyWithoutUserNestedInput
    courseReviews?: CourseReviewUncheckedUpdateManyWithoutUserNestedInput
    tutoringSessions?: TutoringSessionUncheckedUpdateManyWithoutTeacherNestedInput
    tutoringRequests?: TutoringRequestUncheckedUpdateManyWithoutStudentNestedInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUncheckedUpdateManyWithoutTeacherNestedInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUncheckedUpdateManyWithoutStudentNestedInput
    tutoringReviews?: TutoringReviewUncheckedUpdateManyWithoutStudentNestedInput
    tutoringMessages?: TutoringMessageUncheckedUpdateManyWithoutSenderNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    conversationParts?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    subscriptionRecords?: UserSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    bundlesOwned?: UserBundleUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUncheckedUpdateManyWithoutUserNestedInput
    eventsAsTeacher?: CalendarEventUncheckedUpdateManyWithoutTeacherNestedInput
    eventsAsStudent?: CalendarEventUncheckedUpdateManyWithoutStudentNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
    blogComments?: BlogCommentUncheckedUpdateManyWithoutUserNestedInput
    submissionsGraded?: AssignmentSubmissionUncheckedUpdateManyWithoutGradedByNestedInput
    referralCodesOwned?: ReferralCodeUncheckedUpdateManyWithoutUserNestedInput
    referralUsesGained?: ReferralUseUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AchievementUpsertWithoutUsersInput = {
    update: XOR<AchievementUpdateWithoutUsersInput, AchievementUncheckedUpdateWithoutUsersInput>
    create: XOR<AchievementCreateWithoutUsersInput, AchievementUncheckedCreateWithoutUsersInput>
    where?: AchievementWhereInput
  }

  export type AchievementUpdateToOneWithWhereWithoutUsersInput = {
    where?: AchievementWhereInput
    data: XOR<AchievementUpdateWithoutUsersInput, AchievementUncheckedUpdateWithoutUsersInput>
  }

  export type AchievementUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pointsRewarded?: IntFieldUpdateOperationsInput | number
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumAchievementCategoryFieldUpdateOperationsInput | $Enums.AchievementCategory
  }

  export type AchievementUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pointsRewarded?: IntFieldUpdateOperationsInput | number
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumAchievementCategoryFieldUpdateOperationsInput | $Enums.AchievementCategory
  }

  export type CertificateCreateWithoutBadgeInput = {
    id?: string
    title: string
    issueDate?: Date | string
    type: string
    courseName?: string | null
    tutoringSubject?: string | null
    teacherId?: string | null
    teacherName?: string | null
    customMessage?: string | null
    imageUrl?: string | null
    user: UserCreateNestedOneWithoutCertificatesInput
    course?: CourseCreateNestedOneWithoutCertificatesInput
    tutoring?: TutoringSessionCreateNestedOneWithoutCertificatesInput
  }

  export type CertificateUncheckedCreateWithoutBadgeInput = {
    id?: string
    userId: string
    title: string
    issueDate?: Date | string
    type: string
    courseId?: string | null
    courseName?: string | null
    tutoringId?: string | null
    tutoringSubject?: string | null
    teacherId?: string | null
    teacherName?: string | null
    customMessage?: string | null
    imageUrl?: string | null
  }

  export type CertificateCreateOrConnectWithoutBadgeInput = {
    where: CertificateWhereUniqueInput
    create: XOR<CertificateCreateWithoutBadgeInput, CertificateUncheckedCreateWithoutBadgeInput>
  }

  export type CertificateCreateManyBadgeInputEnvelope = {
    data: CertificateCreateManyBadgeInput | CertificateCreateManyBadgeInput[]
    skipDuplicates?: boolean
  }

  export type CertificateUpsertWithWhereUniqueWithoutBadgeInput = {
    where: CertificateWhereUniqueInput
    update: XOR<CertificateUpdateWithoutBadgeInput, CertificateUncheckedUpdateWithoutBadgeInput>
    create: XOR<CertificateCreateWithoutBadgeInput, CertificateUncheckedCreateWithoutBadgeInput>
  }

  export type CertificateUpdateWithWhereUniqueWithoutBadgeInput = {
    where: CertificateWhereUniqueInput
    data: XOR<CertificateUpdateWithoutBadgeInput, CertificateUncheckedUpdateWithoutBadgeInput>
  }

  export type CertificateUpdateManyWithWhereWithoutBadgeInput = {
    where: CertificateScalarWhereInput
    data: XOR<CertificateUpdateManyMutationInput, CertificateUncheckedUpdateManyWithoutBadgeInput>
  }

  export type UserCreateWithoutCertificatesInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    avatar?: string | null
    bio?: string | null
    createdAt?: Date | string
    points?: number
    referralCode?: string | null
    lastLogin?: Date | string | null
    referredBy?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferredByInput
    teacherProfile?: TeacherProfileCreateNestedOneWithoutUserInput
    availability?: UserAvailabilityCreateNestedManyWithoutUserInput
    pointsTransactions?: PointsTransactionCreateNestedManyWithoutUserInput
    courses?: CourseCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    savedCourses?: SavedCourseCreateNestedManyWithoutUserInput
    likedCourses?: LikedCourseCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutUserInput
    assignmentSubs?: AssignmentSubmissionCreateNestedManyWithoutUserInput
    courseReviews?: CourseReviewCreateNestedManyWithoutUserInput
    tutoringSessions?: TutoringSessionCreateNestedManyWithoutTeacherInput
    tutoringRequests?: TutoringRequestCreateNestedManyWithoutStudentInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentCreateNestedManyWithoutTeacherInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentCreateNestedManyWithoutStudentInput
    tutoringReviews?: TutoringReviewCreateNestedManyWithoutStudentInput
    tutoringMessages?: TutoringMessageCreateNestedManyWithoutSenderInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    conversationParts?: ConversationParticipantCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    attachments?: AttachmentCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    subscriptionRecords?: UserSubscriptionCreateNestedManyWithoutUserInput
    bundlesOwned?: UserBundleCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventCreateNestedManyWithoutUserInput
    eventsAsTeacher?: CalendarEventCreateNestedManyWithoutTeacherInput
    eventsAsStudent?: CalendarEventCreateNestedManyWithoutStudentInput
    blogPosts?: BlogPostCreateNestedManyWithoutAuthorInput
    blogComments?: BlogCommentCreateNestedManyWithoutUserInput
    submissionsGraded?: AssignmentSubmissionCreateNestedManyWithoutGradedByInput
    referralCodesOwned?: ReferralCodeCreateNestedManyWithoutUserInput
    referralUsesGained?: ReferralUseCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCertificatesInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    avatar?: string | null
    bio?: string | null
    createdAt?: Date | string
    points?: number
    referralCode?: string | null
    referredById?: string | null
    lastLogin?: Date | string | null
    referrals?: UserUncheckedCreateNestedManyWithoutReferredByInput
    teacherProfile?: TeacherProfileUncheckedCreateNestedOneWithoutUserInput
    availability?: UserAvailabilityUncheckedCreateNestedManyWithoutUserInput
    pointsTransactions?: PointsTransactionUncheckedCreateNestedManyWithoutUserInput
    courses?: CourseUncheckedCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    savedCourses?: SavedCourseUncheckedCreateNestedManyWithoutUserInput
    likedCourses?: LikedCourseUncheckedCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressUncheckedCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutUserInput
    assignmentSubs?: AssignmentSubmissionUncheckedCreateNestedManyWithoutUserInput
    courseReviews?: CourseReviewUncheckedCreateNestedManyWithoutUserInput
    tutoringSessions?: TutoringSessionUncheckedCreateNestedManyWithoutTeacherInput
    tutoringRequests?: TutoringRequestUncheckedCreateNestedManyWithoutStudentInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUncheckedCreateNestedManyWithoutTeacherInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUncheckedCreateNestedManyWithoutStudentInput
    tutoringReviews?: TutoringReviewUncheckedCreateNestedManyWithoutStudentInput
    tutoringMessages?: TutoringMessageUncheckedCreateNestedManyWithoutSenderInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    conversationParts?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    subscriptionRecords?: UserSubscriptionUncheckedCreateNestedManyWithoutUserInput
    bundlesOwned?: UserBundleUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventUncheckedCreateNestedManyWithoutUserInput
    eventsAsTeacher?: CalendarEventUncheckedCreateNestedManyWithoutTeacherInput
    eventsAsStudent?: CalendarEventUncheckedCreateNestedManyWithoutStudentInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
    blogComments?: BlogCommentUncheckedCreateNestedManyWithoutUserInput
    submissionsGraded?: AssignmentSubmissionUncheckedCreateNestedManyWithoutGradedByInput
    referralCodesOwned?: ReferralCodeUncheckedCreateNestedManyWithoutUserInput
    referralUsesGained?: ReferralUseUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCertificatesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCertificatesInput, UserUncheckedCreateWithoutCertificatesInput>
  }

  export type CourseCreateWithoutCertificatesInput = {
    id?: string
    title: string
    description?: string | null
    subject: string
    image?: string | null
    price: Decimal | DecimalJsLike | number | string
    pointsPrice: number
    students?: number
    rating?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.CourseStatus
    featured?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teacher: UserCreateNestedOneWithoutCoursesInput
    topics?: TopicCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentCreateNestedManyWithoutCourseInput
    savedBy?: SavedCourseCreateNestedManyWithoutCourseInput
    likedBy?: LikedCourseCreateNestedManyWithoutCourseInput
    reviews?: CourseReviewCreateNestedManyWithoutCourseInput
    lessons?: LessonCreateNestedManyWithoutCourseInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutCourseInput
    bundleCourses?: BundleCourseCreateNestedManyWithoutCourseInput
    calendarEvents?: CalendarEventCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutCertificatesInput = {
    id?: string
    title: string
    description?: string | null
    subject: string
    image?: string | null
    price: Decimal | DecimalJsLike | number | string
    pointsPrice: number
    teacherId: string
    students?: number
    rating?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.CourseStatus
    featured?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    topics?: TopicUncheckedCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutCourseInput
    savedBy?: SavedCourseUncheckedCreateNestedManyWithoutCourseInput
    likedBy?: LikedCourseUncheckedCreateNestedManyWithoutCourseInput
    reviews?: CourseReviewUncheckedCreateNestedManyWithoutCourseInput
    lessons?: LessonUncheckedCreateNestedManyWithoutCourseInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutCourseInput
    bundleCourses?: BundleCourseUncheckedCreateNestedManyWithoutCourseInput
    calendarEvents?: CalendarEventUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutCertificatesInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutCertificatesInput, CourseUncheckedCreateWithoutCertificatesInput>
  }

  export type TutoringSessionCreateWithoutCertificatesInput = {
    id?: string
    subject: string
    description?: string | null
    pricePerHour: Decimal | DecimalJsLike | number | string
    locationType: $Enums.TutoringLocationType
    status?: $Enums.TutoringStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    maxStudents?: number
    prerequisites?: TutoringSessionCreateprerequisitesInput | string[]
    level?: string | null
    tags?: TutoringSessionCreatetagsInput | string[]
    featured?: boolean
    teacher: UserCreateNestedOneWithoutTutoringSessionsInput
    availability?: TutoringAvailabilityCreateNestedManyWithoutSessionInput
    requests?: TutoringRequestCreateNestedManyWithoutSessionInput
    appointments?: TutoringAppointmentCreateNestedManyWithoutSessionInput
    reviews?: TutoringReviewCreateNestedManyWithoutSessionInput
  }

  export type TutoringSessionUncheckedCreateWithoutCertificatesInput = {
    id?: string
    teacherId: string
    subject: string
    description?: string | null
    pricePerHour: Decimal | DecimalJsLike | number | string
    locationType: $Enums.TutoringLocationType
    status?: $Enums.TutoringStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    maxStudents?: number
    prerequisites?: TutoringSessionCreateprerequisitesInput | string[]
    level?: string | null
    tags?: TutoringSessionCreatetagsInput | string[]
    featured?: boolean
    availability?: TutoringAvailabilityUncheckedCreateNestedManyWithoutSessionInput
    requests?: TutoringRequestUncheckedCreateNestedManyWithoutSessionInput
    appointments?: TutoringAppointmentUncheckedCreateNestedManyWithoutSessionInput
    reviews?: TutoringReviewUncheckedCreateNestedManyWithoutSessionInput
  }

  export type TutoringSessionCreateOrConnectWithoutCertificatesInput = {
    where: TutoringSessionWhereUniqueInput
    create: XOR<TutoringSessionCreateWithoutCertificatesInput, TutoringSessionUncheckedCreateWithoutCertificatesInput>
  }

  export type BadgeCreateWithoutCertificatesInput = {
    id?: string
    name: string
    description?: string | null
    imageUrl?: string | null
    type: $Enums.BadgeType
    category?: string | null
  }

  export type BadgeUncheckedCreateWithoutCertificatesInput = {
    id?: string
    name: string
    description?: string | null
    imageUrl?: string | null
    type: $Enums.BadgeType
    category?: string | null
  }

  export type BadgeCreateOrConnectWithoutCertificatesInput = {
    where: BadgeWhereUniqueInput
    create: XOR<BadgeCreateWithoutCertificatesInput, BadgeUncheckedCreateWithoutCertificatesInput>
  }

  export type UserUpsertWithoutCertificatesInput = {
    update: XOR<UserUpdateWithoutCertificatesInput, UserUncheckedUpdateWithoutCertificatesInput>
    create: XOR<UserCreateWithoutCertificatesInput, UserUncheckedCreateWithoutCertificatesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCertificatesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCertificatesInput, UserUncheckedUpdateWithoutCertificatesInput>
  }

  export type UserUpdateWithoutCertificatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: IntFieldUpdateOperationsInput | number
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referredBy?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferredByNestedInput
    teacherProfile?: TeacherProfileUpdateOneWithoutUserNestedInput
    availability?: UserAvailabilityUpdateManyWithoutUserNestedInput
    pointsTransactions?: PointsTransactionUpdateManyWithoutUserNestedInput
    courses?: CourseUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    savedCourses?: SavedCourseUpdateManyWithoutUserNestedInput
    likedCourses?: LikedCourseUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutUserNestedInput
    assignmentSubs?: AssignmentSubmissionUpdateManyWithoutUserNestedInput
    courseReviews?: CourseReviewUpdateManyWithoutUserNestedInput
    tutoringSessions?: TutoringSessionUpdateManyWithoutTeacherNestedInput
    tutoringRequests?: TutoringRequestUpdateManyWithoutStudentNestedInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUpdateManyWithoutTeacherNestedInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUpdateManyWithoutStudentNestedInput
    tutoringReviews?: TutoringReviewUpdateManyWithoutStudentNestedInput
    tutoringMessages?: TutoringMessageUpdateManyWithoutSenderNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    conversationParts?: ConversationParticipantUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    attachments?: AttachmentUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    subscriptionRecords?: UserSubscriptionUpdateManyWithoutUserNestedInput
    bundlesOwned?: UserBundleUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUpdateManyWithoutUserNestedInput
    eventsAsTeacher?: CalendarEventUpdateManyWithoutTeacherNestedInput
    eventsAsStudent?: CalendarEventUpdateManyWithoutStudentNestedInput
    blogPosts?: BlogPostUpdateManyWithoutAuthorNestedInput
    blogComments?: BlogCommentUpdateManyWithoutUserNestedInput
    submissionsGraded?: AssignmentSubmissionUpdateManyWithoutGradedByNestedInput
    referralCodesOwned?: ReferralCodeUpdateManyWithoutUserNestedInput
    referralUsesGained?: ReferralUseUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCertificatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: IntFieldUpdateOperationsInput | number
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referrals?: UserUncheckedUpdateManyWithoutReferredByNestedInput
    teacherProfile?: TeacherProfileUncheckedUpdateOneWithoutUserNestedInput
    availability?: UserAvailabilityUncheckedUpdateManyWithoutUserNestedInput
    pointsTransactions?: PointsTransactionUncheckedUpdateManyWithoutUserNestedInput
    courses?: CourseUncheckedUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    savedCourses?: SavedCourseUncheckedUpdateManyWithoutUserNestedInput
    likedCourses?: LikedCourseUncheckedUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUncheckedUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    assignmentSubs?: AssignmentSubmissionUncheckedUpdateManyWithoutUserNestedInput
    courseReviews?: CourseReviewUncheckedUpdateManyWithoutUserNestedInput
    tutoringSessions?: TutoringSessionUncheckedUpdateManyWithoutTeacherNestedInput
    tutoringRequests?: TutoringRequestUncheckedUpdateManyWithoutStudentNestedInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUncheckedUpdateManyWithoutTeacherNestedInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUncheckedUpdateManyWithoutStudentNestedInput
    tutoringReviews?: TutoringReviewUncheckedUpdateManyWithoutStudentNestedInput
    tutoringMessages?: TutoringMessageUncheckedUpdateManyWithoutSenderNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    conversationParts?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    subscriptionRecords?: UserSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    bundlesOwned?: UserBundleUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUncheckedUpdateManyWithoutUserNestedInput
    eventsAsTeacher?: CalendarEventUncheckedUpdateManyWithoutTeacherNestedInput
    eventsAsStudent?: CalendarEventUncheckedUpdateManyWithoutStudentNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
    blogComments?: BlogCommentUncheckedUpdateManyWithoutUserNestedInput
    submissionsGraded?: AssignmentSubmissionUncheckedUpdateManyWithoutGradedByNestedInput
    referralCodesOwned?: ReferralCodeUncheckedUpdateManyWithoutUserNestedInput
    referralUsesGained?: ReferralUseUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CourseUpsertWithoutCertificatesInput = {
    update: XOR<CourseUpdateWithoutCertificatesInput, CourseUncheckedUpdateWithoutCertificatesInput>
    create: XOR<CourseCreateWithoutCertificatesInput, CourseUncheckedCreateWithoutCertificatesInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutCertificatesInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutCertificatesInput, CourseUncheckedUpdateWithoutCertificatesInput>
  }

  export type CourseUpdateWithoutCertificatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pointsPrice?: IntFieldUpdateOperationsInput | number
    students?: IntFieldUpdateOperationsInput | number
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumCourseStatusFieldUpdateOperationsInput | $Enums.CourseStatus
    featured?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher?: UserUpdateOneRequiredWithoutCoursesNestedInput
    topics?: TopicUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUpdateManyWithoutCourseNestedInput
    savedBy?: SavedCourseUpdateManyWithoutCourseNestedInput
    likedBy?: LikedCourseUpdateManyWithoutCourseNestedInput
    reviews?: CourseReviewUpdateManyWithoutCourseNestedInput
    lessons?: LessonUpdateManyWithoutCourseNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutCourseNestedInput
    bundleCourses?: BundleCourseUpdateManyWithoutCourseNestedInput
    calendarEvents?: CalendarEventUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutCertificatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pointsPrice?: IntFieldUpdateOperationsInput | number
    teacherId?: StringFieldUpdateOperationsInput | string
    students?: IntFieldUpdateOperationsInput | number
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumCourseStatusFieldUpdateOperationsInput | $Enums.CourseStatus
    featured?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    topics?: TopicUncheckedUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutCourseNestedInput
    savedBy?: SavedCourseUncheckedUpdateManyWithoutCourseNestedInput
    likedBy?: LikedCourseUncheckedUpdateManyWithoutCourseNestedInput
    reviews?: CourseReviewUncheckedUpdateManyWithoutCourseNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutCourseNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutCourseNestedInput
    bundleCourses?: BundleCourseUncheckedUpdateManyWithoutCourseNestedInput
    calendarEvents?: CalendarEventUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type TutoringSessionUpsertWithoutCertificatesInput = {
    update: XOR<TutoringSessionUpdateWithoutCertificatesInput, TutoringSessionUncheckedUpdateWithoutCertificatesInput>
    create: XOR<TutoringSessionCreateWithoutCertificatesInput, TutoringSessionUncheckedCreateWithoutCertificatesInput>
    where?: TutoringSessionWhereInput
  }

  export type TutoringSessionUpdateToOneWithWhereWithoutCertificatesInput = {
    where?: TutoringSessionWhereInput
    data: XOR<TutoringSessionUpdateWithoutCertificatesInput, TutoringSessionUncheckedUpdateWithoutCertificatesInput>
  }

  export type TutoringSessionUpdateWithoutCertificatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pricePerHour?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    locationType?: EnumTutoringLocationTypeFieldUpdateOperationsInput | $Enums.TutoringLocationType
    status?: EnumTutoringStatusFieldUpdateOperationsInput | $Enums.TutoringStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maxStudents?: IntFieldUpdateOperationsInput | number
    prerequisites?: TutoringSessionUpdateprerequisitesInput | string[]
    level?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: TutoringSessionUpdatetagsInput | string[]
    featured?: BoolFieldUpdateOperationsInput | boolean
    teacher?: UserUpdateOneRequiredWithoutTutoringSessionsNestedInput
    availability?: TutoringAvailabilityUpdateManyWithoutSessionNestedInput
    requests?: TutoringRequestUpdateManyWithoutSessionNestedInput
    appointments?: TutoringAppointmentUpdateManyWithoutSessionNestedInput
    reviews?: TutoringReviewUpdateManyWithoutSessionNestedInput
  }

  export type TutoringSessionUncheckedUpdateWithoutCertificatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pricePerHour?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    locationType?: EnumTutoringLocationTypeFieldUpdateOperationsInput | $Enums.TutoringLocationType
    status?: EnumTutoringStatusFieldUpdateOperationsInput | $Enums.TutoringStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maxStudents?: IntFieldUpdateOperationsInput | number
    prerequisites?: TutoringSessionUpdateprerequisitesInput | string[]
    level?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: TutoringSessionUpdatetagsInput | string[]
    featured?: BoolFieldUpdateOperationsInput | boolean
    availability?: TutoringAvailabilityUncheckedUpdateManyWithoutSessionNestedInput
    requests?: TutoringRequestUncheckedUpdateManyWithoutSessionNestedInput
    appointments?: TutoringAppointmentUncheckedUpdateManyWithoutSessionNestedInput
    reviews?: TutoringReviewUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type BadgeUpsertWithoutCertificatesInput = {
    update: XOR<BadgeUpdateWithoutCertificatesInput, BadgeUncheckedUpdateWithoutCertificatesInput>
    create: XOR<BadgeCreateWithoutCertificatesInput, BadgeUncheckedCreateWithoutCertificatesInput>
    where?: BadgeWhereInput
  }

  export type BadgeUpdateToOneWithWhereWithoutCertificatesInput = {
    where?: BadgeWhereInput
    data: XOR<BadgeUpdateWithoutCertificatesInput, BadgeUncheckedUpdateWithoutCertificatesInput>
  }

  export type BadgeUpdateWithoutCertificatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumBadgeTypeFieldUpdateOperationsInput | $Enums.BadgeType
    category?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BadgeUncheckedUpdateWithoutCertificatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumBadgeTypeFieldUpdateOperationsInput | $Enums.BadgeType
    category?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ConversationParticipantCreateWithoutConversationInput = {
    user: UserCreateNestedOneWithoutConversationPartsInput
  }

  export type ConversationParticipantUncheckedCreateWithoutConversationInput = {
    userId: string
  }

  export type ConversationParticipantCreateOrConnectWithoutConversationInput = {
    where: ConversationParticipantWhereUniqueInput
    create: XOR<ConversationParticipantCreateWithoutConversationInput, ConversationParticipantUncheckedCreateWithoutConversationInput>
  }

  export type ConversationParticipantCreateManyConversationInputEnvelope = {
    data: ConversationParticipantCreateManyConversationInput | ConversationParticipantCreateManyConversationInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutConversationInput = {
    id?: string
    content: string
    timestamp?: Date | string
    read?: boolean
    sender: UserCreateNestedOneWithoutSentMessagesInput
    attachments?: AttachmentCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutConversationInput = {
    id?: string
    senderId: string
    content: string
    timestamp?: Date | string
    read?: boolean
    attachments?: AttachmentUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutConversationInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput>
  }

  export type MessageCreateManyConversationInputEnvelope = {
    data: MessageCreateManyConversationInput | MessageCreateManyConversationInput[]
    skipDuplicates?: boolean
  }

  export type ConversationParticipantUpsertWithWhereUniqueWithoutConversationInput = {
    where: ConversationParticipantWhereUniqueInput
    update: XOR<ConversationParticipantUpdateWithoutConversationInput, ConversationParticipantUncheckedUpdateWithoutConversationInput>
    create: XOR<ConversationParticipantCreateWithoutConversationInput, ConversationParticipantUncheckedCreateWithoutConversationInput>
  }

  export type ConversationParticipantUpdateWithWhereUniqueWithoutConversationInput = {
    where: ConversationParticipantWhereUniqueInput
    data: XOR<ConversationParticipantUpdateWithoutConversationInput, ConversationParticipantUncheckedUpdateWithoutConversationInput>
  }

  export type ConversationParticipantUpdateManyWithWhereWithoutConversationInput = {
    where: ConversationParticipantScalarWhereInput
    data: XOR<ConversationParticipantUpdateManyMutationInput, ConversationParticipantUncheckedUpdateManyWithoutConversationInput>
  }

  export type MessageUpsertWithWhereUniqueWithoutConversationInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutConversationInput, MessageUncheckedUpdateWithoutConversationInput>
    create: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutConversationInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutConversationInput, MessageUncheckedUpdateWithoutConversationInput>
  }

  export type MessageUpdateManyWithWhereWithoutConversationInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutConversationInput>
  }

  export type ConversationCreateWithoutParticipantsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MessageCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateWithoutParticipantsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutParticipantsInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutParticipantsInput, ConversationUncheckedCreateWithoutParticipantsInput>
  }

  export type UserCreateWithoutConversationPartsInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    avatar?: string | null
    bio?: string | null
    createdAt?: Date | string
    points?: number
    referralCode?: string | null
    lastLogin?: Date | string | null
    referredBy?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferredByInput
    teacherProfile?: TeacherProfileCreateNestedOneWithoutUserInput
    availability?: UserAvailabilityCreateNestedManyWithoutUserInput
    pointsTransactions?: PointsTransactionCreateNestedManyWithoutUserInput
    courses?: CourseCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    savedCourses?: SavedCourseCreateNestedManyWithoutUserInput
    likedCourses?: LikedCourseCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutUserInput
    assignmentSubs?: AssignmentSubmissionCreateNestedManyWithoutUserInput
    courseReviews?: CourseReviewCreateNestedManyWithoutUserInput
    tutoringSessions?: TutoringSessionCreateNestedManyWithoutTeacherInput
    tutoringRequests?: TutoringRequestCreateNestedManyWithoutStudentInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentCreateNestedManyWithoutTeacherInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentCreateNestedManyWithoutStudentInput
    tutoringReviews?: TutoringReviewCreateNestedManyWithoutStudentInput
    tutoringMessages?: TutoringMessageCreateNestedManyWithoutSenderInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    attachments?: AttachmentCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    subscriptionRecords?: UserSubscriptionCreateNestedManyWithoutUserInput
    bundlesOwned?: UserBundleCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventCreateNestedManyWithoutUserInput
    eventsAsTeacher?: CalendarEventCreateNestedManyWithoutTeacherInput
    eventsAsStudent?: CalendarEventCreateNestedManyWithoutStudentInput
    blogPosts?: BlogPostCreateNestedManyWithoutAuthorInput
    blogComments?: BlogCommentCreateNestedManyWithoutUserInput
    submissionsGraded?: AssignmentSubmissionCreateNestedManyWithoutGradedByInput
    referralCodesOwned?: ReferralCodeCreateNestedManyWithoutUserInput
    referralUsesGained?: ReferralUseCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutConversationPartsInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    avatar?: string | null
    bio?: string | null
    createdAt?: Date | string
    points?: number
    referralCode?: string | null
    referredById?: string | null
    lastLogin?: Date | string | null
    referrals?: UserUncheckedCreateNestedManyWithoutReferredByInput
    teacherProfile?: TeacherProfileUncheckedCreateNestedOneWithoutUserInput
    availability?: UserAvailabilityUncheckedCreateNestedManyWithoutUserInput
    pointsTransactions?: PointsTransactionUncheckedCreateNestedManyWithoutUserInput
    courses?: CourseUncheckedCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    savedCourses?: SavedCourseUncheckedCreateNestedManyWithoutUserInput
    likedCourses?: LikedCourseUncheckedCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressUncheckedCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutUserInput
    assignmentSubs?: AssignmentSubmissionUncheckedCreateNestedManyWithoutUserInput
    courseReviews?: CourseReviewUncheckedCreateNestedManyWithoutUserInput
    tutoringSessions?: TutoringSessionUncheckedCreateNestedManyWithoutTeacherInput
    tutoringRequests?: TutoringRequestUncheckedCreateNestedManyWithoutStudentInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUncheckedCreateNestedManyWithoutTeacherInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUncheckedCreateNestedManyWithoutStudentInput
    tutoringReviews?: TutoringReviewUncheckedCreateNestedManyWithoutStudentInput
    tutoringMessages?: TutoringMessageUncheckedCreateNestedManyWithoutSenderInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    subscriptionRecords?: UserSubscriptionUncheckedCreateNestedManyWithoutUserInput
    bundlesOwned?: UserBundleUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventUncheckedCreateNestedManyWithoutUserInput
    eventsAsTeacher?: CalendarEventUncheckedCreateNestedManyWithoutTeacherInput
    eventsAsStudent?: CalendarEventUncheckedCreateNestedManyWithoutStudentInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
    blogComments?: BlogCommentUncheckedCreateNestedManyWithoutUserInput
    submissionsGraded?: AssignmentSubmissionUncheckedCreateNestedManyWithoutGradedByInput
    referralCodesOwned?: ReferralCodeUncheckedCreateNestedManyWithoutUserInput
    referralUsesGained?: ReferralUseUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutConversationPartsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutConversationPartsInput, UserUncheckedCreateWithoutConversationPartsInput>
  }

  export type ConversationUpsertWithoutParticipantsInput = {
    update: XOR<ConversationUpdateWithoutParticipantsInput, ConversationUncheckedUpdateWithoutParticipantsInput>
    create: XOR<ConversationCreateWithoutParticipantsInput, ConversationUncheckedCreateWithoutParticipantsInput>
    where?: ConversationWhereInput
  }

  export type ConversationUpdateToOneWithWhereWithoutParticipantsInput = {
    where?: ConversationWhereInput
    data: XOR<ConversationUpdateWithoutParticipantsInput, ConversationUncheckedUpdateWithoutParticipantsInput>
  }

  export type ConversationUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type UserUpsertWithoutConversationPartsInput = {
    update: XOR<UserUpdateWithoutConversationPartsInput, UserUncheckedUpdateWithoutConversationPartsInput>
    create: XOR<UserCreateWithoutConversationPartsInput, UserUncheckedCreateWithoutConversationPartsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutConversationPartsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutConversationPartsInput, UserUncheckedUpdateWithoutConversationPartsInput>
  }

  export type UserUpdateWithoutConversationPartsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: IntFieldUpdateOperationsInput | number
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referredBy?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferredByNestedInput
    teacherProfile?: TeacherProfileUpdateOneWithoutUserNestedInput
    availability?: UserAvailabilityUpdateManyWithoutUserNestedInput
    pointsTransactions?: PointsTransactionUpdateManyWithoutUserNestedInput
    courses?: CourseUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    savedCourses?: SavedCourseUpdateManyWithoutUserNestedInput
    likedCourses?: LikedCourseUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutUserNestedInput
    assignmentSubs?: AssignmentSubmissionUpdateManyWithoutUserNestedInput
    courseReviews?: CourseReviewUpdateManyWithoutUserNestedInput
    tutoringSessions?: TutoringSessionUpdateManyWithoutTeacherNestedInput
    tutoringRequests?: TutoringRequestUpdateManyWithoutStudentNestedInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUpdateManyWithoutTeacherNestedInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUpdateManyWithoutStudentNestedInput
    tutoringReviews?: TutoringReviewUpdateManyWithoutStudentNestedInput
    tutoringMessages?: TutoringMessageUpdateManyWithoutSenderNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    attachments?: AttachmentUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    subscriptionRecords?: UserSubscriptionUpdateManyWithoutUserNestedInput
    bundlesOwned?: UserBundleUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUpdateManyWithoutUserNestedInput
    eventsAsTeacher?: CalendarEventUpdateManyWithoutTeacherNestedInput
    eventsAsStudent?: CalendarEventUpdateManyWithoutStudentNestedInput
    blogPosts?: BlogPostUpdateManyWithoutAuthorNestedInput
    blogComments?: BlogCommentUpdateManyWithoutUserNestedInput
    submissionsGraded?: AssignmentSubmissionUpdateManyWithoutGradedByNestedInput
    referralCodesOwned?: ReferralCodeUpdateManyWithoutUserNestedInput
    referralUsesGained?: ReferralUseUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutConversationPartsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: IntFieldUpdateOperationsInput | number
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referrals?: UserUncheckedUpdateManyWithoutReferredByNestedInput
    teacherProfile?: TeacherProfileUncheckedUpdateOneWithoutUserNestedInput
    availability?: UserAvailabilityUncheckedUpdateManyWithoutUserNestedInput
    pointsTransactions?: PointsTransactionUncheckedUpdateManyWithoutUserNestedInput
    courses?: CourseUncheckedUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    savedCourses?: SavedCourseUncheckedUpdateManyWithoutUserNestedInput
    likedCourses?: LikedCourseUncheckedUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUncheckedUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    assignmentSubs?: AssignmentSubmissionUncheckedUpdateManyWithoutUserNestedInput
    courseReviews?: CourseReviewUncheckedUpdateManyWithoutUserNestedInput
    tutoringSessions?: TutoringSessionUncheckedUpdateManyWithoutTeacherNestedInput
    tutoringRequests?: TutoringRequestUncheckedUpdateManyWithoutStudentNestedInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUncheckedUpdateManyWithoutTeacherNestedInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUncheckedUpdateManyWithoutStudentNestedInput
    tutoringReviews?: TutoringReviewUncheckedUpdateManyWithoutStudentNestedInput
    tutoringMessages?: TutoringMessageUncheckedUpdateManyWithoutSenderNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    subscriptionRecords?: UserSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    bundlesOwned?: UserBundleUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUncheckedUpdateManyWithoutUserNestedInput
    eventsAsTeacher?: CalendarEventUncheckedUpdateManyWithoutTeacherNestedInput
    eventsAsStudent?: CalendarEventUncheckedUpdateManyWithoutStudentNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
    blogComments?: BlogCommentUncheckedUpdateManyWithoutUserNestedInput
    submissionsGraded?: AssignmentSubmissionUncheckedUpdateManyWithoutGradedByNestedInput
    referralCodesOwned?: ReferralCodeUncheckedUpdateManyWithoutUserNestedInput
    referralUsesGained?: ReferralUseUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ConversationCreateWithoutMessagesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: ConversationParticipantCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateWithoutMessagesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: ConversationParticipantUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutMessagesInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
  }

  export type UserCreateWithoutSentMessagesInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    avatar?: string | null
    bio?: string | null
    createdAt?: Date | string
    points?: number
    referralCode?: string | null
    lastLogin?: Date | string | null
    referredBy?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferredByInput
    teacherProfile?: TeacherProfileCreateNestedOneWithoutUserInput
    availability?: UserAvailabilityCreateNestedManyWithoutUserInput
    pointsTransactions?: PointsTransactionCreateNestedManyWithoutUserInput
    courses?: CourseCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    savedCourses?: SavedCourseCreateNestedManyWithoutUserInput
    likedCourses?: LikedCourseCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutUserInput
    assignmentSubs?: AssignmentSubmissionCreateNestedManyWithoutUserInput
    courseReviews?: CourseReviewCreateNestedManyWithoutUserInput
    tutoringSessions?: TutoringSessionCreateNestedManyWithoutTeacherInput
    tutoringRequests?: TutoringRequestCreateNestedManyWithoutStudentInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentCreateNestedManyWithoutTeacherInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentCreateNestedManyWithoutStudentInput
    tutoringReviews?: TutoringReviewCreateNestedManyWithoutStudentInput
    tutoringMessages?: TutoringMessageCreateNestedManyWithoutSenderInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    conversationParts?: ConversationParticipantCreateNestedManyWithoutUserInput
    attachments?: AttachmentCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    subscriptionRecords?: UserSubscriptionCreateNestedManyWithoutUserInput
    bundlesOwned?: UserBundleCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventCreateNestedManyWithoutUserInput
    eventsAsTeacher?: CalendarEventCreateNestedManyWithoutTeacherInput
    eventsAsStudent?: CalendarEventCreateNestedManyWithoutStudentInput
    blogPosts?: BlogPostCreateNestedManyWithoutAuthorInput
    blogComments?: BlogCommentCreateNestedManyWithoutUserInput
    submissionsGraded?: AssignmentSubmissionCreateNestedManyWithoutGradedByInput
    referralCodesOwned?: ReferralCodeCreateNestedManyWithoutUserInput
    referralUsesGained?: ReferralUseCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSentMessagesInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    avatar?: string | null
    bio?: string | null
    createdAt?: Date | string
    points?: number
    referralCode?: string | null
    referredById?: string | null
    lastLogin?: Date | string | null
    referrals?: UserUncheckedCreateNestedManyWithoutReferredByInput
    teacherProfile?: TeacherProfileUncheckedCreateNestedOneWithoutUserInput
    availability?: UserAvailabilityUncheckedCreateNestedManyWithoutUserInput
    pointsTransactions?: PointsTransactionUncheckedCreateNestedManyWithoutUserInput
    courses?: CourseUncheckedCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    savedCourses?: SavedCourseUncheckedCreateNestedManyWithoutUserInput
    likedCourses?: LikedCourseUncheckedCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressUncheckedCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutUserInput
    assignmentSubs?: AssignmentSubmissionUncheckedCreateNestedManyWithoutUserInput
    courseReviews?: CourseReviewUncheckedCreateNestedManyWithoutUserInput
    tutoringSessions?: TutoringSessionUncheckedCreateNestedManyWithoutTeacherInput
    tutoringRequests?: TutoringRequestUncheckedCreateNestedManyWithoutStudentInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUncheckedCreateNestedManyWithoutTeacherInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUncheckedCreateNestedManyWithoutStudentInput
    tutoringReviews?: TutoringReviewUncheckedCreateNestedManyWithoutStudentInput
    tutoringMessages?: TutoringMessageUncheckedCreateNestedManyWithoutSenderInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    conversationParts?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    subscriptionRecords?: UserSubscriptionUncheckedCreateNestedManyWithoutUserInput
    bundlesOwned?: UserBundleUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventUncheckedCreateNestedManyWithoutUserInput
    eventsAsTeacher?: CalendarEventUncheckedCreateNestedManyWithoutTeacherInput
    eventsAsStudent?: CalendarEventUncheckedCreateNestedManyWithoutStudentInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
    blogComments?: BlogCommentUncheckedCreateNestedManyWithoutUserInput
    submissionsGraded?: AssignmentSubmissionUncheckedCreateNestedManyWithoutGradedByInput
    referralCodesOwned?: ReferralCodeUncheckedCreateNestedManyWithoutUserInput
    referralUsesGained?: ReferralUseUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSentMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
  }

  export type AttachmentCreateWithoutMessageInput = {
    id?: string
    fileName: string
    fileUrl: string
    fileType: string
    fileSize: number
    user?: UserCreateNestedOneWithoutAttachmentsInput
  }

  export type AttachmentUncheckedCreateWithoutMessageInput = {
    id?: string
    userId?: string | null
    fileName: string
    fileUrl: string
    fileType: string
    fileSize: number
  }

  export type AttachmentCreateOrConnectWithoutMessageInput = {
    where: AttachmentWhereUniqueInput
    create: XOR<AttachmentCreateWithoutMessageInput, AttachmentUncheckedCreateWithoutMessageInput>
  }

  export type AttachmentCreateManyMessageInputEnvelope = {
    data: AttachmentCreateManyMessageInput | AttachmentCreateManyMessageInput[]
    skipDuplicates?: boolean
  }

  export type ConversationUpsertWithoutMessagesInput = {
    update: XOR<ConversationUpdateWithoutMessagesInput, ConversationUncheckedUpdateWithoutMessagesInput>
    create: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    where?: ConversationWhereInput
  }

  export type ConversationUpdateToOneWithWhereWithoutMessagesInput = {
    where?: ConversationWhereInput
    data: XOR<ConversationUpdateWithoutMessagesInput, ConversationUncheckedUpdateWithoutMessagesInput>
  }

  export type ConversationUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: ConversationParticipantUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: ConversationParticipantUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type UserUpsertWithoutSentMessagesInput = {
    update: XOR<UserUpdateWithoutSentMessagesInput, UserUncheckedUpdateWithoutSentMessagesInput>
    create: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSentMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSentMessagesInput, UserUncheckedUpdateWithoutSentMessagesInput>
  }

  export type UserUpdateWithoutSentMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: IntFieldUpdateOperationsInput | number
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referredBy?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferredByNestedInput
    teacherProfile?: TeacherProfileUpdateOneWithoutUserNestedInput
    availability?: UserAvailabilityUpdateManyWithoutUserNestedInput
    pointsTransactions?: PointsTransactionUpdateManyWithoutUserNestedInput
    courses?: CourseUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    savedCourses?: SavedCourseUpdateManyWithoutUserNestedInput
    likedCourses?: LikedCourseUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutUserNestedInput
    assignmentSubs?: AssignmentSubmissionUpdateManyWithoutUserNestedInput
    courseReviews?: CourseReviewUpdateManyWithoutUserNestedInput
    tutoringSessions?: TutoringSessionUpdateManyWithoutTeacherNestedInput
    tutoringRequests?: TutoringRequestUpdateManyWithoutStudentNestedInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUpdateManyWithoutTeacherNestedInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUpdateManyWithoutStudentNestedInput
    tutoringReviews?: TutoringReviewUpdateManyWithoutStudentNestedInput
    tutoringMessages?: TutoringMessageUpdateManyWithoutSenderNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    conversationParts?: ConversationParticipantUpdateManyWithoutUserNestedInput
    attachments?: AttachmentUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    subscriptionRecords?: UserSubscriptionUpdateManyWithoutUserNestedInput
    bundlesOwned?: UserBundleUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUpdateManyWithoutUserNestedInput
    eventsAsTeacher?: CalendarEventUpdateManyWithoutTeacherNestedInput
    eventsAsStudent?: CalendarEventUpdateManyWithoutStudentNestedInput
    blogPosts?: BlogPostUpdateManyWithoutAuthorNestedInput
    blogComments?: BlogCommentUpdateManyWithoutUserNestedInput
    submissionsGraded?: AssignmentSubmissionUpdateManyWithoutGradedByNestedInput
    referralCodesOwned?: ReferralCodeUpdateManyWithoutUserNestedInput
    referralUsesGained?: ReferralUseUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSentMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: IntFieldUpdateOperationsInput | number
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referrals?: UserUncheckedUpdateManyWithoutReferredByNestedInput
    teacherProfile?: TeacherProfileUncheckedUpdateOneWithoutUserNestedInput
    availability?: UserAvailabilityUncheckedUpdateManyWithoutUserNestedInput
    pointsTransactions?: PointsTransactionUncheckedUpdateManyWithoutUserNestedInput
    courses?: CourseUncheckedUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    savedCourses?: SavedCourseUncheckedUpdateManyWithoutUserNestedInput
    likedCourses?: LikedCourseUncheckedUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUncheckedUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    assignmentSubs?: AssignmentSubmissionUncheckedUpdateManyWithoutUserNestedInput
    courseReviews?: CourseReviewUncheckedUpdateManyWithoutUserNestedInput
    tutoringSessions?: TutoringSessionUncheckedUpdateManyWithoutTeacherNestedInput
    tutoringRequests?: TutoringRequestUncheckedUpdateManyWithoutStudentNestedInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUncheckedUpdateManyWithoutTeacherNestedInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUncheckedUpdateManyWithoutStudentNestedInput
    tutoringReviews?: TutoringReviewUncheckedUpdateManyWithoutStudentNestedInput
    tutoringMessages?: TutoringMessageUncheckedUpdateManyWithoutSenderNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    conversationParts?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    subscriptionRecords?: UserSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    bundlesOwned?: UserBundleUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUncheckedUpdateManyWithoutUserNestedInput
    eventsAsTeacher?: CalendarEventUncheckedUpdateManyWithoutTeacherNestedInput
    eventsAsStudent?: CalendarEventUncheckedUpdateManyWithoutStudentNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
    blogComments?: BlogCommentUncheckedUpdateManyWithoutUserNestedInput
    submissionsGraded?: AssignmentSubmissionUncheckedUpdateManyWithoutGradedByNestedInput
    referralCodesOwned?: ReferralCodeUncheckedUpdateManyWithoutUserNestedInput
    referralUsesGained?: ReferralUseUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AttachmentUpsertWithWhereUniqueWithoutMessageInput = {
    where: AttachmentWhereUniqueInput
    update: XOR<AttachmentUpdateWithoutMessageInput, AttachmentUncheckedUpdateWithoutMessageInput>
    create: XOR<AttachmentCreateWithoutMessageInput, AttachmentUncheckedCreateWithoutMessageInput>
  }

  export type AttachmentUpdateWithWhereUniqueWithoutMessageInput = {
    where: AttachmentWhereUniqueInput
    data: XOR<AttachmentUpdateWithoutMessageInput, AttachmentUncheckedUpdateWithoutMessageInput>
  }

  export type AttachmentUpdateManyWithWhereWithoutMessageInput = {
    where: AttachmentScalarWhereInput
    data: XOR<AttachmentUpdateManyMutationInput, AttachmentUncheckedUpdateManyWithoutMessageInput>
  }

  export type MessageCreateWithoutAttachmentsInput = {
    id?: string
    content: string
    timestamp?: Date | string
    read?: boolean
    conversation: ConversationCreateNestedOneWithoutMessagesInput
    sender: UserCreateNestedOneWithoutSentMessagesInput
  }

  export type MessageUncheckedCreateWithoutAttachmentsInput = {
    id?: string
    conversationId: string
    senderId: string
    content: string
    timestamp?: Date | string
    read?: boolean
  }

  export type MessageCreateOrConnectWithoutAttachmentsInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutAttachmentsInput, MessageUncheckedCreateWithoutAttachmentsInput>
  }

  export type UserCreateWithoutAttachmentsInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    avatar?: string | null
    bio?: string | null
    createdAt?: Date | string
    points?: number
    referralCode?: string | null
    lastLogin?: Date | string | null
    referredBy?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferredByInput
    teacherProfile?: TeacherProfileCreateNestedOneWithoutUserInput
    availability?: UserAvailabilityCreateNestedManyWithoutUserInput
    pointsTransactions?: PointsTransactionCreateNestedManyWithoutUserInput
    courses?: CourseCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    savedCourses?: SavedCourseCreateNestedManyWithoutUserInput
    likedCourses?: LikedCourseCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutUserInput
    assignmentSubs?: AssignmentSubmissionCreateNestedManyWithoutUserInput
    courseReviews?: CourseReviewCreateNestedManyWithoutUserInput
    tutoringSessions?: TutoringSessionCreateNestedManyWithoutTeacherInput
    tutoringRequests?: TutoringRequestCreateNestedManyWithoutStudentInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentCreateNestedManyWithoutTeacherInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentCreateNestedManyWithoutStudentInput
    tutoringReviews?: TutoringReviewCreateNestedManyWithoutStudentInput
    tutoringMessages?: TutoringMessageCreateNestedManyWithoutSenderInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    conversationParts?: ConversationParticipantCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    subscriptionRecords?: UserSubscriptionCreateNestedManyWithoutUserInput
    bundlesOwned?: UserBundleCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventCreateNestedManyWithoutUserInput
    eventsAsTeacher?: CalendarEventCreateNestedManyWithoutTeacherInput
    eventsAsStudent?: CalendarEventCreateNestedManyWithoutStudentInput
    blogPosts?: BlogPostCreateNestedManyWithoutAuthorInput
    blogComments?: BlogCommentCreateNestedManyWithoutUserInput
    submissionsGraded?: AssignmentSubmissionCreateNestedManyWithoutGradedByInput
    referralCodesOwned?: ReferralCodeCreateNestedManyWithoutUserInput
    referralUsesGained?: ReferralUseCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAttachmentsInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    avatar?: string | null
    bio?: string | null
    createdAt?: Date | string
    points?: number
    referralCode?: string | null
    referredById?: string | null
    lastLogin?: Date | string | null
    referrals?: UserUncheckedCreateNestedManyWithoutReferredByInput
    teacherProfile?: TeacherProfileUncheckedCreateNestedOneWithoutUserInput
    availability?: UserAvailabilityUncheckedCreateNestedManyWithoutUserInput
    pointsTransactions?: PointsTransactionUncheckedCreateNestedManyWithoutUserInput
    courses?: CourseUncheckedCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    savedCourses?: SavedCourseUncheckedCreateNestedManyWithoutUserInput
    likedCourses?: LikedCourseUncheckedCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressUncheckedCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutUserInput
    assignmentSubs?: AssignmentSubmissionUncheckedCreateNestedManyWithoutUserInput
    courseReviews?: CourseReviewUncheckedCreateNestedManyWithoutUserInput
    tutoringSessions?: TutoringSessionUncheckedCreateNestedManyWithoutTeacherInput
    tutoringRequests?: TutoringRequestUncheckedCreateNestedManyWithoutStudentInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUncheckedCreateNestedManyWithoutTeacherInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUncheckedCreateNestedManyWithoutStudentInput
    tutoringReviews?: TutoringReviewUncheckedCreateNestedManyWithoutStudentInput
    tutoringMessages?: TutoringMessageUncheckedCreateNestedManyWithoutSenderInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    conversationParts?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    subscriptionRecords?: UserSubscriptionUncheckedCreateNestedManyWithoutUserInput
    bundlesOwned?: UserBundleUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventUncheckedCreateNestedManyWithoutUserInput
    eventsAsTeacher?: CalendarEventUncheckedCreateNestedManyWithoutTeacherInput
    eventsAsStudent?: CalendarEventUncheckedCreateNestedManyWithoutStudentInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
    blogComments?: BlogCommentUncheckedCreateNestedManyWithoutUserInput
    submissionsGraded?: AssignmentSubmissionUncheckedCreateNestedManyWithoutGradedByInput
    referralCodesOwned?: ReferralCodeUncheckedCreateNestedManyWithoutUserInput
    referralUsesGained?: ReferralUseUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAttachmentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAttachmentsInput, UserUncheckedCreateWithoutAttachmentsInput>
  }

  export type MessageUpsertWithoutAttachmentsInput = {
    update: XOR<MessageUpdateWithoutAttachmentsInput, MessageUncheckedUpdateWithoutAttachmentsInput>
    create: XOR<MessageCreateWithoutAttachmentsInput, MessageUncheckedCreateWithoutAttachmentsInput>
    where?: MessageWhereInput
  }

  export type MessageUpdateToOneWithWhereWithoutAttachmentsInput = {
    where?: MessageWhereInput
    data: XOR<MessageUpdateWithoutAttachmentsInput, MessageUncheckedUpdateWithoutAttachmentsInput>
  }

  export type MessageUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: BoolFieldUpdateOperationsInput | boolean
    conversation?: ConversationUpdateOneRequiredWithoutMessagesNestedInput
    sender?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserUpsertWithoutAttachmentsInput = {
    update: XOR<UserUpdateWithoutAttachmentsInput, UserUncheckedUpdateWithoutAttachmentsInput>
    create: XOR<UserCreateWithoutAttachmentsInput, UserUncheckedCreateWithoutAttachmentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAttachmentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAttachmentsInput, UserUncheckedUpdateWithoutAttachmentsInput>
  }

  export type UserUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: IntFieldUpdateOperationsInput | number
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referredBy?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferredByNestedInput
    teacherProfile?: TeacherProfileUpdateOneWithoutUserNestedInput
    availability?: UserAvailabilityUpdateManyWithoutUserNestedInput
    pointsTransactions?: PointsTransactionUpdateManyWithoutUserNestedInput
    courses?: CourseUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    savedCourses?: SavedCourseUpdateManyWithoutUserNestedInput
    likedCourses?: LikedCourseUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutUserNestedInput
    assignmentSubs?: AssignmentSubmissionUpdateManyWithoutUserNestedInput
    courseReviews?: CourseReviewUpdateManyWithoutUserNestedInput
    tutoringSessions?: TutoringSessionUpdateManyWithoutTeacherNestedInput
    tutoringRequests?: TutoringRequestUpdateManyWithoutStudentNestedInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUpdateManyWithoutTeacherNestedInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUpdateManyWithoutStudentNestedInput
    tutoringReviews?: TutoringReviewUpdateManyWithoutStudentNestedInput
    tutoringMessages?: TutoringMessageUpdateManyWithoutSenderNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    conversationParts?: ConversationParticipantUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    subscriptionRecords?: UserSubscriptionUpdateManyWithoutUserNestedInput
    bundlesOwned?: UserBundleUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUpdateManyWithoutUserNestedInput
    eventsAsTeacher?: CalendarEventUpdateManyWithoutTeacherNestedInput
    eventsAsStudent?: CalendarEventUpdateManyWithoutStudentNestedInput
    blogPosts?: BlogPostUpdateManyWithoutAuthorNestedInput
    blogComments?: BlogCommentUpdateManyWithoutUserNestedInput
    submissionsGraded?: AssignmentSubmissionUpdateManyWithoutGradedByNestedInput
    referralCodesOwned?: ReferralCodeUpdateManyWithoutUserNestedInput
    referralUsesGained?: ReferralUseUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: IntFieldUpdateOperationsInput | number
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referrals?: UserUncheckedUpdateManyWithoutReferredByNestedInput
    teacherProfile?: TeacherProfileUncheckedUpdateOneWithoutUserNestedInput
    availability?: UserAvailabilityUncheckedUpdateManyWithoutUserNestedInput
    pointsTransactions?: PointsTransactionUncheckedUpdateManyWithoutUserNestedInput
    courses?: CourseUncheckedUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    savedCourses?: SavedCourseUncheckedUpdateManyWithoutUserNestedInput
    likedCourses?: LikedCourseUncheckedUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUncheckedUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    assignmentSubs?: AssignmentSubmissionUncheckedUpdateManyWithoutUserNestedInput
    courseReviews?: CourseReviewUncheckedUpdateManyWithoutUserNestedInput
    tutoringSessions?: TutoringSessionUncheckedUpdateManyWithoutTeacherNestedInput
    tutoringRequests?: TutoringRequestUncheckedUpdateManyWithoutStudentNestedInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUncheckedUpdateManyWithoutTeacherNestedInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUncheckedUpdateManyWithoutStudentNestedInput
    tutoringReviews?: TutoringReviewUncheckedUpdateManyWithoutStudentNestedInput
    tutoringMessages?: TutoringMessageUncheckedUpdateManyWithoutSenderNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    conversationParts?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    subscriptionRecords?: UserSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    bundlesOwned?: UserBundleUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUncheckedUpdateManyWithoutUserNestedInput
    eventsAsTeacher?: CalendarEventUncheckedUpdateManyWithoutTeacherNestedInput
    eventsAsStudent?: CalendarEventUncheckedUpdateManyWithoutStudentNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
    blogComments?: BlogCommentUncheckedUpdateManyWithoutUserNestedInput
    submissionsGraded?: AssignmentSubmissionUncheckedUpdateManyWithoutGradedByNestedInput
    referralCodesOwned?: ReferralCodeUncheckedUpdateManyWithoutUserNestedInput
    referralUsesGained?: ReferralUseUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    avatar?: string | null
    bio?: string | null
    createdAt?: Date | string
    points?: number
    referralCode?: string | null
    lastLogin?: Date | string | null
    referredBy?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferredByInput
    teacherProfile?: TeacherProfileCreateNestedOneWithoutUserInput
    availability?: UserAvailabilityCreateNestedManyWithoutUserInput
    pointsTransactions?: PointsTransactionCreateNestedManyWithoutUserInput
    courses?: CourseCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    savedCourses?: SavedCourseCreateNestedManyWithoutUserInput
    likedCourses?: LikedCourseCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutUserInput
    assignmentSubs?: AssignmentSubmissionCreateNestedManyWithoutUserInput
    courseReviews?: CourseReviewCreateNestedManyWithoutUserInput
    tutoringSessions?: TutoringSessionCreateNestedManyWithoutTeacherInput
    tutoringRequests?: TutoringRequestCreateNestedManyWithoutStudentInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentCreateNestedManyWithoutTeacherInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentCreateNestedManyWithoutStudentInput
    tutoringReviews?: TutoringReviewCreateNestedManyWithoutStudentInput
    tutoringMessages?: TutoringMessageCreateNestedManyWithoutSenderInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    conversationParts?: ConversationParticipantCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    attachments?: AttachmentCreateNestedManyWithoutUserInput
    subscriptionRecords?: UserSubscriptionCreateNestedManyWithoutUserInput
    bundlesOwned?: UserBundleCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventCreateNestedManyWithoutUserInput
    eventsAsTeacher?: CalendarEventCreateNestedManyWithoutTeacherInput
    eventsAsStudent?: CalendarEventCreateNestedManyWithoutStudentInput
    blogPosts?: BlogPostCreateNestedManyWithoutAuthorInput
    blogComments?: BlogCommentCreateNestedManyWithoutUserInput
    submissionsGraded?: AssignmentSubmissionCreateNestedManyWithoutGradedByInput
    referralCodesOwned?: ReferralCodeCreateNestedManyWithoutUserInput
    referralUsesGained?: ReferralUseCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    avatar?: string | null
    bio?: string | null
    createdAt?: Date | string
    points?: number
    referralCode?: string | null
    referredById?: string | null
    lastLogin?: Date | string | null
    referrals?: UserUncheckedCreateNestedManyWithoutReferredByInput
    teacherProfile?: TeacherProfileUncheckedCreateNestedOneWithoutUserInput
    availability?: UserAvailabilityUncheckedCreateNestedManyWithoutUserInput
    pointsTransactions?: PointsTransactionUncheckedCreateNestedManyWithoutUserInput
    courses?: CourseUncheckedCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    savedCourses?: SavedCourseUncheckedCreateNestedManyWithoutUserInput
    likedCourses?: LikedCourseUncheckedCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressUncheckedCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutUserInput
    assignmentSubs?: AssignmentSubmissionUncheckedCreateNestedManyWithoutUserInput
    courseReviews?: CourseReviewUncheckedCreateNestedManyWithoutUserInput
    tutoringSessions?: TutoringSessionUncheckedCreateNestedManyWithoutTeacherInput
    tutoringRequests?: TutoringRequestUncheckedCreateNestedManyWithoutStudentInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUncheckedCreateNestedManyWithoutTeacherInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUncheckedCreateNestedManyWithoutStudentInput
    tutoringReviews?: TutoringReviewUncheckedCreateNestedManyWithoutStudentInput
    tutoringMessages?: TutoringMessageUncheckedCreateNestedManyWithoutSenderInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    conversationParts?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutUserInput
    subscriptionRecords?: UserSubscriptionUncheckedCreateNestedManyWithoutUserInput
    bundlesOwned?: UserBundleUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventUncheckedCreateNestedManyWithoutUserInput
    eventsAsTeacher?: CalendarEventUncheckedCreateNestedManyWithoutTeacherInput
    eventsAsStudent?: CalendarEventUncheckedCreateNestedManyWithoutStudentInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
    blogComments?: BlogCommentUncheckedCreateNestedManyWithoutUserInput
    submissionsGraded?: AssignmentSubmissionUncheckedCreateNestedManyWithoutGradedByInput
    referralCodesOwned?: ReferralCodeUncheckedCreateNestedManyWithoutUserInput
    referralUsesGained?: ReferralUseUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: IntFieldUpdateOperationsInput | number
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referredBy?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferredByNestedInput
    teacherProfile?: TeacherProfileUpdateOneWithoutUserNestedInput
    availability?: UserAvailabilityUpdateManyWithoutUserNestedInput
    pointsTransactions?: PointsTransactionUpdateManyWithoutUserNestedInput
    courses?: CourseUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    savedCourses?: SavedCourseUpdateManyWithoutUserNestedInput
    likedCourses?: LikedCourseUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutUserNestedInput
    assignmentSubs?: AssignmentSubmissionUpdateManyWithoutUserNestedInput
    courseReviews?: CourseReviewUpdateManyWithoutUserNestedInput
    tutoringSessions?: TutoringSessionUpdateManyWithoutTeacherNestedInput
    tutoringRequests?: TutoringRequestUpdateManyWithoutStudentNestedInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUpdateManyWithoutTeacherNestedInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUpdateManyWithoutStudentNestedInput
    tutoringReviews?: TutoringReviewUpdateManyWithoutStudentNestedInput
    tutoringMessages?: TutoringMessageUpdateManyWithoutSenderNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    conversationParts?: ConversationParticipantUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    attachments?: AttachmentUpdateManyWithoutUserNestedInput
    subscriptionRecords?: UserSubscriptionUpdateManyWithoutUserNestedInput
    bundlesOwned?: UserBundleUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUpdateManyWithoutUserNestedInput
    eventsAsTeacher?: CalendarEventUpdateManyWithoutTeacherNestedInput
    eventsAsStudent?: CalendarEventUpdateManyWithoutStudentNestedInput
    blogPosts?: BlogPostUpdateManyWithoutAuthorNestedInput
    blogComments?: BlogCommentUpdateManyWithoutUserNestedInput
    submissionsGraded?: AssignmentSubmissionUpdateManyWithoutGradedByNestedInput
    referralCodesOwned?: ReferralCodeUpdateManyWithoutUserNestedInput
    referralUsesGained?: ReferralUseUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: IntFieldUpdateOperationsInput | number
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referrals?: UserUncheckedUpdateManyWithoutReferredByNestedInput
    teacherProfile?: TeacherProfileUncheckedUpdateOneWithoutUserNestedInput
    availability?: UserAvailabilityUncheckedUpdateManyWithoutUserNestedInput
    pointsTransactions?: PointsTransactionUncheckedUpdateManyWithoutUserNestedInput
    courses?: CourseUncheckedUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    savedCourses?: SavedCourseUncheckedUpdateManyWithoutUserNestedInput
    likedCourses?: LikedCourseUncheckedUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUncheckedUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    assignmentSubs?: AssignmentSubmissionUncheckedUpdateManyWithoutUserNestedInput
    courseReviews?: CourseReviewUncheckedUpdateManyWithoutUserNestedInput
    tutoringSessions?: TutoringSessionUncheckedUpdateManyWithoutTeacherNestedInput
    tutoringRequests?: TutoringRequestUncheckedUpdateManyWithoutStudentNestedInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUncheckedUpdateManyWithoutTeacherNestedInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUncheckedUpdateManyWithoutStudentNestedInput
    tutoringReviews?: TutoringReviewUncheckedUpdateManyWithoutStudentNestedInput
    tutoringMessages?: TutoringMessageUncheckedUpdateManyWithoutSenderNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    conversationParts?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutUserNestedInput
    subscriptionRecords?: UserSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    bundlesOwned?: UserBundleUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUncheckedUpdateManyWithoutUserNestedInput
    eventsAsTeacher?: CalendarEventUncheckedUpdateManyWithoutTeacherNestedInput
    eventsAsStudent?: CalendarEventUncheckedUpdateManyWithoutStudentNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
    blogComments?: BlogCommentUncheckedUpdateManyWithoutUserNestedInput
    submissionsGraded?: AssignmentSubmissionUncheckedUpdateManyWithoutGradedByNestedInput
    referralCodesOwned?: ReferralCodeUncheckedUpdateManyWithoutUserNestedInput
    referralUsesGained?: ReferralUseUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserSubscriptionCreateWithoutPlanInput = {
    id?: string
    startDate?: Date | string
    endDate: Date | string
    isActive?: boolean
    autoRenew?: boolean
    paymentMethod?: string | null
    lastPaymentDate?: Date | string | null
    user: UserCreateNestedOneWithoutSubscriptionRecordsInput
  }

  export type UserSubscriptionUncheckedCreateWithoutPlanInput = {
    id?: string
    userId: string
    startDate?: Date | string
    endDate: Date | string
    isActive?: boolean
    autoRenew?: boolean
    paymentMethod?: string | null
    lastPaymentDate?: Date | string | null
  }

  export type UserSubscriptionCreateOrConnectWithoutPlanInput = {
    where: UserSubscriptionWhereUniqueInput
    create: XOR<UserSubscriptionCreateWithoutPlanInput, UserSubscriptionUncheckedCreateWithoutPlanInput>
  }

  export type UserSubscriptionCreateManyPlanInputEnvelope = {
    data: UserSubscriptionCreateManyPlanInput | UserSubscriptionCreateManyPlanInput[]
    skipDuplicates?: boolean
  }

  export type UserSubscriptionUpsertWithWhereUniqueWithoutPlanInput = {
    where: UserSubscriptionWhereUniqueInput
    update: XOR<UserSubscriptionUpdateWithoutPlanInput, UserSubscriptionUncheckedUpdateWithoutPlanInput>
    create: XOR<UserSubscriptionCreateWithoutPlanInput, UserSubscriptionUncheckedCreateWithoutPlanInput>
  }

  export type UserSubscriptionUpdateWithWhereUniqueWithoutPlanInput = {
    where: UserSubscriptionWhereUniqueInput
    data: XOR<UserSubscriptionUpdateWithoutPlanInput, UserSubscriptionUncheckedUpdateWithoutPlanInput>
  }

  export type UserSubscriptionUpdateManyWithWhereWithoutPlanInput = {
    where: UserSubscriptionScalarWhereInput
    data: XOR<UserSubscriptionUpdateManyMutationInput, UserSubscriptionUncheckedUpdateManyWithoutPlanInput>
  }

  export type BundleCourseCreateWithoutBundleInput = {
    course: CourseCreateNestedOneWithoutBundleCoursesInput
  }

  export type BundleCourseUncheckedCreateWithoutBundleInput = {
    courseId: string
  }

  export type BundleCourseCreateOrConnectWithoutBundleInput = {
    where: BundleCourseWhereUniqueInput
    create: XOR<BundleCourseCreateWithoutBundleInput, BundleCourseUncheckedCreateWithoutBundleInput>
  }

  export type BundleCourseCreateManyBundleInputEnvelope = {
    data: BundleCourseCreateManyBundleInput | BundleCourseCreateManyBundleInput[]
    skipDuplicates?: boolean
  }

  export type UserBundleCreateWithoutBundleInput = {
    id?: string
    purchaseDate?: Date | string
    user: UserCreateNestedOneWithoutBundlesOwnedInput
  }

  export type UserBundleUncheckedCreateWithoutBundleInput = {
    id?: string
    userId: string
    purchaseDate?: Date | string
  }

  export type UserBundleCreateOrConnectWithoutBundleInput = {
    where: UserBundleWhereUniqueInput
    create: XOR<UserBundleCreateWithoutBundleInput, UserBundleUncheckedCreateWithoutBundleInput>
  }

  export type UserBundleCreateManyBundleInputEnvelope = {
    data: UserBundleCreateManyBundleInput | UserBundleCreateManyBundleInput[]
    skipDuplicates?: boolean
  }

  export type BundleCourseUpsertWithWhereUniqueWithoutBundleInput = {
    where: BundleCourseWhereUniqueInput
    update: XOR<BundleCourseUpdateWithoutBundleInput, BundleCourseUncheckedUpdateWithoutBundleInput>
    create: XOR<BundleCourseCreateWithoutBundleInput, BundleCourseUncheckedCreateWithoutBundleInput>
  }

  export type BundleCourseUpdateWithWhereUniqueWithoutBundleInput = {
    where: BundleCourseWhereUniqueInput
    data: XOR<BundleCourseUpdateWithoutBundleInput, BundleCourseUncheckedUpdateWithoutBundleInput>
  }

  export type BundleCourseUpdateManyWithWhereWithoutBundleInput = {
    where: BundleCourseScalarWhereInput
    data: XOR<BundleCourseUpdateManyMutationInput, BundleCourseUncheckedUpdateManyWithoutBundleInput>
  }

  export type UserBundleUpsertWithWhereUniqueWithoutBundleInput = {
    where: UserBundleWhereUniqueInput
    update: XOR<UserBundleUpdateWithoutBundleInput, UserBundleUncheckedUpdateWithoutBundleInput>
    create: XOR<UserBundleCreateWithoutBundleInput, UserBundleUncheckedCreateWithoutBundleInput>
  }

  export type UserBundleUpdateWithWhereUniqueWithoutBundleInput = {
    where: UserBundleWhereUniqueInput
    data: XOR<UserBundleUpdateWithoutBundleInput, UserBundleUncheckedUpdateWithoutBundleInput>
  }

  export type UserBundleUpdateManyWithWhereWithoutBundleInput = {
    where: UserBundleScalarWhereInput
    data: XOR<UserBundleUpdateManyMutationInput, UserBundleUncheckedUpdateManyWithoutBundleInput>
  }

  export type CourseBundleCreateWithoutCoursesInput = {
    id?: string
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    originalPrice: Decimal | DecimalJsLike | number | string
    discount: number
    featuredBenefit?: string | null
    benefits?: CourseBundleCreatebenefitsInput | string[]
    imageUrl?: string | null
    owners?: UserBundleCreateNestedManyWithoutBundleInput
  }

  export type CourseBundleUncheckedCreateWithoutCoursesInput = {
    id?: string
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    originalPrice: Decimal | DecimalJsLike | number | string
    discount: number
    featuredBenefit?: string | null
    benefits?: CourseBundleCreatebenefitsInput | string[]
    imageUrl?: string | null
    owners?: UserBundleUncheckedCreateNestedManyWithoutBundleInput
  }

  export type CourseBundleCreateOrConnectWithoutCoursesInput = {
    where: CourseBundleWhereUniqueInput
    create: XOR<CourseBundleCreateWithoutCoursesInput, CourseBundleUncheckedCreateWithoutCoursesInput>
  }

  export type CourseCreateWithoutBundleCoursesInput = {
    id?: string
    title: string
    description?: string | null
    subject: string
    image?: string | null
    price: Decimal | DecimalJsLike | number | string
    pointsPrice: number
    students?: number
    rating?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.CourseStatus
    featured?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teacher: UserCreateNestedOneWithoutCoursesInput
    topics?: TopicCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentCreateNestedManyWithoutCourseInput
    savedBy?: SavedCourseCreateNestedManyWithoutCourseInput
    likedBy?: LikedCourseCreateNestedManyWithoutCourseInput
    reviews?: CourseReviewCreateNestedManyWithoutCourseInput
    lessons?: LessonCreateNestedManyWithoutCourseInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutCourseInput
    certificates?: CertificateCreateNestedManyWithoutCourseInput
    calendarEvents?: CalendarEventCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutBundleCoursesInput = {
    id?: string
    title: string
    description?: string | null
    subject: string
    image?: string | null
    price: Decimal | DecimalJsLike | number | string
    pointsPrice: number
    teacherId: string
    students?: number
    rating?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.CourseStatus
    featured?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    topics?: TopicUncheckedCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutCourseInput
    savedBy?: SavedCourseUncheckedCreateNestedManyWithoutCourseInput
    likedBy?: LikedCourseUncheckedCreateNestedManyWithoutCourseInput
    reviews?: CourseReviewUncheckedCreateNestedManyWithoutCourseInput
    lessons?: LessonUncheckedCreateNestedManyWithoutCourseInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutCourseInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutCourseInput
    calendarEvents?: CalendarEventUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutBundleCoursesInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutBundleCoursesInput, CourseUncheckedCreateWithoutBundleCoursesInput>
  }

  export type CourseBundleUpsertWithoutCoursesInput = {
    update: XOR<CourseBundleUpdateWithoutCoursesInput, CourseBundleUncheckedUpdateWithoutCoursesInput>
    create: XOR<CourseBundleCreateWithoutCoursesInput, CourseBundleUncheckedCreateWithoutCoursesInput>
    where?: CourseBundleWhereInput
  }

  export type CourseBundleUpdateToOneWithWhereWithoutCoursesInput = {
    where?: CourseBundleWhereInput
    data: XOR<CourseBundleUpdateWithoutCoursesInput, CourseBundleUncheckedUpdateWithoutCoursesInput>
  }

  export type CourseBundleUpdateWithoutCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    originalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: IntFieldUpdateOperationsInput | number
    featuredBenefit?: NullableStringFieldUpdateOperationsInput | string | null
    benefits?: CourseBundleUpdatebenefitsInput | string[]
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    owners?: UserBundleUpdateManyWithoutBundleNestedInput
  }

  export type CourseBundleUncheckedUpdateWithoutCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    originalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: IntFieldUpdateOperationsInput | number
    featuredBenefit?: NullableStringFieldUpdateOperationsInput | string | null
    benefits?: CourseBundleUpdatebenefitsInput | string[]
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    owners?: UserBundleUncheckedUpdateManyWithoutBundleNestedInput
  }

  export type CourseUpsertWithoutBundleCoursesInput = {
    update: XOR<CourseUpdateWithoutBundleCoursesInput, CourseUncheckedUpdateWithoutBundleCoursesInput>
    create: XOR<CourseCreateWithoutBundleCoursesInput, CourseUncheckedCreateWithoutBundleCoursesInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutBundleCoursesInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutBundleCoursesInput, CourseUncheckedUpdateWithoutBundleCoursesInput>
  }

  export type CourseUpdateWithoutBundleCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pointsPrice?: IntFieldUpdateOperationsInput | number
    students?: IntFieldUpdateOperationsInput | number
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumCourseStatusFieldUpdateOperationsInput | $Enums.CourseStatus
    featured?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher?: UserUpdateOneRequiredWithoutCoursesNestedInput
    topics?: TopicUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUpdateManyWithoutCourseNestedInput
    savedBy?: SavedCourseUpdateManyWithoutCourseNestedInput
    likedBy?: LikedCourseUpdateManyWithoutCourseNestedInput
    reviews?: CourseReviewUpdateManyWithoutCourseNestedInput
    lessons?: LessonUpdateManyWithoutCourseNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutCourseNestedInput
    certificates?: CertificateUpdateManyWithoutCourseNestedInput
    calendarEvents?: CalendarEventUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutBundleCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pointsPrice?: IntFieldUpdateOperationsInput | number
    teacherId?: StringFieldUpdateOperationsInput | string
    students?: IntFieldUpdateOperationsInput | number
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumCourseStatusFieldUpdateOperationsInput | $Enums.CourseStatus
    featured?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    topics?: TopicUncheckedUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutCourseNestedInput
    savedBy?: SavedCourseUncheckedUpdateManyWithoutCourseNestedInput
    likedBy?: LikedCourseUncheckedUpdateManyWithoutCourseNestedInput
    reviews?: CourseReviewUncheckedUpdateManyWithoutCourseNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutCourseNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutCourseNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutCourseNestedInput
    calendarEvents?: CalendarEventUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type UserCreateWithoutSubscriptionRecordsInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    avatar?: string | null
    bio?: string | null
    createdAt?: Date | string
    points?: number
    referralCode?: string | null
    lastLogin?: Date | string | null
    referredBy?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferredByInput
    teacherProfile?: TeacherProfileCreateNestedOneWithoutUserInput
    availability?: UserAvailabilityCreateNestedManyWithoutUserInput
    pointsTransactions?: PointsTransactionCreateNestedManyWithoutUserInput
    courses?: CourseCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    savedCourses?: SavedCourseCreateNestedManyWithoutUserInput
    likedCourses?: LikedCourseCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutUserInput
    assignmentSubs?: AssignmentSubmissionCreateNestedManyWithoutUserInput
    courseReviews?: CourseReviewCreateNestedManyWithoutUserInput
    tutoringSessions?: TutoringSessionCreateNestedManyWithoutTeacherInput
    tutoringRequests?: TutoringRequestCreateNestedManyWithoutStudentInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentCreateNestedManyWithoutTeacherInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentCreateNestedManyWithoutStudentInput
    tutoringReviews?: TutoringReviewCreateNestedManyWithoutStudentInput
    tutoringMessages?: TutoringMessageCreateNestedManyWithoutSenderInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    conversationParts?: ConversationParticipantCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    attachments?: AttachmentCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    bundlesOwned?: UserBundleCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventCreateNestedManyWithoutUserInput
    eventsAsTeacher?: CalendarEventCreateNestedManyWithoutTeacherInput
    eventsAsStudent?: CalendarEventCreateNestedManyWithoutStudentInput
    blogPosts?: BlogPostCreateNestedManyWithoutAuthorInput
    blogComments?: BlogCommentCreateNestedManyWithoutUserInput
    submissionsGraded?: AssignmentSubmissionCreateNestedManyWithoutGradedByInput
    referralCodesOwned?: ReferralCodeCreateNestedManyWithoutUserInput
    referralUsesGained?: ReferralUseCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSubscriptionRecordsInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    avatar?: string | null
    bio?: string | null
    createdAt?: Date | string
    points?: number
    referralCode?: string | null
    referredById?: string | null
    lastLogin?: Date | string | null
    referrals?: UserUncheckedCreateNestedManyWithoutReferredByInput
    teacherProfile?: TeacherProfileUncheckedCreateNestedOneWithoutUserInput
    availability?: UserAvailabilityUncheckedCreateNestedManyWithoutUserInput
    pointsTransactions?: PointsTransactionUncheckedCreateNestedManyWithoutUserInput
    courses?: CourseUncheckedCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    savedCourses?: SavedCourseUncheckedCreateNestedManyWithoutUserInput
    likedCourses?: LikedCourseUncheckedCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressUncheckedCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutUserInput
    assignmentSubs?: AssignmentSubmissionUncheckedCreateNestedManyWithoutUserInput
    courseReviews?: CourseReviewUncheckedCreateNestedManyWithoutUserInput
    tutoringSessions?: TutoringSessionUncheckedCreateNestedManyWithoutTeacherInput
    tutoringRequests?: TutoringRequestUncheckedCreateNestedManyWithoutStudentInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUncheckedCreateNestedManyWithoutTeacherInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUncheckedCreateNestedManyWithoutStudentInput
    tutoringReviews?: TutoringReviewUncheckedCreateNestedManyWithoutStudentInput
    tutoringMessages?: TutoringMessageUncheckedCreateNestedManyWithoutSenderInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    conversationParts?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    bundlesOwned?: UserBundleUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventUncheckedCreateNestedManyWithoutUserInput
    eventsAsTeacher?: CalendarEventUncheckedCreateNestedManyWithoutTeacherInput
    eventsAsStudent?: CalendarEventUncheckedCreateNestedManyWithoutStudentInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
    blogComments?: BlogCommentUncheckedCreateNestedManyWithoutUserInput
    submissionsGraded?: AssignmentSubmissionUncheckedCreateNestedManyWithoutGradedByInput
    referralCodesOwned?: ReferralCodeUncheckedCreateNestedManyWithoutUserInput
    referralUsesGained?: ReferralUseUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSubscriptionRecordsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSubscriptionRecordsInput, UserUncheckedCreateWithoutSubscriptionRecordsInput>
  }

  export type SubscriptionPlanCreateWithoutUsersInput = {
    id?: string
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    period: $Enums.SubscriptionPeriod
    featuredBenefit?: string | null
    benefits?: SubscriptionPlanCreatebenefitsInput | string[]
    isPopular?: boolean
  }

  export type SubscriptionPlanUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    period: $Enums.SubscriptionPeriod
    featuredBenefit?: string | null
    benefits?: SubscriptionPlanCreatebenefitsInput | string[]
    isPopular?: boolean
  }

  export type SubscriptionPlanCreateOrConnectWithoutUsersInput = {
    where: SubscriptionPlanWhereUniqueInput
    create: XOR<SubscriptionPlanCreateWithoutUsersInput, SubscriptionPlanUncheckedCreateWithoutUsersInput>
  }

  export type UserUpsertWithoutSubscriptionRecordsInput = {
    update: XOR<UserUpdateWithoutSubscriptionRecordsInput, UserUncheckedUpdateWithoutSubscriptionRecordsInput>
    create: XOR<UserCreateWithoutSubscriptionRecordsInput, UserUncheckedCreateWithoutSubscriptionRecordsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSubscriptionRecordsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSubscriptionRecordsInput, UserUncheckedUpdateWithoutSubscriptionRecordsInput>
  }

  export type UserUpdateWithoutSubscriptionRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: IntFieldUpdateOperationsInput | number
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referredBy?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferredByNestedInput
    teacherProfile?: TeacherProfileUpdateOneWithoutUserNestedInput
    availability?: UserAvailabilityUpdateManyWithoutUserNestedInput
    pointsTransactions?: PointsTransactionUpdateManyWithoutUserNestedInput
    courses?: CourseUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    savedCourses?: SavedCourseUpdateManyWithoutUserNestedInput
    likedCourses?: LikedCourseUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutUserNestedInput
    assignmentSubs?: AssignmentSubmissionUpdateManyWithoutUserNestedInput
    courseReviews?: CourseReviewUpdateManyWithoutUserNestedInput
    tutoringSessions?: TutoringSessionUpdateManyWithoutTeacherNestedInput
    tutoringRequests?: TutoringRequestUpdateManyWithoutStudentNestedInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUpdateManyWithoutTeacherNestedInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUpdateManyWithoutStudentNestedInput
    tutoringReviews?: TutoringReviewUpdateManyWithoutStudentNestedInput
    tutoringMessages?: TutoringMessageUpdateManyWithoutSenderNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    conversationParts?: ConversationParticipantUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    attachments?: AttachmentUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    bundlesOwned?: UserBundleUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUpdateManyWithoutUserNestedInput
    eventsAsTeacher?: CalendarEventUpdateManyWithoutTeacherNestedInput
    eventsAsStudent?: CalendarEventUpdateManyWithoutStudentNestedInput
    blogPosts?: BlogPostUpdateManyWithoutAuthorNestedInput
    blogComments?: BlogCommentUpdateManyWithoutUserNestedInput
    submissionsGraded?: AssignmentSubmissionUpdateManyWithoutGradedByNestedInput
    referralCodesOwned?: ReferralCodeUpdateManyWithoutUserNestedInput
    referralUsesGained?: ReferralUseUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSubscriptionRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: IntFieldUpdateOperationsInput | number
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referrals?: UserUncheckedUpdateManyWithoutReferredByNestedInput
    teacherProfile?: TeacherProfileUncheckedUpdateOneWithoutUserNestedInput
    availability?: UserAvailabilityUncheckedUpdateManyWithoutUserNestedInput
    pointsTransactions?: PointsTransactionUncheckedUpdateManyWithoutUserNestedInput
    courses?: CourseUncheckedUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    savedCourses?: SavedCourseUncheckedUpdateManyWithoutUserNestedInput
    likedCourses?: LikedCourseUncheckedUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUncheckedUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    assignmentSubs?: AssignmentSubmissionUncheckedUpdateManyWithoutUserNestedInput
    courseReviews?: CourseReviewUncheckedUpdateManyWithoutUserNestedInput
    tutoringSessions?: TutoringSessionUncheckedUpdateManyWithoutTeacherNestedInput
    tutoringRequests?: TutoringRequestUncheckedUpdateManyWithoutStudentNestedInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUncheckedUpdateManyWithoutTeacherNestedInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUncheckedUpdateManyWithoutStudentNestedInput
    tutoringReviews?: TutoringReviewUncheckedUpdateManyWithoutStudentNestedInput
    tutoringMessages?: TutoringMessageUncheckedUpdateManyWithoutSenderNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    conversationParts?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    bundlesOwned?: UserBundleUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUncheckedUpdateManyWithoutUserNestedInput
    eventsAsTeacher?: CalendarEventUncheckedUpdateManyWithoutTeacherNestedInput
    eventsAsStudent?: CalendarEventUncheckedUpdateManyWithoutStudentNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
    blogComments?: BlogCommentUncheckedUpdateManyWithoutUserNestedInput
    submissionsGraded?: AssignmentSubmissionUncheckedUpdateManyWithoutGradedByNestedInput
    referralCodesOwned?: ReferralCodeUncheckedUpdateManyWithoutUserNestedInput
    referralUsesGained?: ReferralUseUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SubscriptionPlanUpsertWithoutUsersInput = {
    update: XOR<SubscriptionPlanUpdateWithoutUsersInput, SubscriptionPlanUncheckedUpdateWithoutUsersInput>
    create: XOR<SubscriptionPlanCreateWithoutUsersInput, SubscriptionPlanUncheckedCreateWithoutUsersInput>
    where?: SubscriptionPlanWhereInput
  }

  export type SubscriptionPlanUpdateToOneWithWhereWithoutUsersInput = {
    where?: SubscriptionPlanWhereInput
    data: XOR<SubscriptionPlanUpdateWithoutUsersInput, SubscriptionPlanUncheckedUpdateWithoutUsersInput>
  }

  export type SubscriptionPlanUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    period?: EnumSubscriptionPeriodFieldUpdateOperationsInput | $Enums.SubscriptionPeriod
    featuredBenefit?: NullableStringFieldUpdateOperationsInput | string | null
    benefits?: SubscriptionPlanUpdatebenefitsInput | string[]
    isPopular?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SubscriptionPlanUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    period?: EnumSubscriptionPeriodFieldUpdateOperationsInput | $Enums.SubscriptionPeriod
    featuredBenefit?: NullableStringFieldUpdateOperationsInput | string | null
    benefits?: SubscriptionPlanUpdatebenefitsInput | string[]
    isPopular?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserCreateWithoutBundlesOwnedInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    avatar?: string | null
    bio?: string | null
    createdAt?: Date | string
    points?: number
    referralCode?: string | null
    lastLogin?: Date | string | null
    referredBy?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferredByInput
    teacherProfile?: TeacherProfileCreateNestedOneWithoutUserInput
    availability?: UserAvailabilityCreateNestedManyWithoutUserInput
    pointsTransactions?: PointsTransactionCreateNestedManyWithoutUserInput
    courses?: CourseCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    savedCourses?: SavedCourseCreateNestedManyWithoutUserInput
    likedCourses?: LikedCourseCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutUserInput
    assignmentSubs?: AssignmentSubmissionCreateNestedManyWithoutUserInput
    courseReviews?: CourseReviewCreateNestedManyWithoutUserInput
    tutoringSessions?: TutoringSessionCreateNestedManyWithoutTeacherInput
    tutoringRequests?: TutoringRequestCreateNestedManyWithoutStudentInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentCreateNestedManyWithoutTeacherInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentCreateNestedManyWithoutStudentInput
    tutoringReviews?: TutoringReviewCreateNestedManyWithoutStudentInput
    tutoringMessages?: TutoringMessageCreateNestedManyWithoutSenderInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    conversationParts?: ConversationParticipantCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    attachments?: AttachmentCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    subscriptionRecords?: UserSubscriptionCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventCreateNestedManyWithoutUserInput
    eventsAsTeacher?: CalendarEventCreateNestedManyWithoutTeacherInput
    eventsAsStudent?: CalendarEventCreateNestedManyWithoutStudentInput
    blogPosts?: BlogPostCreateNestedManyWithoutAuthorInput
    blogComments?: BlogCommentCreateNestedManyWithoutUserInput
    submissionsGraded?: AssignmentSubmissionCreateNestedManyWithoutGradedByInput
    referralCodesOwned?: ReferralCodeCreateNestedManyWithoutUserInput
    referralUsesGained?: ReferralUseCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBundlesOwnedInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    avatar?: string | null
    bio?: string | null
    createdAt?: Date | string
    points?: number
    referralCode?: string | null
    referredById?: string | null
    lastLogin?: Date | string | null
    referrals?: UserUncheckedCreateNestedManyWithoutReferredByInput
    teacherProfile?: TeacherProfileUncheckedCreateNestedOneWithoutUserInput
    availability?: UserAvailabilityUncheckedCreateNestedManyWithoutUserInput
    pointsTransactions?: PointsTransactionUncheckedCreateNestedManyWithoutUserInput
    courses?: CourseUncheckedCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    savedCourses?: SavedCourseUncheckedCreateNestedManyWithoutUserInput
    likedCourses?: LikedCourseUncheckedCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressUncheckedCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutUserInput
    assignmentSubs?: AssignmentSubmissionUncheckedCreateNestedManyWithoutUserInput
    courseReviews?: CourseReviewUncheckedCreateNestedManyWithoutUserInput
    tutoringSessions?: TutoringSessionUncheckedCreateNestedManyWithoutTeacherInput
    tutoringRequests?: TutoringRequestUncheckedCreateNestedManyWithoutStudentInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUncheckedCreateNestedManyWithoutTeacherInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUncheckedCreateNestedManyWithoutStudentInput
    tutoringReviews?: TutoringReviewUncheckedCreateNestedManyWithoutStudentInput
    tutoringMessages?: TutoringMessageUncheckedCreateNestedManyWithoutSenderInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    conversationParts?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    subscriptionRecords?: UserSubscriptionUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventUncheckedCreateNestedManyWithoutUserInput
    eventsAsTeacher?: CalendarEventUncheckedCreateNestedManyWithoutTeacherInput
    eventsAsStudent?: CalendarEventUncheckedCreateNestedManyWithoutStudentInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
    blogComments?: BlogCommentUncheckedCreateNestedManyWithoutUserInput
    submissionsGraded?: AssignmentSubmissionUncheckedCreateNestedManyWithoutGradedByInput
    referralCodesOwned?: ReferralCodeUncheckedCreateNestedManyWithoutUserInput
    referralUsesGained?: ReferralUseUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBundlesOwnedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBundlesOwnedInput, UserUncheckedCreateWithoutBundlesOwnedInput>
  }

  export type CourseBundleCreateWithoutOwnersInput = {
    id?: string
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    originalPrice: Decimal | DecimalJsLike | number | string
    discount: number
    featuredBenefit?: string | null
    benefits?: CourseBundleCreatebenefitsInput | string[]
    imageUrl?: string | null
    courses?: BundleCourseCreateNestedManyWithoutBundleInput
  }

  export type CourseBundleUncheckedCreateWithoutOwnersInput = {
    id?: string
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    originalPrice: Decimal | DecimalJsLike | number | string
    discount: number
    featuredBenefit?: string | null
    benefits?: CourseBundleCreatebenefitsInput | string[]
    imageUrl?: string | null
    courses?: BundleCourseUncheckedCreateNestedManyWithoutBundleInput
  }

  export type CourseBundleCreateOrConnectWithoutOwnersInput = {
    where: CourseBundleWhereUniqueInput
    create: XOR<CourseBundleCreateWithoutOwnersInput, CourseBundleUncheckedCreateWithoutOwnersInput>
  }

  export type UserUpsertWithoutBundlesOwnedInput = {
    update: XOR<UserUpdateWithoutBundlesOwnedInput, UserUncheckedUpdateWithoutBundlesOwnedInput>
    create: XOR<UserCreateWithoutBundlesOwnedInput, UserUncheckedCreateWithoutBundlesOwnedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBundlesOwnedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBundlesOwnedInput, UserUncheckedUpdateWithoutBundlesOwnedInput>
  }

  export type UserUpdateWithoutBundlesOwnedInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: IntFieldUpdateOperationsInput | number
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referredBy?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferredByNestedInput
    teacherProfile?: TeacherProfileUpdateOneWithoutUserNestedInput
    availability?: UserAvailabilityUpdateManyWithoutUserNestedInput
    pointsTransactions?: PointsTransactionUpdateManyWithoutUserNestedInput
    courses?: CourseUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    savedCourses?: SavedCourseUpdateManyWithoutUserNestedInput
    likedCourses?: LikedCourseUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutUserNestedInput
    assignmentSubs?: AssignmentSubmissionUpdateManyWithoutUserNestedInput
    courseReviews?: CourseReviewUpdateManyWithoutUserNestedInput
    tutoringSessions?: TutoringSessionUpdateManyWithoutTeacherNestedInput
    tutoringRequests?: TutoringRequestUpdateManyWithoutStudentNestedInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUpdateManyWithoutTeacherNestedInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUpdateManyWithoutStudentNestedInput
    tutoringReviews?: TutoringReviewUpdateManyWithoutStudentNestedInput
    tutoringMessages?: TutoringMessageUpdateManyWithoutSenderNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    conversationParts?: ConversationParticipantUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    attachments?: AttachmentUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    subscriptionRecords?: UserSubscriptionUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUpdateManyWithoutUserNestedInput
    eventsAsTeacher?: CalendarEventUpdateManyWithoutTeacherNestedInput
    eventsAsStudent?: CalendarEventUpdateManyWithoutStudentNestedInput
    blogPosts?: BlogPostUpdateManyWithoutAuthorNestedInput
    blogComments?: BlogCommentUpdateManyWithoutUserNestedInput
    submissionsGraded?: AssignmentSubmissionUpdateManyWithoutGradedByNestedInput
    referralCodesOwned?: ReferralCodeUpdateManyWithoutUserNestedInput
    referralUsesGained?: ReferralUseUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBundlesOwnedInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: IntFieldUpdateOperationsInput | number
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referrals?: UserUncheckedUpdateManyWithoutReferredByNestedInput
    teacherProfile?: TeacherProfileUncheckedUpdateOneWithoutUserNestedInput
    availability?: UserAvailabilityUncheckedUpdateManyWithoutUserNestedInput
    pointsTransactions?: PointsTransactionUncheckedUpdateManyWithoutUserNestedInput
    courses?: CourseUncheckedUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    savedCourses?: SavedCourseUncheckedUpdateManyWithoutUserNestedInput
    likedCourses?: LikedCourseUncheckedUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUncheckedUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    assignmentSubs?: AssignmentSubmissionUncheckedUpdateManyWithoutUserNestedInput
    courseReviews?: CourseReviewUncheckedUpdateManyWithoutUserNestedInput
    tutoringSessions?: TutoringSessionUncheckedUpdateManyWithoutTeacherNestedInput
    tutoringRequests?: TutoringRequestUncheckedUpdateManyWithoutStudentNestedInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUncheckedUpdateManyWithoutTeacherNestedInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUncheckedUpdateManyWithoutStudentNestedInput
    tutoringReviews?: TutoringReviewUncheckedUpdateManyWithoutStudentNestedInput
    tutoringMessages?: TutoringMessageUncheckedUpdateManyWithoutSenderNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    conversationParts?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    subscriptionRecords?: UserSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUncheckedUpdateManyWithoutUserNestedInput
    eventsAsTeacher?: CalendarEventUncheckedUpdateManyWithoutTeacherNestedInput
    eventsAsStudent?: CalendarEventUncheckedUpdateManyWithoutStudentNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
    blogComments?: BlogCommentUncheckedUpdateManyWithoutUserNestedInput
    submissionsGraded?: AssignmentSubmissionUncheckedUpdateManyWithoutGradedByNestedInput
    referralCodesOwned?: ReferralCodeUncheckedUpdateManyWithoutUserNestedInput
    referralUsesGained?: ReferralUseUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CourseBundleUpsertWithoutOwnersInput = {
    update: XOR<CourseBundleUpdateWithoutOwnersInput, CourseBundleUncheckedUpdateWithoutOwnersInput>
    create: XOR<CourseBundleCreateWithoutOwnersInput, CourseBundleUncheckedCreateWithoutOwnersInput>
    where?: CourseBundleWhereInput
  }

  export type CourseBundleUpdateToOneWithWhereWithoutOwnersInput = {
    where?: CourseBundleWhereInput
    data: XOR<CourseBundleUpdateWithoutOwnersInput, CourseBundleUncheckedUpdateWithoutOwnersInput>
  }

  export type CourseBundleUpdateWithoutOwnersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    originalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: IntFieldUpdateOperationsInput | number
    featuredBenefit?: NullableStringFieldUpdateOperationsInput | string | null
    benefits?: CourseBundleUpdatebenefitsInput | string[]
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    courses?: BundleCourseUpdateManyWithoutBundleNestedInput
  }

  export type CourseBundleUncheckedUpdateWithoutOwnersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    originalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: IntFieldUpdateOperationsInput | number
    featuredBenefit?: NullableStringFieldUpdateOperationsInput | string | null
    benefits?: CourseBundleUpdatebenefitsInput | string[]
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    courses?: BundleCourseUncheckedUpdateManyWithoutBundleNestedInput
  }

  export type UserCreateWithoutPaymentsInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    avatar?: string | null
    bio?: string | null
    createdAt?: Date | string
    points?: number
    referralCode?: string | null
    lastLogin?: Date | string | null
    referredBy?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferredByInput
    teacherProfile?: TeacherProfileCreateNestedOneWithoutUserInput
    availability?: UserAvailabilityCreateNestedManyWithoutUserInput
    pointsTransactions?: PointsTransactionCreateNestedManyWithoutUserInput
    courses?: CourseCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    savedCourses?: SavedCourseCreateNestedManyWithoutUserInput
    likedCourses?: LikedCourseCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutUserInput
    assignmentSubs?: AssignmentSubmissionCreateNestedManyWithoutUserInput
    courseReviews?: CourseReviewCreateNestedManyWithoutUserInput
    tutoringSessions?: TutoringSessionCreateNestedManyWithoutTeacherInput
    tutoringRequests?: TutoringRequestCreateNestedManyWithoutStudentInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentCreateNestedManyWithoutTeacherInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentCreateNestedManyWithoutStudentInput
    tutoringReviews?: TutoringReviewCreateNestedManyWithoutStudentInput
    tutoringMessages?: TutoringMessageCreateNestedManyWithoutSenderInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    conversationParts?: ConversationParticipantCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    attachments?: AttachmentCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    subscriptionRecords?: UserSubscriptionCreateNestedManyWithoutUserInput
    bundlesOwned?: UserBundleCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventCreateNestedManyWithoutUserInput
    eventsAsTeacher?: CalendarEventCreateNestedManyWithoutTeacherInput
    eventsAsStudent?: CalendarEventCreateNestedManyWithoutStudentInput
    blogPosts?: BlogPostCreateNestedManyWithoutAuthorInput
    blogComments?: BlogCommentCreateNestedManyWithoutUserInput
    submissionsGraded?: AssignmentSubmissionCreateNestedManyWithoutGradedByInput
    referralCodesOwned?: ReferralCodeCreateNestedManyWithoutUserInput
    referralUsesGained?: ReferralUseCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPaymentsInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    avatar?: string | null
    bio?: string | null
    createdAt?: Date | string
    points?: number
    referralCode?: string | null
    referredById?: string | null
    lastLogin?: Date | string | null
    referrals?: UserUncheckedCreateNestedManyWithoutReferredByInput
    teacherProfile?: TeacherProfileUncheckedCreateNestedOneWithoutUserInput
    availability?: UserAvailabilityUncheckedCreateNestedManyWithoutUserInput
    pointsTransactions?: PointsTransactionUncheckedCreateNestedManyWithoutUserInput
    courses?: CourseUncheckedCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    savedCourses?: SavedCourseUncheckedCreateNestedManyWithoutUserInput
    likedCourses?: LikedCourseUncheckedCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressUncheckedCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutUserInput
    assignmentSubs?: AssignmentSubmissionUncheckedCreateNestedManyWithoutUserInput
    courseReviews?: CourseReviewUncheckedCreateNestedManyWithoutUserInput
    tutoringSessions?: TutoringSessionUncheckedCreateNestedManyWithoutTeacherInput
    tutoringRequests?: TutoringRequestUncheckedCreateNestedManyWithoutStudentInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUncheckedCreateNestedManyWithoutTeacherInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUncheckedCreateNestedManyWithoutStudentInput
    tutoringReviews?: TutoringReviewUncheckedCreateNestedManyWithoutStudentInput
    tutoringMessages?: TutoringMessageUncheckedCreateNestedManyWithoutSenderInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    conversationParts?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    subscriptionRecords?: UserSubscriptionUncheckedCreateNestedManyWithoutUserInput
    bundlesOwned?: UserBundleUncheckedCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventUncheckedCreateNestedManyWithoutUserInput
    eventsAsTeacher?: CalendarEventUncheckedCreateNestedManyWithoutTeacherInput
    eventsAsStudent?: CalendarEventUncheckedCreateNestedManyWithoutStudentInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
    blogComments?: BlogCommentUncheckedCreateNestedManyWithoutUserInput
    submissionsGraded?: AssignmentSubmissionUncheckedCreateNestedManyWithoutGradedByInput
    referralCodesOwned?: ReferralCodeUncheckedCreateNestedManyWithoutUserInput
    referralUsesGained?: ReferralUseUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPaymentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
  }

  export type UserUpsertWithoutPaymentsInput = {
    update: XOR<UserUpdateWithoutPaymentsInput, UserUncheckedUpdateWithoutPaymentsInput>
    create: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPaymentsInput, UserUncheckedUpdateWithoutPaymentsInput>
  }

  export type UserUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: IntFieldUpdateOperationsInput | number
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referredBy?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferredByNestedInput
    teacherProfile?: TeacherProfileUpdateOneWithoutUserNestedInput
    availability?: UserAvailabilityUpdateManyWithoutUserNestedInput
    pointsTransactions?: PointsTransactionUpdateManyWithoutUserNestedInput
    courses?: CourseUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    savedCourses?: SavedCourseUpdateManyWithoutUserNestedInput
    likedCourses?: LikedCourseUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutUserNestedInput
    assignmentSubs?: AssignmentSubmissionUpdateManyWithoutUserNestedInput
    courseReviews?: CourseReviewUpdateManyWithoutUserNestedInput
    tutoringSessions?: TutoringSessionUpdateManyWithoutTeacherNestedInput
    tutoringRequests?: TutoringRequestUpdateManyWithoutStudentNestedInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUpdateManyWithoutTeacherNestedInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUpdateManyWithoutStudentNestedInput
    tutoringReviews?: TutoringReviewUpdateManyWithoutStudentNestedInput
    tutoringMessages?: TutoringMessageUpdateManyWithoutSenderNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    conversationParts?: ConversationParticipantUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    attachments?: AttachmentUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    subscriptionRecords?: UserSubscriptionUpdateManyWithoutUserNestedInput
    bundlesOwned?: UserBundleUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUpdateManyWithoutUserNestedInput
    eventsAsTeacher?: CalendarEventUpdateManyWithoutTeacherNestedInput
    eventsAsStudent?: CalendarEventUpdateManyWithoutStudentNestedInput
    blogPosts?: BlogPostUpdateManyWithoutAuthorNestedInput
    blogComments?: BlogCommentUpdateManyWithoutUserNestedInput
    submissionsGraded?: AssignmentSubmissionUpdateManyWithoutGradedByNestedInput
    referralCodesOwned?: ReferralCodeUpdateManyWithoutUserNestedInput
    referralUsesGained?: ReferralUseUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: IntFieldUpdateOperationsInput | number
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referrals?: UserUncheckedUpdateManyWithoutReferredByNestedInput
    teacherProfile?: TeacherProfileUncheckedUpdateOneWithoutUserNestedInput
    availability?: UserAvailabilityUncheckedUpdateManyWithoutUserNestedInput
    pointsTransactions?: PointsTransactionUncheckedUpdateManyWithoutUserNestedInput
    courses?: CourseUncheckedUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    savedCourses?: SavedCourseUncheckedUpdateManyWithoutUserNestedInput
    likedCourses?: LikedCourseUncheckedUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUncheckedUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    assignmentSubs?: AssignmentSubmissionUncheckedUpdateManyWithoutUserNestedInput
    courseReviews?: CourseReviewUncheckedUpdateManyWithoutUserNestedInput
    tutoringSessions?: TutoringSessionUncheckedUpdateManyWithoutTeacherNestedInput
    tutoringRequests?: TutoringRequestUncheckedUpdateManyWithoutStudentNestedInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUncheckedUpdateManyWithoutTeacherNestedInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUncheckedUpdateManyWithoutStudentNestedInput
    tutoringReviews?: TutoringReviewUncheckedUpdateManyWithoutStudentNestedInput
    tutoringMessages?: TutoringMessageUncheckedUpdateManyWithoutSenderNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    conversationParts?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    subscriptionRecords?: UserSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    bundlesOwned?: UserBundleUncheckedUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUncheckedUpdateManyWithoutUserNestedInput
    eventsAsTeacher?: CalendarEventUncheckedUpdateManyWithoutTeacherNestedInput
    eventsAsStudent?: CalendarEventUncheckedUpdateManyWithoutStudentNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
    blogComments?: BlogCommentUncheckedUpdateManyWithoutUserNestedInput
    submissionsGraded?: AssignmentSubmissionUncheckedUpdateManyWithoutGradedByNestedInput
    referralCodesOwned?: ReferralCodeUncheckedUpdateManyWithoutUserNestedInput
    referralUsesGained?: ReferralUseUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutCalendarEventsInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    avatar?: string | null
    bio?: string | null
    createdAt?: Date | string
    points?: number
    referralCode?: string | null
    lastLogin?: Date | string | null
    referredBy?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferredByInput
    teacherProfile?: TeacherProfileCreateNestedOneWithoutUserInput
    availability?: UserAvailabilityCreateNestedManyWithoutUserInput
    pointsTransactions?: PointsTransactionCreateNestedManyWithoutUserInput
    courses?: CourseCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    savedCourses?: SavedCourseCreateNestedManyWithoutUserInput
    likedCourses?: LikedCourseCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutUserInput
    assignmentSubs?: AssignmentSubmissionCreateNestedManyWithoutUserInput
    courseReviews?: CourseReviewCreateNestedManyWithoutUserInput
    tutoringSessions?: TutoringSessionCreateNestedManyWithoutTeacherInput
    tutoringRequests?: TutoringRequestCreateNestedManyWithoutStudentInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentCreateNestedManyWithoutTeacherInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentCreateNestedManyWithoutStudentInput
    tutoringReviews?: TutoringReviewCreateNestedManyWithoutStudentInput
    tutoringMessages?: TutoringMessageCreateNestedManyWithoutSenderInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    conversationParts?: ConversationParticipantCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    attachments?: AttachmentCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    subscriptionRecords?: UserSubscriptionCreateNestedManyWithoutUserInput
    bundlesOwned?: UserBundleCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    eventsAsTeacher?: CalendarEventCreateNestedManyWithoutTeacherInput
    eventsAsStudent?: CalendarEventCreateNestedManyWithoutStudentInput
    blogPosts?: BlogPostCreateNestedManyWithoutAuthorInput
    blogComments?: BlogCommentCreateNestedManyWithoutUserInput
    submissionsGraded?: AssignmentSubmissionCreateNestedManyWithoutGradedByInput
    referralCodesOwned?: ReferralCodeCreateNestedManyWithoutUserInput
    referralUsesGained?: ReferralUseCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCalendarEventsInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    avatar?: string | null
    bio?: string | null
    createdAt?: Date | string
    points?: number
    referralCode?: string | null
    referredById?: string | null
    lastLogin?: Date | string | null
    referrals?: UserUncheckedCreateNestedManyWithoutReferredByInput
    teacherProfile?: TeacherProfileUncheckedCreateNestedOneWithoutUserInput
    availability?: UserAvailabilityUncheckedCreateNestedManyWithoutUserInput
    pointsTransactions?: PointsTransactionUncheckedCreateNestedManyWithoutUserInput
    courses?: CourseUncheckedCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    savedCourses?: SavedCourseUncheckedCreateNestedManyWithoutUserInput
    likedCourses?: LikedCourseUncheckedCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressUncheckedCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutUserInput
    assignmentSubs?: AssignmentSubmissionUncheckedCreateNestedManyWithoutUserInput
    courseReviews?: CourseReviewUncheckedCreateNestedManyWithoutUserInput
    tutoringSessions?: TutoringSessionUncheckedCreateNestedManyWithoutTeacherInput
    tutoringRequests?: TutoringRequestUncheckedCreateNestedManyWithoutStudentInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUncheckedCreateNestedManyWithoutTeacherInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUncheckedCreateNestedManyWithoutStudentInput
    tutoringReviews?: TutoringReviewUncheckedCreateNestedManyWithoutStudentInput
    tutoringMessages?: TutoringMessageUncheckedCreateNestedManyWithoutSenderInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    conversationParts?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    subscriptionRecords?: UserSubscriptionUncheckedCreateNestedManyWithoutUserInput
    bundlesOwned?: UserBundleUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    eventsAsTeacher?: CalendarEventUncheckedCreateNestedManyWithoutTeacherInput
    eventsAsStudent?: CalendarEventUncheckedCreateNestedManyWithoutStudentInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
    blogComments?: BlogCommentUncheckedCreateNestedManyWithoutUserInput
    submissionsGraded?: AssignmentSubmissionUncheckedCreateNestedManyWithoutGradedByInput
    referralCodesOwned?: ReferralCodeUncheckedCreateNestedManyWithoutUserInput
    referralUsesGained?: ReferralUseUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCalendarEventsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCalendarEventsInput, UserUncheckedCreateWithoutCalendarEventsInput>
  }

  export type CourseCreateWithoutCalendarEventsInput = {
    id?: string
    title: string
    description?: string | null
    subject: string
    image?: string | null
    price: Decimal | DecimalJsLike | number | string
    pointsPrice: number
    students?: number
    rating?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.CourseStatus
    featured?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teacher: UserCreateNestedOneWithoutCoursesInput
    topics?: TopicCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentCreateNestedManyWithoutCourseInput
    savedBy?: SavedCourseCreateNestedManyWithoutCourseInput
    likedBy?: LikedCourseCreateNestedManyWithoutCourseInput
    reviews?: CourseReviewCreateNestedManyWithoutCourseInput
    lessons?: LessonCreateNestedManyWithoutCourseInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutCourseInput
    certificates?: CertificateCreateNestedManyWithoutCourseInput
    bundleCourses?: BundleCourseCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutCalendarEventsInput = {
    id?: string
    title: string
    description?: string | null
    subject: string
    image?: string | null
    price: Decimal | DecimalJsLike | number | string
    pointsPrice: number
    teacherId: string
    students?: number
    rating?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.CourseStatus
    featured?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    topics?: TopicUncheckedCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutCourseInput
    savedBy?: SavedCourseUncheckedCreateNestedManyWithoutCourseInput
    likedBy?: LikedCourseUncheckedCreateNestedManyWithoutCourseInput
    reviews?: CourseReviewUncheckedCreateNestedManyWithoutCourseInput
    lessons?: LessonUncheckedCreateNestedManyWithoutCourseInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutCourseInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutCourseInput
    bundleCourses?: BundleCourseUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutCalendarEventsInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutCalendarEventsInput, CourseUncheckedCreateWithoutCalendarEventsInput>
  }

  export type LessonCreateWithoutCalendarEventsInput = {
    id?: string
    title: string
    description?: string | null
    videoUrl?: string | null
    content?: string | null
    duration?: number | null
    orderIndex: number
    type: $Enums.LessonType
    topic: TopicCreateNestedOneWithoutLessonsInput
    quiz?: QuizCreateNestedOneWithoutLessonInput
    assignment?: AssignmentCreateNestedOneWithoutLessonInput
    progress?: LessonProgressCreateNestedManyWithoutLessonInput
    course?: CourseCreateNestedOneWithoutLessonsInput
  }

  export type LessonUncheckedCreateWithoutCalendarEventsInput = {
    id?: string
    topicId: string
    title: string
    description?: string | null
    videoUrl?: string | null
    content?: string | null
    duration?: number | null
    orderIndex: number
    type: $Enums.LessonType
    courseId?: string | null
    quiz?: QuizUncheckedCreateNestedOneWithoutLessonInput
    assignment?: AssignmentUncheckedCreateNestedOneWithoutLessonInput
    progress?: LessonProgressUncheckedCreateNestedManyWithoutLessonInput
  }

  export type LessonCreateOrConnectWithoutCalendarEventsInput = {
    where: LessonWhereUniqueInput
    create: XOR<LessonCreateWithoutCalendarEventsInput, LessonUncheckedCreateWithoutCalendarEventsInput>
  }

  export type UserCreateWithoutEventsAsTeacherInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    avatar?: string | null
    bio?: string | null
    createdAt?: Date | string
    points?: number
    referralCode?: string | null
    lastLogin?: Date | string | null
    referredBy?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferredByInput
    teacherProfile?: TeacherProfileCreateNestedOneWithoutUserInput
    availability?: UserAvailabilityCreateNestedManyWithoutUserInput
    pointsTransactions?: PointsTransactionCreateNestedManyWithoutUserInput
    courses?: CourseCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    savedCourses?: SavedCourseCreateNestedManyWithoutUserInput
    likedCourses?: LikedCourseCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutUserInput
    assignmentSubs?: AssignmentSubmissionCreateNestedManyWithoutUserInput
    courseReviews?: CourseReviewCreateNestedManyWithoutUserInput
    tutoringSessions?: TutoringSessionCreateNestedManyWithoutTeacherInput
    tutoringRequests?: TutoringRequestCreateNestedManyWithoutStudentInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentCreateNestedManyWithoutTeacherInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentCreateNestedManyWithoutStudentInput
    tutoringReviews?: TutoringReviewCreateNestedManyWithoutStudentInput
    tutoringMessages?: TutoringMessageCreateNestedManyWithoutSenderInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    conversationParts?: ConversationParticipantCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    attachments?: AttachmentCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    subscriptionRecords?: UserSubscriptionCreateNestedManyWithoutUserInput
    bundlesOwned?: UserBundleCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventCreateNestedManyWithoutUserInput
    eventsAsStudent?: CalendarEventCreateNestedManyWithoutStudentInput
    blogPosts?: BlogPostCreateNestedManyWithoutAuthorInput
    blogComments?: BlogCommentCreateNestedManyWithoutUserInput
    submissionsGraded?: AssignmentSubmissionCreateNestedManyWithoutGradedByInput
    referralCodesOwned?: ReferralCodeCreateNestedManyWithoutUserInput
    referralUsesGained?: ReferralUseCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEventsAsTeacherInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    avatar?: string | null
    bio?: string | null
    createdAt?: Date | string
    points?: number
    referralCode?: string | null
    referredById?: string | null
    lastLogin?: Date | string | null
    referrals?: UserUncheckedCreateNestedManyWithoutReferredByInput
    teacherProfile?: TeacherProfileUncheckedCreateNestedOneWithoutUserInput
    availability?: UserAvailabilityUncheckedCreateNestedManyWithoutUserInput
    pointsTransactions?: PointsTransactionUncheckedCreateNestedManyWithoutUserInput
    courses?: CourseUncheckedCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    savedCourses?: SavedCourseUncheckedCreateNestedManyWithoutUserInput
    likedCourses?: LikedCourseUncheckedCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressUncheckedCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutUserInput
    assignmentSubs?: AssignmentSubmissionUncheckedCreateNestedManyWithoutUserInput
    courseReviews?: CourseReviewUncheckedCreateNestedManyWithoutUserInput
    tutoringSessions?: TutoringSessionUncheckedCreateNestedManyWithoutTeacherInput
    tutoringRequests?: TutoringRequestUncheckedCreateNestedManyWithoutStudentInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUncheckedCreateNestedManyWithoutTeacherInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUncheckedCreateNestedManyWithoutStudentInput
    tutoringReviews?: TutoringReviewUncheckedCreateNestedManyWithoutStudentInput
    tutoringMessages?: TutoringMessageUncheckedCreateNestedManyWithoutSenderInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    conversationParts?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    subscriptionRecords?: UserSubscriptionUncheckedCreateNestedManyWithoutUserInput
    bundlesOwned?: UserBundleUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventUncheckedCreateNestedManyWithoutUserInput
    eventsAsStudent?: CalendarEventUncheckedCreateNestedManyWithoutStudentInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
    blogComments?: BlogCommentUncheckedCreateNestedManyWithoutUserInput
    submissionsGraded?: AssignmentSubmissionUncheckedCreateNestedManyWithoutGradedByInput
    referralCodesOwned?: ReferralCodeUncheckedCreateNestedManyWithoutUserInput
    referralUsesGained?: ReferralUseUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEventsAsTeacherInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEventsAsTeacherInput, UserUncheckedCreateWithoutEventsAsTeacherInput>
  }

  export type UserCreateWithoutEventsAsStudentInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    avatar?: string | null
    bio?: string | null
    createdAt?: Date | string
    points?: number
    referralCode?: string | null
    lastLogin?: Date | string | null
    referredBy?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferredByInput
    teacherProfile?: TeacherProfileCreateNestedOneWithoutUserInput
    availability?: UserAvailabilityCreateNestedManyWithoutUserInput
    pointsTransactions?: PointsTransactionCreateNestedManyWithoutUserInput
    courses?: CourseCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    savedCourses?: SavedCourseCreateNestedManyWithoutUserInput
    likedCourses?: LikedCourseCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutUserInput
    assignmentSubs?: AssignmentSubmissionCreateNestedManyWithoutUserInput
    courseReviews?: CourseReviewCreateNestedManyWithoutUserInput
    tutoringSessions?: TutoringSessionCreateNestedManyWithoutTeacherInput
    tutoringRequests?: TutoringRequestCreateNestedManyWithoutStudentInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentCreateNestedManyWithoutTeacherInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentCreateNestedManyWithoutStudentInput
    tutoringReviews?: TutoringReviewCreateNestedManyWithoutStudentInput
    tutoringMessages?: TutoringMessageCreateNestedManyWithoutSenderInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    conversationParts?: ConversationParticipantCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    attachments?: AttachmentCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    subscriptionRecords?: UserSubscriptionCreateNestedManyWithoutUserInput
    bundlesOwned?: UserBundleCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventCreateNestedManyWithoutUserInput
    eventsAsTeacher?: CalendarEventCreateNestedManyWithoutTeacherInput
    blogPosts?: BlogPostCreateNestedManyWithoutAuthorInput
    blogComments?: BlogCommentCreateNestedManyWithoutUserInput
    submissionsGraded?: AssignmentSubmissionCreateNestedManyWithoutGradedByInput
    referralCodesOwned?: ReferralCodeCreateNestedManyWithoutUserInput
    referralUsesGained?: ReferralUseCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEventsAsStudentInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    avatar?: string | null
    bio?: string | null
    createdAt?: Date | string
    points?: number
    referralCode?: string | null
    referredById?: string | null
    lastLogin?: Date | string | null
    referrals?: UserUncheckedCreateNestedManyWithoutReferredByInput
    teacherProfile?: TeacherProfileUncheckedCreateNestedOneWithoutUserInput
    availability?: UserAvailabilityUncheckedCreateNestedManyWithoutUserInput
    pointsTransactions?: PointsTransactionUncheckedCreateNestedManyWithoutUserInput
    courses?: CourseUncheckedCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    savedCourses?: SavedCourseUncheckedCreateNestedManyWithoutUserInput
    likedCourses?: LikedCourseUncheckedCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressUncheckedCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutUserInput
    assignmentSubs?: AssignmentSubmissionUncheckedCreateNestedManyWithoutUserInput
    courseReviews?: CourseReviewUncheckedCreateNestedManyWithoutUserInput
    tutoringSessions?: TutoringSessionUncheckedCreateNestedManyWithoutTeacherInput
    tutoringRequests?: TutoringRequestUncheckedCreateNestedManyWithoutStudentInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUncheckedCreateNestedManyWithoutTeacherInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUncheckedCreateNestedManyWithoutStudentInput
    tutoringReviews?: TutoringReviewUncheckedCreateNestedManyWithoutStudentInput
    tutoringMessages?: TutoringMessageUncheckedCreateNestedManyWithoutSenderInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    conversationParts?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    subscriptionRecords?: UserSubscriptionUncheckedCreateNestedManyWithoutUserInput
    bundlesOwned?: UserBundleUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventUncheckedCreateNestedManyWithoutUserInput
    eventsAsTeacher?: CalendarEventUncheckedCreateNestedManyWithoutTeacherInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
    blogComments?: BlogCommentUncheckedCreateNestedManyWithoutUserInput
    submissionsGraded?: AssignmentSubmissionUncheckedCreateNestedManyWithoutGradedByInput
    referralCodesOwned?: ReferralCodeUncheckedCreateNestedManyWithoutUserInput
    referralUsesGained?: ReferralUseUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEventsAsStudentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEventsAsStudentInput, UserUncheckedCreateWithoutEventsAsStudentInput>
  }

  export type UserUpsertWithoutCalendarEventsInput = {
    update: XOR<UserUpdateWithoutCalendarEventsInput, UserUncheckedUpdateWithoutCalendarEventsInput>
    create: XOR<UserCreateWithoutCalendarEventsInput, UserUncheckedCreateWithoutCalendarEventsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCalendarEventsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCalendarEventsInput, UserUncheckedUpdateWithoutCalendarEventsInput>
  }

  export type UserUpdateWithoutCalendarEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: IntFieldUpdateOperationsInput | number
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referredBy?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferredByNestedInput
    teacherProfile?: TeacherProfileUpdateOneWithoutUserNestedInput
    availability?: UserAvailabilityUpdateManyWithoutUserNestedInput
    pointsTransactions?: PointsTransactionUpdateManyWithoutUserNestedInput
    courses?: CourseUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    savedCourses?: SavedCourseUpdateManyWithoutUserNestedInput
    likedCourses?: LikedCourseUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutUserNestedInput
    assignmentSubs?: AssignmentSubmissionUpdateManyWithoutUserNestedInput
    courseReviews?: CourseReviewUpdateManyWithoutUserNestedInput
    tutoringSessions?: TutoringSessionUpdateManyWithoutTeacherNestedInput
    tutoringRequests?: TutoringRequestUpdateManyWithoutStudentNestedInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUpdateManyWithoutTeacherNestedInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUpdateManyWithoutStudentNestedInput
    tutoringReviews?: TutoringReviewUpdateManyWithoutStudentNestedInput
    tutoringMessages?: TutoringMessageUpdateManyWithoutSenderNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    conversationParts?: ConversationParticipantUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    attachments?: AttachmentUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    subscriptionRecords?: UserSubscriptionUpdateManyWithoutUserNestedInput
    bundlesOwned?: UserBundleUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    eventsAsTeacher?: CalendarEventUpdateManyWithoutTeacherNestedInput
    eventsAsStudent?: CalendarEventUpdateManyWithoutStudentNestedInput
    blogPosts?: BlogPostUpdateManyWithoutAuthorNestedInput
    blogComments?: BlogCommentUpdateManyWithoutUserNestedInput
    submissionsGraded?: AssignmentSubmissionUpdateManyWithoutGradedByNestedInput
    referralCodesOwned?: ReferralCodeUpdateManyWithoutUserNestedInput
    referralUsesGained?: ReferralUseUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCalendarEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: IntFieldUpdateOperationsInput | number
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referrals?: UserUncheckedUpdateManyWithoutReferredByNestedInput
    teacherProfile?: TeacherProfileUncheckedUpdateOneWithoutUserNestedInput
    availability?: UserAvailabilityUncheckedUpdateManyWithoutUserNestedInput
    pointsTransactions?: PointsTransactionUncheckedUpdateManyWithoutUserNestedInput
    courses?: CourseUncheckedUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    savedCourses?: SavedCourseUncheckedUpdateManyWithoutUserNestedInput
    likedCourses?: LikedCourseUncheckedUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUncheckedUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    assignmentSubs?: AssignmentSubmissionUncheckedUpdateManyWithoutUserNestedInput
    courseReviews?: CourseReviewUncheckedUpdateManyWithoutUserNestedInput
    tutoringSessions?: TutoringSessionUncheckedUpdateManyWithoutTeacherNestedInput
    tutoringRequests?: TutoringRequestUncheckedUpdateManyWithoutStudentNestedInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUncheckedUpdateManyWithoutTeacherNestedInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUncheckedUpdateManyWithoutStudentNestedInput
    tutoringReviews?: TutoringReviewUncheckedUpdateManyWithoutStudentNestedInput
    tutoringMessages?: TutoringMessageUncheckedUpdateManyWithoutSenderNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    conversationParts?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    subscriptionRecords?: UserSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    bundlesOwned?: UserBundleUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    eventsAsTeacher?: CalendarEventUncheckedUpdateManyWithoutTeacherNestedInput
    eventsAsStudent?: CalendarEventUncheckedUpdateManyWithoutStudentNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
    blogComments?: BlogCommentUncheckedUpdateManyWithoutUserNestedInput
    submissionsGraded?: AssignmentSubmissionUncheckedUpdateManyWithoutGradedByNestedInput
    referralCodesOwned?: ReferralCodeUncheckedUpdateManyWithoutUserNestedInput
    referralUsesGained?: ReferralUseUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CourseUpsertWithoutCalendarEventsInput = {
    update: XOR<CourseUpdateWithoutCalendarEventsInput, CourseUncheckedUpdateWithoutCalendarEventsInput>
    create: XOR<CourseCreateWithoutCalendarEventsInput, CourseUncheckedCreateWithoutCalendarEventsInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutCalendarEventsInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutCalendarEventsInput, CourseUncheckedUpdateWithoutCalendarEventsInput>
  }

  export type CourseUpdateWithoutCalendarEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pointsPrice?: IntFieldUpdateOperationsInput | number
    students?: IntFieldUpdateOperationsInput | number
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumCourseStatusFieldUpdateOperationsInput | $Enums.CourseStatus
    featured?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher?: UserUpdateOneRequiredWithoutCoursesNestedInput
    topics?: TopicUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUpdateManyWithoutCourseNestedInput
    savedBy?: SavedCourseUpdateManyWithoutCourseNestedInput
    likedBy?: LikedCourseUpdateManyWithoutCourseNestedInput
    reviews?: CourseReviewUpdateManyWithoutCourseNestedInput
    lessons?: LessonUpdateManyWithoutCourseNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutCourseNestedInput
    certificates?: CertificateUpdateManyWithoutCourseNestedInput
    bundleCourses?: BundleCourseUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutCalendarEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pointsPrice?: IntFieldUpdateOperationsInput | number
    teacherId?: StringFieldUpdateOperationsInput | string
    students?: IntFieldUpdateOperationsInput | number
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumCourseStatusFieldUpdateOperationsInput | $Enums.CourseStatus
    featured?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    topics?: TopicUncheckedUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutCourseNestedInput
    savedBy?: SavedCourseUncheckedUpdateManyWithoutCourseNestedInput
    likedBy?: LikedCourseUncheckedUpdateManyWithoutCourseNestedInput
    reviews?: CourseReviewUncheckedUpdateManyWithoutCourseNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutCourseNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutCourseNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutCourseNestedInput
    bundleCourses?: BundleCourseUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type LessonUpsertWithoutCalendarEventsInput = {
    update: XOR<LessonUpdateWithoutCalendarEventsInput, LessonUncheckedUpdateWithoutCalendarEventsInput>
    create: XOR<LessonCreateWithoutCalendarEventsInput, LessonUncheckedCreateWithoutCalendarEventsInput>
    where?: LessonWhereInput
  }

  export type LessonUpdateToOneWithWhereWithoutCalendarEventsInput = {
    where?: LessonWhereInput
    data: XOR<LessonUpdateWithoutCalendarEventsInput, LessonUncheckedUpdateWithoutCalendarEventsInput>
  }

  export type LessonUpdateWithoutCalendarEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    orderIndex?: IntFieldUpdateOperationsInput | number
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    topic?: TopicUpdateOneRequiredWithoutLessonsNestedInput
    quiz?: QuizUpdateOneWithoutLessonNestedInput
    assignment?: AssignmentUpdateOneWithoutLessonNestedInput
    progress?: LessonProgressUpdateManyWithoutLessonNestedInput
    course?: CourseUpdateOneWithoutLessonsNestedInput
  }

  export type LessonUncheckedUpdateWithoutCalendarEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    orderIndex?: IntFieldUpdateOperationsInput | number
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    quiz?: QuizUncheckedUpdateOneWithoutLessonNestedInput
    assignment?: AssignmentUncheckedUpdateOneWithoutLessonNestedInput
    progress?: LessonProgressUncheckedUpdateManyWithoutLessonNestedInput
  }

  export type UserUpsertWithoutEventsAsTeacherInput = {
    update: XOR<UserUpdateWithoutEventsAsTeacherInput, UserUncheckedUpdateWithoutEventsAsTeacherInput>
    create: XOR<UserCreateWithoutEventsAsTeacherInput, UserUncheckedCreateWithoutEventsAsTeacherInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEventsAsTeacherInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEventsAsTeacherInput, UserUncheckedUpdateWithoutEventsAsTeacherInput>
  }

  export type UserUpdateWithoutEventsAsTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: IntFieldUpdateOperationsInput | number
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referredBy?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferredByNestedInput
    teacherProfile?: TeacherProfileUpdateOneWithoutUserNestedInput
    availability?: UserAvailabilityUpdateManyWithoutUserNestedInput
    pointsTransactions?: PointsTransactionUpdateManyWithoutUserNestedInput
    courses?: CourseUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    savedCourses?: SavedCourseUpdateManyWithoutUserNestedInput
    likedCourses?: LikedCourseUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutUserNestedInput
    assignmentSubs?: AssignmentSubmissionUpdateManyWithoutUserNestedInput
    courseReviews?: CourseReviewUpdateManyWithoutUserNestedInput
    tutoringSessions?: TutoringSessionUpdateManyWithoutTeacherNestedInput
    tutoringRequests?: TutoringRequestUpdateManyWithoutStudentNestedInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUpdateManyWithoutTeacherNestedInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUpdateManyWithoutStudentNestedInput
    tutoringReviews?: TutoringReviewUpdateManyWithoutStudentNestedInput
    tutoringMessages?: TutoringMessageUpdateManyWithoutSenderNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    conversationParts?: ConversationParticipantUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    attachments?: AttachmentUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    subscriptionRecords?: UserSubscriptionUpdateManyWithoutUserNestedInput
    bundlesOwned?: UserBundleUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUpdateManyWithoutUserNestedInput
    eventsAsStudent?: CalendarEventUpdateManyWithoutStudentNestedInput
    blogPosts?: BlogPostUpdateManyWithoutAuthorNestedInput
    blogComments?: BlogCommentUpdateManyWithoutUserNestedInput
    submissionsGraded?: AssignmentSubmissionUpdateManyWithoutGradedByNestedInput
    referralCodesOwned?: ReferralCodeUpdateManyWithoutUserNestedInput
    referralUsesGained?: ReferralUseUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEventsAsTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: IntFieldUpdateOperationsInput | number
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referrals?: UserUncheckedUpdateManyWithoutReferredByNestedInput
    teacherProfile?: TeacherProfileUncheckedUpdateOneWithoutUserNestedInput
    availability?: UserAvailabilityUncheckedUpdateManyWithoutUserNestedInput
    pointsTransactions?: PointsTransactionUncheckedUpdateManyWithoutUserNestedInput
    courses?: CourseUncheckedUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    savedCourses?: SavedCourseUncheckedUpdateManyWithoutUserNestedInput
    likedCourses?: LikedCourseUncheckedUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUncheckedUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    assignmentSubs?: AssignmentSubmissionUncheckedUpdateManyWithoutUserNestedInput
    courseReviews?: CourseReviewUncheckedUpdateManyWithoutUserNestedInput
    tutoringSessions?: TutoringSessionUncheckedUpdateManyWithoutTeacherNestedInput
    tutoringRequests?: TutoringRequestUncheckedUpdateManyWithoutStudentNestedInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUncheckedUpdateManyWithoutTeacherNestedInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUncheckedUpdateManyWithoutStudentNestedInput
    tutoringReviews?: TutoringReviewUncheckedUpdateManyWithoutStudentNestedInput
    tutoringMessages?: TutoringMessageUncheckedUpdateManyWithoutSenderNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    conversationParts?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    subscriptionRecords?: UserSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    bundlesOwned?: UserBundleUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUncheckedUpdateManyWithoutUserNestedInput
    eventsAsStudent?: CalendarEventUncheckedUpdateManyWithoutStudentNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
    blogComments?: BlogCommentUncheckedUpdateManyWithoutUserNestedInput
    submissionsGraded?: AssignmentSubmissionUncheckedUpdateManyWithoutGradedByNestedInput
    referralCodesOwned?: ReferralCodeUncheckedUpdateManyWithoutUserNestedInput
    referralUsesGained?: ReferralUseUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutEventsAsStudentInput = {
    update: XOR<UserUpdateWithoutEventsAsStudentInput, UserUncheckedUpdateWithoutEventsAsStudentInput>
    create: XOR<UserCreateWithoutEventsAsStudentInput, UserUncheckedCreateWithoutEventsAsStudentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEventsAsStudentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEventsAsStudentInput, UserUncheckedUpdateWithoutEventsAsStudentInput>
  }

  export type UserUpdateWithoutEventsAsStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: IntFieldUpdateOperationsInput | number
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referredBy?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferredByNestedInput
    teacherProfile?: TeacherProfileUpdateOneWithoutUserNestedInput
    availability?: UserAvailabilityUpdateManyWithoutUserNestedInput
    pointsTransactions?: PointsTransactionUpdateManyWithoutUserNestedInput
    courses?: CourseUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    savedCourses?: SavedCourseUpdateManyWithoutUserNestedInput
    likedCourses?: LikedCourseUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutUserNestedInput
    assignmentSubs?: AssignmentSubmissionUpdateManyWithoutUserNestedInput
    courseReviews?: CourseReviewUpdateManyWithoutUserNestedInput
    tutoringSessions?: TutoringSessionUpdateManyWithoutTeacherNestedInput
    tutoringRequests?: TutoringRequestUpdateManyWithoutStudentNestedInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUpdateManyWithoutTeacherNestedInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUpdateManyWithoutStudentNestedInput
    tutoringReviews?: TutoringReviewUpdateManyWithoutStudentNestedInput
    tutoringMessages?: TutoringMessageUpdateManyWithoutSenderNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    conversationParts?: ConversationParticipantUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    attachments?: AttachmentUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    subscriptionRecords?: UserSubscriptionUpdateManyWithoutUserNestedInput
    bundlesOwned?: UserBundleUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUpdateManyWithoutUserNestedInput
    eventsAsTeacher?: CalendarEventUpdateManyWithoutTeacherNestedInput
    blogPosts?: BlogPostUpdateManyWithoutAuthorNestedInput
    blogComments?: BlogCommentUpdateManyWithoutUserNestedInput
    submissionsGraded?: AssignmentSubmissionUpdateManyWithoutGradedByNestedInput
    referralCodesOwned?: ReferralCodeUpdateManyWithoutUserNestedInput
    referralUsesGained?: ReferralUseUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEventsAsStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: IntFieldUpdateOperationsInput | number
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referrals?: UserUncheckedUpdateManyWithoutReferredByNestedInput
    teacherProfile?: TeacherProfileUncheckedUpdateOneWithoutUserNestedInput
    availability?: UserAvailabilityUncheckedUpdateManyWithoutUserNestedInput
    pointsTransactions?: PointsTransactionUncheckedUpdateManyWithoutUserNestedInput
    courses?: CourseUncheckedUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    savedCourses?: SavedCourseUncheckedUpdateManyWithoutUserNestedInput
    likedCourses?: LikedCourseUncheckedUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUncheckedUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    assignmentSubs?: AssignmentSubmissionUncheckedUpdateManyWithoutUserNestedInput
    courseReviews?: CourseReviewUncheckedUpdateManyWithoutUserNestedInput
    tutoringSessions?: TutoringSessionUncheckedUpdateManyWithoutTeacherNestedInput
    tutoringRequests?: TutoringRequestUncheckedUpdateManyWithoutStudentNestedInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUncheckedUpdateManyWithoutTeacherNestedInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUncheckedUpdateManyWithoutStudentNestedInput
    tutoringReviews?: TutoringReviewUncheckedUpdateManyWithoutStudentNestedInput
    tutoringMessages?: TutoringMessageUncheckedUpdateManyWithoutSenderNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    conversationParts?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    subscriptionRecords?: UserSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    bundlesOwned?: UserBundleUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUncheckedUpdateManyWithoutUserNestedInput
    eventsAsTeacher?: CalendarEventUncheckedUpdateManyWithoutTeacherNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
    blogComments?: BlogCommentUncheckedUpdateManyWithoutUserNestedInput
    submissionsGraded?: AssignmentSubmissionUncheckedUpdateManyWithoutGradedByNestedInput
    referralCodesOwned?: ReferralCodeUncheckedUpdateManyWithoutUserNestedInput
    referralUsesGained?: ReferralUseUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutBlogPostsInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    avatar?: string | null
    bio?: string | null
    createdAt?: Date | string
    points?: number
    referralCode?: string | null
    lastLogin?: Date | string | null
    referredBy?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferredByInput
    teacherProfile?: TeacherProfileCreateNestedOneWithoutUserInput
    availability?: UserAvailabilityCreateNestedManyWithoutUserInput
    pointsTransactions?: PointsTransactionCreateNestedManyWithoutUserInput
    courses?: CourseCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    savedCourses?: SavedCourseCreateNestedManyWithoutUserInput
    likedCourses?: LikedCourseCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutUserInput
    assignmentSubs?: AssignmentSubmissionCreateNestedManyWithoutUserInput
    courseReviews?: CourseReviewCreateNestedManyWithoutUserInput
    tutoringSessions?: TutoringSessionCreateNestedManyWithoutTeacherInput
    tutoringRequests?: TutoringRequestCreateNestedManyWithoutStudentInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentCreateNestedManyWithoutTeacherInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentCreateNestedManyWithoutStudentInput
    tutoringReviews?: TutoringReviewCreateNestedManyWithoutStudentInput
    tutoringMessages?: TutoringMessageCreateNestedManyWithoutSenderInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    conversationParts?: ConversationParticipantCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    attachments?: AttachmentCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    subscriptionRecords?: UserSubscriptionCreateNestedManyWithoutUserInput
    bundlesOwned?: UserBundleCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventCreateNestedManyWithoutUserInput
    eventsAsTeacher?: CalendarEventCreateNestedManyWithoutTeacherInput
    eventsAsStudent?: CalendarEventCreateNestedManyWithoutStudentInput
    blogComments?: BlogCommentCreateNestedManyWithoutUserInput
    submissionsGraded?: AssignmentSubmissionCreateNestedManyWithoutGradedByInput
    referralCodesOwned?: ReferralCodeCreateNestedManyWithoutUserInput
    referralUsesGained?: ReferralUseCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBlogPostsInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    avatar?: string | null
    bio?: string | null
    createdAt?: Date | string
    points?: number
    referralCode?: string | null
    referredById?: string | null
    lastLogin?: Date | string | null
    referrals?: UserUncheckedCreateNestedManyWithoutReferredByInput
    teacherProfile?: TeacherProfileUncheckedCreateNestedOneWithoutUserInput
    availability?: UserAvailabilityUncheckedCreateNestedManyWithoutUserInput
    pointsTransactions?: PointsTransactionUncheckedCreateNestedManyWithoutUserInput
    courses?: CourseUncheckedCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    savedCourses?: SavedCourseUncheckedCreateNestedManyWithoutUserInput
    likedCourses?: LikedCourseUncheckedCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressUncheckedCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutUserInput
    assignmentSubs?: AssignmentSubmissionUncheckedCreateNestedManyWithoutUserInput
    courseReviews?: CourseReviewUncheckedCreateNestedManyWithoutUserInput
    tutoringSessions?: TutoringSessionUncheckedCreateNestedManyWithoutTeacherInput
    tutoringRequests?: TutoringRequestUncheckedCreateNestedManyWithoutStudentInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUncheckedCreateNestedManyWithoutTeacherInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUncheckedCreateNestedManyWithoutStudentInput
    tutoringReviews?: TutoringReviewUncheckedCreateNestedManyWithoutStudentInput
    tutoringMessages?: TutoringMessageUncheckedCreateNestedManyWithoutSenderInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    conversationParts?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    subscriptionRecords?: UserSubscriptionUncheckedCreateNestedManyWithoutUserInput
    bundlesOwned?: UserBundleUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventUncheckedCreateNestedManyWithoutUserInput
    eventsAsTeacher?: CalendarEventUncheckedCreateNestedManyWithoutTeacherInput
    eventsAsStudent?: CalendarEventUncheckedCreateNestedManyWithoutStudentInput
    blogComments?: BlogCommentUncheckedCreateNestedManyWithoutUserInput
    submissionsGraded?: AssignmentSubmissionUncheckedCreateNestedManyWithoutGradedByInput
    referralCodesOwned?: ReferralCodeUncheckedCreateNestedManyWithoutUserInput
    referralUsesGained?: ReferralUseUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBlogPostsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBlogPostsInput, UserUncheckedCreateWithoutBlogPostsInput>
  }

  export type PostCategoryCreateWithoutPostInput = {
    category: CategoryCreateNestedOneWithoutPostsInput
  }

  export type PostCategoryUncheckedCreateWithoutPostInput = {
    categoryId: string
  }

  export type PostCategoryCreateOrConnectWithoutPostInput = {
    where: PostCategoryWhereUniqueInput
    create: XOR<PostCategoryCreateWithoutPostInput, PostCategoryUncheckedCreateWithoutPostInput>
  }

  export type PostCategoryCreateManyPostInputEnvelope = {
    data: PostCategoryCreateManyPostInput | PostCategoryCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type PostTagCreateWithoutPostInput = {
    tag: TagCreateNestedOneWithoutPostsInput
  }

  export type PostTagUncheckedCreateWithoutPostInput = {
    tagId: string
  }

  export type PostTagCreateOrConnectWithoutPostInput = {
    where: PostTagWhereUniqueInput
    create: XOR<PostTagCreateWithoutPostInput, PostTagUncheckedCreateWithoutPostInput>
  }

  export type PostTagCreateManyPostInputEnvelope = {
    data: PostTagCreateManyPostInput | PostTagCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type BlogCommentCreateWithoutPostInput = {
    id?: string
    content: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutBlogCommentsInput
    parent?: BlogCommentCreateNestedOneWithoutRepliesInput
    replies?: BlogCommentCreateNestedManyWithoutParentInput
  }

  export type BlogCommentUncheckedCreateWithoutPostInput = {
    id?: string
    userId: string
    content: string
    createdAt?: Date | string
    parentId?: string | null
    replies?: BlogCommentUncheckedCreateNestedManyWithoutParentInput
  }

  export type BlogCommentCreateOrConnectWithoutPostInput = {
    where: BlogCommentWhereUniqueInput
    create: XOR<BlogCommentCreateWithoutPostInput, BlogCommentUncheckedCreateWithoutPostInput>
  }

  export type BlogCommentCreateManyPostInputEnvelope = {
    data: BlogCommentCreateManyPostInput | BlogCommentCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutBlogPostsInput = {
    update: XOR<UserUpdateWithoutBlogPostsInput, UserUncheckedUpdateWithoutBlogPostsInput>
    create: XOR<UserCreateWithoutBlogPostsInput, UserUncheckedCreateWithoutBlogPostsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBlogPostsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBlogPostsInput, UserUncheckedUpdateWithoutBlogPostsInput>
  }

  export type UserUpdateWithoutBlogPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: IntFieldUpdateOperationsInput | number
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referredBy?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferredByNestedInput
    teacherProfile?: TeacherProfileUpdateOneWithoutUserNestedInput
    availability?: UserAvailabilityUpdateManyWithoutUserNestedInput
    pointsTransactions?: PointsTransactionUpdateManyWithoutUserNestedInput
    courses?: CourseUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    savedCourses?: SavedCourseUpdateManyWithoutUserNestedInput
    likedCourses?: LikedCourseUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutUserNestedInput
    assignmentSubs?: AssignmentSubmissionUpdateManyWithoutUserNestedInput
    courseReviews?: CourseReviewUpdateManyWithoutUserNestedInput
    tutoringSessions?: TutoringSessionUpdateManyWithoutTeacherNestedInput
    tutoringRequests?: TutoringRequestUpdateManyWithoutStudentNestedInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUpdateManyWithoutTeacherNestedInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUpdateManyWithoutStudentNestedInput
    tutoringReviews?: TutoringReviewUpdateManyWithoutStudentNestedInput
    tutoringMessages?: TutoringMessageUpdateManyWithoutSenderNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    conversationParts?: ConversationParticipantUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    attachments?: AttachmentUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    subscriptionRecords?: UserSubscriptionUpdateManyWithoutUserNestedInput
    bundlesOwned?: UserBundleUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUpdateManyWithoutUserNestedInput
    eventsAsTeacher?: CalendarEventUpdateManyWithoutTeacherNestedInput
    eventsAsStudent?: CalendarEventUpdateManyWithoutStudentNestedInput
    blogComments?: BlogCommentUpdateManyWithoutUserNestedInput
    submissionsGraded?: AssignmentSubmissionUpdateManyWithoutGradedByNestedInput
    referralCodesOwned?: ReferralCodeUpdateManyWithoutUserNestedInput
    referralUsesGained?: ReferralUseUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBlogPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: IntFieldUpdateOperationsInput | number
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referrals?: UserUncheckedUpdateManyWithoutReferredByNestedInput
    teacherProfile?: TeacherProfileUncheckedUpdateOneWithoutUserNestedInput
    availability?: UserAvailabilityUncheckedUpdateManyWithoutUserNestedInput
    pointsTransactions?: PointsTransactionUncheckedUpdateManyWithoutUserNestedInput
    courses?: CourseUncheckedUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    savedCourses?: SavedCourseUncheckedUpdateManyWithoutUserNestedInput
    likedCourses?: LikedCourseUncheckedUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUncheckedUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    assignmentSubs?: AssignmentSubmissionUncheckedUpdateManyWithoutUserNestedInput
    courseReviews?: CourseReviewUncheckedUpdateManyWithoutUserNestedInput
    tutoringSessions?: TutoringSessionUncheckedUpdateManyWithoutTeacherNestedInput
    tutoringRequests?: TutoringRequestUncheckedUpdateManyWithoutStudentNestedInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUncheckedUpdateManyWithoutTeacherNestedInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUncheckedUpdateManyWithoutStudentNestedInput
    tutoringReviews?: TutoringReviewUncheckedUpdateManyWithoutStudentNestedInput
    tutoringMessages?: TutoringMessageUncheckedUpdateManyWithoutSenderNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    conversationParts?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    subscriptionRecords?: UserSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    bundlesOwned?: UserBundleUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUncheckedUpdateManyWithoutUserNestedInput
    eventsAsTeacher?: CalendarEventUncheckedUpdateManyWithoutTeacherNestedInput
    eventsAsStudent?: CalendarEventUncheckedUpdateManyWithoutStudentNestedInput
    blogComments?: BlogCommentUncheckedUpdateManyWithoutUserNestedInput
    submissionsGraded?: AssignmentSubmissionUncheckedUpdateManyWithoutGradedByNestedInput
    referralCodesOwned?: ReferralCodeUncheckedUpdateManyWithoutUserNestedInput
    referralUsesGained?: ReferralUseUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PostCategoryUpsertWithWhereUniqueWithoutPostInput = {
    where: PostCategoryWhereUniqueInput
    update: XOR<PostCategoryUpdateWithoutPostInput, PostCategoryUncheckedUpdateWithoutPostInput>
    create: XOR<PostCategoryCreateWithoutPostInput, PostCategoryUncheckedCreateWithoutPostInput>
  }

  export type PostCategoryUpdateWithWhereUniqueWithoutPostInput = {
    where: PostCategoryWhereUniqueInput
    data: XOR<PostCategoryUpdateWithoutPostInput, PostCategoryUncheckedUpdateWithoutPostInput>
  }

  export type PostCategoryUpdateManyWithWhereWithoutPostInput = {
    where: PostCategoryScalarWhereInput
    data: XOR<PostCategoryUpdateManyMutationInput, PostCategoryUncheckedUpdateManyWithoutPostInput>
  }

  export type PostCategoryScalarWhereInput = {
    AND?: PostCategoryScalarWhereInput | PostCategoryScalarWhereInput[]
    OR?: PostCategoryScalarWhereInput[]
    NOT?: PostCategoryScalarWhereInput | PostCategoryScalarWhereInput[]
    postId?: StringFilter<"PostCategory"> | string
    categoryId?: StringFilter<"PostCategory"> | string
  }

  export type PostTagUpsertWithWhereUniqueWithoutPostInput = {
    where: PostTagWhereUniqueInput
    update: XOR<PostTagUpdateWithoutPostInput, PostTagUncheckedUpdateWithoutPostInput>
    create: XOR<PostTagCreateWithoutPostInput, PostTagUncheckedCreateWithoutPostInput>
  }

  export type PostTagUpdateWithWhereUniqueWithoutPostInput = {
    where: PostTagWhereUniqueInput
    data: XOR<PostTagUpdateWithoutPostInput, PostTagUncheckedUpdateWithoutPostInput>
  }

  export type PostTagUpdateManyWithWhereWithoutPostInput = {
    where: PostTagScalarWhereInput
    data: XOR<PostTagUpdateManyMutationInput, PostTagUncheckedUpdateManyWithoutPostInput>
  }

  export type PostTagScalarWhereInput = {
    AND?: PostTagScalarWhereInput | PostTagScalarWhereInput[]
    OR?: PostTagScalarWhereInput[]
    NOT?: PostTagScalarWhereInput | PostTagScalarWhereInput[]
    postId?: StringFilter<"PostTag"> | string
    tagId?: StringFilter<"PostTag"> | string
  }

  export type BlogCommentUpsertWithWhereUniqueWithoutPostInput = {
    where: BlogCommentWhereUniqueInput
    update: XOR<BlogCommentUpdateWithoutPostInput, BlogCommentUncheckedUpdateWithoutPostInput>
    create: XOR<BlogCommentCreateWithoutPostInput, BlogCommentUncheckedCreateWithoutPostInput>
  }

  export type BlogCommentUpdateWithWhereUniqueWithoutPostInput = {
    where: BlogCommentWhereUniqueInput
    data: XOR<BlogCommentUpdateWithoutPostInput, BlogCommentUncheckedUpdateWithoutPostInput>
  }

  export type BlogCommentUpdateManyWithWhereWithoutPostInput = {
    where: BlogCommentScalarWhereInput
    data: XOR<BlogCommentUpdateManyMutationInput, BlogCommentUncheckedUpdateManyWithoutPostInput>
  }

  export type PostCategoryCreateWithoutCategoryInput = {
    post: BlogPostCreateNestedOneWithoutCategoriesInput
  }

  export type PostCategoryUncheckedCreateWithoutCategoryInput = {
    postId: string
  }

  export type PostCategoryCreateOrConnectWithoutCategoryInput = {
    where: PostCategoryWhereUniqueInput
    create: XOR<PostCategoryCreateWithoutCategoryInput, PostCategoryUncheckedCreateWithoutCategoryInput>
  }

  export type PostCategoryCreateManyCategoryInputEnvelope = {
    data: PostCategoryCreateManyCategoryInput | PostCategoryCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type PostCategoryUpsertWithWhereUniqueWithoutCategoryInput = {
    where: PostCategoryWhereUniqueInput
    update: XOR<PostCategoryUpdateWithoutCategoryInput, PostCategoryUncheckedUpdateWithoutCategoryInput>
    create: XOR<PostCategoryCreateWithoutCategoryInput, PostCategoryUncheckedCreateWithoutCategoryInput>
  }

  export type PostCategoryUpdateWithWhereUniqueWithoutCategoryInput = {
    where: PostCategoryWhereUniqueInput
    data: XOR<PostCategoryUpdateWithoutCategoryInput, PostCategoryUncheckedUpdateWithoutCategoryInput>
  }

  export type PostCategoryUpdateManyWithWhereWithoutCategoryInput = {
    where: PostCategoryScalarWhereInput
    data: XOR<PostCategoryUpdateManyMutationInput, PostCategoryUncheckedUpdateManyWithoutCategoryInput>
  }

  export type BlogPostCreateWithoutCategoriesInput = {
    id?: string
    title: string
    excerpt?: string | null
    content: string
    image?: string | null
    published?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    readTime?: number | null
    author: UserCreateNestedOneWithoutBlogPostsInput
    tags?: PostTagCreateNestedManyWithoutPostInput
    comments?: BlogCommentCreateNestedManyWithoutPostInput
  }

  export type BlogPostUncheckedCreateWithoutCategoriesInput = {
    id?: string
    title: string
    excerpt?: string | null
    content: string
    image?: string | null
    authorId: string
    published?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    readTime?: number | null
    tags?: PostTagUncheckedCreateNestedManyWithoutPostInput
    comments?: BlogCommentUncheckedCreateNestedManyWithoutPostInput
  }

  export type BlogPostCreateOrConnectWithoutCategoriesInput = {
    where: BlogPostWhereUniqueInput
    create: XOR<BlogPostCreateWithoutCategoriesInput, BlogPostUncheckedCreateWithoutCategoriesInput>
  }

  export type CategoryCreateWithoutPostsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
  }

  export type CategoryUncheckedCreateWithoutPostsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
  }

  export type CategoryCreateOrConnectWithoutPostsInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutPostsInput, CategoryUncheckedCreateWithoutPostsInput>
  }

  export type BlogPostUpsertWithoutCategoriesInput = {
    update: XOR<BlogPostUpdateWithoutCategoriesInput, BlogPostUncheckedUpdateWithoutCategoriesInput>
    create: XOR<BlogPostCreateWithoutCategoriesInput, BlogPostUncheckedCreateWithoutCategoriesInput>
    where?: BlogPostWhereInput
  }

  export type BlogPostUpdateToOneWithWhereWithoutCategoriesInput = {
    where?: BlogPostWhereInput
    data: XOR<BlogPostUpdateWithoutCategoriesInput, BlogPostUncheckedUpdateWithoutCategoriesInput>
  }

  export type BlogPostUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readTime?: NullableIntFieldUpdateOperationsInput | number | null
    author?: UserUpdateOneRequiredWithoutBlogPostsNestedInput
    tags?: PostTagUpdateManyWithoutPostNestedInput
    comments?: BlogCommentUpdateManyWithoutPostNestedInput
  }

  export type BlogPostUncheckedUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readTime?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: PostTagUncheckedUpdateManyWithoutPostNestedInput
    comments?: BlogCommentUncheckedUpdateManyWithoutPostNestedInput
  }

  export type CategoryUpsertWithoutPostsInput = {
    update: XOR<CategoryUpdateWithoutPostsInput, CategoryUncheckedUpdateWithoutPostsInput>
    create: XOR<CategoryCreateWithoutPostsInput, CategoryUncheckedCreateWithoutPostsInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutPostsInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutPostsInput, CategoryUncheckedUpdateWithoutPostsInput>
  }

  export type CategoryUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CategoryUncheckedUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PostTagCreateWithoutTagInput = {
    post: BlogPostCreateNestedOneWithoutTagsInput
  }

  export type PostTagUncheckedCreateWithoutTagInput = {
    postId: string
  }

  export type PostTagCreateOrConnectWithoutTagInput = {
    where: PostTagWhereUniqueInput
    create: XOR<PostTagCreateWithoutTagInput, PostTagUncheckedCreateWithoutTagInput>
  }

  export type PostTagCreateManyTagInputEnvelope = {
    data: PostTagCreateManyTagInput | PostTagCreateManyTagInput[]
    skipDuplicates?: boolean
  }

  export type PostTagUpsertWithWhereUniqueWithoutTagInput = {
    where: PostTagWhereUniqueInput
    update: XOR<PostTagUpdateWithoutTagInput, PostTagUncheckedUpdateWithoutTagInput>
    create: XOR<PostTagCreateWithoutTagInput, PostTagUncheckedCreateWithoutTagInput>
  }

  export type PostTagUpdateWithWhereUniqueWithoutTagInput = {
    where: PostTagWhereUniqueInput
    data: XOR<PostTagUpdateWithoutTagInput, PostTagUncheckedUpdateWithoutTagInput>
  }

  export type PostTagUpdateManyWithWhereWithoutTagInput = {
    where: PostTagScalarWhereInput
    data: XOR<PostTagUpdateManyMutationInput, PostTagUncheckedUpdateManyWithoutTagInput>
  }

  export type BlogPostCreateWithoutTagsInput = {
    id?: string
    title: string
    excerpt?: string | null
    content: string
    image?: string | null
    published?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    readTime?: number | null
    author: UserCreateNestedOneWithoutBlogPostsInput
    categories?: PostCategoryCreateNestedManyWithoutPostInput
    comments?: BlogCommentCreateNestedManyWithoutPostInput
  }

  export type BlogPostUncheckedCreateWithoutTagsInput = {
    id?: string
    title: string
    excerpt?: string | null
    content: string
    image?: string | null
    authorId: string
    published?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    readTime?: number | null
    categories?: PostCategoryUncheckedCreateNestedManyWithoutPostInput
    comments?: BlogCommentUncheckedCreateNestedManyWithoutPostInput
  }

  export type BlogPostCreateOrConnectWithoutTagsInput = {
    where: BlogPostWhereUniqueInput
    create: XOR<BlogPostCreateWithoutTagsInput, BlogPostUncheckedCreateWithoutTagsInput>
  }

  export type TagCreateWithoutPostsInput = {
    id?: string
    name: string
    slug: string
  }

  export type TagUncheckedCreateWithoutPostsInput = {
    id?: string
    name: string
    slug: string
  }

  export type TagCreateOrConnectWithoutPostsInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutPostsInput, TagUncheckedCreateWithoutPostsInput>
  }

  export type BlogPostUpsertWithoutTagsInput = {
    update: XOR<BlogPostUpdateWithoutTagsInput, BlogPostUncheckedUpdateWithoutTagsInput>
    create: XOR<BlogPostCreateWithoutTagsInput, BlogPostUncheckedCreateWithoutTagsInput>
    where?: BlogPostWhereInput
  }

  export type BlogPostUpdateToOneWithWhereWithoutTagsInput = {
    where?: BlogPostWhereInput
    data: XOR<BlogPostUpdateWithoutTagsInput, BlogPostUncheckedUpdateWithoutTagsInput>
  }

  export type BlogPostUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readTime?: NullableIntFieldUpdateOperationsInput | number | null
    author?: UserUpdateOneRequiredWithoutBlogPostsNestedInput
    categories?: PostCategoryUpdateManyWithoutPostNestedInput
    comments?: BlogCommentUpdateManyWithoutPostNestedInput
  }

  export type BlogPostUncheckedUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readTime?: NullableIntFieldUpdateOperationsInput | number | null
    categories?: PostCategoryUncheckedUpdateManyWithoutPostNestedInput
    comments?: BlogCommentUncheckedUpdateManyWithoutPostNestedInput
  }

  export type TagUpsertWithoutPostsInput = {
    update: XOR<TagUpdateWithoutPostsInput, TagUncheckedUpdateWithoutPostsInput>
    create: XOR<TagCreateWithoutPostsInput, TagUncheckedCreateWithoutPostsInput>
    where?: TagWhereInput
  }

  export type TagUpdateToOneWithWhereWithoutPostsInput = {
    where?: TagWhereInput
    data: XOR<TagUpdateWithoutPostsInput, TagUncheckedUpdateWithoutPostsInput>
  }

  export type TagUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type TagUncheckedUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type BlogPostCreateWithoutCommentsInput = {
    id?: string
    title: string
    excerpt?: string | null
    content: string
    image?: string | null
    published?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    readTime?: number | null
    author: UserCreateNestedOneWithoutBlogPostsInput
    categories?: PostCategoryCreateNestedManyWithoutPostInput
    tags?: PostTagCreateNestedManyWithoutPostInput
  }

  export type BlogPostUncheckedCreateWithoutCommentsInput = {
    id?: string
    title: string
    excerpt?: string | null
    content: string
    image?: string | null
    authorId: string
    published?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    readTime?: number | null
    categories?: PostCategoryUncheckedCreateNestedManyWithoutPostInput
    tags?: PostTagUncheckedCreateNestedManyWithoutPostInput
  }

  export type BlogPostCreateOrConnectWithoutCommentsInput = {
    where: BlogPostWhereUniqueInput
    create: XOR<BlogPostCreateWithoutCommentsInput, BlogPostUncheckedCreateWithoutCommentsInput>
  }

  export type UserCreateWithoutBlogCommentsInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    avatar?: string | null
    bio?: string | null
    createdAt?: Date | string
    points?: number
    referralCode?: string | null
    lastLogin?: Date | string | null
    referredBy?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferredByInput
    teacherProfile?: TeacherProfileCreateNestedOneWithoutUserInput
    availability?: UserAvailabilityCreateNestedManyWithoutUserInput
    pointsTransactions?: PointsTransactionCreateNestedManyWithoutUserInput
    courses?: CourseCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    savedCourses?: SavedCourseCreateNestedManyWithoutUserInput
    likedCourses?: LikedCourseCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutUserInput
    assignmentSubs?: AssignmentSubmissionCreateNestedManyWithoutUserInput
    courseReviews?: CourseReviewCreateNestedManyWithoutUserInput
    tutoringSessions?: TutoringSessionCreateNestedManyWithoutTeacherInput
    tutoringRequests?: TutoringRequestCreateNestedManyWithoutStudentInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentCreateNestedManyWithoutTeacherInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentCreateNestedManyWithoutStudentInput
    tutoringReviews?: TutoringReviewCreateNestedManyWithoutStudentInput
    tutoringMessages?: TutoringMessageCreateNestedManyWithoutSenderInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    conversationParts?: ConversationParticipantCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    attachments?: AttachmentCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    subscriptionRecords?: UserSubscriptionCreateNestedManyWithoutUserInput
    bundlesOwned?: UserBundleCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventCreateNestedManyWithoutUserInput
    eventsAsTeacher?: CalendarEventCreateNestedManyWithoutTeacherInput
    eventsAsStudent?: CalendarEventCreateNestedManyWithoutStudentInput
    blogPosts?: BlogPostCreateNestedManyWithoutAuthorInput
    submissionsGraded?: AssignmentSubmissionCreateNestedManyWithoutGradedByInput
    referralCodesOwned?: ReferralCodeCreateNestedManyWithoutUserInput
    referralUsesGained?: ReferralUseCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBlogCommentsInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    avatar?: string | null
    bio?: string | null
    createdAt?: Date | string
    points?: number
    referralCode?: string | null
    referredById?: string | null
    lastLogin?: Date | string | null
    referrals?: UserUncheckedCreateNestedManyWithoutReferredByInput
    teacherProfile?: TeacherProfileUncheckedCreateNestedOneWithoutUserInput
    availability?: UserAvailabilityUncheckedCreateNestedManyWithoutUserInput
    pointsTransactions?: PointsTransactionUncheckedCreateNestedManyWithoutUserInput
    courses?: CourseUncheckedCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    savedCourses?: SavedCourseUncheckedCreateNestedManyWithoutUserInput
    likedCourses?: LikedCourseUncheckedCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressUncheckedCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutUserInput
    assignmentSubs?: AssignmentSubmissionUncheckedCreateNestedManyWithoutUserInput
    courseReviews?: CourseReviewUncheckedCreateNestedManyWithoutUserInput
    tutoringSessions?: TutoringSessionUncheckedCreateNestedManyWithoutTeacherInput
    tutoringRequests?: TutoringRequestUncheckedCreateNestedManyWithoutStudentInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUncheckedCreateNestedManyWithoutTeacherInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUncheckedCreateNestedManyWithoutStudentInput
    tutoringReviews?: TutoringReviewUncheckedCreateNestedManyWithoutStudentInput
    tutoringMessages?: TutoringMessageUncheckedCreateNestedManyWithoutSenderInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    conversationParts?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    subscriptionRecords?: UserSubscriptionUncheckedCreateNestedManyWithoutUserInput
    bundlesOwned?: UserBundleUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventUncheckedCreateNestedManyWithoutUserInput
    eventsAsTeacher?: CalendarEventUncheckedCreateNestedManyWithoutTeacherInput
    eventsAsStudent?: CalendarEventUncheckedCreateNestedManyWithoutStudentInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
    submissionsGraded?: AssignmentSubmissionUncheckedCreateNestedManyWithoutGradedByInput
    referralCodesOwned?: ReferralCodeUncheckedCreateNestedManyWithoutUserInput
    referralUsesGained?: ReferralUseUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBlogCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBlogCommentsInput, UserUncheckedCreateWithoutBlogCommentsInput>
  }

  export type BlogCommentCreateWithoutRepliesInput = {
    id?: string
    content: string
    createdAt?: Date | string
    post: BlogPostCreateNestedOneWithoutCommentsInput
    user: UserCreateNestedOneWithoutBlogCommentsInput
    parent?: BlogCommentCreateNestedOneWithoutRepliesInput
  }

  export type BlogCommentUncheckedCreateWithoutRepliesInput = {
    id?: string
    postId: string
    userId: string
    content: string
    createdAt?: Date | string
    parentId?: string | null
  }

  export type BlogCommentCreateOrConnectWithoutRepliesInput = {
    where: BlogCommentWhereUniqueInput
    create: XOR<BlogCommentCreateWithoutRepliesInput, BlogCommentUncheckedCreateWithoutRepliesInput>
  }

  export type BlogCommentCreateWithoutParentInput = {
    id?: string
    content: string
    createdAt?: Date | string
    post: BlogPostCreateNestedOneWithoutCommentsInput
    user: UserCreateNestedOneWithoutBlogCommentsInput
    replies?: BlogCommentCreateNestedManyWithoutParentInput
  }

  export type BlogCommentUncheckedCreateWithoutParentInput = {
    id?: string
    postId: string
    userId: string
    content: string
    createdAt?: Date | string
    replies?: BlogCommentUncheckedCreateNestedManyWithoutParentInput
  }

  export type BlogCommentCreateOrConnectWithoutParentInput = {
    where: BlogCommentWhereUniqueInput
    create: XOR<BlogCommentCreateWithoutParentInput, BlogCommentUncheckedCreateWithoutParentInput>
  }

  export type BlogCommentCreateManyParentInputEnvelope = {
    data: BlogCommentCreateManyParentInput | BlogCommentCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type BlogPostUpsertWithoutCommentsInput = {
    update: XOR<BlogPostUpdateWithoutCommentsInput, BlogPostUncheckedUpdateWithoutCommentsInput>
    create: XOR<BlogPostCreateWithoutCommentsInput, BlogPostUncheckedCreateWithoutCommentsInput>
    where?: BlogPostWhereInput
  }

  export type BlogPostUpdateToOneWithWhereWithoutCommentsInput = {
    where?: BlogPostWhereInput
    data: XOR<BlogPostUpdateWithoutCommentsInput, BlogPostUncheckedUpdateWithoutCommentsInput>
  }

  export type BlogPostUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readTime?: NullableIntFieldUpdateOperationsInput | number | null
    author?: UserUpdateOneRequiredWithoutBlogPostsNestedInput
    categories?: PostCategoryUpdateManyWithoutPostNestedInput
    tags?: PostTagUpdateManyWithoutPostNestedInput
  }

  export type BlogPostUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readTime?: NullableIntFieldUpdateOperationsInput | number | null
    categories?: PostCategoryUncheckedUpdateManyWithoutPostNestedInput
    tags?: PostTagUncheckedUpdateManyWithoutPostNestedInput
  }

  export type UserUpsertWithoutBlogCommentsInput = {
    update: XOR<UserUpdateWithoutBlogCommentsInput, UserUncheckedUpdateWithoutBlogCommentsInput>
    create: XOR<UserCreateWithoutBlogCommentsInput, UserUncheckedCreateWithoutBlogCommentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBlogCommentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBlogCommentsInput, UserUncheckedUpdateWithoutBlogCommentsInput>
  }

  export type UserUpdateWithoutBlogCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: IntFieldUpdateOperationsInput | number
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referredBy?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferredByNestedInput
    teacherProfile?: TeacherProfileUpdateOneWithoutUserNestedInput
    availability?: UserAvailabilityUpdateManyWithoutUserNestedInput
    pointsTransactions?: PointsTransactionUpdateManyWithoutUserNestedInput
    courses?: CourseUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    savedCourses?: SavedCourseUpdateManyWithoutUserNestedInput
    likedCourses?: LikedCourseUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutUserNestedInput
    assignmentSubs?: AssignmentSubmissionUpdateManyWithoutUserNestedInput
    courseReviews?: CourseReviewUpdateManyWithoutUserNestedInput
    tutoringSessions?: TutoringSessionUpdateManyWithoutTeacherNestedInput
    tutoringRequests?: TutoringRequestUpdateManyWithoutStudentNestedInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUpdateManyWithoutTeacherNestedInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUpdateManyWithoutStudentNestedInput
    tutoringReviews?: TutoringReviewUpdateManyWithoutStudentNestedInput
    tutoringMessages?: TutoringMessageUpdateManyWithoutSenderNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    conversationParts?: ConversationParticipantUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    attachments?: AttachmentUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    subscriptionRecords?: UserSubscriptionUpdateManyWithoutUserNestedInput
    bundlesOwned?: UserBundleUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUpdateManyWithoutUserNestedInput
    eventsAsTeacher?: CalendarEventUpdateManyWithoutTeacherNestedInput
    eventsAsStudent?: CalendarEventUpdateManyWithoutStudentNestedInput
    blogPosts?: BlogPostUpdateManyWithoutAuthorNestedInput
    submissionsGraded?: AssignmentSubmissionUpdateManyWithoutGradedByNestedInput
    referralCodesOwned?: ReferralCodeUpdateManyWithoutUserNestedInput
    referralUsesGained?: ReferralUseUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBlogCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: IntFieldUpdateOperationsInput | number
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referrals?: UserUncheckedUpdateManyWithoutReferredByNestedInput
    teacherProfile?: TeacherProfileUncheckedUpdateOneWithoutUserNestedInput
    availability?: UserAvailabilityUncheckedUpdateManyWithoutUserNestedInput
    pointsTransactions?: PointsTransactionUncheckedUpdateManyWithoutUserNestedInput
    courses?: CourseUncheckedUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    savedCourses?: SavedCourseUncheckedUpdateManyWithoutUserNestedInput
    likedCourses?: LikedCourseUncheckedUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUncheckedUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    assignmentSubs?: AssignmentSubmissionUncheckedUpdateManyWithoutUserNestedInput
    courseReviews?: CourseReviewUncheckedUpdateManyWithoutUserNestedInput
    tutoringSessions?: TutoringSessionUncheckedUpdateManyWithoutTeacherNestedInput
    tutoringRequests?: TutoringRequestUncheckedUpdateManyWithoutStudentNestedInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUncheckedUpdateManyWithoutTeacherNestedInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUncheckedUpdateManyWithoutStudentNestedInput
    tutoringReviews?: TutoringReviewUncheckedUpdateManyWithoutStudentNestedInput
    tutoringMessages?: TutoringMessageUncheckedUpdateManyWithoutSenderNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    conversationParts?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    subscriptionRecords?: UserSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    bundlesOwned?: UserBundleUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUncheckedUpdateManyWithoutUserNestedInput
    eventsAsTeacher?: CalendarEventUncheckedUpdateManyWithoutTeacherNestedInput
    eventsAsStudent?: CalendarEventUncheckedUpdateManyWithoutStudentNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
    submissionsGraded?: AssignmentSubmissionUncheckedUpdateManyWithoutGradedByNestedInput
    referralCodesOwned?: ReferralCodeUncheckedUpdateManyWithoutUserNestedInput
    referralUsesGained?: ReferralUseUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BlogCommentUpsertWithoutRepliesInput = {
    update: XOR<BlogCommentUpdateWithoutRepliesInput, BlogCommentUncheckedUpdateWithoutRepliesInput>
    create: XOR<BlogCommentCreateWithoutRepliesInput, BlogCommentUncheckedCreateWithoutRepliesInput>
    where?: BlogCommentWhereInput
  }

  export type BlogCommentUpdateToOneWithWhereWithoutRepliesInput = {
    where?: BlogCommentWhereInput
    data: XOR<BlogCommentUpdateWithoutRepliesInput, BlogCommentUncheckedUpdateWithoutRepliesInput>
  }

  export type BlogCommentUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: BlogPostUpdateOneRequiredWithoutCommentsNestedInput
    user?: UserUpdateOneRequiredWithoutBlogCommentsNestedInput
    parent?: BlogCommentUpdateOneWithoutRepliesNestedInput
  }

  export type BlogCommentUncheckedUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BlogCommentUpsertWithWhereUniqueWithoutParentInput = {
    where: BlogCommentWhereUniqueInput
    update: XOR<BlogCommentUpdateWithoutParentInput, BlogCommentUncheckedUpdateWithoutParentInput>
    create: XOR<BlogCommentCreateWithoutParentInput, BlogCommentUncheckedCreateWithoutParentInput>
  }

  export type BlogCommentUpdateWithWhereUniqueWithoutParentInput = {
    where: BlogCommentWhereUniqueInput
    data: XOR<BlogCommentUpdateWithoutParentInput, BlogCommentUncheckedUpdateWithoutParentInput>
  }

  export type BlogCommentUpdateManyWithWhereWithoutParentInput = {
    where: BlogCommentScalarWhereInput
    data: XOR<BlogCommentUpdateManyMutationInput, BlogCommentUncheckedUpdateManyWithoutParentInput>
  }

  export type UserCreateWithoutReferralCodesOwnedInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    avatar?: string | null
    bio?: string | null
    createdAt?: Date | string
    points?: number
    referralCode?: string | null
    lastLogin?: Date | string | null
    referredBy?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferredByInput
    teacherProfile?: TeacherProfileCreateNestedOneWithoutUserInput
    availability?: UserAvailabilityCreateNestedManyWithoutUserInput
    pointsTransactions?: PointsTransactionCreateNestedManyWithoutUserInput
    courses?: CourseCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    savedCourses?: SavedCourseCreateNestedManyWithoutUserInput
    likedCourses?: LikedCourseCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutUserInput
    assignmentSubs?: AssignmentSubmissionCreateNestedManyWithoutUserInput
    courseReviews?: CourseReviewCreateNestedManyWithoutUserInput
    tutoringSessions?: TutoringSessionCreateNestedManyWithoutTeacherInput
    tutoringRequests?: TutoringRequestCreateNestedManyWithoutStudentInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentCreateNestedManyWithoutTeacherInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentCreateNestedManyWithoutStudentInput
    tutoringReviews?: TutoringReviewCreateNestedManyWithoutStudentInput
    tutoringMessages?: TutoringMessageCreateNestedManyWithoutSenderInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    conversationParts?: ConversationParticipantCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    attachments?: AttachmentCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    subscriptionRecords?: UserSubscriptionCreateNestedManyWithoutUserInput
    bundlesOwned?: UserBundleCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventCreateNestedManyWithoutUserInput
    eventsAsTeacher?: CalendarEventCreateNestedManyWithoutTeacherInput
    eventsAsStudent?: CalendarEventCreateNestedManyWithoutStudentInput
    blogPosts?: BlogPostCreateNestedManyWithoutAuthorInput
    blogComments?: BlogCommentCreateNestedManyWithoutUserInput
    submissionsGraded?: AssignmentSubmissionCreateNestedManyWithoutGradedByInput
    referralUsesGained?: ReferralUseCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReferralCodesOwnedInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    avatar?: string | null
    bio?: string | null
    createdAt?: Date | string
    points?: number
    referralCode?: string | null
    referredById?: string | null
    lastLogin?: Date | string | null
    referrals?: UserUncheckedCreateNestedManyWithoutReferredByInput
    teacherProfile?: TeacherProfileUncheckedCreateNestedOneWithoutUserInput
    availability?: UserAvailabilityUncheckedCreateNestedManyWithoutUserInput
    pointsTransactions?: PointsTransactionUncheckedCreateNestedManyWithoutUserInput
    courses?: CourseUncheckedCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    savedCourses?: SavedCourseUncheckedCreateNestedManyWithoutUserInput
    likedCourses?: LikedCourseUncheckedCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressUncheckedCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutUserInput
    assignmentSubs?: AssignmentSubmissionUncheckedCreateNestedManyWithoutUserInput
    courseReviews?: CourseReviewUncheckedCreateNestedManyWithoutUserInput
    tutoringSessions?: TutoringSessionUncheckedCreateNestedManyWithoutTeacherInput
    tutoringRequests?: TutoringRequestUncheckedCreateNestedManyWithoutStudentInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUncheckedCreateNestedManyWithoutTeacherInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUncheckedCreateNestedManyWithoutStudentInput
    tutoringReviews?: TutoringReviewUncheckedCreateNestedManyWithoutStudentInput
    tutoringMessages?: TutoringMessageUncheckedCreateNestedManyWithoutSenderInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    conversationParts?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    subscriptionRecords?: UserSubscriptionUncheckedCreateNestedManyWithoutUserInput
    bundlesOwned?: UserBundleUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventUncheckedCreateNestedManyWithoutUserInput
    eventsAsTeacher?: CalendarEventUncheckedCreateNestedManyWithoutTeacherInput
    eventsAsStudent?: CalendarEventUncheckedCreateNestedManyWithoutStudentInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
    blogComments?: BlogCommentUncheckedCreateNestedManyWithoutUserInput
    submissionsGraded?: AssignmentSubmissionUncheckedCreateNestedManyWithoutGradedByInput
    referralUsesGained?: ReferralUseUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReferralCodesOwnedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReferralCodesOwnedInput, UserUncheckedCreateWithoutReferralCodesOwnedInput>
  }

  export type ReferralUseCreateWithoutReferralCodeInput = {
    id?: string
    pointsAwarded?: number
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutReferralUsesGainedInput
  }

  export type ReferralUseUncheckedCreateWithoutReferralCodeInput = {
    id?: string
    userId: string
    pointsAwarded?: number
    createdAt?: Date | string
  }

  export type ReferralUseCreateOrConnectWithoutReferralCodeInput = {
    where: ReferralUseWhereUniqueInput
    create: XOR<ReferralUseCreateWithoutReferralCodeInput, ReferralUseUncheckedCreateWithoutReferralCodeInput>
  }

  export type ReferralUseCreateManyReferralCodeInputEnvelope = {
    data: ReferralUseCreateManyReferralCodeInput | ReferralUseCreateManyReferralCodeInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutReferralCodesOwnedInput = {
    update: XOR<UserUpdateWithoutReferralCodesOwnedInput, UserUncheckedUpdateWithoutReferralCodesOwnedInput>
    create: XOR<UserCreateWithoutReferralCodesOwnedInput, UserUncheckedCreateWithoutReferralCodesOwnedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReferralCodesOwnedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReferralCodesOwnedInput, UserUncheckedUpdateWithoutReferralCodesOwnedInput>
  }

  export type UserUpdateWithoutReferralCodesOwnedInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: IntFieldUpdateOperationsInput | number
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referredBy?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferredByNestedInput
    teacherProfile?: TeacherProfileUpdateOneWithoutUserNestedInput
    availability?: UserAvailabilityUpdateManyWithoutUserNestedInput
    pointsTransactions?: PointsTransactionUpdateManyWithoutUserNestedInput
    courses?: CourseUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    savedCourses?: SavedCourseUpdateManyWithoutUserNestedInput
    likedCourses?: LikedCourseUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutUserNestedInput
    assignmentSubs?: AssignmentSubmissionUpdateManyWithoutUserNestedInput
    courseReviews?: CourseReviewUpdateManyWithoutUserNestedInput
    tutoringSessions?: TutoringSessionUpdateManyWithoutTeacherNestedInput
    tutoringRequests?: TutoringRequestUpdateManyWithoutStudentNestedInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUpdateManyWithoutTeacherNestedInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUpdateManyWithoutStudentNestedInput
    tutoringReviews?: TutoringReviewUpdateManyWithoutStudentNestedInput
    tutoringMessages?: TutoringMessageUpdateManyWithoutSenderNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    conversationParts?: ConversationParticipantUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    attachments?: AttachmentUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    subscriptionRecords?: UserSubscriptionUpdateManyWithoutUserNestedInput
    bundlesOwned?: UserBundleUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUpdateManyWithoutUserNestedInput
    eventsAsTeacher?: CalendarEventUpdateManyWithoutTeacherNestedInput
    eventsAsStudent?: CalendarEventUpdateManyWithoutStudentNestedInput
    blogPosts?: BlogPostUpdateManyWithoutAuthorNestedInput
    blogComments?: BlogCommentUpdateManyWithoutUserNestedInput
    submissionsGraded?: AssignmentSubmissionUpdateManyWithoutGradedByNestedInput
    referralUsesGained?: ReferralUseUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReferralCodesOwnedInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: IntFieldUpdateOperationsInput | number
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referrals?: UserUncheckedUpdateManyWithoutReferredByNestedInput
    teacherProfile?: TeacherProfileUncheckedUpdateOneWithoutUserNestedInput
    availability?: UserAvailabilityUncheckedUpdateManyWithoutUserNestedInput
    pointsTransactions?: PointsTransactionUncheckedUpdateManyWithoutUserNestedInput
    courses?: CourseUncheckedUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    savedCourses?: SavedCourseUncheckedUpdateManyWithoutUserNestedInput
    likedCourses?: LikedCourseUncheckedUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUncheckedUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    assignmentSubs?: AssignmentSubmissionUncheckedUpdateManyWithoutUserNestedInput
    courseReviews?: CourseReviewUncheckedUpdateManyWithoutUserNestedInput
    tutoringSessions?: TutoringSessionUncheckedUpdateManyWithoutTeacherNestedInput
    tutoringRequests?: TutoringRequestUncheckedUpdateManyWithoutStudentNestedInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUncheckedUpdateManyWithoutTeacherNestedInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUncheckedUpdateManyWithoutStudentNestedInput
    tutoringReviews?: TutoringReviewUncheckedUpdateManyWithoutStudentNestedInput
    tutoringMessages?: TutoringMessageUncheckedUpdateManyWithoutSenderNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    conversationParts?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    subscriptionRecords?: UserSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    bundlesOwned?: UserBundleUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUncheckedUpdateManyWithoutUserNestedInput
    eventsAsTeacher?: CalendarEventUncheckedUpdateManyWithoutTeacherNestedInput
    eventsAsStudent?: CalendarEventUncheckedUpdateManyWithoutStudentNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
    blogComments?: BlogCommentUncheckedUpdateManyWithoutUserNestedInput
    submissionsGraded?: AssignmentSubmissionUncheckedUpdateManyWithoutGradedByNestedInput
    referralUsesGained?: ReferralUseUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ReferralUseUpsertWithWhereUniqueWithoutReferralCodeInput = {
    where: ReferralUseWhereUniqueInput
    update: XOR<ReferralUseUpdateWithoutReferralCodeInput, ReferralUseUncheckedUpdateWithoutReferralCodeInput>
    create: XOR<ReferralUseCreateWithoutReferralCodeInput, ReferralUseUncheckedCreateWithoutReferralCodeInput>
  }

  export type ReferralUseUpdateWithWhereUniqueWithoutReferralCodeInput = {
    where: ReferralUseWhereUniqueInput
    data: XOR<ReferralUseUpdateWithoutReferralCodeInput, ReferralUseUncheckedUpdateWithoutReferralCodeInput>
  }

  export type ReferralUseUpdateManyWithWhereWithoutReferralCodeInput = {
    where: ReferralUseScalarWhereInput
    data: XOR<ReferralUseUpdateManyMutationInput, ReferralUseUncheckedUpdateManyWithoutReferralCodeInput>
  }

  export type ReferralCodeCreateWithoutUsesInput = {
    id?: string
    code: string
    isActive?: boolean
    usageLimit?: number | null
    maxUses?: number | null
    pointsReward?: number
    isUserCode?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutReferralCodesOwnedInput
  }

  export type ReferralCodeUncheckedCreateWithoutUsesInput = {
    id?: string
    code: string
    userId: string
    isActive?: boolean
    usageLimit?: number | null
    maxUses?: number | null
    pointsReward?: number
    isUserCode?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReferralCodeCreateOrConnectWithoutUsesInput = {
    where: ReferralCodeWhereUniqueInput
    create: XOR<ReferralCodeCreateWithoutUsesInput, ReferralCodeUncheckedCreateWithoutUsesInput>
  }

  export type UserCreateWithoutReferralUsesGainedInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    avatar?: string | null
    bio?: string | null
    createdAt?: Date | string
    points?: number
    referralCode?: string | null
    lastLogin?: Date | string | null
    referredBy?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferredByInput
    teacherProfile?: TeacherProfileCreateNestedOneWithoutUserInput
    availability?: UserAvailabilityCreateNestedManyWithoutUserInput
    pointsTransactions?: PointsTransactionCreateNestedManyWithoutUserInput
    courses?: CourseCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    savedCourses?: SavedCourseCreateNestedManyWithoutUserInput
    likedCourses?: LikedCourseCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutUserInput
    assignmentSubs?: AssignmentSubmissionCreateNestedManyWithoutUserInput
    courseReviews?: CourseReviewCreateNestedManyWithoutUserInput
    tutoringSessions?: TutoringSessionCreateNestedManyWithoutTeacherInput
    tutoringRequests?: TutoringRequestCreateNestedManyWithoutStudentInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentCreateNestedManyWithoutTeacherInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentCreateNestedManyWithoutStudentInput
    tutoringReviews?: TutoringReviewCreateNestedManyWithoutStudentInput
    tutoringMessages?: TutoringMessageCreateNestedManyWithoutSenderInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    conversationParts?: ConversationParticipantCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    attachments?: AttachmentCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    subscriptionRecords?: UserSubscriptionCreateNestedManyWithoutUserInput
    bundlesOwned?: UserBundleCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventCreateNestedManyWithoutUserInput
    eventsAsTeacher?: CalendarEventCreateNestedManyWithoutTeacherInput
    eventsAsStudent?: CalendarEventCreateNestedManyWithoutStudentInput
    blogPosts?: BlogPostCreateNestedManyWithoutAuthorInput
    blogComments?: BlogCommentCreateNestedManyWithoutUserInput
    submissionsGraded?: AssignmentSubmissionCreateNestedManyWithoutGradedByInput
    referralCodesOwned?: ReferralCodeCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReferralUsesGainedInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    avatar?: string | null
    bio?: string | null
    createdAt?: Date | string
    points?: number
    referralCode?: string | null
    referredById?: string | null
    lastLogin?: Date | string | null
    referrals?: UserUncheckedCreateNestedManyWithoutReferredByInput
    teacherProfile?: TeacherProfileUncheckedCreateNestedOneWithoutUserInput
    availability?: UserAvailabilityUncheckedCreateNestedManyWithoutUserInput
    pointsTransactions?: PointsTransactionUncheckedCreateNestedManyWithoutUserInput
    courses?: CourseUncheckedCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    savedCourses?: SavedCourseUncheckedCreateNestedManyWithoutUserInput
    likedCourses?: LikedCourseUncheckedCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressUncheckedCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutUserInput
    assignmentSubs?: AssignmentSubmissionUncheckedCreateNestedManyWithoutUserInput
    courseReviews?: CourseReviewUncheckedCreateNestedManyWithoutUserInput
    tutoringSessions?: TutoringSessionUncheckedCreateNestedManyWithoutTeacherInput
    tutoringRequests?: TutoringRequestUncheckedCreateNestedManyWithoutStudentInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUncheckedCreateNestedManyWithoutTeacherInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUncheckedCreateNestedManyWithoutStudentInput
    tutoringReviews?: TutoringReviewUncheckedCreateNestedManyWithoutStudentInput
    tutoringMessages?: TutoringMessageUncheckedCreateNestedManyWithoutSenderInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    conversationParts?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    subscriptionRecords?: UserSubscriptionUncheckedCreateNestedManyWithoutUserInput
    bundlesOwned?: UserBundleUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventUncheckedCreateNestedManyWithoutUserInput
    eventsAsTeacher?: CalendarEventUncheckedCreateNestedManyWithoutTeacherInput
    eventsAsStudent?: CalendarEventUncheckedCreateNestedManyWithoutStudentInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
    blogComments?: BlogCommentUncheckedCreateNestedManyWithoutUserInput
    submissionsGraded?: AssignmentSubmissionUncheckedCreateNestedManyWithoutGradedByInput
    referralCodesOwned?: ReferralCodeUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReferralUsesGainedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReferralUsesGainedInput, UserUncheckedCreateWithoutReferralUsesGainedInput>
  }

  export type ReferralCodeUpsertWithoutUsesInput = {
    update: XOR<ReferralCodeUpdateWithoutUsesInput, ReferralCodeUncheckedUpdateWithoutUsesInput>
    create: XOR<ReferralCodeCreateWithoutUsesInput, ReferralCodeUncheckedCreateWithoutUsesInput>
    where?: ReferralCodeWhereInput
  }

  export type ReferralCodeUpdateToOneWithWhereWithoutUsesInput = {
    where?: ReferralCodeWhereInput
    data: XOR<ReferralCodeUpdateWithoutUsesInput, ReferralCodeUncheckedUpdateWithoutUsesInput>
  }

  export type ReferralCodeUpdateWithoutUsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    pointsReward?: IntFieldUpdateOperationsInput | number
    isUserCode?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutReferralCodesOwnedNestedInput
  }

  export type ReferralCodeUncheckedUpdateWithoutUsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    pointsReward?: IntFieldUpdateOperationsInput | number
    isUserCode?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutReferralUsesGainedInput = {
    update: XOR<UserUpdateWithoutReferralUsesGainedInput, UserUncheckedUpdateWithoutReferralUsesGainedInput>
    create: XOR<UserCreateWithoutReferralUsesGainedInput, UserUncheckedCreateWithoutReferralUsesGainedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReferralUsesGainedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReferralUsesGainedInput, UserUncheckedUpdateWithoutReferralUsesGainedInput>
  }

  export type UserUpdateWithoutReferralUsesGainedInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: IntFieldUpdateOperationsInput | number
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referredBy?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferredByNestedInput
    teacherProfile?: TeacherProfileUpdateOneWithoutUserNestedInput
    availability?: UserAvailabilityUpdateManyWithoutUserNestedInput
    pointsTransactions?: PointsTransactionUpdateManyWithoutUserNestedInput
    courses?: CourseUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    savedCourses?: SavedCourseUpdateManyWithoutUserNestedInput
    likedCourses?: LikedCourseUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutUserNestedInput
    assignmentSubs?: AssignmentSubmissionUpdateManyWithoutUserNestedInput
    courseReviews?: CourseReviewUpdateManyWithoutUserNestedInput
    tutoringSessions?: TutoringSessionUpdateManyWithoutTeacherNestedInput
    tutoringRequests?: TutoringRequestUpdateManyWithoutStudentNestedInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUpdateManyWithoutTeacherNestedInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUpdateManyWithoutStudentNestedInput
    tutoringReviews?: TutoringReviewUpdateManyWithoutStudentNestedInput
    tutoringMessages?: TutoringMessageUpdateManyWithoutSenderNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    conversationParts?: ConversationParticipantUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    attachments?: AttachmentUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    subscriptionRecords?: UserSubscriptionUpdateManyWithoutUserNestedInput
    bundlesOwned?: UserBundleUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUpdateManyWithoutUserNestedInput
    eventsAsTeacher?: CalendarEventUpdateManyWithoutTeacherNestedInput
    eventsAsStudent?: CalendarEventUpdateManyWithoutStudentNestedInput
    blogPosts?: BlogPostUpdateManyWithoutAuthorNestedInput
    blogComments?: BlogCommentUpdateManyWithoutUserNestedInput
    submissionsGraded?: AssignmentSubmissionUpdateManyWithoutGradedByNestedInput
    referralCodesOwned?: ReferralCodeUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReferralUsesGainedInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: IntFieldUpdateOperationsInput | number
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referrals?: UserUncheckedUpdateManyWithoutReferredByNestedInput
    teacherProfile?: TeacherProfileUncheckedUpdateOneWithoutUserNestedInput
    availability?: UserAvailabilityUncheckedUpdateManyWithoutUserNestedInput
    pointsTransactions?: PointsTransactionUncheckedUpdateManyWithoutUserNestedInput
    courses?: CourseUncheckedUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    savedCourses?: SavedCourseUncheckedUpdateManyWithoutUserNestedInput
    likedCourses?: LikedCourseUncheckedUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUncheckedUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    assignmentSubs?: AssignmentSubmissionUncheckedUpdateManyWithoutUserNestedInput
    courseReviews?: CourseReviewUncheckedUpdateManyWithoutUserNestedInput
    tutoringSessions?: TutoringSessionUncheckedUpdateManyWithoutTeacherNestedInput
    tutoringRequests?: TutoringRequestUncheckedUpdateManyWithoutStudentNestedInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUncheckedUpdateManyWithoutTeacherNestedInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUncheckedUpdateManyWithoutStudentNestedInput
    tutoringReviews?: TutoringReviewUncheckedUpdateManyWithoutStudentNestedInput
    tutoringMessages?: TutoringMessageUncheckedUpdateManyWithoutSenderNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    conversationParts?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    subscriptionRecords?: UserSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    bundlesOwned?: UserBundleUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUncheckedUpdateManyWithoutUserNestedInput
    eventsAsTeacher?: CalendarEventUncheckedUpdateManyWithoutTeacherNestedInput
    eventsAsStudent?: CalendarEventUncheckedUpdateManyWithoutStudentNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
    blogComments?: BlogCommentUncheckedUpdateManyWithoutUserNestedInput
    submissionsGraded?: AssignmentSubmissionUncheckedUpdateManyWithoutGradedByNestedInput
    referralCodesOwned?: ReferralCodeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyReferredByInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    avatar?: string | null
    bio?: string | null
    createdAt?: Date | string
    points?: number
    referralCode?: string | null
    lastLogin?: Date | string | null
  }

  export type UserAvailabilityCreateManyUserInput = {
    id?: string
    dayOfWeek: number
    startTime: Date | string
    endTime: Date | string
  }

  export type PointsTransactionCreateManyUserInput = {
    id?: string
    amount: number
    type: $Enums.PointsTxnType
    description?: string | null
    createdAt?: Date | string
  }

  export type CourseCreateManyTeacherInput = {
    id?: string
    title: string
    description?: string | null
    subject: string
    image?: string | null
    price: Decimal | DecimalJsLike | number | string
    pointsPrice: number
    students?: number
    rating?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.CourseStatus
    featured?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EnrollmentCreateManyUserInput = {
    id?: string
    courseId: string
    enrolledAt?: Date | string
    completed?: boolean
    completedAt?: Date | string | null
    status?: string
  }

  export type SavedCourseCreateManyUserInput = {
    id?: string
    courseId: string
    savedAt?: Date | string
  }

  export type LikedCourseCreateManyUserInput = {
    id?: string
    courseId: string
    likedAt?: Date | string
  }

  export type LessonProgressCreateManyUserInput = {
    id?: string
    lessonId: string
    completed?: boolean
    completedAt?: Date | string | null
    lastPosition?: number
  }

  export type QuizAttemptCreateManyUserInput = {
    id?: string
    quizId: string
    score: number
    duration?: number | null
    completedAt?: Date | string
    answers: JsonNullValueInput | InputJsonValue
    courseId?: string | null
  }

  export type AssignmentSubmissionCreateManyUserInput = {
    id?: string
    assignmentId: string
    content?: string | null
    fileUrls?: AssignmentSubmissionCreatefileUrlsInput | string[]
    submittedAt?: Date | string
    score?: number | null
    feedback?: string | null
    gradedAt?: Date | string | null
    gradedById?: string | null
  }

  export type CourseReviewCreateManyUserInput = {
    id?: string
    courseId: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
  }

  export type TutoringSessionCreateManyTeacherInput = {
    id?: string
    subject: string
    description?: string | null
    pricePerHour: Decimal | DecimalJsLike | number | string
    locationType: $Enums.TutoringLocationType
    status?: $Enums.TutoringStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    maxStudents?: number
    prerequisites?: TutoringSessionCreateprerequisitesInput | string[]
    level?: string | null
    tags?: TutoringSessionCreatetagsInput | string[]
    featured?: boolean
  }

  export type TutoringRequestCreateManyStudentInput = {
    id?: string
    sessionId: string
    message?: string | null
    preferredDates?: TutoringRequestCreatepreferredDatesInput | Date[] | string[]
    status?: $Enums.TutoringRequestStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TutoringAppointmentCreateManyTeacherInput = {
    id?: string
    requestId: string
    sessionId: string
    scheduledAt: Date | string
    duration: number
    notes?: string | null
    meetingLink?: string | null
    status?: $Enums.AppointmentStatus
    price: Decimal | DecimalJsLike | number | string
    studentId: string
  }

  export type TutoringAppointmentCreateManyStudentInput = {
    id?: string
    requestId: string
    sessionId: string
    scheduledAt: Date | string
    duration: number
    notes?: string | null
    meetingLink?: string | null
    status?: $Enums.AppointmentStatus
    price: Decimal | DecimalJsLike | number | string
    teacherId: string
  }

  export type TutoringReviewCreateManyStudentInput = {
    id?: string
    sessionId: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
  }

  export type TutoringMessageCreateManySenderInput = {
    id?: string
    requestId: string
    message: string
    read?: boolean
    createdAt?: Date | string
  }

  export type UserAchievementCreateManyUserInput = {
    id?: string
    achievementId: string
    completed?: boolean
    completedAt?: Date | string | null
    progress?: number
  }

  export type CertificateCreateManyUserInput = {
    id?: string
    title: string
    issueDate?: Date | string
    type: string
    courseId?: string | null
    courseName?: string | null
    tutoringId?: string | null
    tutoringSubject?: string | null
    teacherId?: string | null
    teacherName?: string | null
    customMessage?: string | null
    imageUrl?: string | null
    badgeId?: string | null
  }

  export type ConversationParticipantCreateManyUserInput = {
    conversationId: string
  }

  export type MessageCreateManySenderInput = {
    id?: string
    conversationId: string
    content: string
    timestamp?: Date | string
    read?: boolean
  }

  export type AttachmentCreateManyUserInput = {
    id?: string
    messageId: string
    fileName: string
    fileUrl: string
    fileType: string
    fileSize: number
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    title: string
    message: string
    read?: boolean
    type: $Enums.NotificationType
    link?: string | null
    createdAt?: Date | string
  }

  export type UserSubscriptionCreateManyUserInput = {
    id?: string
    planId: string
    startDate?: Date | string
    endDate: Date | string
    isActive?: boolean
    autoRenew?: boolean
    paymentMethod?: string | null
    lastPaymentDate?: Date | string | null
  }

  export type UserBundleCreateManyUserInput = {
    id?: string
    bundleId: string
    purchaseDate?: Date | string
  }

  export type PaymentCreateManyUserInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    paymentMethod?: string | null
    status: $Enums.PaymentStatus
    referenceType: $Enums.PaymentReferenceType
    referenceId?: string | null
    transactionId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CalendarEventCreateManyUserInput = {
    id?: string
    title: string
    description?: string | null
    type: string
    startTime: Date | string
    endTime?: Date | string | null
    courseId?: string | null
    lessonId?: string | null
    teacherId?: string | null
    studentId?: string | null
    location?: string | null
    createdAt?: Date | string
  }

  export type CalendarEventCreateManyTeacherInput = {
    id?: string
    userId: string
    title: string
    description?: string | null
    type: string
    startTime: Date | string
    endTime?: Date | string | null
    courseId?: string | null
    lessonId?: string | null
    studentId?: string | null
    location?: string | null
    createdAt?: Date | string
  }

  export type CalendarEventCreateManyStudentInput = {
    id?: string
    userId: string
    title: string
    description?: string | null
    type: string
    startTime: Date | string
    endTime?: Date | string | null
    courseId?: string | null
    lessonId?: string | null
    teacherId?: string | null
    location?: string | null
    createdAt?: Date | string
  }

  export type BlogPostCreateManyAuthorInput = {
    id?: string
    title: string
    excerpt?: string | null
    content: string
    image?: string | null
    published?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    readTime?: number | null
  }

  export type BlogCommentCreateManyUserInput = {
    id?: string
    postId: string
    content: string
    createdAt?: Date | string
    parentId?: string | null
  }

  export type AssignmentSubmissionCreateManyGradedByInput = {
    id?: string
    userId: string
    assignmentId: string
    content?: string | null
    fileUrls?: AssignmentSubmissionCreatefileUrlsInput | string[]
    submittedAt?: Date | string
    score?: number | null
    feedback?: string | null
    gradedAt?: Date | string | null
  }

  export type ReferralCodeCreateManyUserInput = {
    id?: string
    code: string
    isActive?: boolean
    usageLimit?: number | null
    maxUses?: number | null
    pointsReward?: number
    isUserCode?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReferralUseCreateManyUserInput = {
    id?: string
    referralCodeId: string
    pointsAwarded?: number
    createdAt?: Date | string
  }

  export type UserUpdateWithoutReferredByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: IntFieldUpdateOperationsInput | number
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referrals?: UserUpdateManyWithoutReferredByNestedInput
    teacherProfile?: TeacherProfileUpdateOneWithoutUserNestedInput
    availability?: UserAvailabilityUpdateManyWithoutUserNestedInput
    pointsTransactions?: PointsTransactionUpdateManyWithoutUserNestedInput
    courses?: CourseUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    savedCourses?: SavedCourseUpdateManyWithoutUserNestedInput
    likedCourses?: LikedCourseUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutUserNestedInput
    assignmentSubs?: AssignmentSubmissionUpdateManyWithoutUserNestedInput
    courseReviews?: CourseReviewUpdateManyWithoutUserNestedInput
    tutoringSessions?: TutoringSessionUpdateManyWithoutTeacherNestedInput
    tutoringRequests?: TutoringRequestUpdateManyWithoutStudentNestedInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUpdateManyWithoutTeacherNestedInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUpdateManyWithoutStudentNestedInput
    tutoringReviews?: TutoringReviewUpdateManyWithoutStudentNestedInput
    tutoringMessages?: TutoringMessageUpdateManyWithoutSenderNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    conversationParts?: ConversationParticipantUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    attachments?: AttachmentUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    subscriptionRecords?: UserSubscriptionUpdateManyWithoutUserNestedInput
    bundlesOwned?: UserBundleUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUpdateManyWithoutUserNestedInput
    eventsAsTeacher?: CalendarEventUpdateManyWithoutTeacherNestedInput
    eventsAsStudent?: CalendarEventUpdateManyWithoutStudentNestedInput
    blogPosts?: BlogPostUpdateManyWithoutAuthorNestedInput
    blogComments?: BlogCommentUpdateManyWithoutUserNestedInput
    submissionsGraded?: AssignmentSubmissionUpdateManyWithoutGradedByNestedInput
    referralCodesOwned?: ReferralCodeUpdateManyWithoutUserNestedInput
    referralUsesGained?: ReferralUseUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReferredByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: IntFieldUpdateOperationsInput | number
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referrals?: UserUncheckedUpdateManyWithoutReferredByNestedInput
    teacherProfile?: TeacherProfileUncheckedUpdateOneWithoutUserNestedInput
    availability?: UserAvailabilityUncheckedUpdateManyWithoutUserNestedInput
    pointsTransactions?: PointsTransactionUncheckedUpdateManyWithoutUserNestedInput
    courses?: CourseUncheckedUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    savedCourses?: SavedCourseUncheckedUpdateManyWithoutUserNestedInput
    likedCourses?: LikedCourseUncheckedUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUncheckedUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    assignmentSubs?: AssignmentSubmissionUncheckedUpdateManyWithoutUserNestedInput
    courseReviews?: CourseReviewUncheckedUpdateManyWithoutUserNestedInput
    tutoringSessions?: TutoringSessionUncheckedUpdateManyWithoutTeacherNestedInput
    tutoringRequests?: TutoringRequestUncheckedUpdateManyWithoutStudentNestedInput
    tutoringAppointmentsAsTeacher?: TutoringAppointmentUncheckedUpdateManyWithoutTeacherNestedInput
    tutoringAppointmentsAsStudent?: TutoringAppointmentUncheckedUpdateManyWithoutStudentNestedInput
    tutoringReviews?: TutoringReviewUncheckedUpdateManyWithoutStudentNestedInput
    tutoringMessages?: TutoringMessageUncheckedUpdateManyWithoutSenderNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    conversationParts?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    subscriptionRecords?: UserSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    bundlesOwned?: UserBundleUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUncheckedUpdateManyWithoutUserNestedInput
    eventsAsTeacher?: CalendarEventUncheckedUpdateManyWithoutTeacherNestedInput
    eventsAsStudent?: CalendarEventUncheckedUpdateManyWithoutStudentNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
    blogComments?: BlogCommentUncheckedUpdateManyWithoutUserNestedInput
    submissionsGraded?: AssignmentSubmissionUncheckedUpdateManyWithoutGradedByNestedInput
    referralCodesOwned?: ReferralCodeUncheckedUpdateManyWithoutUserNestedInput
    referralUsesGained?: ReferralUseUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutReferredByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: IntFieldUpdateOperationsInput | number
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserAvailabilityUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAvailabilityUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAvailabilityUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PointsTransactionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    type?: EnumPointsTxnTypeFieldUpdateOperationsInput | $Enums.PointsTxnType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PointsTransactionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    type?: EnumPointsTxnTypeFieldUpdateOperationsInput | $Enums.PointsTxnType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PointsTransactionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    type?: EnumPointsTxnTypeFieldUpdateOperationsInput | $Enums.PointsTxnType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pointsPrice?: IntFieldUpdateOperationsInput | number
    students?: IntFieldUpdateOperationsInput | number
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumCourseStatusFieldUpdateOperationsInput | $Enums.CourseStatus
    featured?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    topics?: TopicUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUpdateManyWithoutCourseNestedInput
    savedBy?: SavedCourseUpdateManyWithoutCourseNestedInput
    likedBy?: LikedCourseUpdateManyWithoutCourseNestedInput
    reviews?: CourseReviewUpdateManyWithoutCourseNestedInput
    lessons?: LessonUpdateManyWithoutCourseNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutCourseNestedInput
    certificates?: CertificateUpdateManyWithoutCourseNestedInput
    bundleCourses?: BundleCourseUpdateManyWithoutCourseNestedInput
    calendarEvents?: CalendarEventUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pointsPrice?: IntFieldUpdateOperationsInput | number
    students?: IntFieldUpdateOperationsInput | number
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumCourseStatusFieldUpdateOperationsInput | $Enums.CourseStatus
    featured?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    topics?: TopicUncheckedUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutCourseNestedInput
    savedBy?: SavedCourseUncheckedUpdateManyWithoutCourseNestedInput
    likedBy?: LikedCourseUncheckedUpdateManyWithoutCourseNestedInput
    reviews?: CourseReviewUncheckedUpdateManyWithoutCourseNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutCourseNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutCourseNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutCourseNestedInput
    bundleCourses?: BundleCourseUncheckedUpdateManyWithoutCourseNestedInput
    calendarEvents?: CalendarEventUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateManyWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pointsPrice?: IntFieldUpdateOperationsInput | number
    students?: IntFieldUpdateOperationsInput | number
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumCourseStatusFieldUpdateOperationsInput | $Enums.CourseStatus
    featured?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnrollmentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    course?: CourseUpdateOneRequiredWithoutEnrollmentsNestedInput
  }

  export type EnrollmentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type EnrollmentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type SavedCourseUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    savedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneRequiredWithoutSavedByNestedInput
  }

  export type SavedCourseUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    savedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SavedCourseUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    savedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikedCourseUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    likedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneRequiredWithoutLikedByNestedInput
  }

  export type LikedCourseUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    likedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikedCourseUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    likedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LessonProgressUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPosition?: IntFieldUpdateOperationsInput | number
    lesson?: LessonUpdateOneRequiredWithoutProgressNestedInput
  }

  export type LessonProgressUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    lessonId?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPosition?: IntFieldUpdateOperationsInput | number
  }

  export type LessonProgressUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    lessonId?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPosition?: IntFieldUpdateOperationsInput | number
  }

  export type QuizAttemptUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answers?: JsonNullValueInput | InputJsonValue
    quiz?: QuizUpdateOneRequiredWithoutAttemptsNestedInput
    course?: CourseUpdateOneWithoutQuizAttemptsNestedInput
  }

  export type QuizAttemptUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    quizId?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answers?: JsonNullValueInput | InputJsonValue
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QuizAttemptUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    quizId?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answers?: JsonNullValueInput | InputJsonValue
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AssignmentSubmissionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrls?: AssignmentSubmissionUpdatefileUrlsInput | string[]
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    score?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    gradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignment?: AssignmentUpdateOneRequiredWithoutSubmissionsNestedInput
    gradedBy?: UserUpdateOneWithoutSubmissionsGradedNestedInput
  }

  export type AssignmentSubmissionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignmentId?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrls?: AssignmentSubmissionUpdatefileUrlsInput | string[]
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    score?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    gradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gradedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AssignmentSubmissionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignmentId?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrls?: AssignmentSubmissionUpdatefileUrlsInput | string[]
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    score?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    gradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gradedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CourseReviewUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type CourseReviewUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseReviewUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TutoringSessionUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pricePerHour?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    locationType?: EnumTutoringLocationTypeFieldUpdateOperationsInput | $Enums.TutoringLocationType
    status?: EnumTutoringStatusFieldUpdateOperationsInput | $Enums.TutoringStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maxStudents?: IntFieldUpdateOperationsInput | number
    prerequisites?: TutoringSessionUpdateprerequisitesInput | string[]
    level?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: TutoringSessionUpdatetagsInput | string[]
    featured?: BoolFieldUpdateOperationsInput | boolean
    availability?: TutoringAvailabilityUpdateManyWithoutSessionNestedInput
    requests?: TutoringRequestUpdateManyWithoutSessionNestedInput
    appointments?: TutoringAppointmentUpdateManyWithoutSessionNestedInput
    reviews?: TutoringReviewUpdateManyWithoutSessionNestedInput
    certificates?: CertificateUpdateManyWithoutTutoringNestedInput
  }

  export type TutoringSessionUncheckedUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pricePerHour?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    locationType?: EnumTutoringLocationTypeFieldUpdateOperationsInput | $Enums.TutoringLocationType
    status?: EnumTutoringStatusFieldUpdateOperationsInput | $Enums.TutoringStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maxStudents?: IntFieldUpdateOperationsInput | number
    prerequisites?: TutoringSessionUpdateprerequisitesInput | string[]
    level?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: TutoringSessionUpdatetagsInput | string[]
    featured?: BoolFieldUpdateOperationsInput | boolean
    availability?: TutoringAvailabilityUncheckedUpdateManyWithoutSessionNestedInput
    requests?: TutoringRequestUncheckedUpdateManyWithoutSessionNestedInput
    appointments?: TutoringAppointmentUncheckedUpdateManyWithoutSessionNestedInput
    reviews?: TutoringReviewUncheckedUpdateManyWithoutSessionNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutTutoringNestedInput
  }

  export type TutoringSessionUncheckedUpdateManyWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pricePerHour?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    locationType?: EnumTutoringLocationTypeFieldUpdateOperationsInput | $Enums.TutoringLocationType
    status?: EnumTutoringStatusFieldUpdateOperationsInput | $Enums.TutoringStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maxStudents?: IntFieldUpdateOperationsInput | number
    prerequisites?: TutoringSessionUpdateprerequisitesInput | string[]
    level?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: TutoringSessionUpdatetagsInput | string[]
    featured?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TutoringRequestUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    preferredDates?: TutoringRequestUpdatepreferredDatesInput | Date[] | string[]
    status?: EnumTutoringRequestStatusFieldUpdateOperationsInput | $Enums.TutoringRequestStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: TutoringSessionUpdateOneRequiredWithoutRequestsNestedInput
    appointment?: TutoringAppointmentUpdateOneWithoutRequestNestedInput
    messages?: TutoringMessageUpdateManyWithoutRequestNestedInput
  }

  export type TutoringRequestUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    preferredDates?: TutoringRequestUpdatepreferredDatesInput | Date[] | string[]
    status?: EnumTutoringRequestStatusFieldUpdateOperationsInput | $Enums.TutoringRequestStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: TutoringAppointmentUncheckedUpdateOneWithoutRequestNestedInput
    messages?: TutoringMessageUncheckedUpdateManyWithoutRequestNestedInput
  }

  export type TutoringRequestUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    preferredDates?: TutoringRequestUpdatepreferredDatesInput | Date[] | string[]
    status?: EnumTutoringRequestStatusFieldUpdateOperationsInput | $Enums.TutoringRequestStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TutoringAppointmentUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    request?: TutoringRequestUpdateOneRequiredWithoutAppointmentNestedInput
    session?: TutoringSessionUpdateOneRequiredWithoutAppointmentsNestedInput
    student?: UserUpdateOneRequiredWithoutTutoringAppointmentsAsStudentNestedInput
  }

  export type TutoringAppointmentUncheckedUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    studentId?: StringFieldUpdateOperationsInput | string
  }

  export type TutoringAppointmentUncheckedUpdateManyWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    studentId?: StringFieldUpdateOperationsInput | string
  }

  export type TutoringAppointmentUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    request?: TutoringRequestUpdateOneRequiredWithoutAppointmentNestedInput
    session?: TutoringSessionUpdateOneRequiredWithoutAppointmentsNestedInput
    teacher?: UserUpdateOneRequiredWithoutTutoringAppointmentsAsTeacherNestedInput
  }

  export type TutoringAppointmentUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    teacherId?: StringFieldUpdateOperationsInput | string
  }

  export type TutoringAppointmentUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    teacherId?: StringFieldUpdateOperationsInput | string
  }

  export type TutoringReviewUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: TutoringSessionUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type TutoringReviewUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TutoringReviewUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TutoringMessageUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    request?: TutoringRequestUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type TutoringMessageUncheckedUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TutoringMessageUncheckedUpdateManyWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAchievementUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    achievement?: AchievementUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserAchievementUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
  }

  export type UserAchievementUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
  }

  export type CertificateUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    courseName?: NullableStringFieldUpdateOperationsInput | string | null
    tutoringSubject?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    teacherName?: NullableStringFieldUpdateOperationsInput | string | null
    customMessage?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    course?: CourseUpdateOneWithoutCertificatesNestedInput
    tutoring?: TutoringSessionUpdateOneWithoutCertificatesNestedInput
    badge?: BadgeUpdateOneWithoutCertificatesNestedInput
  }

  export type CertificateUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    courseName?: NullableStringFieldUpdateOperationsInput | string | null
    tutoringId?: NullableStringFieldUpdateOperationsInput | string | null
    tutoringSubject?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    teacherName?: NullableStringFieldUpdateOperationsInput | string | null
    customMessage?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    badgeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CertificateUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    courseName?: NullableStringFieldUpdateOperationsInput | string | null
    tutoringId?: NullableStringFieldUpdateOperationsInput | string | null
    tutoringSubject?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    teacherName?: NullableStringFieldUpdateOperationsInput | string | null
    customMessage?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    badgeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ConversationParticipantUpdateWithoutUserInput = {
    conversation?: ConversationUpdateOneRequiredWithoutParticipantsNestedInput
  }

  export type ConversationParticipantUncheckedUpdateWithoutUserInput = {
    conversationId?: StringFieldUpdateOperationsInput | string
  }

  export type ConversationParticipantUncheckedUpdateManyWithoutUserInput = {
    conversationId?: StringFieldUpdateOperationsInput | string
  }

  export type MessageUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: BoolFieldUpdateOperationsInput | boolean
    conversation?: ConversationUpdateOneRequiredWithoutMessagesNestedInput
    attachments?: AttachmentUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: BoolFieldUpdateOperationsInput | boolean
    attachments?: AttachmentUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateManyWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AttachmentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    message?: MessageUpdateOneRequiredWithoutAttachmentsNestedInput
  }

  export type AttachmentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
  }

  export type AttachmentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    link?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    link?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    link?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSubscriptionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plan?: SubscriptionPlanUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserSubscriptionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserSubscriptionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserBundleUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    bundle?: CourseBundleUpdateOneRequiredWithoutOwnersNestedInput
  }

  export type UserBundleUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    bundleId?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBundleUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    bundleId?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    referenceType?: EnumPaymentReferenceTypeFieldUpdateOperationsInput | $Enums.PaymentReferenceType
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    referenceType?: EnumPaymentReferenceTypeFieldUpdateOperationsInput | $Enums.PaymentReferenceType
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    referenceType?: EnumPaymentReferenceTypeFieldUpdateOperationsInput | $Enums.PaymentReferenceType
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarEventUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneWithoutCalendarEventsNestedInput
    lesson?: LessonUpdateOneWithoutCalendarEventsNestedInput
    teacher?: UserUpdateOneWithoutEventsAsTeacherNestedInput
    student?: UserUpdateOneWithoutEventsAsStudentNestedInput
  }

  export type CalendarEventUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    lessonId?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarEventUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    lessonId?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarEventUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCalendarEventsNestedInput
    course?: CourseUpdateOneWithoutCalendarEventsNestedInput
    lesson?: LessonUpdateOneWithoutCalendarEventsNestedInput
    student?: UserUpdateOneWithoutEventsAsStudentNestedInput
  }

  export type CalendarEventUncheckedUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    lessonId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarEventUncheckedUpdateManyWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    lessonId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarEventUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCalendarEventsNestedInput
    course?: CourseUpdateOneWithoutCalendarEventsNestedInput
    lesson?: LessonUpdateOneWithoutCalendarEventsNestedInput
    teacher?: UserUpdateOneWithoutEventsAsTeacherNestedInput
  }

  export type CalendarEventUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    lessonId?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarEventUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    lessonId?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogPostUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readTime?: NullableIntFieldUpdateOperationsInput | number | null
    categories?: PostCategoryUpdateManyWithoutPostNestedInput
    tags?: PostTagUpdateManyWithoutPostNestedInput
    comments?: BlogCommentUpdateManyWithoutPostNestedInput
  }

  export type BlogPostUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readTime?: NullableIntFieldUpdateOperationsInput | number | null
    categories?: PostCategoryUncheckedUpdateManyWithoutPostNestedInput
    tags?: PostTagUncheckedUpdateManyWithoutPostNestedInput
    comments?: BlogCommentUncheckedUpdateManyWithoutPostNestedInput
  }

  export type BlogPostUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readTime?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BlogCommentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: BlogPostUpdateOneRequiredWithoutCommentsNestedInput
    parent?: BlogCommentUpdateOneWithoutRepliesNestedInput
    replies?: BlogCommentUpdateManyWithoutParentNestedInput
  }

  export type BlogCommentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    replies?: BlogCommentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type BlogCommentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AssignmentSubmissionUpdateWithoutGradedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrls?: AssignmentSubmissionUpdatefileUrlsInput | string[]
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    score?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    gradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutAssignmentSubsNestedInput
    assignment?: AssignmentUpdateOneRequiredWithoutSubmissionsNestedInput
  }

  export type AssignmentSubmissionUncheckedUpdateWithoutGradedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    assignmentId?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrls?: AssignmentSubmissionUpdatefileUrlsInput | string[]
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    score?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    gradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AssignmentSubmissionUncheckedUpdateManyWithoutGradedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    assignmentId?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrls?: AssignmentSubmissionUpdatefileUrlsInput | string[]
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    score?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    gradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReferralCodeUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    pointsReward?: IntFieldUpdateOperationsInput | number
    isUserCode?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uses?: ReferralUseUpdateManyWithoutReferralCodeNestedInput
  }

  export type ReferralCodeUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    pointsReward?: IntFieldUpdateOperationsInput | number
    isUserCode?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uses?: ReferralUseUncheckedUpdateManyWithoutReferralCodeNestedInput
  }

  export type ReferralCodeUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    pointsReward?: IntFieldUpdateOperationsInput | number
    isUserCode?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralUseUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    pointsAwarded?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: ReferralCodeUpdateOneRequiredWithoutUsesNestedInput
  }

  export type ReferralUseUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    referralCodeId?: StringFieldUpdateOperationsInput | string
    pointsAwarded?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralUseUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    referralCodeId?: StringFieldUpdateOperationsInput | string
    pointsAwarded?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TopicCreateManyCourseInput = {
    id?: string
    title: string
    description?: string | null
    orderIndex: number
  }

  export type EnrollmentCreateManyCourseInput = {
    id?: string
    userId: string
    enrolledAt?: Date | string
    completed?: boolean
    completedAt?: Date | string | null
    status?: string
  }

  export type SavedCourseCreateManyCourseInput = {
    id?: string
    userId: string
    savedAt?: Date | string
  }

  export type LikedCourseCreateManyCourseInput = {
    id?: string
    userId: string
    likedAt?: Date | string
  }

  export type CourseReviewCreateManyCourseInput = {
    id?: string
    userId: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
  }

  export type LessonCreateManyCourseInput = {
    id?: string
    topicId: string
    title: string
    description?: string | null
    videoUrl?: string | null
    content?: string | null
    duration?: number | null
    orderIndex: number
    type: $Enums.LessonType
  }

  export type QuizAttemptCreateManyCourseInput = {
    id?: string
    userId: string
    quizId: string
    score: number
    duration?: number | null
    completedAt?: Date | string
    answers: JsonNullValueInput | InputJsonValue
  }

  export type CertificateCreateManyCourseInput = {
    id?: string
    userId: string
    title: string
    issueDate?: Date | string
    type: string
    courseName?: string | null
    tutoringId?: string | null
    tutoringSubject?: string | null
    teacherId?: string | null
    teacherName?: string | null
    customMessage?: string | null
    imageUrl?: string | null
    badgeId?: string | null
  }

  export type BundleCourseCreateManyCourseInput = {
    bundleId: string
  }

  export type CalendarEventCreateManyCourseInput = {
    id?: string
    userId: string
    title: string
    description?: string | null
    type: string
    startTime: Date | string
    endTime?: Date | string | null
    lessonId?: string | null
    teacherId?: string | null
    studentId?: string | null
    location?: string | null
    createdAt?: Date | string
  }

  export type TopicUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    orderIndex?: IntFieldUpdateOperationsInput | number
    lessons?: LessonUpdateManyWithoutTopicNestedInput
  }

  export type TopicUncheckedUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    orderIndex?: IntFieldUpdateOperationsInput | number
    lessons?: LessonUncheckedUpdateManyWithoutTopicNestedInput
  }

  export type TopicUncheckedUpdateManyWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    orderIndex?: IntFieldUpdateOperationsInput | number
  }

  export type EnrollmentUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutEnrollmentsNestedInput
  }

  export type EnrollmentUncheckedUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type EnrollmentUncheckedUpdateManyWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type SavedCourseUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    savedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSavedCoursesNestedInput
  }

  export type SavedCourseUncheckedUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    savedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SavedCourseUncheckedUpdateManyWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    savedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikedCourseUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    likedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLikedCoursesNestedInput
  }

  export type LikedCourseUncheckedUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    likedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikedCourseUncheckedUpdateManyWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    likedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseReviewUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCourseReviewsNestedInput
  }

  export type CourseReviewUncheckedUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseReviewUncheckedUpdateManyWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LessonUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    orderIndex?: IntFieldUpdateOperationsInput | number
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    topic?: TopicUpdateOneRequiredWithoutLessonsNestedInput
    quiz?: QuizUpdateOneWithoutLessonNestedInput
    assignment?: AssignmentUpdateOneWithoutLessonNestedInput
    progress?: LessonProgressUpdateManyWithoutLessonNestedInput
    calendarEvents?: CalendarEventUpdateManyWithoutLessonNestedInput
  }

  export type LessonUncheckedUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    orderIndex?: IntFieldUpdateOperationsInput | number
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    quiz?: QuizUncheckedUpdateOneWithoutLessonNestedInput
    assignment?: AssignmentUncheckedUpdateOneWithoutLessonNestedInput
    progress?: LessonProgressUncheckedUpdateManyWithoutLessonNestedInput
    calendarEvents?: CalendarEventUncheckedUpdateManyWithoutLessonNestedInput
  }

  export type LessonUncheckedUpdateManyWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    orderIndex?: IntFieldUpdateOperationsInput | number
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
  }

  export type QuizAttemptUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answers?: JsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutQuizAttemptsNestedInput
    quiz?: QuizUpdateOneRequiredWithoutAttemptsNestedInput
  }

  export type QuizAttemptUncheckedUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    quizId?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answers?: JsonNullValueInput | InputJsonValue
  }

  export type QuizAttemptUncheckedUpdateManyWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    quizId?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answers?: JsonNullValueInput | InputJsonValue
  }

  export type CertificateUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    courseName?: NullableStringFieldUpdateOperationsInput | string | null
    tutoringSubject?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    teacherName?: NullableStringFieldUpdateOperationsInput | string | null
    customMessage?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutCertificatesNestedInput
    tutoring?: TutoringSessionUpdateOneWithoutCertificatesNestedInput
    badge?: BadgeUpdateOneWithoutCertificatesNestedInput
  }

  export type CertificateUncheckedUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    courseName?: NullableStringFieldUpdateOperationsInput | string | null
    tutoringId?: NullableStringFieldUpdateOperationsInput | string | null
    tutoringSubject?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    teacherName?: NullableStringFieldUpdateOperationsInput | string | null
    customMessage?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    badgeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CertificateUncheckedUpdateManyWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    courseName?: NullableStringFieldUpdateOperationsInput | string | null
    tutoringId?: NullableStringFieldUpdateOperationsInput | string | null
    tutoringSubject?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    teacherName?: NullableStringFieldUpdateOperationsInput | string | null
    customMessage?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    badgeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BundleCourseUpdateWithoutCourseInput = {
    bundle?: CourseBundleUpdateOneRequiredWithoutCoursesNestedInput
  }

  export type BundleCourseUncheckedUpdateWithoutCourseInput = {
    bundleId?: StringFieldUpdateOperationsInput | string
  }

  export type BundleCourseUncheckedUpdateManyWithoutCourseInput = {
    bundleId?: StringFieldUpdateOperationsInput | string
  }

  export type CalendarEventUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCalendarEventsNestedInput
    lesson?: LessonUpdateOneWithoutCalendarEventsNestedInput
    teacher?: UserUpdateOneWithoutEventsAsTeacherNestedInput
    student?: UserUpdateOneWithoutEventsAsStudentNestedInput
  }

  export type CalendarEventUncheckedUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lessonId?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarEventUncheckedUpdateManyWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lessonId?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LessonCreateManyTopicInput = {
    id?: string
    title: string
    description?: string | null
    videoUrl?: string | null
    content?: string | null
    duration?: number | null
    orderIndex: number
    type: $Enums.LessonType
    courseId?: string | null
  }

  export type LessonUpdateWithoutTopicInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    orderIndex?: IntFieldUpdateOperationsInput | number
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    quiz?: QuizUpdateOneWithoutLessonNestedInput
    assignment?: AssignmentUpdateOneWithoutLessonNestedInput
    progress?: LessonProgressUpdateManyWithoutLessonNestedInput
    calendarEvents?: CalendarEventUpdateManyWithoutLessonNestedInput
    course?: CourseUpdateOneWithoutLessonsNestedInput
  }

  export type LessonUncheckedUpdateWithoutTopicInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    orderIndex?: IntFieldUpdateOperationsInput | number
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    quiz?: QuizUncheckedUpdateOneWithoutLessonNestedInput
    assignment?: AssignmentUncheckedUpdateOneWithoutLessonNestedInput
    progress?: LessonProgressUncheckedUpdateManyWithoutLessonNestedInput
    calendarEvents?: CalendarEventUncheckedUpdateManyWithoutLessonNestedInput
  }

  export type LessonUncheckedUpdateManyWithoutTopicInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    orderIndex?: IntFieldUpdateOperationsInput | number
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LessonProgressCreateManyLessonInput = {
    id?: string
    userId: string
    completed?: boolean
    completedAt?: Date | string | null
    lastPosition?: number
  }

  export type CalendarEventCreateManyLessonInput = {
    id?: string
    userId: string
    title: string
    description?: string | null
    type: string
    startTime: Date | string
    endTime?: Date | string | null
    courseId?: string | null
    teacherId?: string | null
    studentId?: string | null
    location?: string | null
    createdAt?: Date | string
  }

  export type LessonProgressUpdateWithoutLessonInput = {
    id?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPosition?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutLessonProgressNestedInput
  }

  export type LessonProgressUncheckedUpdateWithoutLessonInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPosition?: IntFieldUpdateOperationsInput | number
  }

  export type LessonProgressUncheckedUpdateManyWithoutLessonInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPosition?: IntFieldUpdateOperationsInput | number
  }

  export type CalendarEventUpdateWithoutLessonInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCalendarEventsNestedInput
    course?: CourseUpdateOneWithoutCalendarEventsNestedInput
    teacher?: UserUpdateOneWithoutEventsAsTeacherNestedInput
    student?: UserUpdateOneWithoutEventsAsStudentNestedInput
  }

  export type CalendarEventUncheckedUpdateWithoutLessonInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarEventUncheckedUpdateManyWithoutLessonInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionCreateManyQuizInput = {
    id?: string
    questionText: string
    type: $Enums.QuestionType
    options: JsonNullValueInput | InputJsonValue
    correctOptions?: QuestionCreatecorrectOptionsInput | number[]
    orderIndex?: number | null
  }

  export type QuizAttemptCreateManyQuizInput = {
    id?: string
    userId: string
    score: number
    duration?: number | null
    completedAt?: Date | string
    answers: JsonNullValueInput | InputJsonValue
    courseId?: string | null
  }

  export type QuestionUpdateWithoutQuizInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionText?: StringFieldUpdateOperationsInput | string
    type?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    options?: JsonNullValueInput | InputJsonValue
    correctOptions?: QuestionUpdatecorrectOptionsInput | number[]
    orderIndex?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type QuestionUncheckedUpdateWithoutQuizInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionText?: StringFieldUpdateOperationsInput | string
    type?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    options?: JsonNullValueInput | InputJsonValue
    correctOptions?: QuestionUpdatecorrectOptionsInput | number[]
    orderIndex?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type QuestionUncheckedUpdateManyWithoutQuizInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionText?: StringFieldUpdateOperationsInput | string
    type?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    options?: JsonNullValueInput | InputJsonValue
    correctOptions?: QuestionUpdatecorrectOptionsInput | number[]
    orderIndex?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type QuizAttemptUpdateWithoutQuizInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answers?: JsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutQuizAttemptsNestedInput
    course?: CourseUpdateOneWithoutQuizAttemptsNestedInput
  }

  export type QuizAttemptUncheckedUpdateWithoutQuizInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answers?: JsonNullValueInput | InputJsonValue
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QuizAttemptUncheckedUpdateManyWithoutQuizInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answers?: JsonNullValueInput | InputJsonValue
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AssignmentSubmissionCreateManyAssignmentInput = {
    id?: string
    userId: string
    content?: string | null
    fileUrls?: AssignmentSubmissionCreatefileUrlsInput | string[]
    submittedAt?: Date | string
    score?: number | null
    feedback?: string | null
    gradedAt?: Date | string | null
    gradedById?: string | null
  }

  export type AssignmentSubmissionUpdateWithoutAssignmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrls?: AssignmentSubmissionUpdatefileUrlsInput | string[]
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    score?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    gradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutAssignmentSubsNestedInput
    gradedBy?: UserUpdateOneWithoutSubmissionsGradedNestedInput
  }

  export type AssignmentSubmissionUncheckedUpdateWithoutAssignmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrls?: AssignmentSubmissionUpdatefileUrlsInput | string[]
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    score?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    gradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gradedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AssignmentSubmissionUncheckedUpdateManyWithoutAssignmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrls?: AssignmentSubmissionUpdatefileUrlsInput | string[]
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    score?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    gradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gradedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TutoringAvailabilityCreateManySessionInput = {
    id?: string
    dayOfWeek: number
    startTime: Date | string
    endTime: Date | string
  }

  export type TutoringRequestCreateManySessionInput = {
    id?: string
    studentId: string
    message?: string | null
    preferredDates?: TutoringRequestCreatepreferredDatesInput | Date[] | string[]
    status?: $Enums.TutoringRequestStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TutoringAppointmentCreateManySessionInput = {
    id?: string
    requestId: string
    scheduledAt: Date | string
    duration: number
    notes?: string | null
    meetingLink?: string | null
    status?: $Enums.AppointmentStatus
    price: Decimal | DecimalJsLike | number | string
    teacherId: string
    studentId: string
  }

  export type TutoringReviewCreateManySessionInput = {
    id?: string
    studentId: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
  }

  export type CertificateCreateManyTutoringInput = {
    id?: string
    userId: string
    title: string
    issueDate?: Date | string
    type: string
    courseId?: string | null
    courseName?: string | null
    tutoringSubject?: string | null
    teacherId?: string | null
    teacherName?: string | null
    customMessage?: string | null
    imageUrl?: string | null
    badgeId?: string | null
  }

  export type TutoringAvailabilityUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TutoringAvailabilityUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TutoringAvailabilityUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TutoringRequestUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    preferredDates?: TutoringRequestUpdatepreferredDatesInput | Date[] | string[]
    status?: EnumTutoringRequestStatusFieldUpdateOperationsInput | $Enums.TutoringRequestStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: UserUpdateOneRequiredWithoutTutoringRequestsNestedInput
    appointment?: TutoringAppointmentUpdateOneWithoutRequestNestedInput
    messages?: TutoringMessageUpdateManyWithoutRequestNestedInput
  }

  export type TutoringRequestUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    preferredDates?: TutoringRequestUpdatepreferredDatesInput | Date[] | string[]
    status?: EnumTutoringRequestStatusFieldUpdateOperationsInput | $Enums.TutoringRequestStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: TutoringAppointmentUncheckedUpdateOneWithoutRequestNestedInput
    messages?: TutoringMessageUncheckedUpdateManyWithoutRequestNestedInput
  }

  export type TutoringRequestUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    preferredDates?: TutoringRequestUpdatepreferredDatesInput | Date[] | string[]
    status?: EnumTutoringRequestStatusFieldUpdateOperationsInput | $Enums.TutoringRequestStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TutoringAppointmentUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    request?: TutoringRequestUpdateOneRequiredWithoutAppointmentNestedInput
    teacher?: UserUpdateOneRequiredWithoutTutoringAppointmentsAsTeacherNestedInput
    student?: UserUpdateOneRequiredWithoutTutoringAppointmentsAsStudentNestedInput
  }

  export type TutoringAppointmentUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestId?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    teacherId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
  }

  export type TutoringAppointmentUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestId?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    teacherId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
  }

  export type TutoringReviewUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: UserUpdateOneRequiredWithoutTutoringReviewsNestedInput
  }

  export type TutoringReviewUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TutoringReviewUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificateUpdateWithoutTutoringInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    courseName?: NullableStringFieldUpdateOperationsInput | string | null
    tutoringSubject?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    teacherName?: NullableStringFieldUpdateOperationsInput | string | null
    customMessage?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutCertificatesNestedInput
    course?: CourseUpdateOneWithoutCertificatesNestedInput
    badge?: BadgeUpdateOneWithoutCertificatesNestedInput
  }

  export type CertificateUncheckedUpdateWithoutTutoringInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    courseName?: NullableStringFieldUpdateOperationsInput | string | null
    tutoringSubject?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    teacherName?: NullableStringFieldUpdateOperationsInput | string | null
    customMessage?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    badgeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CertificateUncheckedUpdateManyWithoutTutoringInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    courseName?: NullableStringFieldUpdateOperationsInput | string | null
    tutoringSubject?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    teacherName?: NullableStringFieldUpdateOperationsInput | string | null
    customMessage?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    badgeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TutoringMessageCreateManyRequestInput = {
    id?: string
    senderId: string
    message: string
    read?: boolean
    createdAt?: Date | string
  }

  export type TutoringMessageUpdateWithoutRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutTutoringMessagesNestedInput
  }

  export type TutoringMessageUncheckedUpdateWithoutRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TutoringMessageUncheckedUpdateManyWithoutRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAchievementCreateManyAchievementInput = {
    id?: string
    userId: string
    completed?: boolean
    completedAt?: Date | string | null
    progress?: number
  }

  export type UserAchievementUpdateWithoutAchievementInput = {
    id?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutAchievementsNestedInput
  }

  export type UserAchievementUncheckedUpdateWithoutAchievementInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
  }

  export type UserAchievementUncheckedUpdateManyWithoutAchievementInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
  }

  export type CertificateCreateManyBadgeInput = {
    id?: string
    userId: string
    title: string
    issueDate?: Date | string
    type: string
    courseId?: string | null
    courseName?: string | null
    tutoringId?: string | null
    tutoringSubject?: string | null
    teacherId?: string | null
    teacherName?: string | null
    customMessage?: string | null
    imageUrl?: string | null
  }

  export type CertificateUpdateWithoutBadgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    courseName?: NullableStringFieldUpdateOperationsInput | string | null
    tutoringSubject?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    teacherName?: NullableStringFieldUpdateOperationsInput | string | null
    customMessage?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutCertificatesNestedInput
    course?: CourseUpdateOneWithoutCertificatesNestedInput
    tutoring?: TutoringSessionUpdateOneWithoutCertificatesNestedInput
  }

  export type CertificateUncheckedUpdateWithoutBadgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    courseName?: NullableStringFieldUpdateOperationsInput | string | null
    tutoringId?: NullableStringFieldUpdateOperationsInput | string | null
    tutoringSubject?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    teacherName?: NullableStringFieldUpdateOperationsInput | string | null
    customMessage?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CertificateUncheckedUpdateManyWithoutBadgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    courseName?: NullableStringFieldUpdateOperationsInput | string | null
    tutoringId?: NullableStringFieldUpdateOperationsInput | string | null
    tutoringSubject?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    teacherName?: NullableStringFieldUpdateOperationsInput | string | null
    customMessage?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ConversationParticipantCreateManyConversationInput = {
    userId: string
  }

  export type MessageCreateManyConversationInput = {
    id?: string
    senderId: string
    content: string
    timestamp?: Date | string
    read?: boolean
  }

  export type ConversationParticipantUpdateWithoutConversationInput = {
    user?: UserUpdateOneRequiredWithoutConversationPartsNestedInput
  }

  export type ConversationParticipantUncheckedUpdateWithoutConversationInput = {
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type ConversationParticipantUncheckedUpdateManyWithoutConversationInput = {
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type MessageUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: BoolFieldUpdateOperationsInput | boolean
    sender?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
    attachments?: AttachmentUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: BoolFieldUpdateOperationsInput | boolean
    attachments?: AttachmentUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateManyWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AttachmentCreateManyMessageInput = {
    id?: string
    userId?: string | null
    fileName: string
    fileUrl: string
    fileType: string
    fileSize: number
  }

  export type AttachmentUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneWithoutAttachmentsNestedInput
  }

  export type AttachmentUncheckedUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
  }

  export type AttachmentUncheckedUpdateManyWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
  }

  export type UserSubscriptionCreateManyPlanInput = {
    id?: string
    userId: string
    startDate?: Date | string
    endDate: Date | string
    isActive?: boolean
    autoRenew?: boolean
    paymentMethod?: string | null
    lastPaymentDate?: Date | string | null
  }

  export type UserSubscriptionUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutSubscriptionRecordsNestedInput
  }

  export type UserSubscriptionUncheckedUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserSubscriptionUncheckedUpdateManyWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BundleCourseCreateManyBundleInput = {
    courseId: string
  }

  export type UserBundleCreateManyBundleInput = {
    id?: string
    userId: string
    purchaseDate?: Date | string
  }

  export type BundleCourseUpdateWithoutBundleInput = {
    course?: CourseUpdateOneRequiredWithoutBundleCoursesNestedInput
  }

  export type BundleCourseUncheckedUpdateWithoutBundleInput = {
    courseId?: StringFieldUpdateOperationsInput | string
  }

  export type BundleCourseUncheckedUpdateManyWithoutBundleInput = {
    courseId?: StringFieldUpdateOperationsInput | string
  }

  export type UserBundleUpdateWithoutBundleInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBundlesOwnedNestedInput
  }

  export type UserBundleUncheckedUpdateWithoutBundleInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBundleUncheckedUpdateManyWithoutBundleInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostCategoryCreateManyPostInput = {
    categoryId: string
  }

  export type PostTagCreateManyPostInput = {
    tagId: string
  }

  export type BlogCommentCreateManyPostInput = {
    id?: string
    userId: string
    content: string
    createdAt?: Date | string
    parentId?: string | null
  }

  export type PostCategoryUpdateWithoutPostInput = {
    category?: CategoryUpdateOneRequiredWithoutPostsNestedInput
  }

  export type PostCategoryUncheckedUpdateWithoutPostInput = {
    categoryId?: StringFieldUpdateOperationsInput | string
  }

  export type PostCategoryUncheckedUpdateManyWithoutPostInput = {
    categoryId?: StringFieldUpdateOperationsInput | string
  }

  export type PostTagUpdateWithoutPostInput = {
    tag?: TagUpdateOneRequiredWithoutPostsNestedInput
  }

  export type PostTagUncheckedUpdateWithoutPostInput = {
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type PostTagUncheckedUpdateManyWithoutPostInput = {
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type BlogCommentUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBlogCommentsNestedInput
    parent?: BlogCommentUpdateOneWithoutRepliesNestedInput
    replies?: BlogCommentUpdateManyWithoutParentNestedInput
  }

  export type BlogCommentUncheckedUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    replies?: BlogCommentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type BlogCommentUncheckedUpdateManyWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PostCategoryCreateManyCategoryInput = {
    postId: string
  }

  export type PostCategoryUpdateWithoutCategoryInput = {
    post?: BlogPostUpdateOneRequiredWithoutCategoriesNestedInput
  }

  export type PostCategoryUncheckedUpdateWithoutCategoryInput = {
    postId?: StringFieldUpdateOperationsInput | string
  }

  export type PostCategoryUncheckedUpdateManyWithoutCategoryInput = {
    postId?: StringFieldUpdateOperationsInput | string
  }

  export type PostTagCreateManyTagInput = {
    postId: string
  }

  export type PostTagUpdateWithoutTagInput = {
    post?: BlogPostUpdateOneRequiredWithoutTagsNestedInput
  }

  export type PostTagUncheckedUpdateWithoutTagInput = {
    postId?: StringFieldUpdateOperationsInput | string
  }

  export type PostTagUncheckedUpdateManyWithoutTagInput = {
    postId?: StringFieldUpdateOperationsInput | string
  }

  export type BlogCommentCreateManyParentInput = {
    id?: string
    postId: string
    userId: string
    content: string
    createdAt?: Date | string
  }

  export type BlogCommentUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: BlogPostUpdateOneRequiredWithoutCommentsNestedInput
    user?: UserUpdateOneRequiredWithoutBlogCommentsNestedInput
    replies?: BlogCommentUpdateManyWithoutParentNestedInput
  }

  export type BlogCommentUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: BlogCommentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type BlogCommentUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralUseCreateManyReferralCodeInput = {
    id?: string
    userId: string
    pointsAwarded?: number
    createdAt?: Date | string
  }

  export type ReferralUseUpdateWithoutReferralCodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    pointsAwarded?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutReferralUsesGainedNestedInput
  }

  export type ReferralUseUncheckedUpdateWithoutReferralCodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    pointsAwarded?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralUseUncheckedUpdateManyWithoutReferralCodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    pointsAwarded?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CourseCountOutputTypeDefaultArgs instead
     */
    export type CourseCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CourseCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TopicCountOutputTypeDefaultArgs instead
     */
    export type TopicCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TopicCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LessonCountOutputTypeDefaultArgs instead
     */
    export type LessonCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LessonCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use QuizCountOutputTypeDefaultArgs instead
     */
    export type QuizCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = QuizCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AssignmentCountOutputTypeDefaultArgs instead
     */
    export type AssignmentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AssignmentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TutoringSessionCountOutputTypeDefaultArgs instead
     */
    export type TutoringSessionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TutoringSessionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TutoringRequestCountOutputTypeDefaultArgs instead
     */
    export type TutoringRequestCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TutoringRequestCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AchievementCountOutputTypeDefaultArgs instead
     */
    export type AchievementCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AchievementCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BadgeCountOutputTypeDefaultArgs instead
     */
    export type BadgeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BadgeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConversationCountOutputTypeDefaultArgs instead
     */
    export type ConversationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConversationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MessageCountOutputTypeDefaultArgs instead
     */
    export type MessageCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MessageCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubscriptionPlanCountOutputTypeDefaultArgs instead
     */
    export type SubscriptionPlanCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubscriptionPlanCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CourseBundleCountOutputTypeDefaultArgs instead
     */
    export type CourseBundleCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CourseBundleCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BlogPostCountOutputTypeDefaultArgs instead
     */
    export type BlogPostCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BlogPostCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CategoryCountOutputTypeDefaultArgs instead
     */
    export type CategoryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CategoryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TagCountOutputTypeDefaultArgs instead
     */
    export type TagCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TagCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BlogCommentCountOutputTypeDefaultArgs instead
     */
    export type BlogCommentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BlogCommentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReferralCodeCountOutputTypeDefaultArgs instead
     */
    export type ReferralCodeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReferralCodeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TeacherProfileDefaultArgs instead
     */
    export type TeacherProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TeacherProfileDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserAvailabilityDefaultArgs instead
     */
    export type UserAvailabilityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserAvailabilityDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PointsTransactionDefaultArgs instead
     */
    export type PointsTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PointsTransactionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PointsPackageDefaultArgs instead
     */
    export type PointsPackageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PointsPackageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CourseDefaultArgs instead
     */
    export type CourseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CourseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TopicDefaultArgs instead
     */
    export type TopicArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TopicDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LessonDefaultArgs instead
     */
    export type LessonArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LessonDefaultArgs<ExtArgs>
    /**
     * @deprecated Use QuizDefaultArgs instead
     */
    export type QuizArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = QuizDefaultArgs<ExtArgs>
    /**
     * @deprecated Use QuestionDefaultArgs instead
     */
    export type QuestionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = QuestionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AssignmentDefaultArgs instead
     */
    export type AssignmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AssignmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EnrollmentDefaultArgs instead
     */
    export type EnrollmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EnrollmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SavedCourseDefaultArgs instead
     */
    export type SavedCourseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SavedCourseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LikedCourseDefaultArgs instead
     */
    export type LikedCourseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LikedCourseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LessonProgressDefaultArgs instead
     */
    export type LessonProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LessonProgressDefaultArgs<ExtArgs>
    /**
     * @deprecated Use QuizAttemptDefaultArgs instead
     */
    export type QuizAttemptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = QuizAttemptDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AssignmentSubmissionDefaultArgs instead
     */
    export type AssignmentSubmissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AssignmentSubmissionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CourseReviewDefaultArgs instead
     */
    export type CourseReviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CourseReviewDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TutoringSessionDefaultArgs instead
     */
    export type TutoringSessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TutoringSessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TutoringAvailabilityDefaultArgs instead
     */
    export type TutoringAvailabilityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TutoringAvailabilityDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TutoringRequestDefaultArgs instead
     */
    export type TutoringRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TutoringRequestDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TutoringAppointmentDefaultArgs instead
     */
    export type TutoringAppointmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TutoringAppointmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TutoringReviewDefaultArgs instead
     */
    export type TutoringReviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TutoringReviewDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TutoringMessageDefaultArgs instead
     */
    export type TutoringMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TutoringMessageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AchievementDefaultArgs instead
     */
    export type AchievementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AchievementDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserAchievementDefaultArgs instead
     */
    export type UserAchievementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserAchievementDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BadgeDefaultArgs instead
     */
    export type BadgeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BadgeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CertificateDefaultArgs instead
     */
    export type CertificateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CertificateDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConversationDefaultArgs instead
     */
    export type ConversationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConversationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConversationParticipantDefaultArgs instead
     */
    export type ConversationParticipantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConversationParticipantDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MessageDefaultArgs instead
     */
    export type MessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MessageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AttachmentDefaultArgs instead
     */
    export type AttachmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AttachmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationDefaultArgs instead
     */
    export type NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubscriptionPlanDefaultArgs instead
     */
    export type SubscriptionPlanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubscriptionPlanDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CourseBundleDefaultArgs instead
     */
    export type CourseBundleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CourseBundleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BundleCourseDefaultArgs instead
     */
    export type BundleCourseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BundleCourseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserSubscriptionDefaultArgs instead
     */
    export type UserSubscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserSubscriptionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserBundleDefaultArgs instead
     */
    export type UserBundleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserBundleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PaymentDefaultArgs instead
     */
    export type PaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PaymentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CalendarEventDefaultArgs instead
     */
    export type CalendarEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CalendarEventDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BlogPostDefaultArgs instead
     */
    export type BlogPostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BlogPostDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CategoryDefaultArgs instead
     */
    export type CategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CategoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PostCategoryDefaultArgs instead
     */
    export type PostCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PostCategoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TagDefaultArgs instead
     */
    export type TagArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TagDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PostTagDefaultArgs instead
     */
    export type PostTagArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PostTagDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BlogCommentDefaultArgs instead
     */
    export type BlogCommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BlogCommentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReferralCodeDefaultArgs instead
     */
    export type ReferralCodeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReferralCodeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReferralUseDefaultArgs instead
     */
    export type ReferralUseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReferralUseDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}